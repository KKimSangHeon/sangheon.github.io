<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kim Sang Heon&#39;s Bolg</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://KKimSangHeon.github.io/"/>
  <updated>2020-01-16T13:40:23.691Z</updated>
  <id>http://KKimSangHeon.github.io/</id>
  
  <author>
    <name>Kim Sang Heon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>9.ResourceLoader</title>
    <link href="http://KKimSangHeon.github.io/2020/01/16/spring3/"/>
    <id>http://KKimSangHeon.github.io/2020/01/16/spring3/</id>
    <published>2020-01-16T12:58:25.000Z</published>
    <updated>2020-01-16T13:40:23.691Z</updated>
    
    <content type="html"><![CDATA[<p>리소스를 읽어오는 기능을 제공하는 인터페이스인 ResourceLoader를 ApplicationContext이 구현한다.</p>
<p>test.txt 파일을 리소스 안에 넣어주자.</p>
<figure class="highlight java"><figcaption><span>AppRunner.java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span></span>&#123;</div><div class="line">  <span class="meta">@Autowired</span></div><div class="line">  ResourceLoader를 resourceLoader를;  <span class="comment">// ApplicationContext로 해도 가능하긴함</span></div><div class="line">...run()&#123;</div><div class="line">    Resouce resource = resourceLoader.getResource(<span class="string">"classpath:test.txt"</span>);</div><div class="line">    print(resource.exists());</div><div class="line">    print(resource.getDescription());</div><div class="line">    print(Files.readString(Path.of(resource.getURI())));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;리소스를 읽어오는 기능을 제공하는 인터페이스인 ResourceLoader를 ApplicationContext이 구현한다.&lt;/p&gt;
&lt;p&gt;test.txt 파일을 리소스 안에 넣어주자.&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;
    
    </summary>
    
      <category term="Web/App" scheme="http://KKimSangHeon.github.io/categories/Web-App/"/>
    
      <category term="Spring" scheme="http://KKimSangHeon.github.io/categories/Web-App/Spring/"/>
    
    
      <category term="Spring" scheme="http://KKimSangHeon.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>8.ApplicationEventPublisher</title>
    <link href="http://KKimSangHeon.github.io/2020/01/16/spring2/"/>
    <id>http://KKimSangHeon.github.io/2020/01/16/spring2/</id>
    <published>2020-01-16T12:15:47.000Z</published>
    <updated>2020-01-16T13:32:01.234Z</updated>
    
    <content type="html"><![CDATA[<p>ApplicationContext가 상속받고있는 ApplicationEventPublisher인터페이스로서 이는 이벤트 프로그래밍에 필요한 인터페이스이다.</p>
<p>MyEvent를 만들고<br><figure class="highlight java"><figcaption><span>MyEvent.java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEvent</span> <span class="keyword">implements</span> <span class="title">ApplicationEvent</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> data;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyEvent</span><span class="params">(Object source)</span></span>&#123;</div><div class="line">    <span class="keyword">super</span>(source);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyEvent</span><span class="params">(Object source, <span class="keyword">int</span> data)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(source);</div><div class="line">    <span class="keyword">this</span>.data=data;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> data;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>이벤트를 발생시켜보자.<br><figure class="highlight java"><figcaption><span>AppRunner.java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span></span>&#123;</div><div class="line">  <span class="meta">@Autowired</span></div><div class="line">  ApplicationEventPublisher publishEvent;  <span class="comment">// ApplicationContext로 해도 가능하긴함</span></div><div class="line">...run()&#123;</div><div class="line">  <span class="comment">//이벤트 발생</span></div><div class="line">  publishEvent.publishEvent(<span class="keyword">new</span> MyEvent (<span class="keyword">this</span>,<span class="number">100</span>));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>이벤트가 발생했을 때 해당이벤트를 받는 핸들러는 빈으로 등록되어 있어야 한다.<br>이벤트를 받는 핸들러를 정의하자.</p>
<figure class="highlight java"><figcaption><span>MyEventHandler.java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventHandler</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">MyEvent</span>&gt;</span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MyEvent event)</span> </span>&#123;</div><div class="line">    print(<span class="string">"핸들러가 받은 이벤트의 데이터"</span>+event.getData());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>4.2 이후부터는 위와같이 불편하게 하지 않아도 된다.</code></p>
<p>Event 클래스는 ApplicationEvent를 구현하지 않아도 된다.<br><figure class="highlight java"><figcaption><span>MyEvent.java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEvent</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> data;</div><div class="line">  <span class="keyword">private</span> Object source;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyEvent</span><span class="params">(Object source, <span class="keyword">int</span> data)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.source = source;</div><div class="line">    <span class="keyword">this</span>.data = data;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getSource</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> source;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> data;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>위와같은 소스는 스프링이 추구하는 비침투성(스프링 코드가 사용자 코드에 들어가지 않는것)을 구현한것</p>
<p>핸들러도 ApplicationListener 인터페이스를 구현하지 않아도 되게 되었지만 빈으로는 등록해야 한다.</p>
<figure class="highlight java"><figcaption><span>MyEventHandler.java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventHandler</span></span>&#123;</div><div class="line"></div><div class="line">  <span class="meta">@EventListener</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myhandle</span><span class="params">(MyEvent event)</span> </span>&#123;</div><div class="line">    print(<span class="string">"핸들러가 받은 이벤트의 데이터"</span>+event.getData());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>여러개의 핸들러가 하나의 이벤트를 핸들 할 경우?</code><br>동일한 쓰레드 내에서 순차적으로 실행된다. 순서는 보장되지 않으며 순서를 보장하고 싶으면 다음과 같이 @Order을 주면 된다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@EventListener</div><div class="line">@Order(Ordered.HIGHEST_PRECEDENCE)  // @Order(Ordered.HIGHEST_PRECEDENCE)+3</div><div class="line">//낮은것이 먼저 실행됨</div><div class="line">public void myhandle(MyEvent event) &#123;</div><div class="line">  print(&quot;핸들러가 받은 이벤트의 데이터&quot;+event.getData());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>비동기적으로 실행하고 싶을 때는?</code><br>순서는 보장안된다. 이땐 order도 무의미해짐.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@EventListener</div><div class="line">@Async</div><div class="line">//낮은것이 먼저 실행됨</div><div class="line">public void myhandle(MyEvent event) &#123;</div><div class="line">  print(&quot;핸들러가 받은 이벤트의 데이터&quot;+event.getData());</div><div class="line">&#125;</div><div class="line">``</div></pre></td></tr></table></figure></p>
<p>그리고 Application 클래스에 @EnableAsync 어노테이션을 붙여준다.<br>이 외에도 쓰레드 풀에 관련한 설정을 더 해야되는데 비동기 관련된 수업이 아니므로 건너뛴다.</p>
<p><code>스플링이 기본적으로 제공하는 이벤트들을 확인해보자</code><br>ContextRefreshedEvent: ApplicationContext를 초기화 했더나 리프래시 했을 때 발생.<br>ContextStartedEvent: ApplicationContext를 start()하여 라이프사이클 빈들이 시작 신호를 받은 시점에 발생.<br>ContextStoppedEvent: ApplicationContext를 stop()하여 라이프사이클 빈들이 정지 신호를 받은 시점에 발생.<br>ContextClosedEvent: ApplicationContext를 close()하여 싱글톤 빈 소멸되는 시점에 발생.<br>RequestHandledEvent: HTTP 요청을 처리했을 때 발생.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@EventListener</div><div class="line">public void myhandle(ContextRefreshedEvent event) &#123;</div><div class="line">  print(&quot;핸들러가 받은 이벤트의 데이터&quot;+event.getData());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>이벤트는 위와같이 확인할 수 있다는점을 잊지말자.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ApplicationContext가 상속받고있는 ApplicationEventPublisher인터페이스로서 이는 이벤트 프로그래밍에 필요한 인터페이스이다.&lt;/p&gt;
&lt;p&gt;MyEvent를 만들고&lt;br&gt;&lt;figure class=&quot;highlight ja
    
    </summary>
    
      <category term="Web/App" scheme="http://KKimSangHeon.github.io/categories/Web-App/"/>
    
      <category term="Spring" scheme="http://KKimSangHeon.github.io/categories/Web-App/Spring/"/>
    
    
      <category term="Spring" scheme="http://KKimSangHeon.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>7.MessageSource</title>
    <link href="http://KKimSangHeon.github.io/2020/01/16/spring/"/>
    <id>http://KKimSangHeon.github.io/2020/01/16/spring/</id>
    <published>2020-01-16T10:50:46.000Z</published>
    <updated>2020-01-16T12:01:17.591Z</updated>
    
    <content type="html"><![CDATA[<p>ApplicationContext가 갖고있는 또다른 기능인 MessageSource에 대해 알아보겠다.<br>ApplicationContext가 MessageSource 인터페이스를 구현한다.</p>
<p>i18n와 관련된 기능인데 메세지를 다국화 하는 기능이다.</p>
<p>스프링 부트를 사용한다면 아래 두개를 바로 만들어 사용할 수 있다.</p>
<figure class="highlight java"><figcaption><span>messages.properties</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">greeting=Hello &#123;<span class="number">0</span>&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><figcaption><span>messages_ko_kr.properties</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">greeting=안녕, &#123;<span class="number">0</span>&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><figcaption><span>AppRunner.java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppRunner</span> <span class="keyword">implements</span> <span class="title">ApplicationRunner</span></span>&#123;</div><div class="line">  <span class="meta">@Autowired</span></div><div class="line">  MessageSource messageSource;  <span class="comment">// ApplicationContext로 해도 가능하긴함</span></div><div class="line">...run()&#123;</div><div class="line">  print(messageSource.getMessage(<span class="string">"greeting"</span>,<span class="keyword">new</span> String[]&#123;<span class="string">"sangheon"</span>&#125;,Locale.KOREA));</div><div class="line">  print(messageSource.getMessage(<span class="string">"greeting"</span>,<span class="keyword">new</span> String[]&#123;<span class="string">"sangheon"</span>&#125;,Locale.getDefault()));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>동작원리?</code> ResourceBundleMessageSource라는 빈이 메세지를 읽어들인다.</p>
<p><code>직접 MessageSource를 정의해보자</code><br>ReloadableResourceBundleMessageSource는 reload가 가능한 것으로서 운영중에 메세지 변경이 가능하다. 즉 프로그램 런타임 중에 빌드를 다시해주면 변경된다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Bean</div><div class="line">public MessageSource messageSource() &#123;</div><div class="line">  var messageSource = new ReloadableResourceBundleMessageSource();</div><div class="line">  messageSource.setBasename(&quot;classpath:/messages&quot;);</div><div class="line">  messageSource.setDefaultEncoding(&quot;UTF-8&quot;);</div><div class="line">  messageSource.setCacheSeconds(3);</div><div class="line">  return messageSource;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ApplicationContext가 갖고있는 또다른 기능인 MessageSource에 대해 알아보겠다.&lt;br&gt;ApplicationContext가 MessageSource 인터페이스를 구현한다.&lt;/p&gt;
&lt;p&gt;i18n와 관련된 기능인데 메세지를 다국
    
    </summary>
    
      <category term="Web/App" scheme="http://KKimSangHeon.github.io/categories/Web-App/"/>
    
      <category term="Spring" scheme="http://KKimSangHeon.github.io/categories/Web-App/Spring/"/>
    
    
      <category term="Spring" scheme="http://KKimSangHeon.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>6.Environment 프로파일, 프로퍼티</title>
    <link href="http://KKimSangHeon.github.io/2020/01/15/spring/"/>
    <id>http://KKimSangHeon.github.io/2020/01/15/spring/</id>
    <published>2020-01-15T12:46:20.000Z</published>
    <updated>2020-01-15T13:32:17.594Z</updated>
    
    <content type="html"><![CDATA[<p>지금까진 빈과 빈을 등록하는 방법에 대해 알아봤는데 applicationContext에 대해 더 알아보겠다.</p>
<h3 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h3><p>ApplicationContext는 빈  보관 외 다양한 기능을 갖고있는데 그 중 EnvironmentCapable(ApplicationContext가 EnvironmentCapable를 구현한다)는 두가지 기능을 제공하는 데 그 중 프로파일이라는 기능에 대해 알아보겠다.</p>
<p><code>프로파일</code>: 빈들의 묶음이다. 어떤 환경을 의미한다. 즉 각각의 환경에 따라 다른 빈을 써야하는 경우 유용(ex. 테스트 서버에서는 a빈을 쓰겠다.)</p>
<figure class="highlight java"><figcaption><span>TestConfiguration.java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="meta">@Profile</span>(<span class="string">"test"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConfiguration</span> </span>&#123;</div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> BookRepository <span class="title">bookRepository</span> <span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TestBookRepository();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>위처럼 할 경우 다른곳에서</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@Autowired</div><div class="line">BookRepository bookRepository;</div></pre></td></tr></table></figure>
<p>위와같이 호출할 경우 BookRepository 빈을 못찾게 된다. 왜? test프로파일 일 때만 실행하도록 설정했기 때문(@Profile(“test”))</p>
<p><code>그렇다면 프로파일을 설정해보자</code><br>IDE에서 Active profile 설정을 줄 수 있다.<br>해당 옵션이 없으면<br>VM option에다 -Dspring.profiles.avtive=”test” 와 같이 주면 된다.</p>
<p><code>TestConfiguration 없이 빈에다 바로 프로파일 설정하는 방법은?</code><br>TestConfiguration방법은 불편하긴 하다. @profile를 붙여주자.<br><figure class="highlight java"><figcaption><span>TestBookRepository.java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Repository</span></div><div class="line"><span class="meta">@Profile</span>(<span class="string">"test"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBookRepository</span> <span class="keyword">implements</span> <span class="title">BookRepository</span> </span>&#123;&#125;</div></pre></td></tr></table></figure></p>
<p><code>프로파일 표현식</code><br>! - not<br>&amp; - and<br>| - or<br>위와같이 표현식을 쓸 수 있다.<br>@Profile(“!prod &amp; test”) 일 경우 prod가 아니고 test인 경우에만 실행되는것이다.</p>
<p>다음과 같이 프로파일을 적용해 보며 확인해볼 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">@Autowired</div><div class="line">ApplicationContext ctx;</div><div class="line"></div><div class="line">@Autowired</div><div class="line">BookRepository bookRepository;</div><div class="line"></div><div class="line">public class AppRunner implements ApplicationRunner&#123;</div><div class="line">..run()&#123;</div><div class="line">  Environment environment = ctx.getEnvironment();</div><div class="line">  print(environment.getActiveProfile);    </div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h3><p>어플리케이션에 등록되어있는 키 밸류 쌍에 접근하는 것으로 계층형으로 접근한다. 프로퍼티는 여러가지 형태로 제공될 수 있는데 OS에 있는 환경변수, 자바 실행할 때의 -D로 넘겨주는 옵션, 서블릿 컨텍스트, 서블릿 콘텍스트 등에도 들어갈 수 있다.</p>
<p><code>Property 설정방법 1</code><br>vm  옵션으로 -Dapp.name=spring5 을 입력하자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Autowired</div><div class="line">ApplicationContext ctx;</div><div class="line"></div><div class="line">public class AppRunner implements ApplicationRunner&#123;</div><div class="line">...run()&#123;</div><div class="line">  Environment environment = ctx.getEnvironment();</div><div class="line">  print(environment.getProperty(&quot;app.name&quot;));    </div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Property 설정방법 2</code><br>application.properties 파일 생성하고 app.name=spring 을 입력하자</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@SpringBootApplication</div><div class="line">@PropertySource(&quot;classpath:/app.properties&quot;)</div><div class="line">public class Demospring51Application</div><div class="line">....</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Autowired</div><div class="line">ApplicationContext ctx;</div><div class="line"></div><div class="line">public class AppRunner implements ApplicationRunner&#123;</div><div class="line">...run()&#123;</div><div class="line">  Environment environment = ctx.getEnvironment();</div><div class="line">  print(environment.getProperty(&quot;app.name&quot;));        </div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>두 방법을 사용하여 app.name을 설정하여 출력할경우 누가 출력될까<br>vm 옵션이 이긴다.</p>
<p>아래처럼도 설정이 가능하다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class AppRunner implements ApplicationRunner&#123;</div><div class="line"></div><div class="line">  @Value(&quot;$&#123;app.name&#125;&quot;)</div><div class="line">  String appName;</div><div class="line"></div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;지금까진 빈과 빈을 등록하는 방법에 대해 알아봤는데 applicationContext에 대해 더 알아보겠다.&lt;/p&gt;
&lt;h3 id=&quot;Environment&quot;&gt;&lt;a href=&quot;#Environment&quot; class=&quot;headerlink&quot; title=&quot;En
    
    </summary>
    
      <category term="Web/App" scheme="http://KKimSangHeon.github.io/categories/Web-App/"/>
    
      <category term="Spring" scheme="http://KKimSangHeon.github.io/categories/Web-App/Spring/"/>
    
    
      <category term="Spring" scheme="http://KKimSangHeon.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>AWS VPC 전반 기초 요약</title>
    <link href="http://KKimSangHeon.github.io/2020/01/14/aws/"/>
    <id>http://KKimSangHeon.github.io/2020/01/14/aws/</id>
    <published>2020-01-14T00:29:38.000Z</published>
    <updated>2020-01-14T10:11:12.789Z</updated>
    
    <content type="html"><![CDATA[<h3 id="AWS"><a href="#AWS" class="headerlink" title="AWS"></a>AWS</h3><p>전세계에서 가장 많이 쓰는 퍼블릭 서버<br>IAAS로 시작함</p>
<h3 id="가용성-존-AZ"><a href="#가용성-존-AZ" class="headerlink" title="가용성 존(AZ)"></a>가용성 존(AZ)</h3><p>가장 기본적인 단위는 Region 이다.<br>한국의 경우 서울 하나만 있다.<br>Region는 논리적인 단위이고 가용성 존(AZ)이 물리적인 단위이다.<br>한 Region은 여러개의 가용성 존을 갖고 있다.<br>가용성 존이 오늘 다룰 단위이다.</p>
<p>AZ 하나는 CIDC(클라우드 IDC)로서 하나의 단위이다.</p>
<p>VPC(Virtual Private Cloud) - AZ를 포함하는 단위. 리전마다 만들 수 있다.<br>자기 자신만의 가상 IDC를 만들어서 활용하는것.</p>
<p>가상서버의 인스턴스는 VPC안에 생성된다.</p>
<p>IDC는 게이트웨이, 방화벽, 서버, 서브넷 등이 필요한데 이들은 VPC안에 정의 가능하다.</p>
<img src="/2020/01/14/aws/vpc.png" alt="VPC" title="VPC">
<p><code>Bastion Host / VPN</code> 으로 접속하는 방법이 있다.  Bastion Host의 경우 SSH을 열은 EC2 로 접근하여 다른 서브넷에 접근하는 방식이다.<br>둘 다 그림으론 IGW를 안거치는것 처럼 보이지만 거치는 형태이다.</p>
<p><code>ELB</code> 는 로드벨런서이다.</p>
<h3 id="실습"><a href="#실습" class="headerlink" title="실습"></a>실습</h3><p>vpc 검색</p>
<h3 id="VPC-생성"><a href="#VPC-생성" class="headerlink" title="VPC 생성"></a>VPC 생성</h3><p>대부분의 오브젝트 이름이 태그로 관리된다. 논리적인 이름이다.</p>
<p><code>이름태그</code><br>퍼블릭 클라우드는 네이밍이 중요하기 떄문에 신중해야 함. 왜?<br>VPC를 여러개 만드는 경우가 생기게 되는데 (ex. 개발, 프로덕트, 스테이징 등등 생성하고자 할 때 / 부서별로 생성하는 경우)</p>
<p>네이밍 방법<br>vpc-opne2-dev-{서비스 약칭}</p>
<p>opne2 - 한국지역<br>dev - 개발용 (dev,prod,stg 중 선택)<br>서비스 약칭</p>
<p><code>IPv4 CIDR 블록</code><br>10.1.0.0/16 을 하면 156xx개를 사용할 수 있다</p>
<p><code>IPv6 CIDR 블록</code><br>IPv6를 지원하면 켜줘야함</p>
<p>이제 생성클릭</p>
<h3 id="VPC-목록-화면"><a href="#VPC-목록-화면" class="headerlink" title="VPC 목록 화면"></a>VPC 목록 화면</h3><p>VPC ID가 식별자이다.</p>
<p><code>DNS 호스트 이름</code> : 도메인네임도 내부 룰에 맞춰서 생성해서 붙여줄까?<br><code>라우팅 테이블</code> : VPC안에서 서브넷간 통신을 어떻게 할지<br>어디서 어디까지 흘러가는건 막고 등… 내부흐름 조절<br><code>DHCP 옵션 세트</code>:내부적으로 붙는 인스턴스가 AWS가 내부 IP로 붙인다.</p>
<p><code>네트워크 ACL</code> : 서브넷 단위의 firewall  주로 ACL보다는 시큐리티 그룹을 즐겨쓴다.</p>
<h4 id="DNS-호스트-이름-활성화"><a href="#DNS-호스트-이름-활성화" class="headerlink" title="DNS 호스트 이름 활성화"></a>DNS 호스트 이름 활성화</h4><p>좌측 위 작업 - DNS 호스트 이름 편집- 활성화 체크</p>
<hr>
<h4 id="인터넷-게이트웨이"><a href="#인터넷-게이트웨이" class="headerlink" title="인터넷 게이트웨이"></a>인터넷 게이트웨이</h4><p>VPC를 생성한 이후에 가장먼저해야할게 외부와 통신하기 위해 게이트웨이를 만들어야한다.</p>
<p>좌측에서 인터넷 게이트웨이 생성 클릭<br><code>네이밍 규칙</code><br>igw-opne2-dev</p>
<p>우즉 위 작업 - VPC에 연결클릭 후 연결시켜준다.</p>
<hr>
<h3 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h3><p>firewall로서 서브넷 단위로 통신흐름을 제어하는데 인바운드 아웃바운드 제어가 가능. 서브넷 처럼 뭐는 되고 뭐는 안되는 세밀한 조정은 안됨</p>
<p>ACL은 서브넷 단위로 트래픽을 제어하고 RT를 통해 어느서브넷에서 나온것은 어디로 흘러갈지 정의한다.</p>
<p>ACL은 디폴트로 생성된다. 좌측에 네트워크 ACL 클릭 후 선택 후 인바운드, 아웃바운드 보면 다열려있다,</p>
<p>서브넷 연결탭은 아무것도 없는데 조금 뒤 서브넷을 만들고 설정하도록 하겠다.</p>
<hr>
<h4 id="서브넷-생성"><a href="#서브넷-생성" class="headerlink" title="서브넷 생성"></a>서브넷 생성</h4><p>VPC에 저복하기 위해서는 VPN을 사용하지만 이는 비용이 든다.</p>
<p>그래서 VPC 내 여러개의 서브넷 중 하나에 EC2를 생성하고 SSH로 접속하여 다른곳에 붙는다. 이를 Bastion Host라 함.</p>
<p>좌측 서브넷 선택<br><code>네이밍 규칙</code><br>subnet-opne2-dev-ssh</p>
<p><code>VPC 선택</code><br>가용영역: 서울리전에는 AZ가 3개가 있다고 했었따.</p>
<p><code>가용영역</code><br>서브넷은 가용영역이 있으므로 이름태그를 subnet-apne2a-dev-ssh로 수정한다. a는 가용영역 3개중 비교를 위해 붙임.</p>
<p>AZ를 여러개로 구성하여 다중화를 통해 장애에 유연하게 대처할 수 있도록 하는것이 좋다</p>
<p><code>CIDR</code><br>VPC가 갖고있는 범위안에서 CIDR을 만들어야 한다.(아까 만든 10.1.0.0/16)<br>10.1.1.0/24</p>
<p>관례적으로 3번째 숫자가 낮아질 수록 은밀성이 높아진다.<br>내부적으로 10번대는 웹서버, 20번대는 디비 …. 이런식으로 정한다.</p>
<p>VPC의 CIDR 블록값이 다른값과 겹치면 안된다.<br>블록값이 겹치면 VPC간 페어링을 해야할 때 동일한 CIDR 블록을 갖는것들은 페어링이 안된다.</p>
<p><code>과금팁</code></p>
<ul>
<li>EC2 는 메모리,CPU 를 점유하므로 그냥 있어도 과금이 된다.</li>
<li>같은 AZ안에서의 통신은 과금이 되지않는다(조금씩 다르긴하다)</li>
<li>인바운드는 보통 과금이 되지만 아웃바운드는 과금이 되지 않는 경우도 존재</li>
</ul>
<h3 id="다시-ACL가서-생성한-서브넷-연결확인"><a href="#다시-ACL가서-생성한-서브넷-연결확인" class="headerlink" title="다시 ACL가서 생성한 서브넷 연결확인"></a>다시 ACL가서 생성한 서브넷 연결확인</h3><p>좌측에 네트워크 ACL 선택 후 서브넷 하나 선택하고 서브넷 연결탭에서 등록되어있따 확인.</p>
<h3 id="라우트-테이블"><a href="#라우트-테이블" class="headerlink" title="라우트 테이블"></a>라우트 테이블</h3><p>VPC 왼쪽메뉴 보면 라우팅 테이블이있다.</p>
<p><code>네이밍규칙</code><br>rt-apne-dev-ssh</p>
<p>생성되어있는것의 이름을 네이밍 규칙에 맞게 설정</p>
<p>그 후 서브넷 연결 편 탭에서 서브넷 연결편집 클릭 - 하나 선택후 저장</p>
<h3 id="EC2-생성"><a href="#EC2-생성" class="headerlink" title="EC2 생성"></a>EC2 생성</h3><p>ec2 검색<br>인스턴스</p>
<p><code>키페어 생성</code><br>키페어 생성버튼 클릭</p>
<p>네이밍<br>keypair-apne2-dev-public 을 입력하고 파일을 내려받게된다.</p>
<p>키페어만 있으면 ACL, 시큐리티 그룹에서 막히지 않았을 때 어디서든 들어올 수 있다.</p>
<p><code>인스턴스 생성</code><br>왼쪽인스턴스 선택 - 인스턴스 생성 클릭 - Amazon Linux 2 AMI (HVM), SSD Volume Type - ami-0bea7fd38fabe821a 선택</p>
<p>t2.micro 는 Bastion Host로 사용하기에 널널하다<br>General Purpose의 유형중 t로 시작하는것은 개발/테스트 용도로 사용하기 적당<br>m으로 시작하는것은 메모리가 많다.<br>t 뒤에 위치한 숫자는 세대(Generation)라고 보면 된다.</p>
<p>t2.micro 선택 후 다음 클릭</p>
<p>네트워크에서 내가 만든것 선택<br>서브넷은 하나뿐일것임<br>퍼플릭 IP 자동할당 - 활성화 (외부와 통신이 필요할 때 활성화를 한다. 리스타트하면 ip가 바뀌므로 해당 ip로 통신하도록 박아놓으면 안된다.)<br>종료방식 - 중지(종료로 되어있으면 종료했을 때 인스턴스가 종료된다.)</p>
<p>네트워크 인터페이스</p>
<p>고급세부정보<br>인스턴스를 기동할 때 특정 행위를 하도록 할 수 있는데 여기에 집어넣는것.</p>
<p>다음 스토리지 추가 클릭</p>
<p>다음 태그추가 클릭<br>키가 : name<br>값이 : ec2-apne2a-dev-ssh</p>
<p>다음 보안그룹 클릭</p>
<p>보안그룹 이름 : sg-apne-dev-ssh으로 해야되지만<br>시큐리티 그룹은 특수문자를 허용하지 않기 때문에 sgapnedevssh로 하자</p>
<p>유형 : SSH<br>소스 : 내 IP<br>설명 : xxx(꼭 넣어주는것이 좋다. 어딘지 알 수 있도록)</p>
<p>검토및 시작 클릭 후 시작하기 클릭</p>
<p>기존 키 페어 선택 클릭 후 인스턴스 시작</p>
<p>퍼블릭 IP는 다시시작하면 바뀌므로 접속정보로 사용하지 말것.</p>
<hr>
<h3 id="라우트-테이블에-연결"><a href="#라우트-테이블에-연결" class="headerlink" title="라우트 테이블에 연결"></a>라우트 테이블에 연결</h3><p>왼쪽탭의 라우팅테이블<br>라우팅 추가 - 0.0.0.0/0<br>(잘 선택해서 추가해라… 잘못해서 해멨다..)</p>
<p>EC2에 접속해보면 잘될것이다.</p>
<h3 id="1차-정리해보자"><a href="#1차-정리해보자" class="headerlink" title="1차 정리해보자"></a>1차 정리해보자</h3><p>가상의 IDC이다.</p>
<p>외부와 통신하기 위해 게이트웨이를 붙이고</p>
<p>VPC에 게이트웨이 바인딩하고 서브넷을 만들었다.</p>
<p>서브넷은 퍼블릿/프라이빗을 구분하기 위해 라우팅테이블에 포함되어 있는지 판단한다. 라우팅테이블에 존재하면 퍼블릭</p>
<p>ACL은 서브넷 단위까지밖에 관리 못함</p>
<p>실제로 인터넷 서비스를 이용하기 위해 게이트웨이, 라우터 등이 필요한데</p>
<p>집에있는 모뎀은 라우터 , 게이트웨이가 합쳐져있는것이다.</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo yum update</div></pre></td></tr></table></figure>
<h3 id="서브넷-새로-하나-추가"><a href="#서브넷-새로-하나-추가" class="headerlink" title="서브넷 새로 하나 추가"></a>서브넷 새로 하나 추가</h3><p>서브넷 (CIDR 추가), 라우팅테이블 추가</p>
<p><code>서브넷 추가</code><br>서브넷 탭에서 서브넷 생성<br>subnet-apne2a-dev-web<br>CIDR 블록<br>10.1.2.0/24<br>추가</p>
<p><code>라우팅테이블</code><br>서브넷 연결 설정<br>rt-apne2-dev-web<br>web에 0.0.0.0/0  /  Internet gateway 추가</p>
<p><code>보안그룹 생성</code><br>sgapne2devweb와<br>ssh / http 생성</p>
<p><code>EC2생성</code><br>ec2-apne2a-dev-web</p>
<p>생성한 서브넷에 접속하여</p>
<p>아래 입력<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo yum update</div><div class="line">sudo yum install httpd</div><div class="line">sudo systemctl start httpd</div><div class="line">curl localhost</div></pre></td></tr></table></figure></p>
<p>지금까지 환경 구성했ㅆ던것들을 템플릿화 하여 코드로 관리할 수 도 있다<br>CloudFormation 활용하여….</p>
<h3 id="로드벨런서"><a href="#로드벨런서" class="headerlink" title="로드벨런서"></a>로드벨런서</h3><p>서브넷에 붙기전에 로드벨런서에 붙는다.<br>이는 로컬 로드벨런서임.</p>
<p>elb를 거치도록 하는것이 좋다. elb는 다른서브넷에도 접근이 가능하다. 즉 서브넷이 죽었을 때 다른곳으로 보내줄 수 있다</p>
<p>elb에는 인스턴스를 식별할 수 있는것이 주어져야함</p>
<p>최근에는 DNS또한 로드벨런싱을 어느정도 해주긴 함.<br>DNS가 위치 등의 정보에 따라 적절한 elb에 연결해줌</p>
<h3 id="로드벨런서-생성-실습"><a href="#로드벨런서-생성-실습" class="headerlink" title="로드벨런서 생성 실습"></a>로드벨런서 생성 실습</h3><p>EC2의 좌측 로드밸런서 탭</p>
<p>로드밸런서 생성 클릭</p>
<p>Classic Load Balancer 생성<br>이름 : elb-apne2-deb-web<br>내부 로드 밸런서 생성 : 체크</p>
<p>다음<br>보안설정구성 그냥 다음</p>
<p>4단계: 상태 검사 구성은 헬스체크를 어디로 얼마 주기로 할 것인지.<br>다음</p>
<h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p>프라이빗으로 구성하여 yum update를 할 경우 외부로 나갈 수 없게되는데 이를 해결하기 위해 NAT를 쓴다.</p>
<p>기본적인가 BastionHost Public로 두고 ELB public로 하고<br>NAT, Web on premese 등을 private로 많이쓴다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;AWS&quot;&gt;&lt;a href=&quot;#AWS&quot; class=&quot;headerlink&quot; title=&quot;AWS&quot;&gt;&lt;/a&gt;AWS&lt;/h3&gt;&lt;p&gt;전세계에서 가장 많이 쓰는 퍼블릭 서버&lt;br&gt;IAAS로 시작함&lt;/p&gt;
&lt;h3 id=&quot;가용성-존-AZ&quot;&gt;&lt;a href=&quot;
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="오픈소스,기술" scheme="http://KKimSangHeon.github.io/categories/CS/%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4-%EA%B8%B0%EC%88%A0/"/>
    
    
      <category term="Streamset" scheme="http://KKimSangHeon.github.io/tags/Streamset/"/>
    
  </entry>
  
  <entry>
    <title>5.빈의 스코프</title>
    <link href="http://KKimSangHeon.github.io/2020/01/13/spring/"/>
    <id>http://KKimSangHeon.github.io/2020/01/13/spring/</id>
    <published>2020-01-13T12:27:57.000Z</published>
    <updated>2020-01-13T13:17:57.374Z</updated>
    
    <content type="html"><![CDATA[<p>앞에까지는 아무 설정도 하지 않은 싱글톤 스코프의 빈을 사용하였다.<br>(강사님은 싱글톤 스코프 외에는 사용할 일이 거의 없을거라 하심.)</p>
<h3 id="싱글톤-스코프"><a href="#싱글톤-스코프" class="headerlink" title="싱글톤 스코프"></a>싱글톤 스코프</h3><p><code>싱글톤 스코프</code> : 어플리케이션에 걸쳐 인스턴스가 하나뿐!<br>어플리케이션 콘텍스트를 만들 때 만들어진다. 즉 어플리케이션 구동 시 시간이 길어질 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@Component</div><div class="line">public class Proto &#123;</div><div class="line">  @Autowired</div><div class="line">  Single single;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">@Component</div><div class="line">public class Single &#123;</div><div class="line">  @Autowired</div><div class="line">  Proto proto;</div><div class="line"></div><div class="line">  public Proto getProto() &#123;</div><div class="line">    return proto;</div><div class="line">  &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="프로토타입-스코프"><a href="#프로토타입-스코프" class="headerlink" title="프로토타입 스코프"></a>프로토타입 스코프</h3><p><code>프로토타입 스코프</code> : 매번 새로운 인스턴스를 만드는 스코프<br>@Scope(“prototype”) 를 붙여주면 된다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@Component @Scope(&quot;prototype&quot;)</div><div class="line">public class Proto &#123;</div><div class="line">  @Autowired</div><div class="line">  Single single;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위 처럼 프로토 타입 빈이 싱글톤 빈을 참조하면 문제가 없다<br>(프로토타입의 빈은 매번 새롭겠지만 프로토타입의 빈은 동일 한 것)</p>
<p>하지만 싱글톤 빈이 프로토 타입 빈을 참조하면??<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@Component</div><div class="line">public class Single &#123;</div><div class="line"></div><div class="line">  @Autowired</div><div class="line">  private Proto proto;</div><div class="line"></div><div class="line">  public Proto getProto() &#123;</div><div class="line">    return proto;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">....getBean(Single.class).getProto()  </div><div class="line">....getBean(Single.class).getProto()</div><div class="line">....getBean(Single.class).getProto()</div></pre></td></tr></table></figure></p>
<p>마지막 3줄의 Proto 는 모두 동일<br>의도한 바가 아님!</p>
<h3 id="해결방법은"><a href="#해결방법은" class="headerlink" title="해결방법은?"></a>해결방법은?</h3><h4 id="해결방법-1-scoped-proxy"><a href="#해결방법-1-scoped-proxy" class="headerlink" title="해결방법 1. scoped-proxy"></a>해결방법 1. scoped-proxy</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Component @Scope(&quot;prototype&quot;, proxyMode = ScopedProxyMode.TARGET_CLASS)</div><div class="line">public class Proto &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Proto 빈을 클래스기반 프록시로 감싸라<br>프록시로 감싸는 이유 : 다른 빈들이 프로토 빈을 직접 참조하면 안되기 때문에… 직접 쓰면 바궈줄 여지가 없다. cg라이브러리를 활용해 클래스 기반 프록시를 만들어준다.</p>
<p>Single 내 Proto의 참조변수는 Proto 클래스를 상속한 Proxy가 주입되게 되는것이다.</p>
<h4 id="해결방법-2-ObjectProvider"><a href="#해결방법-2-ObjectProvider" class="headerlink" title="해결방법 2.ObjectProvider"></a>해결방법 2.ObjectProvider</h4><p>1번이 어렵고 성능에도 영향을 줄것같다면 이 방법을 쓰자.  하지만 ObjectProvider라는 스프링 코드가 들어가기 때문에 조금 그렇다….</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@Component @Scope(&quot;prototype&quot;)</div><div class="line">public class Proto &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Component</div><div class="line">public class Single &#123;</div><div class="line"></div><div class="line">  @Autowired</div><div class="line">  private ObjectProvider&lt;Proto&gt; proto;</div><div class="line"></div><div class="line">  public Proto getProto() &#123;</div><div class="line">    return proto.getIfAvailable();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="싱글톤-객체를-사용할-때-주의해야-할-점"><a href="#싱글톤-객체를-사용할-때-주의해야-할-점" class="headerlink" title="싱글톤 객체를 사용할 때 주의해야 할 점"></a>싱글톤 객체를 사용할 때 주의해야 할 점</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@Component</div><div class="line">public class Single &#123;</div><div class="line"></div><div class="line">  int counter;</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">  counter++;  //Thread Safe하지 않다.</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="참고할것"><a href="#참고할것" class="headerlink" title="참고할것"></a>참고할것</h3><p><a href="https://en.wikipedia.org/wiki/Proxy_pattern" target="_blank" rel="external">https://en.wikipedia.org/wiki/Proxy_pattern</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;앞에까지는 아무 설정도 하지 않은 싱글톤 스코프의 빈을 사용하였다.&lt;br&gt;(강사님은 싱글톤 스코프 외에는 사용할 일이 거의 없을거라 하심.)&lt;/p&gt;
&lt;h3 id=&quot;싱글톤-스코프&quot;&gt;&lt;a href=&quot;#싱글톤-스코프&quot; class=&quot;headerlink&quot;
    
    </summary>
    
      <category term="Web/App" scheme="http://KKimSangHeon.github.io/categories/Web-App/"/>
    
      <category term="Spring" scheme="http://KKimSangHeon.github.io/categories/Web-App/Spring/"/>
    
    
      <category term="Spring" scheme="http://KKimSangHeon.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Thingsboard</title>
    <link href="http://KKimSangHeon.github.io/2020/01/13/thingsboard/"/>
    <id>http://KKimSangHeon.github.io/2020/01/13/thingsboard/</id>
    <published>2020-01-13T11:24:26.000Z</published>
    <updated>2020-01-13T12:03:45.548Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Thingsboard"><a href="#Thingsboard" class="headerlink" title="Thingsboard"></a>Thingsboard</h3><ul>
<li>오픈소스 IoT 플랫폼으로서 데이터 수집, 처리, 시각화, 디바이스 관리 기능 등을 제공</li>
<li>클라우드, on-premise 환경에서 손쉬운 설치를 제공하며 데이터 유실이 없음 (한 노드가 죽었을 때 downtime 없이 대체 가능)</li>
<li>Multi-tenancy 구조</li>
<li>Downtime 없는 Scale Out 가능</li>
<li>SQL / NoSQL / SQL + NoSQL 사용 가능</li>
</ul>
<h3 id="가격정책"><a href="#가격정책" class="headerlink" title="가격정책"></a>가격정책</h3><img src="/2020/01/13/thingsboard/1.jpg" alt="가격정책" title="가격정책">
<p>사용 환경에 따른 다양한 가격정책이 존재. 영구사용의 경우 2999$</p>
<h3 id="Use-Case"><a href="#Use-Case" class="headerlink" title="Use Case"></a>Use Case</h3><img src="/2020/01/13/thingsboard/2.jpg" alt="Use Case" title="Use Case">
<h3 id="제공-설치환경"><a href="#제공-설치환경" class="headerlink" title="제공 설치환경"></a>제공 설치환경</h3><img src="/2020/01/13/thingsboard/3.jpg" alt="가격정책" title="가격정책">
<p>다양한 플랫폼에서 설치를 지원하므로 on premise 혹은 cloud 환경에 손쉽게 설치 가능.</p>
<h3 id="Multi-tenancy"><a href="#Multi-tenancy" class="headerlink" title="Multi-tenancy"></a>Multi-tenancy</h3><p>ThingsBoard의 유저 구분</p>
<ul>
<li>System Administrator</li>
<li>Tenant Administrator</li>
<li>Customer</li>
</ul>
<h3 id="Asset"><a href="#Asset" class="headerlink" title="Asset"></a>Asset</h3><img src="/2020/01/13/thingsboard/5.jpg" alt="Asset" title="Asset">
<p>논리적 구성단위인 Asset</p>
<ul>
<li>Asset과 Device를 계층 형태(Contain, Manage), 즉 상위/하위 개념으로 구성가능</li>
<li>Device, Asset에 속성 정보 지정가능</li>
</ul>
<p>속성정보 활용예</p>
<ul>
<li>Device의 속성정보에 위경도를 지정해 지도상에 표시 가능</li>
</ul>
<h3 id="Multi-tenancy-amp-Asset의-활용예"><a href="#Multi-tenancy-amp-Asset의-활용예" class="headerlink" title="Multi-tenancy &amp; Asset의 활용예"></a>Multi-tenancy &amp; Asset의 활용예</h3><img src="/2020/01/13/thingsboard/6.jpg" alt="Multi-tenancy & Asset" title="Multi-tenancy & Asset">
<h3 id="System-Administrator의-역할"><a href="#System-Administrator의-역할" class="headerlink" title="System Administrator의 역할"></a>System Administrator의 역할</h3><ul>
<li>IoT 플랫폼을 사용할 Tenant 관리</li>
<li>위젯관리</li>
<li>보안설정</li>
</ul>
<p>Security Setting 내 항목</p>
<ul>
<li>최대 로그인 시도횟수, 계정이 잠기게 될 경우 메일을 수신할 주소 설정</li>
<li>최소 패스워드 길이 설정</li>
<li>최소 소문자/대문자/숫자/특수문자 의 수 설정</li>
<li>패스워드 유지 기간 설정</li>
</ul>
<h3 id="Tenant-Administrator의-역할"><a href="#Tenant-Administrator의-역할" class="headerlink" title="Tenant Administrator의 역할"></a>Tenant Administrator의 역할</h3><ul>
<li>디바이스, 룰, 대시보드, 위젯 등을 관리하며 Customer 가 각종 정보를 확인할 수 있도록 권한을 부여 함.</li>
</ul>
<h3 id="기능-정리"><a href="#기능-정리" class="headerlink" title="기능 정리"></a>기능 정리</h3><img src="/2020/01/13/thingsboard/7.jpg" alt="룰관리 기능" title="룰관리 기능">
<img src="/2020/01/13/thingsboard/8.jpg" alt="디바이스 연동" title="디바이스 연동">
<img src="/2020/01/13/thingsboard/9.jpg" alt="기타" title="기타">
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Thingsboard&quot;&gt;&lt;a href=&quot;#Thingsboard&quot; class=&quot;headerlink&quot; title=&quot;Thingsboard&quot;&gt;&lt;/a&gt;Thingsboard&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;오픈소스 IoT 플랫폼으로서 데이터 수집, 처리, 
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="오픈소스,기술" scheme="http://KKimSangHeon.github.io/categories/CS/%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4-%EA%B8%B0%EC%88%A0/"/>
    
    
      <category term="Streamset" scheme="http://KKimSangHeon.github.io/tags/Streamset/"/>
    
  </entry>
  
  <entry>
    <title>20200112 돈의문마을</title>
    <link href="http://KKimSangHeon.github.io/2020/01/12/photography/"/>
    <id>http://KKimSangHeon.github.io/2020/01/12/photography/</id>
    <published>2020-01-12T13:51:39.000Z</published>
    <updated>2020-01-12T14:01:45.382Z</updated>
    
    <content type="html"><![CDATA[<p>출사 소모임 두번째 활동<br><img src="/2020/01/12/photography/IMG_2802.jpg" alt="1" title="1"><br><img src="/2020/01/12/photography/IMG_2794.jpg" alt="1" title="1"><br><img src="/2020/01/12/photography/IMG_2799.jpg" alt="1" title="1"><br><img src="/2020/01/12/photography/IMG_2814.jpg" alt="1" title="1"><br><img src="/2020/01/12/photography/IMG_2825.jpg" alt="1" title="1"><br><img src="/2020/01/12/photography/IMG_2834.jpg" alt="1" title="1"><br><img src="/2020/01/12/photography/IMG_2839.jpg" alt="1" title="1"><br><img src="/2020/01/12/photography/IMG_2843.jpg" alt="1" title="1"><br><img src="/2020/01/12/photography/IMG_2847.jpg" alt="1" title="1"><br><img src="/2020/01/12/photography/IMG_2867.jpg" alt="1" title="1"><br><img src="/2020/01/12/photography/IMG_2888.jpg" alt="1" title="1"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;출사 소모임 두번째 활동&lt;br&gt;&lt;img src=&quot;/2020/01/12/photography/IMG_2802.jpg&quot; alt=&quot;1&quot; title=&quot;1&quot;&gt;&lt;br&gt;&lt;img src=&quot;/2020/01/12/photography/IMG_2794.jpg&quot; al
    
    </summary>
    
      <category term="About Me" scheme="http://KKimSangHeon.github.io/categories/About-Me/"/>
    
      <category term="Photograph" scheme="http://KKimSangHeon.github.io/categories/About-Me/Photograph/"/>
    
    
      <category term="Photograph" scheme="http://KKimSangHeon.github.io/tags/Photograph/"/>
    
  </entry>
  
  <entry>
    <title>4.@Component와 컴포넌트스캔</title>
    <link href="http://KKimSangHeon.github.io/2020/01/10/spring/"/>
    <id>http://KKimSangHeon.github.io/2020/01/10/spring/</id>
    <published>2020-01-10T10:02:18.000Z</published>
    <updated>2020-01-10T11:00:14.702Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Component와-컴포넌트스캔"><a href="#Component와-컴포넌트스캔" class="headerlink" title="@Component와 컴포넌트스캔"></a>@Component와 컴포넌트스캔</h3><h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>SpringBootApplication이 @ComponentScan을 갖고있는데 @ComponentScan으로 인해 @Service @Repository @Controller @Configuration를 붙이면 빈으로 등록되게 해준것이다.<br>(@Service/ @Repository/ @Controller/ @Configuration 은 내부적으로 @Component 를 갖고있다)</p>
<p>ComponentScan은 basePackagesClasses로 값을 주면 스캔을 해서 빈을 생성하게 된다.</p>
<p>즉 @SpringBootApplication이 어플리케이션 클래스에 붙어있을 경우 해당패키지에 대해 컴포넌트 스캔을 하게된다.(타 패키지는 스캔을 하지않음)</p>
<p>컴포넌트 스캔을 한다고 해서 모든것을 빈으로 생성해주진 않는다. @Filter 으로 원하지 않는것에 대해 거를 수 있다.</p>
<p><code>빈 주입이 잘안될땐 컴포넌트 스캔의 범위를 잘 생각해보자</code></p>
<p>요약하면 @Component스캔은 basePackagesClasses /  @Filter 만 기억하자!</p>
<p>빈이 많을경우 어플리케이션을 실행할 때 구동시간이 오래걸릴 수 있다.</p>
<p>구동시간이 오래걸려서 싫을 때는 펑션을 사용한 빈 등록을 고려해보자(Spring 5부터 지원)</p>
<h3 id="펑션을-사용한-빈-등록"><a href="#펑션을-사용한-빈-등록" class="headerlink" title="펑션을 사용한 빈 등록"></a>펑션을 사용한 빈 등록</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">MyBean 클래스는 @ComponentScan의 basePackagesClasses 범위 밖이다. MyBean은 @Service 없어도 됨.</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">	new SpringApplicationBuilder().sources(Demospring51Application.class)</div><div class="line">		.initializers((ApplicationContextInitializer&lt;GenericApplicationContext&gt;)applicationContext -&gt; &#123;</div><div class="line">			applicationContext.registerBean(MyBean.class);</div><div class="line">		&#125;).run(args);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위를 할경우 빈을 생성할 때 자신의 코드를 추가할 수 있고 구동시간의 이점이 있다.</p>
<h3 id="ComponentScan의-동작-원리"><a href="#ComponentScan의-동작-원리" class="headerlink" title="ComponentScan의 동작 원리"></a>ComponentScan의 동작 원리</h3><p>BeanPostProcessor이 아닌 BeanFactoryPostProcessor를 구현한 ConfigurationClassPostProcessor와 연결되어 있다.<br>BeanFactoryPostProcessor은 BeanPostProcessor와 비슷한데 실행되는 시점이 다름. 다른 모든 빈들이 만들어지기 전에 적용해준다.<br>다른빈들이 모두 등록되기전에 컴포넌트 스캔을 해서 빈을 등록해준다.<br>여기서 다른빈이란 펑션을 사용한 빈 등록 등등…</p>
<h3 id="참고사항"><a href="#참고사항" class="headerlink" title="참고사항"></a>참고사항</h3><p>펑션을 사용한 빈등록, @Bean 을 통해 빈을 등록하는 방법은 @ComponentScan을 나오게한 원인(많은 빈을 수동으로 등록하는 불편함)을 다시 야기하므로<br>@ComponentScan외의 것들을 사용하여 빈을 등록할 때는 잘생각해보자.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Component와-컴포넌트스캔&quot;&gt;&lt;a href=&quot;#Component와-컴포넌트스캔&quot; class=&quot;headerlink&quot; title=&quot;@Component와 컴포넌트스캔&quot;&gt;&lt;/a&gt;@Component와 컴포넌트스캔&lt;/h3&gt;&lt;h3 id=&quot;Com
    
    </summary>
    
      <category term="Web/App" scheme="http://KKimSangHeon.github.io/categories/Web-App/"/>
    
      <category term="Spring" scheme="http://KKimSangHeon.github.io/categories/Web-App/Spring/"/>
    
    
      <category term="Spring" scheme="http://KKimSangHeon.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>StreamSets의 에러처리</title>
    <link href="http://KKimSangHeon.github.io/2020/01/09/streamset/"/>
    <id>http://KKimSangHeon.github.io/2020/01/09/streamset/</id>
    <published>2020-01-09T12:59:00.000Z</published>
    <updated>2020-01-09T13:03:39.876Z</updated>
    
    <content type="html"><![CDATA[<p>에러 처리는 Stage(Origin, Processor, Destination, Executor) 관점, 파이프라인 관점에서 처리방법이 존재</p>
<h3 id="Stage-Origin-Processor-Destination-Executor-관점"><a href="#Stage-Origin-Processor-Destination-Executor-관점" class="headerlink" title="Stage(Origin, Processor, Destination, Executor) 관점"></a>Stage(Origin, Processor, Destination, Executor) 관점</h3><p>Discard , Send to Error, Stop Pipeline</p>
<h3 id="파이프라인-관점"><a href="#파이프라인-관점" class="headerlink" title="파이프라인 관점"></a>파이프라인 관점</h3><p>Discard, Send Response to Origin, Write to Another Pipeline, Write to Elasticsearch/File/Kafka …</p>
<img src="/2020/01/09/streamset/error1.png" alt="에러처리 예시" title="에러처리 예시">
<p>위 그림은 파이프라인을 총 2개 생성한 상황이다.</p>
<p><code>카프카 컨슘 파이프라인</code>에서 에러가 발생할 경우 SDC RPC를 통해 다른 파이프라인으로 에러내용을 전달하도록 하였고 <code>에러처리 파이프라인</code>에서는 RPC로 받은 에러데이터를 Email로 보내고 Local 파일로 저장하는 상황이다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;에러 처리는 Stage(Origin, Processor, Destination, Executor) 관점, 파이프라인 관점에서 처리방법이 존재&lt;/p&gt;
&lt;h3 id=&quot;Stage-Origin-Processor-Destination-Executor-관점
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="오픈소스,기술" scheme="http://KKimSangHeon.github.io/categories/CS/%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4-%EA%B8%B0%EC%88%A0/"/>
    
    
      <category term="Streamset" scheme="http://KKimSangHeon.github.io/tags/Streamset/"/>
    
  </entry>
  
  <entry>
    <title>object</title>
    <link href="http://KKimSangHeon.github.io/2020/01/09/object/"/>
    <id>http://KKimSangHeon.github.io/2020/01/09/object/</id>
    <published>2020-01-09T12:57:06.000Z</published>
    <updated>2020-01-19T04:56:16.011Z</updated>
    
    <content type="html"><![CDATA[<h3 id="오브젝트-9장"><a href="#오브젝트-9장" class="headerlink" title="오브젝트 9장"></a>오브젝트 9장</h3><p>OCP - 추상화에 의존하여 컴파일 타임의존성은 유지하면서 런타임 의존성의 가능성을 확장하고 수정할 수 있는 구조.</p>
<p>객체 생성,사용자 분리 - 동일 클래스 안에서 객체 생성과 사용이라는 두가지 이질적인 목적을 가진 코드가 공존할 경우 부적절.<br>(Movie에게 금액할인정책을 적용할지, 비율할인 정책을 적용할지 알고 있는것은 그 시점에 Movie와 협력할 클라이언트이므로 클라이언트가 할인정책을 생성하고 Movie는 추상화된 메소드를 사용하여 구현)</p>
<p>FACTORY - 생성과 사용을 분리하기 위해 객체생성에 특화된 객체</p>
<p>표현적 분해 - 도메인에 존재하는 사물 또는 개념을 표현하는 객체들을 이용해 시스템 분해</p>
<p>PURE FABRICATION - 특정 책임을 할당하기 위해 Information expert를 찾아봤는데 없을 경우 도메인 모델에 속하지 않는 Factory를 활용. 보통 행위적 분해로 인해 생성되는것이 대부분</p>
<p>의존성주입 - 생성자 주입, setter주입, 메서드 주입(주입인가에 대한 논란이 있다)</p>
<p>SERVICE LOCATOR 패턴 - 저장소(Storage.AmountDiscountPolicy)를 통해 의존성 해결하는 패턴 (가장널리 쓰임 - 그렇지만 비추함)</p>
<p>의존성역전원칙 - 상위 모듈, 하위모듈 둘 다 추상화에 의존하라(과거 패러다임은 상위가 하위에 의존)</p>
<p>SEPARATED INTERFACE 패턴 - 추상화(인터페이스 등)를 별도의 패키지가 아닌 클라이언트가 속한 패키지에 포함시켜라</p>
<h3 id="오브젝트-10장"><a href="#오브젝트-10장" class="headerlink" title="오브젝트 10장"></a>오브젝트 10장</h3><p>상속을 위한 경고- 자식 클래스의 메소드 아넹서 super 참조를 이용해 부모클래스의 메소드를 호출할 경우 두 클래스는 강하게 결합된다. super호출을 제거 할 수읶는 방법을 찾아라</p>
<p>경고2 상속받은 부모 클래스의 메소드가 자식 클래스의 내부 구조에 대한 규칙을 깨뜨릴수있다<br>ex 스택 add(0,”data”) 으로 맨앞에 넣는것…</p>
<p>경고3 자식 클래스가 부모 클래스의 메소드를 오버라이딩 할 경우 부모클래스가 자신의 메소드를 사용하는 방법에 클래스가 결합될 수 있다</p>
<p>경고4 클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수 밖에 없다</p>
<p>취약한 기반 클래스문제- 자식클래스가 부모 클래스의 뱐경에 취약해지는 현상</p>
<p>상속문제 해결방법<br>1.차이를 메서드로 추출하라 -&gt; 중복코드를 부모 클래스로 올려라(메소드 먼저 올리면 불필요한 인스턴스 변수를 남겨두기 쉽다) -&gt; 다른부분은 시그니처만 올려라(protected로)</p>
<p>상속의 오용과 남용은 어플리케이션을 이해하고 확장하기 어렵게 만드므로 정말로 필요한 경우에만 사용하라</p>
<h3 id="오브젝트-11장"><a href="#오브젝트-11장" class="headerlink" title="오브젝트 11장"></a>오브젝트 11장</h3><p>재사용을 위한 방법 - 상속, 합성<br>상속관계 - Is-a - 화이트박스 재사용(부모클래스의 내부가 자식에 공개되기 때문)<br>합성관계 - Has-a - 블랙박스 재사용(객체의 내부는 공개되지 않고 인터페이스를 통해서만 재사용됨.)</p>
<p>상속은 결합도를 높이며 코드재사용을 위해서는 상속보다는 합성을 써라</p>
<p>상속은 부모클래스의 안에 구현된 코드에 의존하지만 합성은 객체의 퍼블릭 인터페이스를 의존하므로 결합도 낮아진다.</p>
<p>훅메서드 - 추상 메서드와 동일하게 자식 클래스에서 오버라이딩할 의도로 메서드를 추가했지만 편의를 위해 기본 구현을 제공하는 메서드.<br>ex , 추상클래스 내 afterCalculate 메소드를 단순히 retrun fee; 로 구현하고 다른 메서드가 afterCalculate를 호출할 경우 추상클래스를 상속한 클래스들은  afterCalculate메서드를 적절히 오버라이딩 하여 활용할 수 있다.</p>
<p>/</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;오브젝트-9장&quot;&gt;&lt;a href=&quot;#오브젝트-9장&quot; class=&quot;headerlink&quot; title=&quot;오브젝트 9장&quot;&gt;&lt;/a&gt;오브젝트 9장&lt;/h3&gt;&lt;p&gt;OCP - 추상화에 의존하여 컴파일 타임의존성은 유지하면서 런타임 의존성의 가능성을 확장하
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="OOP" scheme="http://KKimSangHeon.github.io/categories/CS/OOP/"/>
    
    
      <category term="OOP" scheme="http://KKimSangHeon.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>3.@Autowired</title>
    <link href="http://KKimSangHeon.github.io/2020/01/08/spring/"/>
    <id>http://KKimSangHeon.github.io/2020/01/08/spring/</id>
    <published>2020-01-08T12:48:13.000Z</published>
    <updated>2020-01-10T10:03:25.470Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><p>필요한 의존 객체의 “타입”에 해당하는 빈을 찾아 주입한다.</p>
<p>생성자, 세터, 필드에 사용가능하다 아래 예시를 참고하자.</p>
<p>BookService의 생성자에 Autowired를 달았다. 잘동작할것이다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@Service</div><div class="line">public class BookService &#123;</div><div class="line">  BookRepository bookRepository;</div><div class="line"></div><div class="line">  @Autowired</div><div class="line">  public BookService(BookRepository bookRepository) &#123;</div><div class="line">    this.bookRepository = bookRepository;</div><div class="line">  &#125;  </div><div class="line">&#125;</div><div class="line">///////////////////////////////////</div><div class="line">@Repository</div><div class="line">public class BookRepository&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>이번에는 세터에다 Autowired를 달아주고 @Repository를 지워보자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@Service</div><div class="line">public class BookService &#123;</div><div class="line">  BookRepository bookRepository;</div><div class="line"></div><div class="line">  @Autowired</div><div class="line">  public void setBookRepository(BookRepository bookRepository) &#123;</div><div class="line">    this.bookRepository = bookRepository;</div><div class="line">  &#125;  </div><div class="line">&#125;</div><div class="line">///////////////////////////////////</div><div class="line"></div><div class="line">public class BookRepository&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위는 실패하는데 왜 실패할까<br><code>단순 세터에 Autowired만 붙였으므로 인스턴스 생성은 되어야 하는거아녀?</code></p>
<p>Autowired가 있기때문에 의존성 주입을 시도하게되고 이로 인해 실패한다.</p>
<p>실패를 벗어나기 위해서는 @Autowired(require = false)로 해결할 수 있다.</p>
<p>즉 생성자가 아닌곳에 붙은 @Autowird는 require = false 옵션을 적절히 활용할 수 있다.<br>(생성자에 Autowired(required = false) 가 붙어있으면 객체 자체 생성이 불가능하므로 생성자에는 부적절)</p>
<h3 id="해당-타입의-빈이-여러개인-경우"><a href="#해당-타입의-빈이-여러개인-경우" class="headerlink" title="해당 타입의 빈이 여러개인 경우"></a>해당 타입의 빈이 여러개인 경우</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">interface A &#123;</div><div class="line">  ..</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Repository</div><div class="line">class BRepository implements ARepository &#123;</div><div class="line">  ..</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Repository</div><div class="line">class CRepository implements ARepository &#123;</div><div class="line">  ..</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">@service</div><div class="line">public class AService &#123;</div><div class="line">  @Autowired</div><div class="line">  ARepository aRepository;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AService의 aRepository에는 누가 주입될까?<br>내가 어떤걸 원하는지 스프링은 모르기 때문에 에러가 발생한다.</p>
<p>해결방법은?</p>
<ol>
<li>@Primary 어노테이션 붙이기 (추천)<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Repository @Primary</div><div class="line">class CRepository implements ARepository &#123;</div><div class="line">  ..</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>위처럼 할경우 CRepository가 주입된다.</p>
<ol>
<li>Qualifier 활용<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@service</div><div class="line">public class AService &#123;</div><div class="line">  @Autowired @Qualifier(&quot;cRepository&quot;)</div><div class="line">  ARepository aRepository;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>위처럼 할경우 CRepository가 주입된다.</p>
<ol>
<li>해당 타입의 빈 모두 주입받기<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@service</div><div class="line">public class AService &#123;</div><div class="line">  @Autowired</div><div class="line">   List&lt;ARepository&gt; aRepository;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>리스트에 BRepository , CRepository가 들어간다.</p>
<ol>
<li>추천하진 않지만 알고만 있어라<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@service</div><div class="line">public class AService &#123;</div><div class="line">  @Autowired</div><div class="line">  ARepository cRepository;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>Autowired는 타입만 보는것이 아니라 이름도 한번 보기때문에 위처럼 할 경우 cRepository를 주입받을 수 있다.</p>
<hr>
<h3 id="동작원리는"><a href="#동작원리는" class="headerlink" title="동작원리는?"></a>동작원리는?</h3><p><code>BeanPostProcessor</code><br>새로 만든 빈 인스턴스를 수정할 수 있도록 도와주는 인터페이스이다.</p>
<p><code>AutowiredAnnotationBeanPostProcessor​ extends BeanPostProcessor</code><br>위에 보다시피 AutowiredAnnotationBeanPostProcessor​가 BeanPostProcessor을 상속하여 사용하는데 초기화 이전에 @Autowired같은 어노테이션을 찾아 주입을 해준다.</p>
<p><code>이제 동작원리 설명</code><br>ApplicationContext (BeanFactory)가 BeanPostProcessor을 구현한 빈을 찾고 AutowiredAnnotationBeanPostProcessor를 찾아 일반적인 빈들에게 해당 로직을 적용하는것이다.<br>(결국 AutowiredAnnotationBeanPostProcessor​도 빈으로 등록되어있다는것)<br>(ApplicationContext는 빈 들을 갖고있다)</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Autowired&quot;&gt;&lt;a href=&quot;#Autowired&quot; class=&quot;headerlink&quot; title=&quot;@Autowired&quot;&gt;&lt;/a&gt;@Autowired&lt;/h3&gt;&lt;p&gt;필요한 의존 객체의 “타입”에 해당하는 빈을 찾아 주입한다.&lt;/p&gt;
&lt;p
    
    </summary>
    
      <category term="Web/App" scheme="http://KKimSangHeon.github.io/categories/Web-App/"/>
    
      <category term="Spring" scheme="http://KKimSangHeon.github.io/categories/Web-App/Spring/"/>
    
    
      <category term="Spring" scheme="http://KKimSangHeon.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>2.스프링  ApplicationContext와 다양한 빈 설정 방법</title>
    <link href="http://KKimSangHeon.github.io/2020/01/07/spring/"/>
    <id>http://KKimSangHeon.github.io/2020/01/07/spring/</id>
    <published>2020-01-07T12:26:10.000Z</published>
    <updated>2020-01-08T12:51:34.926Z</updated>
    
    <content type="html"><![CDATA[<h3 id="고전적인-빈-생성방법"><a href="#고전적인-빈-생성방법" class="headerlink" title="고전적인 빈 생성방법"></a>고전적인 빈 생성방법</h3><h4 id="application-xml의-등장"><a href="#application-xml의-등장" class="headerlink" title="application.xml의 등장"></a>application.xml의 등장</h4><p>리소스에 application.xml을 생성하고</p>
<p><beans></beans> 안에 <bean> 을 생성한다<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;beans .....&gt;</div><div class="line">  &lt;bean id=&quot;bookService&quot; class=&quot;xxxxxx&quot; &gt;</div><div class="line">    &lt;property name=&quot;bookRepository&quot; ref=&quot;bookRepository&quot;/&gt;</div><div class="line">  &lt;/bean&gt;</div><div class="line"></div><div class="line">  &lt;bean id=&quot;bookRepository&quot; class=&quot;bookRepository&quot;/&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure></bean></p>
<p>해당 방법은 번거롭다!</p>
<p><u>그래서 등장한것이 바로 컴포넌트 스캔</u></p>
<h4 id="component-scan의-등장"><a href="#component-scan의-등장" class="headerlink" title="component-scan의 등장"></a>component-scan의 등장</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;beans ...&gt;</div><div class="line"> &lt;context:component-scan base-package=&quot;xxxxxxxx&quot;/&gt;</div><div class="line"></div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>이 경우 @Componet라는 어노테이션을 클래스 위에 붙여줌으로써 빈을 생성할 수 있다.</p>
<p>위의 두 경우(xml로 빈생성) ClassPathXmlApplicationContext 클래스를 통해 ApplicationContext 인스턴스를 생성한다.</p>
<p>빈을 xml말고 자바로 빈을생성 할 수 없을까? 있다<br><u> ApplicationConfig</u></p>
<h4 id="자바로-빈생성-할래-ApplicationConfig"><a href="#자바로-빈생성-할래-ApplicationConfig" class="headerlink" title="자바로 빈생성 할래 . ApplicationConfig"></a>자바로 빈생성 할래 . ApplicationConfig</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">@Configuration</div><div class="line">public class ApplicationConfig&#123;</div><div class="line">  @Bean</div><div class="line">  public BookRepository bookRepository() &#123;</div><div class="line">    return new BookRepository();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Bean</div><div class="line">  public BookService bookService()&#123;</div><div class="line">    BookService bookService = new BookService();</div><div class="line">    bookService.setBookRepository(bookRepository());</div><div class="line">    return bookService;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  위 메소드는 아래 메소드와 동일</div><div class="line">  @Bean</div><div class="line">  public BookService bookService(BookRepository bookRepository)&#123;</div><div class="line">    BookService bookService = new BookService();</div><div class="line">    bookService.setBookRepository(bookRepository);</div><div class="line">    return bookService;</div><div class="line">  &#125;  </div><div class="line"></div><div class="line">  두번째 것을 아래 메소드로 할 경우 BookService내 bookRepository에 Autowired를 넣어주면 주입이 된다.</div><div class="line">  //생성자로 주입받아야 할 경우에는 Autowired로 어떻게 할 수 가 없다.</div><div class="line">  @Bean</div><div class="line">  public BookService bookService()&#123;</div><div class="line">      return new BookService();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>자바로 할 땐 오히려 xml보다 불편한다 다른 편한방법없나? 있다<br><u>ComponentScan 어노테이션  </u></p>
<h4 id="좀더-편하게-자바로-빈생성할래-ComponentScan"><a href="#좀더-편하게-자바로-빈생성할래-ComponentScan" class="headerlink" title="좀더 편하게 자바로 빈생성할래 @ComponentScan"></a>좀더 편하게 자바로 빈생성할래 @ComponentScan</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Configuration</div><div class="line">@ComponentScan(basePackageClasses = XXX.class)</div><div class="line">//XXX 클래스가 위치한 곳부터 스캐닝을 함</div><div class="line">public class ApplicationConfig&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p>위의 과정을 하나의 어노테이션으로 해결해주는 어노테이션이 바로 @SpringBootApplication 이다.</p>
<p>위의 두 경우(java로 빈생성) AnnotationConfigApplicationContext 클래스를 통해 ApplicationContext 인스턴스를 생성한다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;고전적인-빈-생성방법&quot;&gt;&lt;a href=&quot;#고전적인-빈-생성방법&quot; class=&quot;headerlink&quot; title=&quot;고전적인 빈 생성방법&quot;&gt;&lt;/a&gt;고전적인 빈 생성방법&lt;/h3&gt;&lt;h4 id=&quot;application-xml의-등장&quot;&gt;&lt;a href=
    
    </summary>
    
      <category term="Web/App" scheme="http://KKimSangHeon.github.io/categories/Web-App/"/>
    
      <category term="Spring" scheme="http://KKimSangHeon.github.io/categories/Web-App/Spring/"/>
    
    
      <category term="Spring" scheme="http://KKimSangHeon.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>StreamSets 이란</title>
    <link href="http://KKimSangHeon.github.io/2020/01/07/streamsets4/"/>
    <id>http://KKimSangHeon.github.io/2020/01/07/streamsets4/</id>
    <published>2020-01-07T11:25:56.000Z</published>
    <updated>2020-01-07T12:09:34.525Z</updated>
    
    <content type="html"><![CDATA[<h3 id="StreamSets란"><a href="#StreamSets란" class="headerlink" title="StreamSets란?"></a>StreamSets란?</h3><p>데이터 흐름을 관리할 수 있으며 Data drift에 유연하게 대처가능한 솔루션</p>
<img src="/2020/01/07/streamsets4/SS1.jpg" alt="StreamSets의 플랫폼들" title="StreamSets의 플랫폼들">
<h3 id="StreamSets-활용-및-장점-요약"><a href="#StreamSets-활용-및-장점-요약" class="headerlink" title="StreamSets 활용 및 장점 요약"></a>StreamSets 활용 및 장점 요약</h3><p>글로벌 社에서 StreamSets을 Data Lakes, Big Data/Hadoop Ingestion, Event Streaming, IoT/edge device integration 등 용도로 사용중.</p>
<ul>
<li>데이터센터, AWS, GCP 등에 배포 가능하며 YARN, MESOS, Kubernetes을 활용한 스케일링 가능.</li>
<li>처리량, 지연, 에러율 등을 UI로 확인할 수 있음.</li>
<li>민감한 데이터를 보호할 수 있음.</li>
</ul>
<h3 id="StreamSets의-개발-운영-Agility-측면의-장점"><a href="#StreamSets의-개발-운영-Agility-측면의-장점" class="headerlink" title="StreamSets의 개발, 운영, Agility 측면의 장점"></a>StreamSets의 개발, 운영, Agility 측면의 장점</h3><p>개발자 생산성 측면</p>
<ul>
<li>코드작성의 최소화, 자동 인스턴스 관리, 파이프라인 로직의 재활용 가능</li>
</ul>
<p>운영효율 측면</p>
<ul>
<li>파이프라인 시각화, 파이프라인 성능 모니터링, 이벤트에 대한 동작설정 가능</li>
</ul>
<p>Agility 측면</p>
<ul>
<li>Downtime 없는 파이프라인 내 데이터 시스템 업데이트, 데이터 변경 시 자동탐지 및 동기화, 버전 별 파이프라인의 성능 비교 가능</li>
</ul>
<h3 id="StreamSets-Data-Collector"><a href="#StreamSets-Data-Collector" class="headerlink" title="StreamSets Data Collector"></a>StreamSets Data Collector</h3><img src="/2020/01/07/streamsets4/SS2.png" alt="파이프라인 생성 시 예시" title="파이프라인 생성 시 예시">
<p>위의 화면에서 드래그앤드롭 방식으로 데이터 flow를 파이프라인으로 생성 및 관리 가능</p>
<p>파이프라인은 Origin/Processor/Destination/Executor 로 구성된다.</p>
<img src="/2020/01/07/streamsets4/SS3.png" alt="파이프라인 요소별 구분" title="파이프라인 요소별 구분">
<h4 id="Origin"><a href="#Origin" class="headerlink" title="Origin"></a>Origin</h4><ul>
<li>파이프라인의 시작점을 의미하며 파이프라인 내 하나만 생성할 수 있다.</li>
<li>Kafka / Redis / GCP / TCP / UDP 를 포함한 약 60여개를 data 근원지로 활용가능</li>
</ul>
<h4 id="Processor"><a href="#Processor" class="headerlink" title="Processor"></a>Processor</h4><ul>
<li>데이터 처리, 가공</li>
<li>Stream Selector / JSON Parser / Jython Evaluator /  Field Masker 를 포함한 약 50여개 기능 제공</li>
</ul>
<h4 id="Destination"><a href="#Destination" class="headerlink" title="Destination"></a>Destination</h4><ul>
<li>파이프라인의 목적지</li>
<li>Hbase / Local file / Redis / DB 를 포함한 50여개를 data 목적지로 활용가능</li>
</ul>
<h4 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h4><ul>
<li>이벤트를 수신했을 때 동작 정의</li>
<li>Email Executor / Shell Executor / JDBC Query Executor 를 포함한 약 10여개 기능 제공</li>
</ul>
<p>세부지원 요소 확인하기<br><a href="https://streamsets.com/documentation/datacollector/latest/help/datacollector/UserGuide/Processors/Processors_overview.html#concept_hpr_twm_jq" target="_blank" rel="external">https://streamsets.com/documentation/datacollector/latest/help/datacollector/UserGuide/Processors/Processors_overview.html#concept_hpr_twm_jq</a><br><a href="https://streamsets.com/documentation/datacollector/latest/help/datacollector/UserGuide/Executors/Executors-title.html" target="_blank" rel="external">https://streamsets.com/documentation/datacollector/latest/help/datacollector/UserGuide/Executors/Executors-title.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;StreamSets란&quot;&gt;&lt;a href=&quot;#StreamSets란&quot; class=&quot;headerlink&quot; title=&quot;StreamSets란?&quot;&gt;&lt;/a&gt;StreamSets란?&lt;/h3&gt;&lt;p&gt;데이터 흐름을 관리할 수 있으며 Data drift에 유연
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="오픈소스,기술" scheme="http://KKimSangHeon.github.io/categories/CS/%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4-%EA%B8%B0%EC%88%A0/"/>
    
    
      <category term="Streamset" scheme="http://KKimSangHeon.github.io/tags/Streamset/"/>
    
  </entry>
  
  <entry>
    <title>StreamSets Data Collector의 클러스터링 방법</title>
    <link href="http://KKimSangHeon.github.io/2020/01/07/streamsets3/"/>
    <id>http://KKimSangHeon.github.io/2020/01/07/streamsets3/</id>
    <published>2020-01-07T11:22:41.000Z</published>
    <updated>2020-01-07T11:25:11.110Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://streamsets.com/blog/five-ways-scale-kafka-streamsets/" target="_blank" rel="external">https://streamsets.com/blog/five-ways-scale-kafka-streamsets/</a></p>
<h3 id="1-Vertical-Scaling-–-Deploy-a-Bigger-Box"><a href="#1-Vertical-Scaling-–-Deploy-a-Bigger-Box" class="headerlink" title="1.Vertical Scaling – Deploy a Bigger Box"></a>1.Vertical Scaling – Deploy a Bigger Box</h3><p>가장 간단한 방법으로 여러개의 컨슈머 스레드를 생성하는 방법<br>컨슈머 스레드를 병렬로 실행하게 됨<br>서버가 죽으면 당연히 데이터 flow 또한 죽게됨.</p>
<p><code>카프카 관련지식으로 스레드는 카프카의 파티션의 수 보다 작아도 된다.</code></p>
<hr>
<h1 id="Horizontal-Scaling-–-Deploy-More-Boxes"><a href="#Horizontal-Scaling-–-Deploy-More-Boxes" class="headerlink" title="Horizontal Scaling – Deploy More Boxes"></a>Horizontal Scaling – Deploy More Boxes</h1><h3 id="2-Manually-Run-Multiple-Data-Collectors"><a href="#2-Manually-Run-Multiple-Data-Collectors" class="headerlink" title="2.Manually Run Multiple Data Collectors"></a>2.Manually Run Multiple Data Collectors</h3><p>수동으로 여러 인스턴스를 생성 후 각 인스턴스에서 파이프라인을 돌리는것이다.<br>이방법의 경우 간단한 방법이지만 수동으로 각 인스턴스의 파이프라인을 제어해야 하기 때문에 운영자가 번거로울 수 있다.</p>
<ul>
<li>장점<br>하나의 인스턴스가 죽게될 경우 카프카는 해당 파티션을 나머지 인스턴스에 할당하기 때문에 데이터 흐름을 유지할 수 있다.</li>
</ul>
<p><code>1.Vertical Scaling – Deploy a Bigger Box 와의 차이는 인스턴스의 수</code></p>
<hr>
<h3 id="3-Run-the-Pipeline-in-Cluster-Streaming-Mode"><a href="#3-Run-the-Pipeline-in-Cluster-Streaming-Mode" class="headerlink" title="3. Run the Pipeline in Cluster Streaming Mode"></a>3. Run the Pipeline in Cluster Streaming Mode</h3><p>분산 컴퓨팅 환경을 제공하는 YARN(Yet Another Resource Negotiator) 혹은 아파치 Mesos cluster 를 사용했다면 Data Collector’s Cluster Streaming mode를 사용하는것이 좋다.<br>파이프라인의 실행모드를 ‘Cluster YARN Streaming’ or ‘Cluster Mesos Streaming’로 설정하고 카프카 consumer을 생성하면 카프카 토픽에 부여된 파티션만큼의 노드를 요청하게 된다.</p>
<ul>
<li>장점<br>운영자가 파이프라인을 수동으로 여러개 생성할 필요가 없으며 클러스터 플랫폼(YARN or Mesos )이 스케일링을 관장한다<br>파티션 수가 변경되면 파이프라인을 재시작 하면된다.<br>또한 YARN의 경우 노드장애가 발생할경우 클러스터 플랫폼이 알아서 다시시작해준다.</li>
</ul>
<hr>
<h3 id="4-Use-StreamSets-Control-Hub-to-Start-Multiple-Pipeline-Instances-유료"><a href="#4-Use-StreamSets-Control-Hub-to-Start-Multiple-Pipeline-Instances-유료" class="headerlink" title="4.Use StreamSets Control Hub to Start Multiple Pipeline Instances ( 유료 )"></a>4.Use StreamSets Control Hub to Start Multiple Pipeline Instances ( 유료 )</h3><p>YARN이나 Mesos를 사용하지 않지만 Data Collector의 인스턴스를 자동으로 관리하고 싶을 때 StreamSets Control Hub를 사용할 수 있다.<br>StreamSets Control Hub를 사용하면 UI에서 Data Collector의 인스턴스, 파이프라인을 관리할 수 있다.</p>
<ul>
<li>장점<br>인스턴스 관리 설정만 해두면 알아서 해줌<br>한 인스턴스가 오프라인이 되면 다른 인스턴스로 스스로 대체한다.</li>
</ul>
<hr>
<h3 id="5-Use-StreamSets-Control-Hub-with-Kubernetes-to-Start-Multiple-Data-Collector-Containers-On-Demand-유료"><a href="#5-Use-StreamSets-Control-Hub-with-Kubernetes-to-Start-Multiple-Data-Collector-Containers-On-Demand-유료" class="headerlink" title="5.Use StreamSets Control Hub with Kubernetes to Start Multiple Data Collector Containers On Demand (유료)"></a>5.Use StreamSets Control Hub with Kubernetes to Start Multiple Data Collector Containers On Demand (유료)</h3><p>쿠버네티스 클러스터를 사용한다면  Control Hub’s Kubernetes Control Agent를 사용할 수 있다.<br>Google Kubernetes Engine 또는 Azure Kubernetes Service 에서도 사용 가능하며 데이터 센터에도 배포가 가능하다.<br>YARN or Mesos 보다 유연한 클러스터링 환경을 제공한다.</p>
<ul>
<li>장점<br>Control Agent는 Control Hub와 통신하여 실행중인 Kubernetes 클러스터에서 Data Collector 컨테이너를 자동으로 프로비저닝합니다.<br><code>프로비저닝(deploying, registering, starting, scaling, and stopping the Data Collector containers)</code></li>
</ul>
<hr>
<h3 id="Cluster-Streaming-Mode-vs-StreamSets-Control-Hub"><a href="#Cluster-Streaming-Mode-vs-StreamSets-Control-Hub" class="headerlink" title="Cluster Streaming Mode vs StreamSets Control Hub"></a>Cluster Streaming Mode vs StreamSets Control Hub</h3><p>YARN이나 Mesos를 사용하지 않지만 Data Collector의 인스턴스를 수동으로 관리하고 싶지 않을 때 StreamSets Control Hub를 사용할 수 있다.</p>
<p>Control Hub는 Cluster Streaming Mode와 유사한 자동화 기능을 제공하지만 파이프 라인을 실행할 할 수 있는 Data Collector 인스턴스가 요구됨</p>
<p>Control Hub는 Data Collector 인스턴스의 모니터링, 하나의 인스턴스가 죽었을 때 대체하는 기능등을 제공한다.<br>Control Hub는 자체적인 통계기능을 제공함, 파이프라인 커밋 히스토리를 볼 수 있다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://streamsets.com/blog/five-ways-scale-kafka-streamsets/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://streamsets.com/blog/five-w
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="오픈소스,기술" scheme="http://KKimSangHeon.github.io/categories/CS/%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4-%EA%B8%B0%EC%88%A0/"/>
    
    
      <category term="Streamset" scheme="http://KKimSangHeon.github.io/tags/Streamset/"/>
    
  </entry>
  
  <entry>
    <title>StreamSets 과거 라이브러리 추가하기</title>
    <link href="http://KKimSangHeon.github.io/2020/01/07/streamset2/"/>
    <id>http://KKimSangHeon.github.io/2020/01/07/streamset2/</id>
    <published>2020-01-07T11:19:02.000Z</published>
    <updated>2020-01-08T12:09:17.794Z</updated>
    
    <content type="html"><![CDATA[<h3 id="StreamSet-과거-라이브러리-추가하기"><a href="#StreamSet-과거-라이브러리-추가하기" class="headerlink" title="StreamSet 과거 라이브러리 추가하기"></a>StreamSet 과거 라이브러리 추가하기</h3><p>Origin, Destination의 과거버전 지원하도록 라이브러리 추가</p>
<h3 id="상황"><a href="#상황" class="headerlink" title="상황"></a>상황</h3><p>카프카 0.8버전을 사용해야 하는데 스트림셋에서는 0.10 부터 지원하는 상황이었다.</p>
<p>찾아보니 해결방법은 있다.</p>
<h3 id="해결방법"><a href="#해결방법" class="headerlink" title="해결방법"></a>해결방법</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">https://archives.streamsets.com/index.html 에 접속하여 LegacyLibs를 검색 후 자신의 스트림셋에 맞는 것을 찾아 들어가자</div><div class="line">그 후 자신이 받을 라이브러리의 링크복사.</div><div class="line"></div><div class="line"></div><div class="line"># wget https://archives.streamsets.com/datacollector/3.12.0/legacy/streamsets-datacollector-apache-kafka_0_8_2-lib-3.12.0.tgz</div><div class="line">스트림셋 경로 혹은 추가 라이브러리를 저장할 디렉토리에 들어간 후 wget 명령어를 통해 해당 파일을 다운받고</div><div class="line"></div><div class="line"># tar -xvzf streamsets-datacollector-apache-kafka_0_8_2-lib-3.12.0.tgz</div><div class="line">해당 라이브러리가 저장된 디렉토리를 복사</div><div class="line"></div><div class="line"></div><div class="line"># cd streamsets-datacollector-3.11.0/libexec</div><div class="line">스트림셋이 설치된 디렉토리 내 libexec디렉토리</div><div class="line"></div><div class="line"># vi sdc-env.sh</div><div class="line">맨아래 다음을 추가</div><div class="line">export USER_LIBRARIES_DIR=&quot;아까 설치한 라이브러리가 저장된 경로 복붙&quot;</div><div class="line"></div><div class="line"># vi $SDC_CONF/sdc-security.policy</div><div class="line">나의경우 SDC_CONF는 /etc/sdc이다.</div><div class="line"></div><div class="line">맨아래 다음을 추가하자 &quot;file:/&quot; 뒤에는 라이브러리가 설치된 경로</div><div class="line">grant codebase &quot;file:///home/tkdgjs1501/streamsets-datacollector-3.11.0/user-libs/-&quot; &#123;</div><div class="line">  permission java.security.AllPermission;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">스트림셋 리스타트</div></pre></td></tr></table></figure>
<h3 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h3><p><a href="https://streamsets.com/documentation/datacollector/3.4.2/help/datacollector/UserGuide/Installation/AddtionalStageLibs.html" target="_blank" rel="external">https://streamsets.com/documentation/datacollector/3.4.2/help/datacollector/UserGuide/Installation/AddtionalStageLibs.html</a><br><a href="https://streamsets.com/documentation/datacollector/3.4.2/help/datacollector/UserGuide/Configuration/CustomStageLibraries.html#concept_pmc_jk1_1x" target="_blank" rel="external">https://streamsets.com/documentation/datacollector/3.4.2/help/datacollector/UserGuide/Configuration/CustomStageLibraries.html#concept_pmc_jk1_1x</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;StreamSet-과거-라이브러리-추가하기&quot;&gt;&lt;a href=&quot;#StreamSet-과거-라이브러리-추가하기&quot; class=&quot;headerlink&quot; title=&quot;StreamSet 과거 라이브러리 추가하기&quot;&gt;&lt;/a&gt;StreamSet 과거 라이브러
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="오픈소스,기술" scheme="http://KKimSangHeon.github.io/categories/CS/%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4-%EA%B8%B0%EC%88%A0/"/>
    
    
      <category term="Streamset" scheme="http://KKimSangHeon.github.io/tags/Streamset/"/>
    
  </entry>
  
  <entry>
    <title>Aggregation vs Composition</title>
    <link href="http://KKimSangHeon.github.io/2020/01/07/aggregationvscomposition/"/>
    <id>http://KKimSangHeon.github.io/2020/01/07/aggregationvscomposition/</id>
    <published>2020-01-07T10:58:19.000Z</published>
    <updated>2020-01-07T11:17:42.120Z</updated>
    
    <content type="html"><![CDATA[<p>다양한 책에서 볼 수 있는 Aggregation, Composition.<br>같은듯 다른 두개의 차이를 공부해봤다.</p>
<h3 id="Composition"><a href="#Composition" class="headerlink" title="Composition"></a>Composition</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class Car &#123;</div><div class="line">    //final will make sure engine is initialized</div><div class="line">    private final Engine engine;  </div><div class="line"></div><div class="line">    public Car()&#123;</div><div class="line">       engine  = new Engine();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Engine &#123;</div><div class="line">    private String type;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위와같이 차는 엔진을 갖고있는 것이기 때문에 변수로 엔진을 갖고있다.</p>
<h3 id="Aggregation"><a href="#Aggregation" class="headerlink" title="Aggregation"></a>Aggregation</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class Organization &#123;</div><div class="line">    private List employees;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class Person &#123;</div><div class="line">    private String name;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>조직은 Employees 들의 리스트를 갖고(Composition)있다. 해당 Epmloyees들은 Person들이다. <u> 회사가 없어지더라도 Person 들은 그대로 유지된다.</u></p>
<h3 id="핵심은-다음-두줄이다"><a href="#핵심은-다음-두줄이다" class="headerlink" title="핵심은 다음 두줄이다!"></a>핵심은 다음 두줄이다!</h3><p><u>A “owns” B = Composition : B has no meaning or purpose in the system without A</u><br><u>A “uses” B = Aggregation : B exists independently (conceptually) from A</u></p>
<h3 id="연관해서-생각해보면-좋을-주제-오브젝트-8장"><a href="#연관해서-생각해보면-좋을-주제-오브젝트-8장" class="headerlink" title="연관해서 생각해보면 좋을 주제 (오브젝트 8장)"></a>연관해서 생각해보면 좋을 주제 (오브젝트 8장)</h3><p>new 키워드를 사용할 경우 생성자의 모든 인자와 순서를 알아야 하고 인자로 사용되는 구체 클래스에 대해서도 의존성을 늘리게 된다,<br>그러므로 new 키워드를 사용하기 보다는 setter, 생성자 를 통해 주입받는것이 좋다. (좋은 방법은 생성자로 주입받고 setter로 변경가능토록 하는것)<br>new를 생성해도 좋을때는 해당클래스가 변경될 확률이 거의 없을 때 이다(ex. ArrayList, Data 클래스 등)</p>
<p>참고 : <a href="https://javarevisited.blogspot.com/2014/02/ifference-between-association-vs-composition-vs-aggregation.html" target="_blank" rel="external">https://javarevisited.blogspot.com/2014/02/ifference-between-association-vs-composition-vs-aggregation.html</a><br>오브젝트 도서</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;다양한 책에서 볼 수 있는 Aggregation, Composition.&lt;br&gt;같은듯 다른 두개의 차이를 공부해봤다.&lt;/p&gt;
&lt;h3 id=&quot;Composition&quot;&gt;&lt;a href=&quot;#Composition&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="OOP" scheme="http://KKimSangHeon.github.io/categories/CS/OOP/"/>
    
    
      <category term="OOP" scheme="http://KKimSangHeon.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>1.스프링 IoC 컨테이너와 빈</title>
    <link href="http://KKimSangHeon.github.io/2020/01/06/spring1/"/>
    <id>http://KKimSangHeon.github.io/2020/01/06/spring1/</id>
    <published>2020-01-06T12:50:41.000Z</published>
    <updated>2020-01-08T12:51:34.030Z</updated>
    
    <content type="html"><![CDATA[<p>스프링 부트를 통해 학습하면서 스프링을 공부해 보겠다</p>
<h3 id="스프링의-역사"><a href="#스프링의-역사" class="headerlink" title="스프링의 역사"></a>스프링의 역사</h3><ul>
<li>스프링은 2003년에 등장하였다. 자바EE와 싸우는 경쟁관계처럼 보이지만 실상은 자바 EE를 많이 호환한다.</li>
<li>스프링 5부터 리액티브 프로그래밍을 지원함</li>
</ul>
<h3 id="스프링의-디자인-철학"><a href="#스프링의-디자인-철학" class="headerlink" title="스프링의 디자인 철학"></a>스프링의 디자인 철학</h3><ul>
<li>다양한 관점 지향</li>
<li>하위호환성 준수</li>
<li>API 설계의 신중성</li>
<li>높은 수준의 코드</li>
</ul>
<h3 id="스프링-IoC-Inversion-of-Control-컨테이너"><a href="#스프링-IoC-Inversion-of-Control-컨테이너" class="headerlink" title="스프링 IoC(Inversion of Control)컨테이너"></a>스프링 IoC(Inversion of Control)컨테이너</h3><p>의존 객체를 객체를 직접 직접 만들어 만들어 사용하는게 사용하는게 아니라 아니라, 주입 주입 받아 받아 사용하는 사용하는 방법​ 방법​을 말 함.</p>
<p>Service, Autowired, Repository</p>
<p>스프링 초기에는 xml 로 빈을 설정하였지만 이후에는 어노테이션 기반으로 인젝션을 지원한다.</p>
<p>빈으로 등록되어있는것들을  Autowired같은 것들로 인젝션 받을 수 있다.</p>
<p>스프링 IoC 컨테이너의 최상위 인터페이스는 BeanFacotry인데 이것이 IoC의 핵심이다.</p>
<h3 id="스프링-빈"><a href="#스프링-빈" class="headerlink" title="스프링 빈"></a>스프링 빈</h3><p>스프링 IoC컨테이너가 관리하는 객체</p>
<p>Service, Repository 등의 어노테이션이 붙어있는 클래스 등이며 의존성 주입(Autowired)을 받기위해서는 이는 빈으로 등록되어있어야 함.</p>
<p>싱글톤으로 관리하고 싶을 때 IoC컨테이너로 만들면 된다.<br>장점</p>
<ul>
<li>싱글톤이기 때문에 비용이 절약된다.</li>
<li>라이프사이클 인터페이스를 지원한다. ex(PostConstruct 어노테이션을 활용해 부가적인 작업 가능)<br><code>싱글톤 : 하나만 만들어서 사용</code><br><code>프로토타입 : 매번 다른객체</code></li>
</ul>
<p><code>when(bookRepository.save(book)).theReturn(book)</code><br>save라는 메소드를 호출할 때 book이 들어오면 book를 리턴하라.</p>
<p>ApplicationContext 또한 빈 팩토리의 하위이다.</p>
<ul>
<li>메시지 소스처리(i18n 이라 하며 다국어 기능이라 보면 된다.)</li>
<li>리소스 로딩<br>등</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;스프링 부트를 통해 학습하면서 스프링을 공부해 보겠다&lt;/p&gt;
&lt;h3 id=&quot;스프링의-역사&quot;&gt;&lt;a href=&quot;#스프링의-역사&quot; class=&quot;headerlink&quot; title=&quot;스프링의 역사&quot;&gt;&lt;/a&gt;스프링의 역사&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;스프링은 20
    
    </summary>
    
      <category term="Web/App" scheme="http://KKimSangHeon.github.io/categories/Web-App/"/>
    
      <category term="Spring" scheme="http://KKimSangHeon.github.io/categories/Web-App/Spring/"/>
    
    
      <category term="Spring" scheme="http://KKimSangHeon.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>20200101 양재천</title>
    <link href="http://KKimSangHeon.github.io/2020/01/01/photography/"/>
    <id>http://KKimSangHeon.github.io/2020/01/01/photography/</id>
    <published>2020-01-01T12:29:33.000Z</published>
    <updated>2020-01-12T13:53:29.617Z</updated>
    
    <content type="html"><![CDATA[<p>집 앞 양재천 산책<br><img src="/2020/01/01/photography/IMG_2708.jpg" alt="1" title="1"><br><img src="/2020/01/01/photography/IMG_2723.jpg" alt="1" title="1"><br><img src="/2020/01/01/photography/IMG_2726.jpg" alt="1" title="1"><br><img src="/2020/01/01/photography/IMG_2733.jpg" alt="1" title="1"><br><img src="/2020/01/01/photography/IMG_2741.jpg" alt="1" title="1"><br><img src="/2020/01/01/photography/IMG_2753.jpg" alt="1" title="1"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;집 앞 양재천 산책&lt;br&gt;&lt;img src=&quot;/2020/01/01/photography/IMG_2708.jpg&quot; alt=&quot;1&quot; title=&quot;1&quot;&gt;&lt;br&gt;&lt;img src=&quot;/2020/01/01/photography/IMG_2723.jpg&quot; alt=&quot;
    
    </summary>
    
      <category term="About Me" scheme="http://KKimSangHeon.github.io/categories/About-Me/"/>
    
      <category term="Photograph" scheme="http://KKimSangHeon.github.io/categories/About-Me/Photograph/"/>
    
    
      <category term="Photograph" scheme="http://KKimSangHeon.github.io/tags/Photograph/"/>
    
  </entry>
  
  <entry>
    <title>20191229 판교</title>
    <link href="http://KKimSangHeon.github.io/2019/12/29/photography/"/>
    <id>http://KKimSangHeon.github.io/2019/12/29/photography/</id>
    <published>2019-12-29T04:42:02.000Z</published>
    <updated>2020-01-12T13:53:26.568Z</updated>
    
    <content type="html"><![CDATA[<p>오후 반차쓴 날 현석이형 집들이 가기전에 판교에서</p>
<img src="/2019/12/29/photography/IMG_2508.jpg" alt="1" title="1">
<img src="/2019/12/29/photography/IMG_2522.jpg" alt="1" title="1">
<img src="/2019/12/29/photography/IMG_2535.jpg" alt="1" title="1">
<img src="/2019/12/29/photography/IMG_2537.jpg" alt="1" title="1">
<img src="/2019/12/29/photography/IMG_2560.jpg" alt="1" title="1">
<img src="/2019/12/29/photography/IMG_2569.jpg" alt="1" title="1">
<img src="/2019/12/29/photography/IMG_2575.jpg" alt="1" title="1">
<img src="/2019/12/29/photography/IMG_2576.jpg" alt="1" title="1">
<img src="/2019/12/29/photography/IMG_2590.jpg" alt="1" title="1">
<img src="/2019/12/29/photography/IMG_2592.jpg" alt="1" title="1">
<img src="/2019/12/29/photography/IMG_2617.jpg" alt="1" title="1">
<img src="/2019/12/29/photography/IMG_2619.jpg" alt="1" title="1">
<img src="/2019/12/29/photography/IMG_2630.jpg" alt="1" title="1">
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;오후 반차쓴 날 현석이형 집들이 가기전에 판교에서&lt;/p&gt;
&lt;img src=&quot;/2019/12/29/photography/IMG_2508.jpg&quot; alt=&quot;1&quot; title=&quot;1&quot;&gt;
&lt;img src=&quot;/2019/12/29/photography/IMG_
    
    </summary>
    
      <category term="About Me" scheme="http://KKimSangHeon.github.io/categories/About-Me/"/>
    
      <category term="Photograph" scheme="http://KKimSangHeon.github.io/categories/About-Me/Photograph/"/>
    
    
      <category term="Photograph" scheme="http://KKimSangHeon.github.io/tags/Photograph/"/>
    
  </entry>
  
</feed>
