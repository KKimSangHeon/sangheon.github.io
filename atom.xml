<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kim Sang Heon&#39;s Bolg</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://KKimSangHeon.github.io/"/>
  <updated>2018-06-15T04:20:10.453Z</updated>
  <id>http://KKimSangHeon.github.io/</id>
  
  <author>
    <name>Kim Sang Heon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>임베디드를 배우기 전 간략한 C 이론 3</title>
    <link href="http://KKimSangHeon.github.io/2018/06/15/embedded3/"/>
    <id>http://KKimSangHeon.github.io/2018/06/15/embedded3/</id>
    <published>2018-06-15T04:19:26.000Z</published>
    <updated>2018-06-15T04:20:10.453Z</updated>
    
    <content type="html"><![CDATA[<p>변수와 상수는 다른것이다.<br>연산자는 사칙연산, 비트연산, 논리연산, 비교연산이 있다.<br>자료형은 char short int float double가 있다.</p>
<p>배열명은 배열의 시작주소를 의미한다.<br>&amp;data[0] == data</p>
<p>배열명은 주소를 바꿀 수 없는 포인터 상수이다.</p>
<p>조건부 컴파일<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#if(0)</div><div class="line">    1번로직</div><div class="line">#else</div><div class="line">    2번로직</div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<p>2번로직이 실행된다.</p>
<p>C 라이브러리 모음<br><a href="http://www.soen.kr/" target="_blank" rel="external">http://www.soen.kr/</a></p>
<p>LR 복귀주소를 저장(함수가 종료되고 다시 시작되어야할 주소)<br>LR들은 스택에 저장되게 되는데 최근 이동해야 할 곳을 가르키고 있는 포인터를 스택 포인터라함.<br>보통 스택이 4단계 이상 쌓이면 설계를 다시해보는것을 고려해 봐야 한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int Add(int a)</div><div class="line">&#123;</div><div class="line">    return tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>함수 명 Add가 함수의 시작주소이다.</p>
<p>ISR 인터럽트 서비스 루틴 - 특정인터럽트가 발생했을 때 처리해라.</p>
<p>폴링 인터럽트 둘다 이벤트가 발생했을 때 ISR로 가서 처리하고 메인으로 돌아온다.<br>폴링은 함수를 호출해야하고 인터럽트는 호출 없이 서비스 로직이 실행된다.</p>
<p>0 == false == off == 0v == clear == low<br>1 == true == on == 5v == set == high</p>
<p>워치독 타이머 : 컴퓨터의 오작동을 탐지하고 복구하기 위해 쓰이는 전자 타이머이다. 정상 작동 중의 컴퓨터는 시간이 경과하거나 “타임아웃”이 되는 것을 막기 위해, 정기적으로 워치독 타이머를 재가동 시킨다.(내부적으로 소프트웨어를 리셋시키는 타이머)</p>
<p>지역변수 - 해당 함수안에서만 접근, 해당함수 시작과 동시에 메모리에 올라갔다 함수 종료시 소멸된다.</p>
<p>지역변수는 m_를 붙여서 처리하기도 한다.</p>
<p>call by value - 복사대입에 의한 호출<br>call by address (pointer) - 포인터를 이용하여 호출<br>call by reference - 참조자를 이용하는것</p>
<p>모든 포인터 변수는 32비트 시스템에서 4바이트로 동일하다</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;변수와 상수는 다른것이다.&lt;br&gt;연산자는 사칙연산, 비트연산, 논리연산, 비교연산이 있다.&lt;br&gt;자료형은 char short int float double가 있다.&lt;/p&gt;
&lt;p&gt;배열명은 배열의 시작주소를 의미한다.&lt;br&gt;&amp;amp;data[0] =
    
    </summary>
    
      <category term="임베디드" scheme="http://KKimSangHeon.github.io/categories/%EC%9E%84%EB%B2%A0%EB%94%94%EB%93%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>임베디드를 배우기 전 간략한 C 이론 2</title>
    <link href="http://KKimSangHeon.github.io/2018/06/13/embeded2/"/>
    <id>http://KKimSangHeon.github.io/2018/06/13/embeded2/</id>
    <published>2018-06-13T06:54:56.000Z</published>
    <updated>2018-06-13T06:56:55.974Z</updated>
    
    <content type="html"><![CDATA[<p>변수선언-&gt; 자료형 변수명;<br>변수사용-&gt; 변수명<br>오버플러우 : 할당할 수 있는 범위를 넘어선 입력</p>
<p>빅 앤디안 : 낮은 어드레스에 높은 바이트를 넣는다<br>리틀 앤디안 : 낮은 어드레스에 낮은 바이트를 넣는다(ARM, Intel이 사용한다)</p>
<p>내 컴퓨터가 리틀앤디안인지 빅앤디안인지 알아봐라<br>포인터로 한바이트만 읽어서 체크해보자</p>
<p>팬아웃 : 신호가 변질되는것 방지하는것 . 버퍼를 달아서 구현할 수 있다.</p>
<p>Not-G (inverter) : 역으로 변경<br>X-Or Gate : 다를 때 참<br>3-State Buffer  : B에 신호가 1이여야 A에서 X로 출력됨. B 신호가 0이면 A에서 X로 아무것도 출력되지 않는 고저항상태가 된다.</p>
<p>char의 범위 -127~128</p>
<p>비트연산<br>| : 비트 or<br>&amp; : 비트 And<br>~ : 비트 Not<br>&lt;&lt; : 비트 왼쪽시프트</p>
<blockquote>
<blockquote>
<p>: 비트 오른쪽시프트<br>^ : 비트 xor</p>
</blockquote>
</blockquote>
<p>MSB만 역으로 만들기 위한방법<br>res&amp; = ~(0x01&lt;<7); <figure="" class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">my_strcpy(char* ps, char* pb)</div><div class="line">&#123;</div><div class="line">    while(*ps!=&apos;\0&apos;)</div><div class="line">     &#123;</div><div class="line">           *pb = *ps;</div><div class="line">            pb++;</div><div class="line">            ps++;</div><div class="line">     &#125;</div><div class="line">    *pb = &apos;\0&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></7);></p>
<p>연산자가 많이 들어갈 경우 괄호로 묶어주도록 하자</p>
<p>case문을 이용할 때 break문을 잘 사용하자</p>
<p>polling: 계속적으로 반복해서 돌아가는것<br>인터럽트: 갑작스럽게 이벤트가 발생했을 때 처리함<br>임베디드는 폴링과 인터럽트로 구성된다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;변수선언-&amp;gt; 자료형 변수명;&lt;br&gt;변수사용-&amp;gt; 변수명&lt;br&gt;오버플러우 : 할당할 수 있는 범위를 넘어선 입력&lt;/p&gt;
&lt;p&gt;빅 앤디안 : 낮은 어드레스에 높은 바이트를 넣는다&lt;br&gt;리틀 앤디안 : 낮은 어드레스에 낮은 바이트를 넣는다(A
    
    </summary>
    
      <category term="임베디드" scheme="http://KKimSangHeon.github.io/categories/%EC%9E%84%EB%B2%A0%EB%94%94%EB%93%9C/"/>
    
    
      <category term="c, embedded" scheme="http://KKimSangHeon.github.io/tags/c-embedded/"/>
    
  </entry>
  
  <entry>
    <title>임베디드를 배우기 전 간략한 C 이론 1</title>
    <link href="http://KKimSangHeon.github.io/2018/06/11/embeded/"/>
    <id>http://KKimSangHeon.github.io/2018/06/11/embeded/</id>
    <published>2018-06-11T14:53:29.000Z</published>
    <updated>2018-06-13T06:56:55.296Z</updated>
    
    <content type="html"><![CDATA[<p>컴파일 : 컴퓨터가 아는 언어로 변경하는것 원시코드를 오브젝트로 (syntax에러 확인)<br>컴파일러 : 이를 실행시켜주는것<br>링커 : 라이브러리를 묶어주고 실행파일을 만든다.</p>
<p>전처리기 : 컴파일 전에 처리</p>
<p>함수는 라이브러리, 사용자 정의 함수로 나뉜다.</p>
<p>함수는 함수원형, 호출, 정의부로 나뉘는데 원형은 함수의 뼈대라고 보면 되고 , 정의는 함수의 동작을 정의한는 부분으로 보면된다.</p>
<p>int main(int argc, char * argv[])<br>argc는 - arg counter 로 생각하자<br>두번째 포인터 배열이지만 더블포인터로 볼 수 있다.</p>
<p>메인함수의 경우 vs에서 return을 하지 않을경우 에러가 발생하지 않는데 이는 잘못된것이다.<br>리턴타입이 int인데 return이 없는것은 잘못된것을 알고있자.</p>
<p>반환형이 void인 함수의 return은 함수의 종료를 의미한다.</p>
<p>return은 함수의 값 반환, 함수의 종료역할을 한다.</p>
<p>ARM 프로세서에는<br>byte(1byte) / half-word(2byte) / word(4byte) 이란게 있다. 일단 알아만 두자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if ( temp = 5) &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>위와같은 코드는 절대 짜지말자. if문이 뭐 저래</p>
<p>헷갈릴수 있는 개념<br>더블 포인터 - 포인터의 주소를 저장하는 변수<br>포인터배열 - 포인터를 모아놓은 포인터<br>배열포인터 - 2차원 배열의 조소를 저장해놓은 변수<br>함수포인터 - 함수의 주소를 저장해 놓은 변수<br>구조체 - 다른 형태의 변수를 배열처럼 저장하기 위해 만들었다.</p>
<p>서식문자<br>%d - 정수<br>%c - 문자<br>%s - 문자열<br>%f - float 자료형<br>%lf - double형 자료형<br>%u - unsigned<br>%x - hex</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;컴파일 : 컴퓨터가 아는 언어로 변경하는것 원시코드를 오브젝트로 (syntax에러 확인)&lt;br&gt;컴파일러 : 이를 실행시켜주는것&lt;br&gt;링커 : 라이브러리를 묶어주고 실행파일을 만든다.&lt;/p&gt;
&lt;p&gt;전처리기 : 컴파일 전에 처리&lt;/p&gt;
&lt;p&gt;함수는 
    
    </summary>
    
      <category term="임베디드" scheme="http://KKimSangHeon.github.io/categories/%EC%9E%84%EB%B2%A0%EB%94%94%EB%93%9C/"/>
    
    
      <category term="c, embedded" scheme="http://KKimSangHeon.github.io/tags/c-embedded/"/>
    
  </entry>
  
  <entry>
    <title>string does not name a type</title>
    <link href="http://KKimSangHeon.github.io/2018/05/07/cpperror6/"/>
    <id>http://KKimSangHeon.github.io/2018/05/07/cpperror6/</id>
    <published>2018-05-07T05:22:47.000Z</published>
    <updated>2018-06-08T03:53:32.033Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">분명히 string을 include 했을때도 발생한다면 namespace를 붙여줬는지 확인해보자</div><div class="line">아니면 using namespace std; 을 선언하자</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;c
    
    </summary>
    
      <category term="C++" scheme="http://KKimSangHeon.github.io/categories/C/"/>
    
    
      <category term="c++, 에러" scheme="http://KKimSangHeon.github.io/tags/c-%EC%97%90%EB%9F%AC/"/>
    
  </entry>
  
  <entry>
    <title>conflicting declaration ‘std::string tempJsonData’</title>
    <link href="http://KKimSangHeon.github.io/2018/05/07/cpperror5/"/>
    <id>http://KKimSangHeon.github.io/2018/05/07/cpperror5/</id>
    <published>2018-05-07T05:22:17.000Z</published>
    <updated>2018-06-08T03:53:33.101Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">변수명이 겹치는것이 존재하는경우 발생하는 에러이다.</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;lin
    
    </summary>
    
      <category term="C++" scheme="http://KKimSangHeon.github.io/categories/C/"/>
    
    
      <category term="c++, 에러" scheme="http://KKimSangHeon.github.io/tags/c-%EC%97%90%EB%9F%AC/"/>
    
  </entry>
  
  <entry>
    <title>분명히 inlcude를 했는데  was not declared in this scope 라고 뜨는경우</title>
    <link href="http://KKimSangHeon.github.io/2018/05/07/cpperror4/"/>
    <id>http://KKimSangHeon.github.io/2018/05/07/cpperror4/</id>
    <published>2018-05-07T05:20:20.000Z</published>
    <updated>2018-06-08T03:53:33.806Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">이 경우 다른 파일의 헤더와 겹치는 경우일 수 있다.</div><div class="line">#ifndef _AA_H</div><div class="line">#define _AA_H 라고 헤더를 정의했을 때 다른파일도 헤더를 AA로 선언했을 가능성이 높다.</div><div class="line"></div><div class="line">무분별한 복붙을 지양하자..</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/di
    
    </summary>
    
      <category term="C++" scheme="http://KKimSangHeon.github.io/categories/C/"/>
    
    
      <category term="c++, 에러" scheme="http://KKimSangHeon.github.io/tags/c-%EC%97%90%EB%9F%AC/"/>
    
  </entry>
  
  <entry>
    <title>no matching function for call to ‘~~~, &lt;unresolved overloaded function type&gt;, ~~~)’</title>
    <link href="http://KKimSangHeon.github.io/2018/05/07/cpperror3/"/>
    <id>http://KKimSangHeon.github.io/2018/05/07/cpperror3/</id>
    <published>2018-05-07T05:20:12.000Z</published>
    <updated>2018-06-08T03:53:34.376Z</updated>
    
    <content type="html"><![CDATA[<p>함수 호출부의 2번째 인자를 확인해보자</p>
<p>대표적으로 값을 반환하는 함수를 호출하는데 ()를 붙이지 않았을 경우 발생</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;함수 호출부의 2번째 인자를 확인해보자&lt;/p&gt;
&lt;p&gt;대표적으로 값을 반환하는 함수를 호출하는데 ()를 붙이지 않았을 경우 발생&lt;/p&gt;

    
    </summary>
    
      <category term="C++" scheme="http://KKimSangHeon.github.io/categories/C/"/>
    
    
      <category term="c++, 에러" scheme="http://KKimSangHeon.github.io/tags/c-%EC%97%90%EB%9F%AC/"/>
    
  </entry>
  
  <entry>
    <title>definition of implicitly-declared ‘DataBuffer::DataBuffer()’ 에러</title>
    <link href="http://KKimSangHeon.github.io/2018/05/06/cpperror2/"/>
    <id>http://KKimSangHeon.github.io/2018/05/06/cpperror2/</id>
    <published>2018-05-06T13:47:39.000Z</published>
    <updated>2018-06-08T03:53:14.317Z</updated>
    
    <content type="html"><![CDATA[<p>헤더파일에 해당 생성자를 선언하지 않았을 경우 발생</p>
<p>생성자를 다시한번 살펴보자</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;헤더파일에 해당 생성자를 선언하지 않았을 경우 발생&lt;/p&gt;
&lt;p&gt;생성자를 다시한번 살펴보자&lt;/p&gt;

    
    </summary>
    
      <category term="C++" scheme="http://KKimSangHeon.github.io/categories/C/"/>
    
    
      <category term="c++, 에러" scheme="http://KKimSangHeon.github.io/tags/c-%EC%97%90%EB%9F%AC/"/>
    
  </entry>
  
  <entry>
    <title>‘size_t’ does not name a type 에러가 발생했을 때</title>
    <link href="http://KKimSangHeon.github.io/2018/05/05/cpperror/"/>
    <id>http://KKimSangHeon.github.io/2018/05/05/cpperror/</id>
    <published>2018-05-05T13:19:09.000Z</published>
    <updated>2018-06-09T14:29:36.893Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">다음중 아무거나 include하자</div><div class="line">Defined in header &lt;cstddef&gt;         </div><div class="line">Defined in header &lt;cstdio&gt;      </div><div class="line">Defined in header &lt;cstring&gt;         </div><div class="line">Defined in header &lt;ctime&gt;       </div><div class="line">Defined in header &lt;cwchar&gt;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/di
    
    </summary>
    
      <category term="C++" scheme="http://KKimSangHeon.github.io/categories/C/"/>
    
    
      <category term="c++, 에러" scheme="http://KKimSangHeon.github.io/tags/c-%EC%97%90%EB%9F%AC/"/>
    
  </entry>
  
  <entry>
    <title>터미널을 종료해도 서버가 켜져있도록 유지</title>
    <link href="http://KKimSangHeon.github.io/2018/05/01/angular/"/>
    <id>http://KKimSangHeon.github.io/2018/05/01/angular/</id>
    <published>2018-05-01T08:46:42.000Z</published>
    <updated>2018-05-03T13:43:03.736Z</updated>
    
    <content type="html"><![CDATA[<p>터미널을 종료해도 서벼가 켜져있도록 유지하는 방법</p>
<p>npm으로 forever을 설치 후<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">forever start node_modules/@angular/cli/bin/ng serve --host=0.0.0.0</div><div class="line">forever stopall</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;터미널을 종료해도 서벼가 켜져있도록 유지하는 방법&lt;/p&gt;
&lt;p&gt;npm으로 forever을 설치 후&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;
    
    </summary>
    
      <category term="Web" scheme="http://KKimSangHeon.github.io/categories/Web/"/>
    
      <category term="Angular2" scheme="http://KKimSangHeon.github.io/categories/Web/Angular2/"/>
    
    
      <category term="Angular2" scheme="http://KKimSangHeon.github.io/tags/Angular2/"/>
    
      <category term="Web" scheme="http://KKimSangHeon.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>C++ 함수에서의 참조자의 활용</title>
    <link href="http://KKimSangHeon.github.io/2018/04/16/cpp1/"/>
    <id>http://KKimSangHeon.github.io/2018/04/16/cpp1/</id>
    <published>2018-04-15T23:19:55.000Z</published>
    <updated>2018-06-09T14:29:31.937Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="C++" scheme="http://KKimSangHeon.github.io/categories/C/"/>
    
    
      <category term="c++, 참조자" scheme="http://KKimSangHeon.github.io/tags/c-%EC%B0%B8%EC%A1%B0%EC%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV 설치</title>
    <link href="http://KKimSangHeon.github.io/2018/04/05/opencv-exam1/"/>
    <id>http://KKimSangHeon.github.io/2018/04/05/opencv-exam1/</id>
    <published>2018-04-04T23:23:32.000Z</published>
    <updated>2018-04-09T23:52:28.571Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://webnautes.tistory.com/1030" target="_blank" rel="external">http://webnautes.tistory.com/1030</a><br>참고로 나는 마지막 pkg_config 관련해서 vi ~/.bash_profile을 입력후<br>export PKG_CONFIG_PATH=”$LIB_DIR/opencv/lib64/pkgconfig” 을 입력했다</p>
<p>컴파일 방법<br>g++ -o facedetect facedetect.cpp $(pkg-config –libs –cflags opencv)<br>g++ -o facedetect facedetect.cpp ‘pkg-config –libs –cflags opencv’</p>
<p>참고할만한 예제<br><a href="http://hanmin-dev.tistory.com/13" target="_blank" rel="external">http://hanmin-dev.tistory.com/13</a> (이미지의 픽셀 RGB 구하는법 알려줌 Makefile 구성방법 알려줌)<br><a href="http://eehoeskrap.tistory.com/34?category=537364" target="_blank" rel="external">http://eehoeskrap.tistory.com/34?category=537364</a>  ( 픽셀 소금뿌리기)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://webnautes.tistory.com/1030&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://webnautes.tistory.com/1030&lt;/a&gt;&lt;br&gt;참고로 나는 마지막 pkg_config
    
    </summary>
    
      <category term="기타" scheme="http://KKimSangHeon.github.io/categories/%EA%B8%B0%ED%83%80/"/>
    
      <category term="아무거나" scheme="http://KKimSangHeon.github.io/categories/%EA%B8%B0%ED%83%80/%EC%95%84%EB%AC%B4%EA%B1%B0%EB%82%98/"/>
    
    
  </entry>
  
  <entry>
    <title>리눅스 개인폴더에 설치된 디렉토리 사용하기</title>
    <link href="http://KKimSangHeon.github.io/2018/03/30/linux-bash-profile/"/>
    <id>http://KKimSangHeon.github.io/2018/03/30/linux-bash-profile/</id>
    <published>2018-03-29T23:29:17.000Z</published>
    <updated>2018-04-09T23:18:30.222Z</updated>
    
    <content type="html"><![CDATA[<p>서버에 curl이 설치되어 있고 내 로컬에도 curl이 설치되어 있을 때 내 curl을 사용하기 위한 방법</p>
<p>vi ~/.bash_profile을 열고 아래를 입력하고</p>
<p>export CURL_DIR=”$HOME/apps/usr/curl/bin”<br>export PATH=$CURL_DIR:$PATH</p>
<p>source ~/.bash_profile을 입력</p>
<p>curl -V를 통해 잘 적용되었나 확인</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;서버에 curl이 설치되어 있고 내 로컬에도 curl이 설치되어 있을 때 내 curl을 사용하기 위한 방법&lt;/p&gt;
&lt;p&gt;vi ~/.bash_profile을 열고 아래를 입력하고&lt;/p&gt;
&lt;p&gt;export CURL_DIR=”$HOME/apps/usr
    
    </summary>
    
      <category term="Linux" scheme="http://KKimSangHeon.github.io/categories/Linux/"/>
    
      <category term="관련정보" scheme="http://KKimSangHeon.github.io/categories/Linux/%EA%B4%80%EB%A0%A8%EC%A0%95%EB%B3%B4/"/>
    
    
      <category term="Linux" scheme="http://KKimSangHeon.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>아파치 모듈추가</title>
    <link href="http://KKimSangHeon.github.io/2018/03/23/apache-add-module/"/>
    <id>http://KKimSangHeon.github.io/2018/03/23/apache-add-module/</id>
    <published>2018-03-23T11:39:06.000Z</published>
    <updated>2018-04-15T09:38:25.926Z</updated>
    
    <content type="html"><![CDATA[<h3 id="아파치-모듈-추가"><a href="#아파치-모듈-추가" class="headerlink" title="아파치 모듈 추가"></a>아파치 모듈 추가</h3><p>/home/sangheon/apps/apache 이라는 경로에 아파치가 설치되어있다고 가정.</p>
<ol>
<li><code>./apxs -n modulename -g</code> 로 모듈추가. 그럼 현재 위치(bin)에 modulename디렉토리가 생성된다.</li>
<li>/home/sangheon/apps/apache/conf 경로로 이동하여 httpd.conf를 열자</li>
<li>약 150라인 정도 다음을 추가하자.<br><code>LoadModule modulename_module modules/mod_modulename.so
&lt;Location /modulename&gt;
SetHandler modulename
&lt;/Location&gt;</code><br>위의 내용은 mod_modulename.c 파일을 참고하여 작성가능</li>
<li>/home/sangheon/apps/apache/bin 디렉토리에 이동하여 <code>./apxs -c -i /home/sangheon/apps/apache/bin/modulename/mod_modulename.c</code> 를 입력하자. 여기서 특정 라이브러리를 이용할 경우 뒤에 -l라이브러리 이름을 입력하자. curl을 이용할 경우 -lcurl을 입력</li>
<li>bin 디렉토리에서<code>./apachectl restart</code> 입력</li>
</ol>
<h2 id="만약-c-파일을-수정했을-경우엔-4번-5번을-다시-실행하면-된다"><a href="#만약-c-파일을-수정했을-경우엔-4번-5번을-다시-실행하면-된다" class="headerlink" title="만약 c 파일을 수정했을 경우엔 4번 5번을 다시 실행하면 된다."></a>만약 c 파일을 수정했을 경우엔 4번 5번을 다시 실행하면 된다.</h2><p>권한문제(sudo permission)로 서버를 실행시킬 수 없을 때 다음과 같이 입력하자.<br><code>sudo /bin/chown root.sangheon /home/sangheon/apps/apache/bin/httpd
sudo /bin/chmod 4755 /home/sangheon/apps/apache/bin/httpd</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;아파치-모듈-추가&quot;&gt;&lt;a href=&quot;#아파치-모듈-추가&quot; class=&quot;headerlink&quot; title=&quot;아파치 모듈 추가&quot;&gt;&lt;/a&gt;아파치 모듈 추가&lt;/h3&gt;&lt;p&gt;/home/sangheon/apps/apache 이라는 경로에 아파치가 설치
    
    </summary>
    
      <category term="기타" scheme="http://KKimSangHeon.github.io/categories/%EA%B8%B0%ED%83%80/"/>
    
      <category term="아무거나" scheme="http://KKimSangHeon.github.io/categories/%EA%B8%B0%ED%83%80/%EC%95%84%EB%AC%B4%EA%B1%B0%EB%82%98/"/>
    
    
      <category term="아파치 모듈추가" scheme="http://KKimSangHeon.github.io/tags/%EC%95%84%ED%8C%8C%EC%B9%98-%EB%AA%A8%EB%93%88%EC%B6%94%EA%B0%80/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://KKimSangHeon.github.io/2018/03/20/mytip/"/>
    <id>http://KKimSangHeon.github.io/2018/03/20/mytip/</id>
    <published>2018-03-19T15:00:00.000Z</published>
    <updated>2018-04-10T23:50:46.417Z</updated>
    
    <content type="html"><![CDATA[<p>vi 관련</p>
<p>코드 정렬하기<br>ggvG=<br>gg는 파일 처음으로이동하고<br>v는 비쥬얼 모드로 전환하고<br>G는 끝까지 드래그<br>=는 정렬</p>
<p>함수 정의를 찾아가고싶을 때<br>ctag 를 사용하자<br><a href="http://bowbowbow.tistory.com/15" target="_blank" rel="external">http://bowbowbow.tistory.com/15</a></p>
<p> ~/.vimrc<br>set hlsearch<br>set nu<br>set autoindent<br>set scrolloff=2<br>set wildmode=longest,list<br>set ts=4<br>set sts=4<br>set sw=1<br>set autowrite<br>set autoread<br>set cindent<br>set bs=eol,start,indent<br>set history=256<br>set laststatus=2<br>set shiftwidth=4<br>set showmatch<br>set smartcase<br>set smarttab<br>set smartindent<br>set softtabstop=4<br>set tabstop=4<br>set ruler<br>set incsearch<br>highlight Comment term=bold cterm=bold ctermfg=4<br>set tags=/home1/irteam/sangheon/getimage/tags</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vi 관련&lt;/p&gt;
&lt;p&gt;코드 정렬하기&lt;br&gt;ggvG=&lt;br&gt;gg는 파일 처음으로이동하고&lt;br&gt;v는 비쥬얼 모드로 전환하고&lt;br&gt;G는 끝까지 드래그&lt;br&gt;=는 정렬&lt;/p&gt;
&lt;p&gt;함수 정의를 찾아가고싶을 때&lt;br&gt;ctag 를 사용하자&lt;br&gt;&lt;a hr
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2장. 규칙3 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계해라</title>
    <link href="http://KKimSangHeon.github.io/2018/03/19/effectiveJava4/"/>
    <id>http://KKimSangHeon.github.io/2018/03/19/effectiveJava4/</id>
    <published>2018-03-18T23:00:36.000Z</published>
    <updated>2018-03-18T23:39:16.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="규칙3-생성자나-enum-자료형은-싱글턴-패턴을-따르도록-설계해라"><a href="#규칙3-생성자나-enum-자료형은-싱글턴-패턴을-따르도록-설계해라" class="headerlink" title="규칙3 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계해라"></a>규칙3 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계해라</h2><p><code>싱글턴 : 객체를 하나만 만들 수 있는 클래스. 창관리자, 파일 시스템 같은 것들이 그 예다.</code><br> 싱글턴을 구현하는 방법은 두가지인데 두 방법 다 생성자는 private로 선언하고, 싱글턴 객체는 정적(static)멤버를 이용한다. 첫번째 방법의 경우 정적멤버는 final로 선언한다. 두 번째 방법은 public으로 선언된 정적 팩터리 메서드를 이용하는 것이다. 두 방법 다 리플렉션 기능을 통해 private 생성자를 호출할 수 있다는 점에 주의해야 한다.</p>
<p> 싱글턴을 구현하는 또다른 한가지의 방법은 원소가 하나뿐인 enum 자료형을 정의하는 것이다. 이는 좀 더 간결하며, 직렬화가 자동으로 처리된다. 또한 직렬화가 복잡하게 이루어져도 여러 객체가 생길일이 없으며 리플렉션을 통한 공격에도 안전하다.<br> 책에서는 이 방법이 싱글턴을 구현하는 가장 좋은 방법이라 추천한다.</p>
<h3 id="참고-URL"><a href="#참고-URL" class="headerlink" title="참고 URL"></a>참고 URL</h3><p>직렬화 : <a href="http://woowabros.github.io/experience/2017/10/17/java-serialize.html" target="_blank" rel="external">http://woowabros.github.io/experience/2017/10/17/java-serialize.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;규칙3-생성자나-enum-자료형은-싱글턴-패턴을-따르도록-설계해라&quot;&gt;&lt;a href=&quot;#규칙3-생성자나-enum-자료형은-싱글턴-패턴을-따르도록-설계해라&quot; class=&quot;headerlink&quot; title=&quot;규칙3 생성자나 enum 자료형은 싱
    
    </summary>
    
      <category term="Java" scheme="http://KKimSangHeon.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://KKimSangHeon.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>2장. 규칙2 생성자 인자가 많을 때는 Builder 패턴 적용을 고려하라.</title>
    <link href="http://KKimSangHeon.github.io/2018/03/15/effectiveJava3/"/>
    <id>http://KKimSangHeon.github.io/2018/03/15/effectiveJava3/</id>
    <published>2018-03-15T10:27:56.000Z</published>
    <updated>2018-03-18T09:57:03.232Z</updated>
    
    <content type="html"><![CDATA[<h2 id="규칙2-생성자-인자가-많을-때는-Builder-패턴-적용을-고려하라"><a href="#규칙2-생성자-인자가-많을-때는-Builder-패턴-적용을-고려하라" class="headerlink" title="규칙2. 생성자 인자가 많을 때는 Builder 패턴 적용을 고려하라."></a>규칙2. 생성자 인자가 많을 때는 Builder 패턴 적용을 고려하라.</h2><p>보통 생성자의 인자 혹은 정적팩터리의 인자가 많을 땐 점층적 생성자 패턴(telescping constructor pattern)을 적용한다. 17p<br><code>점층적 생성자 패턴 : 필수인자만 받는 생성자를 하나 정의하고, 선택적 인자를 하나 받는 생성자를 추가하고, 거기에 두 개의 선택적 인자를 받는 생성자를 추가하는 식으로 생성자들을 쌓아 올리듯 추가하는 것. 하지만 점층적 생성자 패턴은 설정할 필요가 없는 필드에도 인자를 전달해야하는 경우가 생긴다. 즉 인자수가 늘어나면 클라이언트 코드를 작성하기 어려워지고 읽기 어려워진다.</code></p>
<p>생성자의 인자가 많을 때 사용할 수 있는 두번째 방법은 자바빈(JavaBeans) 패턴이다. 18p<br><code>자바빈 패턴: 인자없는 생성자를 호출하여 객체부터 만든 다음, 설정메서드(setter)들을 호출하여 필수 필드뿐아니라 선택적 필드값 까지 채우는 것이다. 자바빈 패턴은 1회의 함수 호출로 객체 생성을 끝낼 수 없으므로 객체 일관성이 일시적으로 깨질 수 있다. 또한 변경 불가능(immutable)클래스를 만들 수 없다는점, 스레드 안정성을 제공하기 위해 해야할 일도 많아진다.</code></p>
<p>점층적 생성적 생성자 패턴의 안정성 , 자바빈 패턴의 가독성을 결합한 것이 바로 빌더(Builder)패턴이다.<br>필요한 객체를 직접 생성하는 대신 클라이언트는 먼저 필수인자들을 생성자 또는 정적 팩터리 메서드에 전부 전달하여 빌더객체(Builder object)를 만든다. 그런 다음 빌더 객체에 정의된 설정 메서드들을 호출하여 선택적 인자들을 추가 해 나간다. 그리고 마지막으로 아무런 인자 없이 build 메서드를 호출하여 변경 불가능 객체를 만든다.</p>
<h3 id="빌더패턴의-장점"><a href="#빌더패턴의-장점" class="headerlink" title="빌더패턴의 장점"></a>빌더패턴의 장점</h3><ol>
<li>작성하기 쉽고, 읽기 쉽다.</li>
<li>인자에 불변식(invariant)을 적용할 수 있다.</li>
<li>여러개의 varargs 인자(가변인자)를 받을수 있다.</li>
<li>하나의 빌더 객체로 여러 객체를 만들 수 있어 유연하다.</li>
</ol>
<h3 id="빌더패턴의-단점"><a href="#빌더패턴의-단점" class="headerlink" title="빌더패턴의 단점"></a>빌더패턴의 단점</h3><ol>
<li>객체를 생성하기 위해 빌더 객체를 생성해야한다. 오버헤드의 문제가 될 소지는 적지만 성능이 중요한 상황에서는 문제가 될 수 있다.</li>
</ol>
<h3 id="요약하자면"><a href="#요약하자면" class="headerlink" title="요약하자면"></a>요약하자면</h3><p>대부분의 인자가 선택적 인자이거나 인자가 많은 생성자나 정적 팩터리가 필요한 클래스를 설계할 때 유용하다. 가독성은 점층적 생성자 패턴보다 향상되며 자바빈을 사용할 때 보다 안전하다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;규칙2-생성자-인자가-많을-때는-Builder-패턴-적용을-고려하라&quot;&gt;&lt;a href=&quot;#규칙2-생성자-인자가-많을-때는-Builder-패턴-적용을-고려하라&quot; class=&quot;headerlink&quot; title=&quot;규칙2. 생성자 인자가 많을 때는
    
    </summary>
    
      <category term="Java" scheme="http://KKimSangHeon.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://KKimSangHeon.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>2장. 규칙1 생성자 대신 정적 팩터리 메서드를 사용할 수 없는지 생각해보자.</title>
    <link href="http://KKimSangHeon.github.io/2018/03/14/effectiveJava2/"/>
    <id>http://KKimSangHeon.github.io/2018/03/14/effectiveJava2/</id>
    <published>2018-03-13T22:53:39.000Z</published>
    <updated>2018-03-18T09:35:25.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="규칙-1-생성자-대신-정적-팩터리-메서드를-사용할-수-없는지-생각해보자"><a href="#규칙-1-생성자-대신-정적-팩터리-메서드를-사용할-수-없는지-생각해보자" class="headerlink" title="규칙 1. 생성자 대신 정적 팩터리 메서드를 사용할 수 없는지 생각해보자."></a>규칙 1. 생성자 대신 정적 팩터리 메서드를 사용할 수 없는지 생각해보자.</h2><p>프로그래머가 알아야하는 또다른 객체생성 방법은 클래스에 public로 선언된 팩토리 메서드를 추가하는 것이다.</p>
<h3 id="이러한-방법의-장점은-다음과-같다"><a href="#이러한-방법의-장점은-다음과-같다" class="headerlink" title="이러한 방법의 장점은 다음과 같다."></a>이러한 방법의 장점은 다음과 같다.</h3><p>1.생성자와 달리 정적 팩토리 메소드에는 이름이 있다. (가독성 향상)</p>
<p>2.호출할 때마다 새로운 객체를 생성할 필요 없다.(객체생성 비용이 클 때 효율적, 개체 통제 클래스로의 역할)<br><code>개체 통제 클래스(instance-controlled class) : 어떤 시점에 어떤 객체가 얼마나 존재할지 제어가능한 클래스. 이를 통해 싱글턴 패턴을 따르도록 할수 있고, 객체생성이 불가능한 클래스를 만들 수 도 있다. 변경이 불가능한 클래스의 경우 두개의 같은 객체가 존재하지 못하도록 할 수 있다.</code></p>
<p>3.생성자와 달리 반환값 자료형의 하위 자료형 객체를 반환할 수 있다. (반환되는 객체의 클래스를 유연하게 결정 가능. EnumSet이 그 예시)</p>
<p>4.형인자 자료형(parameterized type) 객체를 만들 때 편하다.(자바 1.7부터는 자료형 유추가 가능해졌다 14p)</p>
<h3 id="단점은-다음과-같다"><a href="#단점은-다음과-같다" class="headerlink" title="단점은 다음과 같다."></a>단점은 다음과 같다.</h3><ol>
<li>public이나 protected로 선언된 생성자가 없으므로 하위 클래스를 만들 수 없다는 것이다.</li>
<li>정적 팩터리 메서드가 다른 정적 메서드와 확연히 구분되지 않는다는 것이다.<br>보통 정적 팩토리 메소드의 이름으로는 다음과같은 이름을 쓴다.<br>valueOf , of , getInstance , newInstance , getType , newType</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;규칙-1-생성자-대신-정적-팩터리-메서드를-사용할-수-없는지-생각해보자&quot;&gt;&lt;a href=&quot;#규칙-1-생성자-대신-정적-팩터리-메서드를-사용할-수-없는지-생각해보자&quot; class=&quot;headerlink&quot; title=&quot;규칙 1. 생성자 대신 정
    
    </summary>
    
      <category term="Java" scheme="http://KKimSangHeon.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://KKimSangHeon.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Effective Java</title>
    <link href="http://KKimSangHeon.github.io/2018/03/12/effectiveJava1/"/>
    <id>http://KKimSangHeon.github.io/2018/03/12/effectiveJava1/</id>
    <published>2018-03-12T13:49:17.000Z</published>
    <updated>2018-03-12T15:03:26.275Z</updated>
    
    <content type="html"><![CDATA[<p>워낙 유명한 이책을 한번쯤 보고싶다는 생각을 했었고 이제서야 이 책을 읽으며 스스로 정리한 내용을 잊지 않기위해 블로그에 올려 공유하고자 한다.<br>다음은 이 책을 읽기위해 알아두자.</p>
<h2 id="1-자바는-네-가지-유형의-자료형을-지원한다"><a href="#1-자바는-네-가지-유형의-자료형을-지원한다" class="headerlink" title="1. 자바는 네 가지 유형의 자료형을 지원한다."></a>1. 자바는 네 가지 유형의 자료형을 지원한다.</h2><ul>
<li>인터페이스(어노테이션 포함)</li>
<li>클래스(enum 포함)</li>
<li>배열</li>
<li>기본 자료형(primitive)<br>여기서 위의 3개는 참조 자료형(reference type)으로 알려져있으며 모든 개체(instance)와 배열은 객체(object)이다. 하지만 기본 자료형은 객체가 아니다. 클래스의 멤버로는 필드(field), 메서드(method), 멤버 클래스(member class), 그리고 멤버 인터페이스(member interface) 등이 있다. 메서드의 시그니처(signature)는 그 이름과 형식 인자 자료형들로 구성된다. 시그니처에는 메서드의 반환값 자료형은 포함되지 않는다.<br><code>메소드 시그니처란 : 메소드의 이름과 매개변수 목록</code></li>
</ul>
<h2 id="2-자바-언어-명세서의-정의를-따르지-않는-것들"><a href="#2-자바-언어-명세서의-정의를-따르지-않는-것들" class="headerlink" title="2. 자바 언어 명세서의 정의를 따르지 않는 것들"></a>2. 자바 언어 명세서의 정의를 따르지 않는 것들</h2><ul>
<li>계승(inheritance)라는 용어를 하위 클래스 정의(subclassing)와 같은 뜻으로 사용한다.</li>
<li>인터페이스에는 계승이라는 용어 대신, 클래스가 인터페이스를 구현(implements)한다고 하거나, 한 인터페이스가 다른 인터페이스를 확장(extends)한다고 표현한다.</li>
<li>접근권한을 명시하지 않았을 때 가능한 접근 수준을 표현할 때는 기본 접근 권한 (default access)대신 의미가 분명한 package-private라는 용어를 사용한다.</li>
</ul>
<h2 id="3-API-관련"><a href="#3-API-관련" class="headerlink" title="3. API 관련"></a>3. API 관련</h2><ul>
<li>API를 사용해 프로그램을 작성하려는 프로그래머는 API의 사용자(user)라고 지칭한다.</li>
<li>어떤 API를 사용해 구현된 클래스는 API의 클라이언트(client)라고 부른다.</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;워낙 유명한 이책을 한번쯤 보고싶다는 생각을 했었고 이제서야 이 책을 읽으며 스스로 정리한 내용을 잊지 않기위해 블로그에 올려 공유하고자 한다.&lt;br&gt;다음은 이 책을 읽기위해 알아두자.&lt;/p&gt;
&lt;h2 id=&quot;1-자바는-네-가지-유형의-자료형을-지
    
    </summary>
    
      <category term="Java" scheme="http://KKimSangHeon.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://KKimSangHeon.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>리눅스마스터 2급</title>
    <link href="http://KKimSangHeon.github.io/2018/03/07/linuxmaster/"/>
    <id>http://KKimSangHeon.github.io/2018/03/07/linuxmaster/</id>
    <published>2018-03-07T14:51:28.000Z</published>
    <updated>2018-03-12T14:14:42.540Z</updated>
    
    <content type="html"><![CDATA[<h3 id="취득시기"><a href="#취득시기" class="headerlink" title="취득시기"></a>취득시기</h3><p>2018년 03월</p>
<h3 id="내용"><a href="#내용" class="headerlink" title="내용"></a>내용</h3><p>데비안, 레드햇 계열 리눅스의 기본적인 역사 그리고 간단한 명령어 정도만 알고있을 경우 일주일 정도면 취득가능하다. www.comcbt.com/ 에서 연도별 문제를 제공하며 총 5회분의 문제(약 400문제)정도를 풀어보고 시험을 봤었다. 용산공업고등학교에서 시험을 봤으며 학교의 정문을 찾는데 애를 먹었던것 말고는 불편했던점은 없다. 하루 2시간씩 약 일주일동안 공부하였으며 시험 3일 후엔 가답안이 나와 가채점이 가능하다는 것이 다른 자격증에 비해 좋았던것 같다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;취득시기&quot;&gt;&lt;a href=&quot;#취득시기&quot; class=&quot;headerlink&quot; title=&quot;취득시기&quot;&gt;&lt;/a&gt;취득시기&lt;/h3&gt;&lt;p&gt;2018년 03월&lt;/p&gt;
&lt;h3 id=&quot;내용&quot;&gt;&lt;a href=&quot;#내용&quot; class=&quot;headerlink&quot; tit
    
    </summary>
    
      <category term="기타" scheme="http://KKimSangHeon.github.io/categories/%EA%B8%B0%ED%83%80/"/>
    
      <category term="자격증" scheme="http://KKimSangHeon.github.io/categories/%EA%B8%B0%ED%83%80/%EC%9E%90%EA%B2%A9%EC%A6%9D/"/>
    
    
      <category term="자격증" scheme="http://KKimSangHeon.github.io/tags/%EC%9E%90%EA%B2%A9%EC%A6%9D/"/>
    
      <category term="리눅스마스터 2급" scheme="http://KKimSangHeon.github.io/tags/%EB%A6%AC%EB%88%85%EC%8A%A4%EB%A7%88%EC%8A%A4%ED%84%B0-2%EA%B8%89/"/>
    
  </entry>
  
</feed>
