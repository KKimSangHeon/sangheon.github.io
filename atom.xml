<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kim Sang Heon&#39;s Bolg</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://KKimSangHeon.github.io/"/>
  <updated>2019-05-22T11:48:50.376Z</updated>
  <id>http://KKimSangHeon.github.io/</id>
  
  <author>
    <name>Kim Sang Heon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kube3</title>
    <link href="http://KKimSangHeon.github.io/2019/05/22/kube3/"/>
    <id>http://KKimSangHeon.github.io/2019/05/22/kube3/</id>
    <published>2019-05-22T11:48:50.000Z</published>
    <updated>2019-05-22T11:48:50.376Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2.도커 컨테이너 배포</title>
    <link href="http://KKimSangHeon.github.io/2019/05/21/kube2/"/>
    <id>http://KKimSangHeon.github.io/2019/05/21/kube2/</id>
    <published>2019-05-21T10:16:49.000Z</published>
    <updated>2019-05-21T10:17:17.787Z</updated>
    
    <content type="html"><![CDATA[<p>도커에서 제공하는 스크립트로 설치</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo wget -qO- https://get.docker.com/ | sh</div><div class="line">$ sudo usermod -aG docker shkim</div></pre></td></tr></table></figure>
<p><code>도커 이미지</code> : 도커 컨테이너를 구성하는 파일 시스템과 실행할 어플리케이션 설정을 하나로 합친것으로, 컨테이너를 생성하는 템플릿 역할을 한다.</p>
<p><code>도커 컨테이너</code> : 도커 이미지를 기반으로 생성되며, 파일 시스템과 어플리케이션이 구체화돼 실행되는 상태.</p>
<p>Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?<br>이라는 에러 뜰 때</p>
<p>sudo systemctl start docker</p>
<p>실습<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker image pull gihyodocker/echo:latest</div></pre></td></tr></table></figure></p>
<p>위를 입력하여 이미지를 내려받자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker container run -t -p 9000:8080 gihyodocker/echo:latest</div></pre></td></tr></table></figure>
<p>를 입력하여 내부 8080포트로 포트포워딩이 가능토록 해보자</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ curl http://localhost:9000</div></pre></td></tr></table></figure>
<p>을 입력하면 정상적으로 동작함을 볼 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker container stop $(docker container ls -q)</div></pre></td></tr></table></figure>
<p>을 입력하여 컨테이너를 중지시킬 수 있다.</p>
<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p><code>FROM</code> : 도커 이미지의 바탕이 될 베이스 이미지. dOCKERFILE로 이미지를 빌드할 때 먼저 from 인스트럭션에 지정된 이미지를 내려받는다. 받아오는 이미지는 모두 도커 허브 레지스트리에 공개된 것이다. 콜론 뒤에 붙는것은 버전이라고 볼 수 있다.</p>
<p><code>RUN</code> : 도커 이미지를 실행할 때 컨테이너 안에서 실행할 명령을 정의하는 인스트럭션. 도커 안에서 실행할 명령을 그대로 기술한다.</p>
<p><code>COPY</code> : 도커가 동작중인 호스트 머신의 파일이나 디렉토리를 도커 컨테이너 안으로 복사하는 인스트럭션이다.</p>
<p><code>CMD</code> : 도커 컨테이너를 실행할 때 컨테이너 안에서 실행할 프로세스를 지정한다. RUN은 이미지를 빌드할 때 실행되고 CMD는 컨테이너를 시작할 때 한번 실행된다. RUN은 어플리케이션 업데이트 및 배치에, CMD는 어플리케이션 자체를 실행하는 명령이라고 생각하면된다.</p>
<p>/</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;도커에서 제공하는 스크립트로 설치&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/d
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="MSA" scheme="http://KKimSangHeon.github.io/categories/CS/MSA/"/>
    
    
      <category term="kubernetes" scheme="http://KKimSangHeon.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>1.도커의 기초</title>
    <link href="http://KKimSangHeon.github.io/2019/05/18/kube1/"/>
    <id>http://KKimSangHeon.github.io/2019/05/18/kube1/</id>
    <published>2019-05-18T14:49:26.000Z</published>
    <updated>2019-05-20T13:39:41.371Z</updated>
    
    <content type="html"><![CDATA[<h3 id="도커-amp-쿠버네티스"><a href="#도커-amp-쿠버네티스" class="headerlink" title="도커 &amp; 쿠버네티스"></a>도커 &amp; 쿠버네티스</h3><p>도커와 쿠버네티스에 대해 더 공부해보고 싶어 아래책을 구매하였고 포스팅해 볼 예정이다.<br><img src="/2019/05/18/kube1/dockerandkube.jpg" alt="[도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문]" title="[도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문]"></p>
<h3 id="도커란-무엇인가"><a href="#도커란-무엇인가" class="headerlink" title="도커란 무엇인가"></a>도커란 무엇인가</h3><p>도커는 컨테이너형 가상화 기술을 구현하기 위한 상주 어플리케이션(dockered라는 데몬)과 이 어플리케이션을 조작하기 위한 명령행 도구로 구성되는 프로덕트이다. 어플리케이션 배포에 특화되어 있기 때문에 어플리케이션 개발 및 운영을 컨테이너 중심으로 할 수 있다.<br>로컬 환경에 도커만 설치하면 몇 줄짜리 구성 파일과 명령어 한줄로 어플리케이션이나 미들웨어가 이미 갖춰진 테스트용 가상환경을 빠르게 구축할 수 있다. 가상화 소프트웨어와 비교해도 오버헤드가 적이진다는 장점이 있다.</p>
<p>도커의 장점</p>
<ul>
<li>기존 가상화 소프트웨어보다 더 가볍다.</li>
<li>이식성이 뛰어나다.</li>
<li>설치가 번거로운 명령형 도구를 도커 컨테이너로 가져다 사용함으로써 호스트를 깔금하게 유지하면서도 바로 실행할 수 있다.</li>
<li>다양한 의존 라이브러리나 도구를 도커 컨테이너에 포함시켜 배포함으로써 실행 환경과 상관없이 스크립트의 동작 재현성을 높임.</li>
<li>도커 컨테이너를 HTTP  부하 테스트의 워커로 사용해  HTTP 요청 수를 증가시킴.</li>
</ul>
<p>컨테이너는 운영체제의 동작을 완전히 재현하지는 못하기 때문에 엄밀한 리눅스 계열 운영체제의 동작이 요구되는 가상환경을 구축해야 한다면 VMWare가 더 적합할 수 있다.</p>
<h3 id="컨테이너-가상화"><a href="#컨테이너-가상화" class="headerlink" title="컨테이너 가상화?"></a>컨테이너 가상화?</h3><p>도커는 컨테이너형 가상화 기술을 사용하는데 이를통해 가상화 소프트웨어 없이도 운여 체제의 리소스를 격리해 가상 운영체제로 만들 수 있다. 이 가상 운영 체제를 컨테이너라 한다.  컨테이너를 만들면서 발생하는 오버헤드는 다른 가상화 소프트웨어보다 더 적다. 빠르게 시작 및 종료할 수 있고 이에 들어가는 리소스도 작은 편이다.</p>
<h3 id="운영체제-가상화"><a href="#운영체제-가상화" class="headerlink" title="운영체제 가상화?"></a>운영체제 가상화?</h3><p>운영체제 위에서 가상화 소프트웨어를 사용해 하드웨어를 에뮬레이션 하는 방법으로 게스트 운영체제를 만드는 방식을 호스트 운영체제 가상화 라고 한다. 컨테이너형 가상화와 비교하면 구조적으로 오버헤드가 크다.</p>
<img src="/2019/05/18/kube1/image1.png" alt="운영체제 가상화 / 컨테이너 가상화" title="운영체제 가상화 / 컨테이너 가상화">
<p>컨테이너 가상화의 경우 하이퍼바이저와, Guest OS를 만들지 않는것을 확인할 수 있다.</p>
<p>그림에 대해 조금 더 알아보자</p>
<p>VMware, VirtualBox는 호스트 OS위에 게스트 OS 전체를 가상화 하여 사용하는 방식 도커는 게스트 OS를 설치하는 방식이 아닌 서버 운영을 위한 라이브러리만 이미지에 담아 설치하게 되므로 기존의 방법들(전가상화, 반가상화)보다 경량화 된 상태입니다. 즉, 하드웨어를 가상화하는 계층이 없어졌기 때문에 기존 가상머신에 대해 보다 빠른 속도를 제공합니다.<br><code>https://real-dongsoo7.tistory.com/60 참고</code></p>
<p>컨테이너는 하이퍼바이저와 다르다. 컨테이너는 하이퍼바이저와 가상화라는 같은 목표를 갖고 있다. 하지만 하이퍼바이저는 OS 및 커널이 통째로 가상화 되지만 컨테이너는 파일시스템만 가상화가 된다. 컨테이너는 호스트 PC의 커널을 공유한다. 따라서 init등의 프로세스가 떠 있을 필요가 없고 가상화 프록르ㅐㅁ과는 다르게 적은 메모리 사용량 적은 오버헤드를 보인다.</p>
<h3 id="도커를-사용하는-의의"><a href="#도커를-사용하는-의의" class="headerlink" title="도커를 사용하는 의의"></a>도커를 사용하는 의의</h3><p>변화하지 않는 실행환경으로 멱등성 확보<br>코드를 통한 실행환경 구축 및 어플리케이션 구성<br>실행환경과 어플리케이션의 일체화로 이식성 향상<br>시스템을 구성하는 어플리케이션 및 미들웨어의 관리 용이성</p>
<p>환경의 차이로 인해 발생하는 문제에 대해 나온것들<br>1.코드로 관리하는 인프라<br>코드 기반으로 인프라를 정의한다는 개념. 멱등성을 확보하기위해 어플리케이션이 의존하는 런타임이나 라이브러리 모두가 확실하게 특정 버전으로 설치되도록 해야한다. <u>멱등성 보장을 위해 항구적인 코드를 계속적으로 작성하는것은 운영 업무에 부담을 주기 쉽다. 또한 서버의 대수가 늘어날 수록 모든서버에 구성을 적용하는 시간도 늘어난다. 이러한 문제에 대한 대책이 불변인프라 개념이다.</u></p>
<p>2.불변인프라<br><u>불변 인프라는 어떤 시점의 서버 상태를 저장해 복제할 수 있게 하자는 개념이다. </u>제대로 설정된 상태의 서버를 항상 사용할 수 있단는 점이 가장 큰 장점이다. 서버에 변경을 가하고 싶은 경우에는 기존 인프라를 수정하는 대신 새로운 서버를 구축하고 그 상태를 이미지로 저장한 다음 그 이미지를 복제한다. 한번 설정된 서버는 수정없이 파기되므로 멱등성을 신경쓸 필요가 없다.</p>
<p>도커를 활용할 경우 위의 두 개념을 쉽고 낮은 비용으로 실현할 수 있다. 도커는 컨테이너형 가상화 기술을 사용하다. 가상 머신의 OS를 재현하는게아닌 운영체제 대부분을 호스트 운영체제와 공유한다. 실행에 걸리는 시간이 짧은만큼 인프라를 완전히 새로 만드는 불변 인프라와 궁합이 잘 맞는다.</p>
<p>도커 컴포즈가 단일 서버를 넘어 여러 서버에 걸쳐있는 여러 컨테이너를 관리할 수 있도록 한 도구가 도커 스웜이다. 여러컨테이너를 관리하는 것만이 목적인 도커 컴포즈와 달리 도커 스웜은 컨테이너 증가 혹은 감소는 물론이고 노드의 리소스를 효율적으로 활용하기 위한 컨테이너 배치 및 로드 밸런싱 기능 등 더욱 실용적인 기능을 갖추고 있다. 또한 롤링업데이트(오래된 컨테이너와 새로운 컨테이너를 단계적으로 서비스에 교체 투입하는것)가 가능하다. 이처럼 여러 서버에 걸쳐있는 여러 컨테이너를 관리하는 기법을 <code>컨테이너 오케스트레이션</code>이라 한다.</p>
<p>컨테이너 오케스트레이션 분야에서 사실상 표준으로 자리 잡은 것은 <code>쿠버네티스</code>이다.</p>
<p>도커를 통해 인프라와 어플리케이션이 모두 컨테이너 형태로 제공되면서 인프라와 어플리케이션의 설정을 모두 코드수준에서 쉽게 수정할 수 있게됐다. 기존에는 명확했던 인프라 엔지니어와 서버 사이드 엔지니어의 영역 구분이 점점 희미해지고 있다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;도커-amp-쿠버네티스&quot;&gt;&lt;a href=&quot;#도커-amp-쿠버네티스&quot; class=&quot;headerlink&quot; title=&quot;도커 &amp;amp; 쿠버네티스&quot;&gt;&lt;/a&gt;도커 &amp;amp; 쿠버네티스&lt;/h3&gt;&lt;p&gt;도커와 쿠버네티스에 대해 더 공부해보고 싶어 아
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="MSA" scheme="http://KKimSangHeon.github.io/categories/CS/MSA/"/>
    
    
      <category term="kubernetes" scheme="http://KKimSangHeon.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>(K8s) 6. 윈도우에서 실습해보기</title>
    <link href="http://KKimSangHeon.github.io/2019/05/06/kubernetes6/"/>
    <id>http://KKimSangHeon.github.io/2019/05/06/kubernetes6/</id>
    <published>2019-05-06T14:26:48.000Z</published>
    <updated>2019-05-06T14:28:07.985Z</updated>
    
    <content type="html"><![CDATA[<p>도커툴박스설치</p>
<p><a href="https://docs.docker.com/toolbox/overview/" target="_blank" rel="external">https://docs.docker.com/toolbox/overview/</a></p>
<p>virtual machine 가 없다면 체크하여 설치</p>
<p>PowerShell 관리자 권한으로 실행</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">$ ExecutionPolicy      &lt;-- 현재상태확인</div><div class="line">$ Set-ExecutionPolicy Unrestricted</div><div class="line"></div><div class="line"></div><div class="line">$ Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))</div><div class="line"></div><div class="line">$ choco install minikube kubernetes-cli</div><div class="line"></div><div class="line">$ kubectl run sangheonkim --image=gcr.io/google-samples/kubernetes-bootcamp:v1 --port=8080</div><div class="line"></div><div class="line"></div><div class="line">$ minikube dashboard</div></pre></td></tr></table></figure>
<p>파드 내부에서 출력하는 로그를 보자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ kubectl get pods</div><div class="line">를 통해 파드의 정보를 복사하자,</div><div class="line">$ kubectl logs $POD_NAME</div></pre></td></tr></table></figure></p>
<p>컨테이너로 들어가서 여러 명령어를 실행해보자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ kubectl exec $POD_NAME env</div><div class="line"></div><div class="line">$ kubectl exec -ti $POD_NAME bash</div></pre></td></tr></table></figure></p>
<p>서비스를 만들어보자</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ kubectl get services</div><div class="line">서비스를 확인해보자. 미니쿠베가 만든게 하나 존재한다.</div><div class="line"></div><div class="line">$ kubectl expose deployment/sangheonkim --type=&quot;NodePort&quot; --port 8080</div><div class="line">서비스를 노출시켜보자</div><div class="line"></div><div class="line">$ kubectl describe services/sangheonkim</div><div class="line">서비스를 자세히 보자</div></pre></td></tr></table></figure>
<p>Deployment를 자세히보자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ kubectl describe deployments</div></pre></td></tr></table></figure></p>
<p>보면 레이블이 있는것을 확인할 수 있는데 디플로이먼트는 저절로 레이블이 하나 생긴다.</p>
<p>레이블을 변경해보자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ kubectl label pod $POD_NAME app=v1</div><div class="line">를 입력하여 레이블을 app=v1 으로 변경하고</div><div class="line"></div><div class="line">$ kubectl describe pods $POD_NAME</div><div class="line">을 입력하여 확인해보자.</div><div class="line"></div><div class="line">$ kubectl get pods -l app=v1</div><div class="line">을 입력하여 잘반영되었나 확인해보자</div></pre></td></tr></table></figure></p>
<p>서비스를 삭제해보자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ kubectl delete service -l run=sangheonkim</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;도커툴박스설치&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/toolbox/overview/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://docs.docker.com/toolbox/overvie
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="MSA" scheme="http://KKimSangHeon.github.io/categories/CS/MSA/"/>
    
    
      <category term="kubernetes" scheme="http://KKimSangHeon.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>(K8s) 5. 여러 인스턴스를 실행하기. Scaling 하기</title>
    <link href="http://KKimSangHeon.github.io/2019/04/23/kubernetes5/"/>
    <id>http://KKimSangHeon.github.io/2019/04/23/kubernetes5/</id>
    <published>2019-04-23T12:08:06.000Z</published>
    <updated>2019-04-28T09:42:12.109Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Scaling"><a href="#Scaling" class="headerlink" title="Scaling"></a>Scaling</h4><p>애플리케이션 스케일링하기<br>이전 모듈에서 서비스를 만들고 퍼블릭하게 노출했다. 해당 디플로이멘트는 하나의 파드로 증가하도록 했다. 트래픽이 증가하면 사용자가 요구하는대로 어플리케이션을 실행할 필요 있다,.<br>스케일링은 디플러이먼트의 어플리케이션 replicas를 몇개할지 정하는것이다.</p>
<p>하나만 감싸고 있는 서비스를 여러노드에 거쳐 서비스를 스케일 아웃을 할 수 있다.<br>디플로이먼트를 스케일 아웃하면 신규 파드가 생성되어서 가용한 자원이 있는 노드에 스케줄된다. 스케일링 인은 파드개수를 줄이는것을 의미한다.</p>
<p>이는 또한 오토스케일링을 지원하기도 한다.(즉 들어오는 유동적으로 결정해주기도 함)<br>제로로 스케일링하는것도 가능한데 이는 디플로이먼트에 정의되어있는 파드를 모드 제거 하는것이다.</p>
<p>애플리케이션의 인스턴스를 복수로 구동하게 되면 트래픽을 해당 인스턴스 모두에 분산시킬 방법이 필요해진다. 서비스는 노출된 디플로이먼트의 모든 파드에 네트워크 트래픽을 분산시켜줄 통합된 로드밸런서를 갖는다. 서비스는 엔드포인트를 이용해서 구동중인 파드를 지속적으로 모니터링함으로써 가용한 파드에만 트래픽이 전달되도록 해준다.</p>
<p>일단 여러인스턴스가 실행되면 롤링 업데이트를 자동으로 할 수 있다.</p>
<p>kubectl get deployments<br>를 입력하여 디플로이 먼트 리스트를 보자<br>DESIRED는 설정에서 정의된 replicas 개수를 의미<br>CURRENT는 현재동작중인 개수<br>UP-TO-DATE 는 DESIRED를 맞추기 위해 뭐가 바뀌었는지<br>AVAILABLE 유저한테 가용할 수 있는 개수</p>
<p>replicas을 네개로 바꿔보자<br>kubectl scale deployments/kubernetes-bootcamp –replicas=4</p>
<p>kubectl get deployments<br>를 입력하여 4개가 도는지 확인해보자</p>
<p>파드는 각 다른 아이피를 갖는데<br>kubectl get pods -o wide<br>를 입력하여 4개에 대해 자세히 볼수 있다.</p>
<p>kubectl describe deployments/kubernetes-bootcamp<br>를 입력하여 변경사항을 기록한 로그를 확인할 수 있다.(replicas를 4개로 바꾼것 확인 가능)</p>
<p>kubectl describe services/kubernetes-bootcamp<br>를 입력하여 서비스가 어떤아이피로 제공하고 있는지 확인할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template=&apos;&#123;&#123;(index .spec.ports 0).nodePort&#125;&#125;&apos;)</div><div class="line">echo NODE_PORT=$NODE_PORT</div></pre></td></tr></table></figure>
<p>를 입력하여 포트를 확인해보자.</p>
<p>이번엔 아래를 입력하여 스케일 다운해보자 replicas를2개로 바꾸자<br>kubectl scale deployments/kubernetes-bootcamp –replicas=2</p>
<p>kubectl get deployments<br>를 입력하여 디폴로이 먼트의 파드 개수를 확인해보자.</p>
<p>kubectl get pods -o wide<br>를 입력하여 2개의 파드가 종료된것을 확인할 수 있다.</p>
<h4 id="Rolling-update"><a href="#Rolling-update" class="headerlink" title="Rolling update"></a>Rolling update</h4><p>유저는 어플리케이션을 항상 사용할수 있도록 원한다. 그리고 개발자는 하루에 여러번 배포할 수 있길 바란다. 이를 쿠버네티스에서 제공한느 롤링 업데이트를 통해 할 수 있다. 이는 디플로이먼트를 제로다운타임으로 점진적으로 파드를 업데이트 할 수 있다. 새파드는 가용한 리소스를 사용하여 새로운 파드가 만들어질 수 있다.</p>
<p>이전에는 여러 인스턴스를 에서 스케일링하는것을 배웠다. 기본적으로, 업데이트가 이루어지는 동안 이용 불가한 파드의 최대 개수와 생성 가능한 새로운 파드의 최대 개수는 하나다. 두 옵션은 기본적으로 업데이트할 때 파드 개수만큼 한번에 꺼버릴수있다. 그리고 최대갯수만큼 파드를 생성할 수있다.(즉 비율을 적용하여 할 수 있다.) 쿠버네티스에서 업데이트는 버전으로 관리되고 어떠한 디플로이먼트 업데이트라도 이전버전으로 원복이 가능하다.</p>
<p>어플리케이션 스케일링과 비슷하게 디플로이먼트가 노출되어있으면 서비는 가용한 파드한테만 보낸다.<br>롤링업데이트는 다음과 같은 행동을 허용한다.</p>
<ul>
<li>어플리케이션 환경 변경(컨테이너 이미지 변경방법)</li>
<li>이전버전으로 롤백</li>
<li>CI/CD 제로다운타임으로</li>
</ul>
<p>새버전으로 업데이트 하고 롤백해보자</p>
<p> kubectl get deployments<br> 를 입력하여 디폴로이 먼트들을 확인해보자(4개가 떠있다)</p>
<p> kubectl get pods<br> 를 입력하여 돌아가고 있는 파드들을 보자</p>
<p>kubectl describe pods<br>를 입력하여  이미지 버전을 보자</p>
<p>이미지를 version2로 바꾸기 위해 다음을 입력하자</p>
<p>kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2</p>
<p>kubectl get pods<br>를 입력하면 4개는 종료하고 러닝은 4개인것을 볼 수 있다.<br>즉 한번에 4개를 죽여버리고 4개를 실행<br>제로 다운타임이 아니다!!</p>
<p>kubectl describe services/kubernetes-bootcamp<br>를 입력하여 앱이 돌아가고 있는것과 아이피 포트를 확인하자</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template=&apos;&#123;&#123;(index .spec.ports 0).nodePort&#125;&#125;&apos;)</div><div class="line">echo NODE_PORT=$NODE_PORT</div></pre></td></tr></table></figure>
<p>를 입력하여 포트 설정 후</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl $(minikube ip):$NODE_PORT</div></pre></td></tr></table></figure>
<p>을 입력하여 잘 돌고있나 보자</p>
<p>kubectl rollout status deployments/kubernetes-bootcamp<br>를 입력하여 롤 아웃된것을 확인할 수 있다</p>
<p>kubectl describe pods<br>를 입력하여 현재 이미지 버전을 볼 수 있다.</p>
<p>kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=gcr.io/google-samples/kubernetes-bootcamp:v10<br>를 입력하여 이미지를 버전 10으로 바꾸자</p>
<p>kubectl get deployments<br>를 입력하여 디플로이먼트의 현재상황을 보자<br>하나가 문제가 생긴것을 확인할 수 있다.</p>
<p>kubectl get pods<br>를 하면 파드들을 더 자세히 볼 수 있다.</p>
<p>kubectl describe pods<br>를 입력하여 파드들의 상태를 보자. 이미지가 바뀐지 보자<br>봤는데 이미지가 바뀌지 않은것을 확인할 수 있다.<br>레파지토리에 v10 이 없어서 그렇다. 그러므로 롤백하자.</p>
<p>kubectl get pods<br>를 입력하여 4개가 잘 돌고있는지 보고</p>
<p>kubectl describe pods<br>를 입력하여 이미지가 잘 돌고있는지 보자</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Scaling&quot;&gt;&lt;a href=&quot;#Scaling&quot; class=&quot;headerlink&quot; title=&quot;Scaling&quot;&gt;&lt;/a&gt;Scaling&lt;/h4&gt;&lt;p&gt;애플리케이션 스케일링하기&lt;br&gt;이전 모듈에서 서비스를 만들고 퍼블릭하게 노출했다. 해당 디
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="MSA" scheme="http://KKimSangHeon.github.io/categories/CS/MSA/"/>
    
    
      <category term="kubernetes" scheme="http://KKimSangHeon.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>(K8s) 4. 서비스를 사용하여 앱을 외부로 공개하기 , 서비스 / 레이블</title>
    <link href="http://KKimSangHeon.github.io/2019/04/23/kubernetes4/"/>
    <id>http://KKimSangHeon.github.io/2019/04/23/kubernetes4/</id>
    <published>2019-04-23T12:08:01.000Z</published>
    <updated>2019-04-23T12:18:16.726Z</updated>
    
    <content type="html"><![CDATA[<h4 id="서비스를-사용하여-앱을-외부로-공개하기"><a href="#서비스를-사용하여-앱을-외부로-공개하기" class="headerlink" title="서비스를 사용하여 앱을 외부로 공개하기"></a>서비스를 사용하여 앱을 외부로 공개하기</h4><p><a href="https://kubernetes.io/ko/docs/tutorials/kubernetes-basics/expose/expose-intro/" target="_blank" rel="external">https://kubernetes.io/ko/docs/tutorials/kubernetes-basics/expose/expose-intro/</a></p>
<p>지금까지의 앱은 컨테이너 안에서 도는데 private하고 네트웍도 isolate되어있었다. 그러므로 proxy 를 붙여서 동작했었다</p>
<h4 id="쿠버네티스-서비스에-대한-개요"><a href="#쿠버네티스-서비스에-대한-개요" class="headerlink" title="쿠버네티스 서비스에 대한 개요"></a>쿠버네티스 서비스에 대한 개요</h4><p>파드는 언젠가 죽는것이다. 즉 라이프사이클이 있다. 어떤 워커노드가 죽으면 그 노드에서 돌고있는 파드도 죽는다.<br> 그렇게되면 ReplicationController 가 클러스터를 동적으로 새로운노드를 만듬으로서 복구한다. 예를들어 이미지 처리하는 백엔드가 3개의 어플리케이션을 갖고있다 해보자. 프론트엔드는 백엔드 파드가 없어지는것 생기는것에 대해 신경쓰지 말고 동작하여야 한다. 각 파드는 유니크한 아이피를 갖고있는데 애플리케이션이 계속해서 동작할 수 있도록 발생하는 변화들을 서로 감지하는 방법이 필요하다.</p>
<h3 id="서비스"><a href="#서비스" class="headerlink" title="서비스"></a>서비스</h3><p>쿠버네티스에 있는 서비스는 파드의 set을 논리적으로 정의 한것이고 그 파드들에게 어떻게 접근할 수 있는지에 대한 정책을 정의한것이다.<br>서비스는 파드들간에 커플링을 낮춘다. 서비스는 모든 쿠버네티스 오브젝트들과 같이 YAML (보다 선호하는) 또는 JSON을 이용하여 정의되고. 서비스가 대상으로 하는 파드 셋은 보통 LabelSelector에 의해 결정된다</p>
<h4 id="서비스-외부로-노출하기"><a href="#서비스-외부로-노출하기" class="headerlink" title="서비스 외부로 노출하기"></a>서비스 외부로 노출하기</h4><p>비록 각각의 파드가 제각각의 IP를 갖고있지만 서비스 없이는 클러스터 바깥으로 노출되지 않는다. 서비스는 어플리케이션이 트래픽을 받게할 수 있는데 ServiceSpec에 type을 지정하여 노출 할 수 있다.</p>
<h4 id="ServiceSpec의-type"><a href="#ServiceSpec의-type" class="headerlink" title="ServiceSpec의 type"></a>ServiceSpec의 type</h4><ul>
<li>ClusterIP (기본값) - 클러스터 내에서 내부 IP 에 대해 서비스를 노출해준다. 이 방식은 오직 클러스터 내에서만 서비스가 접근될 수 있도록 해준다.</li>
<li>NodePort - NAT가 이용되는 클러스터 내에서 각각 선택된 노드들의 동일한 포트에 서비스를 노출시켜준다. <nodeip>:<nodeport>를 이용하여 클러스터 외부로부터 서비스가 접근할 수 있도록 해준다. CluserIP의 상위 집합이다.</nodeport></nodeip></li>
<li>LoadBalancer - (지원 가능한 경우) 기존 클라우드에서 외부용 로드밸런서를 생성하고 서비스에 고정된 공인 IP를 할당해준다. NodePort의 상위 집합이다.</li>
<li>ExternalName - 프록시를 사용하지 않고 임의의 Name을 사용해서 expose 하는방법으로 externalName을 스펙에다 정의함(YAML 혹은 JSON)  kube-dns 1.7 이상 요구됨</li>
</ul>
<p>추가적으로 셀렉터를 지정하지 않는경우도 있는데 셀렉터를 지정하지 않은것은 엔드포인트를 오브젝트를 만들지 않을것이다. 그렇게 함으로써 유저들로 하여금 직접 서비스를 특정엔드포인트에 매핑할 수 있도록 해준다. selector를 생략하게 되는 또 다른 가능성은 여러분이 type: ExternalName을 이용하겠다고 확고하게 의도하는 경우이다.</p>
<h4 id="서비스와-레이블"><a href="#서비스와-레이블" class="headerlink" title="서비스와 레이블"></a>서비스와 레이블</h4><p>서비스는 파드들의 묶음인데 하나의 ip로 묶인다. 하나의 아이피는 외부에 노출되어 서비스안에 존재하는 파드들에 접근할 수 있게해준다. 서비스는 파드셋에다가 트래픽을 라우팅(쿠버네티스 서비스들에 의해 처리된다.)하는데 서비스는 파드가 애플리케이션에 영향을 주지않고 혼자 죽거나 살아날 수 있도록 한다.</p>
<p>파드 셋을 label이랑 selector을 사용하여 매치한다. label은 key / value 쌍이며 오브젝트에 붙어있고 여러가지 방식으로 사용될 수 있다.</p>
<ul>
<li>개발, 테스트, 그리고 상용환경에 대한 객체들의 지정</li>
<li>임베디드된 버전 태그들</li>
<li>태그들을 이용하는 객체들에 대한 분류</li>
</ul>
<p>레이블은 오브젝트가 만들어 질때 붙일수도 있고 나중에 붙일수있고 아무때나 수정할 수 있다.</p>
<p>kubectl get pods<br>를 입력하고 파드들을 확인해보자.</p>
<p>kubectl get services<br>를 입력하여 서비스를 확인해보자. 만들지도 않았는데 하나가 돌아가고 있는데 클러스터에서 미니큐브를 만들면 실행되는것이다.</p>
<p>새로운 서비스를 만들고 노출하려면 다음과 노트 포트를 파라미터로 줘야한다.<br>kubectl expose deployment/kubernetes-bootcamp –type=”NodePort” –port 8080<br>내부 8080포트에 붙으라는것.</p>
<p>kubectl get services<br>를 입력하여 서비스를 확인해보자.<br>하나가 더 추가가 된것을 알 수 있다.</p>
<p>서비스가 클러스터ip로 인터널, external 포트가 있다.</p>
<p>kubectl describe services/kubernetes-bootcamp<br>를 입력하여 자세히 살펴보자.</p>
<p>노드포트라는 환경변수를 만들자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template=&apos;&#123;&#123;(index .spec.ports 0).nodePort&#125;&#125;&apos;)</div><div class="line"></div><div class="line">echo NODE_PORT=$NODE_PORT</div></pre></td></tr></table></figure></p>
<p>아래를 입력하여 접근해보자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl $(minikube ip):$NODE_PORT</div></pre></td></tr></table></figure></p>
<p>디플로이먼트는 자동으로 레이블이 하나있다.<br>이를통해 파드리스트를 쿼리해보자.<br>kubectl get pods -l run=kubernetes-bootcamp<br>run=kubernetes-bootcamp이 label이다.</p>
<p>kubectl get services -l run=kubernetes-bootcamp<br>를 입력하여 run=kubernetes-bootcamp 이라는 레이블을 갖고있는 서비스를 조회해보자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export POD_NAME=$(kubectl get pods -o go-template --template &apos;&#123;&#123;range .items&#125;&#125;&#123;&#123;.metadata.name&#125;&#125;&#123;&#123;&quot;\n&quot;&#125;&#125;&#123;&#123;end&#125;&#125;&apos;)</div><div class="line">echo Name of the Pod: $POD_NAME</div></pre></td></tr></table></figure>
<p>를 입력하여 파드 네임을 환경변수에 넣어보자.</p>
<p>app=v1으로 새로운이름을 주자.<br>kubectl label pod $POD_NAME app=v1</p>
<p>kubectl describe pods $POD_NAME<br>레이블 확인해보자.</p>
<p>kubectl get pods -l app=v1<br>바뀐 레이블로 파드를 조회해보자.</p>
<p>kubectl delete service -l run=kubernetes-bootcamp<br>를 입력하여 서비스를 삭제하자.</p>
<p>kubectl get services<br>서비스를 확인해보자.</p>
<p>라우팅도 잘 안되나 확인해보자.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl $(minikube ip):$NODE_PORT</div></pre></td></tr></table></figure></p>
<p>파드안에서 동작하는 아래의 명령어를 통해 아직 파드가 동작는지 보자.<br>kubectl exec -ti $POD_NAME curl localhost:8080</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;서비스를-사용하여-앱을-외부로-공개하기&quot;&gt;&lt;a href=&quot;#서비스를-사용하여-앱을-외부로-공개하기&quot; class=&quot;headerlink&quot; title=&quot;서비스를 사용하여 앱을 외부로 공개하기&quot;&gt;&lt;/a&gt;서비스를 사용하여 앱을 외부로 공개하기&lt;/
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="MSA" scheme="http://KKimSangHeon.github.io/categories/CS/MSA/"/>
    
    
      <category term="kubernetes" scheme="http://KKimSangHeon.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>(K8s) 3. Pods and Nodes</title>
    <link href="http://KKimSangHeon.github.io/2019/04/23/kubernetes3/"/>
    <id>http://KKimSangHeon.github.io/2019/04/23/kubernetes3/</id>
    <published>2019-04-23T12:07:56.000Z</published>
    <updated>2019-04-23T12:14:58.383Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Pods"><a href="#Pods" class="headerlink" title="Pods"></a>Pods</h4><p><a href="https://kubernetes.io/ko/docs/tutorials/kubernetes-basics/explore/explore-intro/" target="_blank" rel="external">https://kubernetes.io/ko/docs/tutorials/kubernetes-basics/explore/explore-intro/</a></p>
<p>디플로이먼트를 만들면 쿠버네티스는 파드를 만들어 어플리케이션 인스턴스를 호스트 해준다. 파드는 쿠버네티스 인스턴스이며 하나 또는 여러 컨테이너(도커나 rkt) 그룹을 추상화한것이다. 컨테이너 뿐만아니라 컨테이너들이 사용하는 리소스도 포함해서 파드라고 한다.</p>
<p>리소스는 다음을 포함한다.</p>
<ul>
<li>볼륨과 같은, 공유 스토리지</li>
<li>클러스터 IP 주소와 같은, 네트워킹</li>
<li>컨테이너 이미지 버전 또는 사용할 특정 포트와 같이, 각 컨테이너가 동작하는 방식에 대한 정보</li>
</ul>
<p>파드는 어플리케이션에 특화된 논리적인 호스트를 모델링한것이고 다른 어플리케이션 컨테이너를 이 안에 담아놓을 수 있으며 비교적 관련있는것들 끼리 모아놓은것이다. 예를 들어 하나의 팟안에다 두개의 컨테이너를 하나에 파드에 넣을 수 있다, 하나의 파드안에 들은 컨테이너들은 IP와 포트를 공유한다. 그래서 항상 같이 존재하며 같이 스케줄링된다.</p>
<p>파드는 atomic unit 이다. 쿠버네티스에서 디플로이먼트를 만들었을때 디플로이먼트는 컨테이너를 갖고있는 파드를 만든다.(컨테이너를 직접 만드는것이 아님)<br>각각의 파드가 특정한 노드에 묶이게 되고 그 노드안에서 살게된다. 노드가 실패하면 동일한 파드를 또다른 클러스터에 있는 다른노드에서 실행한다.<br>즉 파드 단위로 옮겨다닌다.</p>
<h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><p>파드를 실행하는게 노드이며 노드는 쿠버네티스에서 워커머신이다.(쿠버네티스는 마스터, 워커노드가 존재) 노드는 버츄얼 피지컬 머신일 수 도있다. 노드는 마스터에서 관리되면 여러개의 파드를 갖고있으며 쿠버네티스 마스터는 자동으로 어떤 파드를 노드에 올릴지 클러스터링 한다. 마스터의 자동 스케줄링은 가용한 리소스를 고용해서..</p>
<p>모든 쿠버네티스 노드는 최소한 다음을 실행한다</p>
<ul>
<li><p>Kubelet(팀장님)은, 쿠버네티스 마스터(본부장님)와 노드 간 통신을 책임지는 프로세스이며, 하나의 머신 상에서 동작하는 파드와 컨테이너를 관리한다.</p>
</li>
<li><p>(도커, rkt)와 같은 컨테이너 런타임은 레지스트리에서 컨테이너 이미지를 가져와 묶여 있는 것을 풀고 애플리케이션을 동작시키는 책임을 맡는다.</p>
</li>
</ul>
<p>노드 개요<br>노드안에 파드가 여러개 들어갈 수 있고 파드는 각 아이피를 할당받는다. Kubelet이 노드들을 관리</p>
<p>kubectl을 통해서 배포된 앱들의 정보를 가져올 수 있다.<br>kubectl get - 자원을 나열한다<br>kubectl describe - 자원에 대해 상세한 정보를 보여준다.<br>kubectl logs - 파드 내 컨테이너의 로그들을 출력한다<br>kubectl exec - 파드 내 컨테이너에 대한 명령을 실행한다.</p>
<p>언제 애플리케이션이 배포되었으며, 현재 상태가 어떠한지, 그것의 구성은 어떠한지 등을 보기 위해 이러한 명령을 이용할 수 있다.</p>
<p>kubectl get pods<br>를 입력하여 파드가 있나 확인해보고 없으면 빌드를 다시해라</p>
<p>kubectl describe pods<br>를 입력하여 파드에 대한 자세한 정보를 보자.IP, Port, Event<br>결과물은</p>
<p>kubectl describe node<br>를 입력하여 노드 정보를 갖고올 수 있다.</p>
<p>파드가 isolate, private 네트웍에서 동작하기에 kubectl proxy를 써서 사용하였었다.</p>
<p>kubectl proxy<br>를 입력하여 프록시르 띄우자</p>
<p>파드네임과 쿼리를 갖고와 프록시를 해보자.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export POD_NAME=$(kubectl get pods -o go-template --template &apos;&#123;&#123;range .items&#125;&#125;&#123;&#123;.metadata.name&#125;&#125;&#123;&#123;&quot;\n&quot;&#125;&#125;&#123;&#123;end&#125;&#125;&apos;)</div><div class="line">echo Name of the Pod: $POD_NAME</div></pre></td></tr></table></figure></p>
<p>동작하고 있는 애플리케이션 정보를 보고싶다면<br>curl <a href="http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/proxy/" target="_blank" rel="external">http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/proxy/</a><br>를 입력하면 된다.</p>
<p>애플리케이션에서 보통 STDOUT로 내보내는데 그것이 로그가 된다. 이를 쿠버네티스 다음명령오로 가져올 수 있다.<br>kubectl logs $POD_NAME<br>(지금은 컨테이너가 파드안에 하나이기 때문에 지정하지 않아도 된다.)</p>
<p>파드가 동작하고 있으면 그안에 컨테이너에게 명령어를 실행할 수 있는데 다음과 같이 하면된다.<br>kubectl exec $POD_NAME env<br>(컨테이너 이름을 생략할수 있는것은 지금은 파드안에 컨테이너가 하나이기 때문에)</p>
<p>kubectl exec -ti $POD_NAME bash<br>를 입력하여 NodeJS 가 돌고있는 배쉬가 생겼다.<br>이를통해 컨테이너 안에서 명령들을 동작해볼 수 있다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Pods&quot;&gt;&lt;a href=&quot;#Pods&quot; class=&quot;headerlink&quot; title=&quot;Pods&quot;&gt;&lt;/a&gt;Pods&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/ko/docs/tutorials/kubernetes-ba
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="MSA" scheme="http://KKimSangHeon.github.io/categories/CS/MSA/"/>
    
    
      <category term="kubernetes" scheme="http://KKimSangHeon.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>(K8s) 2. 클러스터 생성 및 앱 배포, 마스터 / 노드</title>
    <link href="http://KKimSangHeon.github.io/2019/04/23/kubernetes2/"/>
    <id>http://KKimSangHeon.github.io/2019/04/23/kubernetes2/</id>
    <published>2019-04-23T12:07:53.000Z</published>
    <updated>2019-04-23T12:12:46.994Z</updated>
    
    <content type="html"><![CDATA[<h4 id="클러스터-생성-및-앱-배포"><a href="#클러스터-생성-및-앱-배포" class="headerlink" title="클러스터 생성 및 앱 배포"></a>클러스터 생성 및 앱 배포</h4><p>이번에는 쿠버네티스란 무엇인지, 미니큐브는 무엇인지에 대해 알아보자.</p>
<p><a href="https://kubernetes.io/ko/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/" target="_blank" rel="external">https://kubernetes.io/ko/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/</a> 참고</p>
<h4 id="쿠버네티스-클러스터"><a href="#쿠버네티스-클러스터" class="headerlink" title="쿠버네티스 클러스터"></a>쿠버네티스 클러스터</h4><p>쿠버네티스는 높은 가용성을 클러스터 하는것이다. 즉 하나의 유닛으로 일하는 여러 컴퓨터들의 클러스터를 의미한다. 도커이미지를 배포할 수 있는 클러스터이다.<br>특정 머신한테 배포 설정하는것이 아니라 쿠버네티스한테 배포하라고 던지면 쿠버네티스가 알아서 배포한다.</p>
<p>이를 사용하려면 어플리케이션은 특정 호스트에 묶이지 않은상태로 패키지 되어야 한다.</p>
<p>컨테이나이저 어플리케이션은 예전 배포모델보다 유연하다. (예전모델은 특정 머신에 의존성이 있었다.)</p>
<p>쿠버네티스는 좀더 효율적인 방법으로 클러스터에 어플리케이션을 어떻게 배포하고 스케줄링해야되는지에 대해 자동화함.</p>
<p>쿠버네티스는 오픈소스이며 클러스터 환경에서 쓸 수 있다.</p>
<p>쿠버네티스는 마스터, 노드로 구성된다.<br>(스웜으로 비교하자면 각각 매니저, 워커이다. 스웜에서는 매니저, 워커 둘다 컨테이너를 띄울 수 있었다. 쿠버네티스에서는 노드에서만 컨테이너를 띄울 수 있다.)</p>
<h4 id="쿠버네티스의-마스터-노드"><a href="#쿠버네티스의-마스터-노드" class="headerlink" title="쿠버네티스의 마스터, 노드"></a>쿠버네티스의 마스터, 노드</h4><p>마스터는 어플리케이션 스케줄링, 특정 상태로 만드는일, 스케일링하는일, 새 버전을 차곡차곡 배포해 나가는것을 관리함</p>
<p>노드들은 vm이거나 물리적인 컴퓨터인데 쿠버네티스에서 워커 머신역할을 한다.<br>각각의 노드는 큐블릿을 갖고있는데 이는 노드를 관리하기 위한 에이전트이고 쿠버네티스 매니저와 의사소통한다.</p>
<p>노드는 도커 혹은 rkt와 같은 컨테이너 오퍼레이팅 툴이 필요하다.</p>
<p>쿠버네티스 클러스터는 프로덕션 트래픽을 다룰 수 있는데 이를 위해 최소 3개 이상의 노드를 갖고있어야 한다.</p>
<h4 id="쿠버네티스의-배포과정"><a href="#쿠버네티스의-배포과정" class="headerlink" title="쿠버네티스의 배포과정"></a>쿠버네티스의 배포과정</h4><ul>
<li>애플리케이션을 쿠버네티스에 배포할 때 마스터한테 어플리케이션 클러스터를 실행하라고 한다.</li>
<li>그럼 마스터는 컨테이너들을 클러스터 노드들에게 실행하도록 스케줄링 한다.</li>
<li>그럼 노드는 쿠버네티스 API를 활용해 마스터와 의사소통해서 쿠버네티스 API를 호출할 수 있다.</li>
<li>엔드유저 또한 API를 사용할 수 있다.</li>
</ul>
<h4 id="미니큐브-활용"><a href="#미니큐브-활용" class="headerlink" title="미니큐브 활용"></a>미니큐브 활용</h4><p>쿠버네티스 클러스터는 vm 혹은 물리적 컴퓨터에도 배포할 수 있다. 배포를 위해서는 미니큐브를 사용하라. 이는 쿠버네티스 경량버전이며 vm이 하나만 있다. 로컬머신에 설치할 수 있고 노드가 하나이다.<br>즉 미니큐브는 vm을 만들어주는것이고 이 안에는 노드가 하나만 들어있다.</p>
<h4 id="실습"><a href="#실습" class="headerlink" title="실습"></a>실습</h4><p>미뉴큐브가 미리 설치되어있는 온라인 환경에서 진행한다.</p>
<p>minikube start<br>를 입력하여 미니큐브를 실행하자</p>
<p>kubectl version<br>을 입력하여 버전을 한번 보자.</p>
<p>kubctl cluster-info<br>를 입력해보자.</p>
<p>kubctl get nodes<br>를 입력하여 노드 정보를 보자.<br>아까 말한대로(미니큐브에서는 노드 하나만 들어있는) 하나가 떠있는것을 볼 수 있다.</p>
<h4 id="kubectl을-활용하여-애플리케이션-배포"><a href="#kubectl을-활용하여-애플리케이션-배포" class="headerlink" title="kubectl을 활용하여 애플리케이션 배포"></a>kubectl을 활용하여 애플리케이션 배포</h4><p>동작하는 쿠버네티스가 있으면 컨테나이저된 앱을 배포할 수 있는데 이를 위해 쿠버네티스 배포 설정을 만들어야 한다.<br><code>배포 설정</code>은 쿠버네티스가 어떻게 인스턴스를 만들고 갱신해야하는지에 대한 역할을 한다.</p>
<p>이를 만들면 마스터가 노드에 배포를 한다.</p>
<p>애플리케이션 인스턴스가 한번 만들어지면 쿠버네티스 배포 컨트롤러는 지속적으로 인스턴스를 모니터링 한다. 만약 노드가 다운되거나 삭제되면 다른 노드에 배포하게 함으로서 셀프 힐링 매커니즘을 제공한다.</p>
<p>오케스트레이션이 없던시절에서는 스크립트를 사용했었다. 머신에 문제가 있을때 처리방법은 없었다.  쿠버네티스는 애플리케이션 인스턴스를 만들고 노드에 계속 실행하는것으로서 이전과는 다르다.</p>
<p>kubectl을 통해 배포를 관리하고 만들 수 있다. 이는 쿠버네티스 API를 통해 소통한다(즉 마스터와 소통한다.) 배포를 만들때는 컨테이너 이미지를 적어야되고, 몇개의 어플리케이션을 실행하기 원하는지 적어줘야함.</p>
<p>kubectl get nodes<br>입력하여 노드를 확인</p>
<p>이제 앱 배포를 따라해보자</p>
<p>kubectl run은 배포를 새로만드는것이다.<br>이를 위해 앱 이름과, 위치를 알려줘야 한다. 도커허브에 올라가있는 이미지가 아닌경우 레파지토리 uri까지 줘야한다. 앱을 특정포트에서 실행하고 싶다면 포트 파라미터까지 줘야한다.</p>
<p>kubectl run kubernetes-bootcamp –image=gcr.io/google-samples/kubernetes-bootcamp:v1 –port=8080<br>을 입력하여 배포하자. deployment 를 만듦과 동시에 배포됨.<br>이를 통해 앱을 배포할 적절한 노드를찾았고 스케줄링을 했고 클러스터를 설정했다.</p>
<p>kubectl get deployments<br>를 입력하여 deployments정보를 얻어보자</p>
<p>파드란 쿠버네티스 안에서 도는것인데 private 하고 isolate하다. 기본적으로 쿠버네티스 안에있는 파드, 서비스들 끼리는 볼 수 있지만 쿠버네티스 클러스터 밖에서는 박에서 못본다, kubectl을 사용하여 api endpoint를 사용해서 어플리케이션과 의사소통할 수 있다.</p>
<p>어플리케이션을 쿠버네티스 클러스터에서 노출시키는 방법은 모듈 4에서 본다.</p>
<p>kubectl proxy<br>를 입력하여 프록시 다른탭에서 만들면 클러스터 wide , private network와 의사소통 할 수 있게된다. 프록시를 컨트롤 씨로 종료시킬 수도 있다</p>
<p>디폴리먼트 하나, 파드하나 , 레플리카 셋이 하나 있는것을 웹 프리뷰로 볼 수 있다.</p>
<p>이를 만들면 호스트와 쿠버네티스 클러스트간에 연결된것이고, 프록시를 사용하면 API 를 직접 사용할 수 있다.</p>
<p>여기서 말하는 API는 쿠버네티스 매니저의 API</p>
<p>API서버는 자동으로 endpoint 를 각각의 pod기반으로 만들어준다. 우리는 pod네임을 가져오려면 다음과 같이하면된다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export POD_NAME=$(kubectl get pods -o go-template --template &apos;&#123;&#123;range .items&#125;&#125;&#123;&#123;.metadata.name&#125;&#125;&#123;&#123;&quot;\n&quot;&#125;&#125;&#123;&#123;end&#125;&#125;&apos;)</div><div class="line">echo Name of the Pod: $POD_NAME</div></pre></td></tr></table></figure></p>
<p>curl <a href="http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/proxy/" target="_blank" rel="external">http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/proxy/</a><br>를 입력하여 pod의 api로 라우팅할수있다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;클러스터-생성-및-앱-배포&quot;&gt;&lt;a href=&quot;#클러스터-생성-및-앱-배포&quot; class=&quot;headerlink&quot; title=&quot;클러스터 생성 및 앱 배포&quot;&gt;&lt;/a&gt;클러스터 생성 및 앱 배포&lt;/h4&gt;&lt;p&gt;이번에는 쿠버네티스란 무엇인지, 미니큐브
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="MSA" scheme="http://KKimSangHeon.github.io/categories/CS/MSA/"/>
    
    
      <category term="kubernetes" scheme="http://KKimSangHeon.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>(K8s) 1. 쿠버네티스 개요</title>
    <link href="http://KKimSangHeon.github.io/2019/04/23/kubernetes1/"/>
    <id>http://KKimSangHeon.github.io/2019/04/23/kubernetes1/</id>
    <published>2019-04-23T12:07:19.000Z</published>
    <updated>2019-04-23T12:09:25.350Z</updated>
    
    <content type="html"><![CDATA[<h4 id="쿠버네티스-개요"><a href="#쿠버네티스-개요" class="headerlink" title="쿠버네티스 개요"></a>쿠버네티스 개요</h4><p><a href="https://kubernetes.io/ko/docs/tutorials/kubernetes-basics/" target="_blank" rel="external">https://kubernetes.io/ko/docs/tutorials/kubernetes-basics/</a> 참고</p>
<p>컨테이너화된 애플리케이션들을 관리할 수 있게 해준다.</p>
<ul>
<li>컨테이너화 된 어플리케이션을 클러스터에 배포하는가. 즉 도커이미지로 만든것을 클러스터 배포하는가. 이번엔 스웜이 아닌 쿠버네티스라는 클러스터에 배포하는것.</li>
<li>어떻게 스케일할것인가.</li>
<li>어떻게 새 버전을 배포할것인가</li>
<li>어떻게 디버깅할것인지</li>
</ul>
<p>카타코드를 사용하여 가상머신을 웹에서 실행 할 수 있다.<br>미니큐브는 작게 만든 쿠버네티스이며 아무곳에서나 설치할 수 있다.</p>
<h4 id="쿠버네티스로-할수-있는것"><a href="#쿠버네티스로-할수-있는것" class="headerlink" title="쿠버네티스로 할수 있는것."></a>쿠버네티스로 할수 있는것.</h4><p>모던한 서비스는 24시간 7일동안 무정지를 기대한다. 개발자들도 새버전을 하루에 몇번씩 배포 할 수 있다는것을 기대한다. 즉 배포에 대한 수준이 높아졌다.</p>
<p>커테나이제이션을 통해 위의 높아진 수준에 부응할 수 있다. 쿠버네티스는 컨테나이저된 어플리케이션을 어디서든 실행할 수 있도록 도와준다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;쿠버네티스-개요&quot;&gt;&lt;a href=&quot;#쿠버네티스-개요&quot; class=&quot;headerlink&quot; title=&quot;쿠버네티스 개요&quot;&gt;&lt;/a&gt;쿠버네티스 개요&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/ko/docs/tutoria
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="MSA" scheme="http://KKimSangHeon.github.io/categories/CS/MSA/"/>
    
    
      <category term="kubernetes" scheme="http://KKimSangHeon.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>(Docker) 4. Stacks</title>
    <link href="http://KKimSangHeon.github.io/2019/04/21/docker4/"/>
    <id>http://KKimSangHeon.github.io/2019/04/21/docker4/</id>
    <published>2019-04-21T10:40:15.000Z</published>
    <updated>2019-04-21T10:53:13.101Z</updated>
    
    <content type="html"><![CDATA[<p>docker-machine start $(docker-machine ls -q)<br>를 입력하여 도커머신들을 띄우자</p>
<h4 id="Swarm"><a href="#Swarm" class="headerlink" title="Swarm?"></a>Swarm?</h4><p><code>스웜</code>은 <u>도커를 실행하는 머신들의 클러스터이며 애플리케이션을 배포할 수 있다. 컨테이너를 실행하고 여러머신에서 실행할 수 있다.</u></p>
<h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack?"></a>Stack?</h4><p>이번에는 구조중 가장 맨위에 있는 스택을 다루겠다. <code>스택</code>은 <u>의존성을 공유하고 있는 관련있는 서비스들의 집합이다. 스택은 전체 어플리케이션과 어떻게 조화를 이루어야하는지 짤 수 있다. 복잡한 어플리케이션의 경우 여러개의 스택을 사용할 수 있다.</u></p>
<p>docker-machine ssh myvm1 “docker swarm init –advertise-addr <myvm1의 ip="">“<br>을 입력하여 스웜 매니저로 띄워주자<br>위를 입력하면 docker swarm join –token …..이라고 출력되는데 이는 스웜에 워커를 추가하고 싶으면 이렇게 입력하라는 것이다,</myvm1의></p>
<p>두번째 머신에 아래와 같이 입력하여 워커를 추가하자<br>docker-machine ssh myvm2 “위에서 출력된값 복붙”</p>
<p>이제 머신 두개를 띄웠다.<br>즉 스웜 매니저, 워커로 띄움</p>
<p>여러개의 멀티 머신에서 띄워보자.</p>
<p>yml 파일을 아래와 같이 수정하자.<br>이전것에서 visualizer 라는 서비스가 추가됨.<br>추가된것은 호스트에 있는 파일을 컨테이너 안에다 집어넣어놨다.(dockersamples/visualizer:stable 안에 /var/run/docker.sock:/var/run/docker.sock 파일 넣음)<br><figure class="highlight"><figcaption><span>default</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">version: "3"</div><div class="line">services:</div><div class="line">  web:</div><div class="line">    # replace username/repo:tag with your name and image details</div><div class="line">    image: username/repo:tag</div><div class="line">    deploy:</div><div class="line">      replicas: 5</div><div class="line">      restart_policy:</div><div class="line">        condition: on-failure</div><div class="line">      resources:</div><div class="line">        limits:</div><div class="line">          cpus: "0.1"</div><div class="line">          memory: 50M</div><div class="line">    ports:</div><div class="line">      - "80:80"</div><div class="line">    networks:</div><div class="line">      - webnet</div><div class="line">  visualizer:</div><div class="line">    image: dockersamples/visualizer:stable</div><div class="line">    ports:</div><div class="line">      - "8080:8080"</div><div class="line">    volumes:</div><div class="line">      - "/var/run/docker.sock:/var/run/docker.sock"</div><div class="line">    deploy:</div><div class="line">      placement:</div><div class="line">        constraints: [node.role == manager]</div><div class="line">    networks:</div><div class="line">      - webnet</div><div class="line">networks:</div><div class="line">  webnet:</div><div class="line">  </div></pre></td></tr></table></figure></p>
<p>docker-machine ev myvm1<br>을 입력하여 매니저와 연결하자.</p>
<p> docker stack deploy -c docker-compose.yml getstartedlab<br> 를 입력하자. (이는 myvm1에서 실행하는것이다.)</p>
<p> docker-machine ls를 입력하여 머신의 ip를 입력하고 8080포트로 접속해보자.</p>
<p>아래를 입력하여 레디스를 추가하자<br><figure class="highlight java"><figcaption><span>default</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">redis:</div><div class="line">  image: redis</div><div class="line">  ports:</div><div class="line">    - <span class="string">"6379:6379"</span></div><div class="line">  volumes:</div><div class="line">    - <span class="string">"/home/docker/data:/data"</span></div><div class="line">  deploy:</div><div class="line">    placement:</div><div class="line">      constraints: [node.role == manager]</div><div class="line">  command: redis-server --appendonly yes</div><div class="line">  networks:</div><div class="line">    - webnet</div><div class="line">    </div></pre></td></tr></table></figure></p>
<p> docker stack deploy -c docker-compose.yml getstartedlab<br> 를 입력하여 디플로이 하자.</p>
<p>레디스는 매니저에서만 실행되므로 동일한 파일 시스템을 쓴다.(워커것과 섞이지 않음)<br>영속화를 위해 볼륨파일을 로컬에서 갖다 쓰고 매니저에서만 돌린다.</p>
<p>docker service ls<br>를 입력해서 돌아가고 있는 서비스를 확인해보자.</p>
<p>docker container ls<br>를 입력해서 각 떠있는 컨테이너들을 확인하자.</p>
<h4 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h4><p>배포하는 방법은 CE(Cloud Provider),Enterprise(Cloud provier), Enterprise(On-Premise)가 있다</p>
<p>도커 클라우드를 써서 앱을 관리할 수 있다.<br>외부 클라우드에 배포하는 방법을 알아보자.</p>
<p>도커 클라우드는 스탠다드모드, 스웜모드로 쓸 수 있다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker-machine start $(docker-machine ls -q)&lt;br&gt;를 입력하여 도커머신들을 띄우자&lt;/p&gt;
&lt;h4 id=&quot;Swarm&quot;&gt;&lt;a href=&quot;#Swarm&quot; class=&quot;headerlink&quot; title=&quot;Swarm?&quot;&gt;&lt;
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="MSA" scheme="http://KKimSangHeon.github.io/categories/CS/MSA/"/>
    
    
      <category term="Docker" scheme="http://KKimSangHeon.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>(Docker) 3. Swarms</title>
    <link href="http://KKimSangHeon.github.io/2019/04/17/docker3/"/>
    <id>http://KKimSangHeon.github.io/2019/04/17/docker3/</id>
    <published>2019-04-17T14:06:35.000Z</published>
    <updated>2019-04-21T10:49:24.025Z</updated>
    
    <content type="html"><![CDATA[<h4 id="이전강의에서는-만든-앱을-가져와서-어떻게-컴포즈로-정의해야-하는지-docker-compose-yml파일로-정의했었다"><a href="#이전강의에서는-만든-앱을-가져와서-어떻게-컴포즈로-정의해야-하는지-docker-compose-yml파일로-정의했었다" class="headerlink" title="이전강의에서는 만든 앱을 가져와서 어떻게 컴포즈로 정의해야 하는지 docker-compose.yml파일로 정의했었다."></a>이전강의에서는 만든 앱을 가져와서 어떻게 컴포즈로 정의해야 하는지 docker-compose.yml파일로 정의했었다.</h4><p>이번에는 애플리케이션을 클러스터에 배포한다. 멀티 컨테이너, 멀티 머신, 멀티 어플리케이션을 스웜이라 불리는 도커나이저 클러스터인 스웜에 배포할것이다.</p>
<h3 id="스웜"><a href="#스웜" class="headerlink" title="스웜?"></a>스웜?</h3><p>스웜은 도커로 실행하는 머신들의 그룹이고 클러스터로 조인되어있다. 도커 커맨드를 그대로 사용할 수 있고 클러스터에 있는 <u>스웜매니저</u>에 도커 커맨드를 쓰는것이다. 스웜에 있는 머신들을 물리적, 가상적이어도 되고 스웜에 들어가있는 머신들을 노드라고 한다.</p>
<p><code>스웜매니저</code> : 여러개의 컨테이너를 어떻게 실행할지에 대한 전략이 있다. empiiest node 전략을 사용하면 컨테이너를 띄우가 위해 최소한의 머신을 쓴다.golbal전략은 컨테이너가 하나의 인스턴스를 갖도록 해준다. 즉 모든서버가 컨테이너 하나는 갖도록 해준다. 이는 컴포즈 파일을 통해 스웜매니저에게 알려줘야 한다.<br>스웜에 들어간것은 노드라 하는데 이들에게 명령을 내릴수 있는건 스웜매니저라 하고 이러한 매니저들은 다른 스웜에 워커로 조인할 수 있도록 해준다. 워커는 컨테이너를 돌릴 수 있는 리소스를 제공해주고 다른머신에 작업을 명령할 권한은 없다.</p>
<p>도커는 스웜모드로 변경될 수 있다. 스웜모드로 바꾸면 현재의 머신이 스웜매니저가 되고 명령어는 현재머신에 시키는것이 아니라 스웜매니저에 시킨다.</p>
<p>스웜은 여러개의 물리 혹은 가상의 머신으로 이뤄진다.</p>
<p>docker swarm init으로 스웜모드를 실행시키면 현재 머신이 스웜 매니저가 된다.<br>docker swarm join을 다른 머신에서 사용하면 다른 머신에서 내가 만든 스웜매니저에 조인하게 된다.</p>
<p>docker-machine create –driver virtualbox myvm1<br>docker-machine create –driver virtualbox myvm2<br>을 입력해 도커 머신을 생성하자.</p>
<p>docker-machin ls 를 입력하면 생성된 머신을 확인할 수 있다.</p>
<p>이후<br>docker-machine start myvm1 을 입력하여 머신을 띄우자.</p>
<p>이제 myvm1을 스웜매니저로 만들고 myvm2을 워커로 만들것이다.</p>
<p>첫번째 머신을 매니저로 먼들기위해 도커에 명령을 보내야한다.<br>docker-machine ssh myvm1 “docker swarm init –advertise-addr <myvm1의 ip="">“<br>을 입력하면 docker swarm join –token …..이라고 출력되는데 이는 스웜에 워커를 추가하고 싶으면 이렇게 입력하라는 것이다,<br>두번째 머신에 아래와 같이 입력하여 워커를 추가하자<br>docker-machine ssh myvm2 “위에서 출력된값 복붙”</myvm1의></p>
<p>docker-machine ssh myvm1 “docker”</p>
<p>앱을 스웜클러스터에 배포<br>스웜매니저(myvm1)만 도커 커맨드를 실행할 수 있다는점을 잊지말자</p>
<p>지금까지는 ssh를 활용하여 가상머신에다 가상명령어를 실행했는데 다른방법으로는 docker-machine env <machine> 를 활용하여 쉘에서 도커데몬 vm을 연결하여 활용할 수 있다.<br>이는 로컬에 있는 docker-compose.yml을 쓸 수 있으므로 유용하게 쓸 수 있다.<br>다시설명하자면 이전에는 docker-compose.yml파일을 주고 디플로이를 해야했다. vm에는 해당 파일이 없으므로 vm에 떠있는 스웜매니저와 쉘을 연결하여 쉽게 사용할 수 있다.</machine></p>
<p>docker-machine env myvm1<br>을 입력하여 쉘이랑 머신을 붙이고 맨아래 나오는 커맨드를 입력하자.<br>그럼 myvm1에 들어온것과 같다.</p>
<p>docker node ls<br>를 입력하여 사용할 수 있는데 마치 myvm1이라는 스웜매니저에 들어온것같이 도커 커맨드를 사용할 수 있다.</p>
<p>즉 도커 디플로이를 하면서도 로컬에 있는 파일을 사용할 수 있게되었다! vm으로 파일을 옮기거나 하는 작업들이 필요없어졌다.</p>
<p>docker stack deploy -c docker-compose.yml getstartedlab<br>을 입력하여 배포 가능하다.</p>
<p>그러면 vm들에 컨테이너가 들어가게 된다.</p>
<p>docker stack ps getstartedlab을 입력하여 여러 노드에 깔린것을 확인할 수 있다.</p>
<p>쉘이 다른 머신에 붙도록 하고싶으면 docker-machine env 명령을 활용하면 된다. 하지만 myvm2는 도커 매니저가 아니라 워커이기 때문에 도커 명령어를 실행할 수 없다.</p>
<p>접속해보자. docker-machine ls를 입력하여 ip를 확인하고 들어가보자.</p>
<p>네트웍은 두 노드끼리 공유되고 로드밸런싱된다.</p>
<p>yml 파일의 replicas를 4로 바꾸고<br>docker stack deploy -c docker-compose.yml getstartedlab<br>을 입력하여 업데이트 하고<br>docker stack ps getstartedlab<br>을 입력하여 확인해보자</p>
<p>2개,2개씩 골고루 배치된것을 확인할 수 있다.</p>
<h3 id="cleanup-and-reboot"><a href="#cleanup-and-reboot" class="headerlink" title="cleanup and reboot"></a>cleanup and reboot</h3><p>docker stack rm getstartedlab<br>을 입력하여 도커를 내려보자,</p>
<p>docker-machine ssh myvm2 “docker swarm leave”<br>를 통해 도커 스웜에서 제거하자(워커는 이렇게 제거하면 된다.)</p>
<p>docker-machine ssh myvm1 “docker swarm leave –force”<br>를 통해 도커 스웜에서 제거하자(매니저는 이렇게 force를 넣어 제거하면 된다.)</p>
<p>eval $(docker-machine env -u)<br>env에 붙은 도커 머신 떼어내자.<br>쉘이 도커 머신에서 떨어져 나간다.<br>이제 로컬에 있는 도커 커맨드가 실행된다..</p>
<p>docker-machine stop<br>를 입력하여 도커 머신을 멈추자.</p>
<p><a href="https://www.youtube.com/watch?v=p58k2_HMWRM&amp;list=PLfI752FpVCS84hxOeCyI4SBPUwt4Itd0T&amp;index=2" target="_blank" rel="external">https://www.youtube.com/watch?v=p58k2_HMWRM&amp;list=PLfI752FpVCS84hxOeCyI4SBPUwt4Itd0T&amp;index=2</a><br>의 53분부터 보면 요약 잘해주신다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;이전강의에서는-만든-앱을-가져와서-어떻게-컴포즈로-정의해야-하는지-docker-compose-yml파일로-정의했었다&quot;&gt;&lt;a href=&quot;#이전강의에서는-만든-앱을-가져와서-어떻게-컴포즈로-정의해야-하는지-docker-compose-yml파
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="MSA" scheme="http://KKimSangHeon.github.io/categories/CS/MSA/"/>
    
    
      <category term="Docker" scheme="http://KKimSangHeon.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>(Docker) 2. Docker Services</title>
    <link href="http://KKimSangHeon.github.io/2019/04/17/docker2/"/>
    <id>http://KKimSangHeon.github.io/2019/04/17/docker2/</id>
    <published>2019-04-17T14:05:48.000Z</published>
    <updated>2019-04-21T10:52:29.843Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Docker-Services"><a href="#Docker-Services" class="headerlink" title="Docker Services"></a>Docker Services</h4><p><a href="https://docs.docker.com/get-started" target="_blank" rel="external">https://docs.docker.com/get-started</a> 를 참고하여 진행</p>
<p>Compose를 설치하자. (보통 도커 설치하면 미리 깔린다.)</p>
<p>이번엔 어플리케이션을 로드밸런싱하고 스케일한다. 즉 컨테이너를 여러개 띄운다.</p>
<p>지난번엔 컨테이너를 했고 이번엔 서비스를 배운다.<br>이전에도 얘기했듯이 컨테이너 위에 서비스 서비스 위에 스택이 존재한다.</p>
<h4 id="서비스"><a href="#서비스" class="headerlink" title="서비스?"></a>서비스?</h4><p>분산된 앱에서는 각각을 서비스라 한다. 비디오 어플리케이션에서 데이터를 db에 저장하는 서비스, 비디오를 변환하는 서비스, 프론트엔드를 위한 서비스가 있을것이다. 서비스는 실제환경에서 쓰이는 컨테이너를 의미. 서비스는 오직 하나의 이미지만 실행한다. 서비스는 컨테이너들이 어떤 포트를 사용하고 얼마나 띄워야할지 씨피유는 얼마나 써야할지를 codify한다.</p>
<h4 id="스케일링"><a href="#스케일링" class="headerlink" title="스케일링?"></a>스케일링?</h4><p>서비스를 스케일링하는것은 실행할 컨테이너의 갯수를 변경하는것을 의미한다.<br>또한 더많은 컴퓨터 자원을 서비스에 할당하는것을 의미</p>
<p>이는 도커에서 매우 쉽다.<br>docker-compose.yml 파일을 사용하면 된다.<br>이는 도커컨테이너가 프로덕션 환경에서 어떻게 동작해야 하는지 정의한다.</p>
<h3 id="실습"><a href="#실습" class="headerlink" title="실습"></a>실습</h3><p>docker-compose.yml을 만들고<br><figure class="highlight"><figcaption><span>default</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">version: "3"</div><div class="line">services:</div><div class="line"># 서비스의 이름은 web이다.</div><div class="line">  web:</div><div class="line">    # replace username/repo:tag with your name and image details</div><div class="line">    # 아래의 이미지를 읽어와라</div><div class="line">    image: tkdgjs1501/get-started:part2</div><div class="line">    deploy:</div><div class="line">    #다섯개의 컨테이너를 만든다.</div><div class="line">      replicas: 5</div><div class="line">      resources:</div><div class="line">        limits:</div><div class="line">        #각각의 컨테이너는 10%의 CPU를 사용하고</div><div class="line">          cpus: "0.1"</div><div class="line">        #50M를 할당한다.</div><div class="line">          memory: 50M</div><div class="line">        #무언가 잘못되었을 때 컨테이너를 다시 띄운다.</div><div class="line">      restart_policy:</div><div class="line">        condition: on-failure</div><div class="line">        #컨테이너의 호스트의 4000번 컨테이너의 80번 포트를 연결</div><div class="line">    ports:</div><div class="line">      - "4000:80"</div><div class="line">      #다섯개의 컨테이는 로드밸런스를 통해 호스트의 80번 포트를 공유해야한다. 이를 위해 네트웍을 webnet 사용</div><div class="line">    networks:</div><div class="line">      - webnet</div><div class="line">      # webnet의 정의</div><div class="line">networks:</div><div class="line">  webnet:</div><div class="line">  </div></pre></td></tr></table></figure></p>
<p>  를 붙여넣음</p>
<p>위 파일은 도커한테 어떤 행동을 해야할지 알려주는것.</p>
<p>docker swarm init<br>을 입력하자</p>
<p>docker stack deploy -c docker-compose.yml getstartedlab<br>getstartedlab 라는 앱 네임으로</p>
<p>docker service ls<br>getstartedlab_web라는게 생성되는데 앱네임 뒤에 web이 붙여진것이다.</p>
<p>서비스안에 돌고있는 다섯개의 컨테이너를 태스크라 부르는데 태스크는 각각의 ID가 있고 순차적으로 증가한다.</p>
<p>docker service ps getstartedlab_web<br>를 입력하여 태스크를 나열해 볼 수 있다.<br>task에 대한 정보들</p>
<p><a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a><br>를 접속할 수 있는데 접속할때마다 호스트 네임이 바뀌는것을 확인할 수 있다.<br>호스트네임 == 컨테이너 ID</p>
<p>docker container ls<br>컨테이너에 대한 정보들</p>
<h4 id="스케일링-하기"><a href="#스케일링-하기" class="headerlink" title="스케일링 하기"></a>스케일링 하기</h4><p>docker-compose.yml 파일의 replicas를 수정하여 스케일링 할 수 있다.</p>
<p>replicas: 7<br>로 바꾸고<br>docker stack deploy -c docker-compose.yml getstartedlab<br>를 입력하면 업데이트를 한다.</p>
<p>docker service ps getstartedlab_web<br>를 입력하면 7개로 변경된것을 확인할 수 있다.</p>
<h4 id="정리하기"><a href="#정리하기" class="headerlink" title="정리하기"></a>정리하기</h4><p>docker stack rm getstartedlab<br>docker swarm leave –force</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Docker-Services&quot;&gt;&lt;a href=&quot;#Docker-Services&quot; class=&quot;headerlink&quot; title=&quot;Docker Services&quot;&gt;&lt;/a&gt;Docker Services&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://d
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="MSA" scheme="http://KKimSangHeon.github.io/categories/CS/MSA/"/>
    
    
      <category term="Docker" scheme="http://KKimSangHeon.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>(Docker) 1. Docker Orientation, Container</title>
    <link href="http://KKimSangHeon.github.io/2019/04/17/docker1/"/>
    <id>http://KKimSangHeon.github.io/2019/04/17/docker1/</id>
    <published>2019-04-17T14:04:15.000Z</published>
    <updated>2019-04-21T10:49:21.876Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Docker-Orientation-Container"><a href="#Docker-Orientation-Container" class="headerlink" title="Docker Orientation, Container"></a>Docker Orientation, Container</h3><h4 id="도커란"><a href="#도커란" class="headerlink" title="도커란?"></a>도커란?</h4><p>도커는 개발자, 시스템관리자를 위한 플랫폼이다. 애플리케이션을 컨테이너를 사용해 개발하고 배포할 수 있는 시스템.</p>
<h4 id="컨테이너"><a href="#컨테이너" class="headerlink" title="컨테이너?"></a>컨테이너?</h4><p>컨테이너는 이미지를 실행한 런타임 인스턴스</p>
<h4 id="이미지"><a href="#이미지" class="headerlink" title="이미지?"></a>이미지?</h4><p>이미지는 실행 가능한 패키지.</p>
<p><a href="https://blog.hanumoka.net/2018/04/28/docker-20180428-windows10pro-install-docker/" target="_blank" rel="external">https://blog.hanumoka.net/2018/04/28/docker-20180428-windows10pro-install-docker/</a></p>
<h4 id="도커의-구성"><a href="#도커의-구성" class="headerlink" title="도커의 구성"></a>도커의 구성</h4><p>하이라키의 맨아래는 컨테이너이고 그 위는 서비스 그위에는 스택이 있다,<br><code>스택</code> - 서비스들간 어떻게 동작해야 하는지 (yml 파일의미)<br><code>서비스</code> - 어떻게 컨테이너들이 프로덕트에서 동작하는지 정의 (yml안에서 정의됨 )<br><code>컨테이너</code>- 이미지를 실행한 런타임 인스턴스</p>
<p>과거엔 파이선을 시작할때 환경을 설치하는것 부터 시작했다. 이를 위해 로컬에 완벽한 환경을 세팅했어야헀다.<br>도커는 포터블한 파이썬 이미지를 가져와 빌드를 가능하게 했다. 이는 도커 파일로 정의한다.<br>도커파일은 컨테이너 안에 있는 파일들을 어떻게 구성해야하는지에 정의하는것이다. 네트워크 환경, 디스크 드라이브 등.<br>도커파일을 한번 세팅해서 빌드하면 어디서 하든 동일하게 동작한다.</p>
<p><a href="https://docs.docker.com/get-started" target="_blank" rel="external">https://docs.docker.com/get-started</a> 를 참고하여 진행</p>
<h3 id="도커-이미지-빌드-및-컨테이너-실행"><a href="#도커-이미지-빌드-및-컨테이너-실행" class="headerlink" title="도커 이미지 빌드 및 컨테이너 실행."></a>도커 이미지 빌드 및 컨테이너 실행.</h3><p>한 디렉토리에 app.py , Dockerfile, requirements.txt 를 만들고</p>
<p>docker build –tag=friendlyhello .<br>를 입력하여 이미지를 빌드한다.</p>
<p>docker image ls<br>를 입력하여 확인가능</p>
<p>docker run -p 4000:80 friendlyhello<br>를 입력하여 파이썬은 80번을 통해 서비스하고 로컬에서는 4000을 통해 접속할 수 있게된다.</p>
<p><a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a><br>를 입력하여 접속하여 보자</p>
<p>docker run -d -p 4000:80 friendlyhello<br>detacth모드로 실행하는 것이다.</p>
<p>docker container ls<br>현재 돌아가고 있는 컨테이너를 확인할 수 있다.</p>
<p>docker container stop 1fa4ab2cf395<br>를 입력하여 돌아가고 있는 컨테이너를 중지시킬 수 있다.</p>
<p>docker container ls<br>를 입력하여 돌아가고 있는 컨테이너 확인</p>
<h3 id="이미지-publish"><a href="#이미지-publish" class="headerlink" title="이미지 publish"></a>이미지 publish</h3><p>docker login<br>을 통해 로그인</p>
<p>docker tag friendlyhello tkdgjs1501/get-started:part2<br>(docker tag image username/repository:tag) 형태<br>를 통해 도커 태그를 생성한다.</p>
<p>docker image ls<br>태그된 이미지 확인</p>
<p>docker push tkdgjs1501/get-started:part2<br>(docker push username/repository:tag) 형태<br>를 통해 push 진행</p>
<h3 id="컨테이너-이미지-제거"><a href="#컨테이너-이미지-제거" class="headerlink" title="컨테이너, 이미지 제거."></a>컨테이너, 이미지 제거.</h3><p>docker container rm <hash></hash></p>
<p>docker image rm <image id=""></image></p>
<h3 id="원격에서-레파지토리에서-pull받고-image-run하기"><a href="#원격에서-레파지토리에서-pull받고-image-run하기" class="headerlink" title="원격에서 레파지토리에서 pull받고 image run하기"></a>원격에서 레파지토리에서 pull받고 image run하기</h3><p>docker run -p 4000:80 tkdgjs1501/get-started:part2<br>(docker run -p 4000:80 username/repository:tag) 형태</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Docker-Orientation-Container&quot;&gt;&lt;a href=&quot;#Docker-Orientation-Container&quot; class=&quot;headerlink&quot; title=&quot;Docker Orientation, Container&quot;&gt;&lt;/a&gt;D
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="MSA" scheme="http://KKimSangHeon.github.io/categories/CS/MSA/"/>
    
    
      <category term="Docker" scheme="http://KKimSangHeon.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>규칙 17. 계승을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 계승을 금지하라</title>
    <link href="http://KKimSangHeon.github.io/2019/04/14/effective/"/>
    <id>http://KKimSangHeon.github.io/2019/04/14/effective/</id>
    <published>2019-04-14T07:39:51.000Z</published>
    <updated>2019-04-14T08:59:41.039Z</updated>
    
    <content type="html"><![CDATA[<h4 id="계승을-위한-설계와-문서를-갖춘다는것은-무슨의미일까"><a href="#계승을-위한-설계와-문서를-갖춘다는것은-무슨의미일까" class="headerlink" title="계승을 위한 설계와 문서를 갖춘다는것은 무슨의미일까?"></a>계승을 위한 설계와 문서를 갖춘다는것은 무슨의미일까?</h4><p><u>메서드를 재정의 하면 어떤일이 생기는 지 문서에 잘 남겨야 한다. 즉 재정의 가능 메소드가 내부적으로 어떻게 동작하는지 문서에 남기라는 것이다.</u> public, protected로 선언된 모든 메서드와 생성자에 대해 어떤 재정의 가능 메서드를 어떤 순서로 호출하는지 호출결과는 어떤 영향을 미치는지 남기라는 것이다.<br>예를들어 후면 스레드가 호출할 수도 있고 static 초기화 구문 안에서 호출할 수도 있다. 관습적으로는 재정의 가능 메서드를 어떤식으로 호출하는지 주석 마지막에 명시한다.</p>
<h4 id="좋은-API-문서는-메서드가-하는-일이-무엇인지-명시하지-어떻게-하는지-명시하면-안되지-않아"><a href="#좋은-API-문서는-메서드가-하는-일이-무엇인지-명시하지-어떻게-하는지-명시하면-안되지-않아" class="headerlink" title="좋은 API 문서는 메서드가 하는 일이 무엇인지 명시하지 어떻게 하는지 명시하면 안되지 않아?"></a>좋은 API 문서는 메서드가 하는 일이 무엇인지 명시하지 어떻게 하는지 명시하면 안되지 않아?</h4><p>그렇다. 이는 맞는말이다. 계승이 캡슐화 원칙을 침해하기 때문에 발생하는 결과로 볼 수 있다. 문서만 제대로 썼다고 계승에 적합한 설계가 되지는 않는다. 너무 애쓰지 않고도 효율적인 하위클래스를 정의하기 위해서는 <u>클래스 내부 동작에 개입할 수 있는 훅을 신중하게 고른 protected 메서드 형태로 제공해야 한다.</u></p>
<h4 id="그렇다면-클래스를-설계할-때-protected로-선언할-멤버는-어떻게-정해"><a href="#그렇다면-클래스를-설계할-때-protected로-선언할-멤버는-어떻게-정해" class="headerlink" title="그렇다면 클래스를 설계할 때 protected로 선언할 멤버는 어떻게 정해?"></a>그렇다면 클래스를 설계할 때 protected로 선언할 멤버는 어떻게 정해?</h4><p>딱히 정해진 방법은 없다. 생각하고 신중하게 고른 다음 실제로 하위 클래스를 만들어 보면서 테스트하는것이 최선이다. protected 멤버 개수는 가능한 한 줄여야 하는데 구현 세부사항에 대한 일종의 서약 구실을 하기 떄문이다.<br>즉 계승을 위해 설계할 클래스를 테스트할 유일한 방법은 하위 클래스를 직접 만들어 보는것이다. 만일 중요한 멤버를 protected로 선언하는것을 잊었다면 하위클래스에서 고통스러울 수 있다. 반대로 하위 클래스를 몇개 만들어봐도 사용할 일이 없는 protected 멤버는 private로 선언해야 한다.</p>
<h4 id="그렇게-까지-신중하게-정해야하나"><a href="#그렇게-까지-신중하게-정해야하나" class="headerlink" title="그렇게 까지 신중하게 정해야하나?"></a>그렇게 까지 신중하게 정해야하나?</h4><p>널리 사용될 클래스를 계승에 맞게 설계할 때는 문서에 명시한 내부 호출 패턴 뿐 아니라 메서드와 필드를 protected로 선언하는 과정에 함축된 구현 관련 결정들을 영원히 고수해야 한다는 점을 기억해야 한다. 따라서 다음 릴리스에 성능이나 기능을 개선하기 어려워진다.<br>또한 계승용 문서는 API문서를 어지럽힐 수 있다.</p>
<h4 id="계승을-허용하기-위해-따라야-할-제약사항"><a href="#계승을-허용하기-위해-따라야-할-제약사항" class="headerlink" title="계승을 허용하기 위해 따라야 할 제약사항."></a>계승을 허용하기 위해 따라야 할 제약사항.</h4><p>1.생성자는 직접적이건 간접적이건 재정의 가능 메서드를 호출해서는 안된다.<br><code>이유:</code>상위클래스 생성자는 하위클래스의 생성자보다 먼저 실행되므로, 하위클래스에서 재정의한 메서드는 하위클래스 생성가가 실행되기 전엔 호출될 것이다. 재정의한 메서드가 하위 클래스 생성자가 초기화한 결과에 의존할 경우 그 메서드는 원하는대로 실행되지 않을것이기 떄문에.</p>
<p>2.계승용 클래스가 Cloneable과 Serializable 와 같은 인터페이스를 구현하도록 하는것은 바람직하지 않다.<br><code>이유:</code>클래스를 계승할 프로그래머에게 과도한 책임을 지우기 때문이다. 하지만 하위 클래스 프로그래머가 이들 인터페이스를 선택적으로 구현할 수 있도록 하는 특별한 방법들이 있는데, 이런 조치들에 대해서는 규칙 11, 규칙 74에서 설명한다.<br>만약 계승용 클래스가 Cloneable과 Serializable 와 같은 인터페이스를 구현해야 한다면 clone이나 readObject 메서드 안에서 직접적이건 간접적이건 재정의 가능한 메서드를 호출하지 않도록 주의해야 한다.</p>
<p>3.Serializable 인터페이스를 구현하는 계승용 클래스에 readResolve와 writeReplace 메서드가 있다면 priavte가 아닌 protected로 선언해야 한다.<br><code>이유 :</code>private로 선언해 버리면 하위 클래스는 해당 메서드들을 조용히 무시하게 된다. 이것은 계승을 허용하기 위해 구현 세부사항을 클래스 API의 일부로 포함시켜야 하는 사례 가운데 하나다.</p>
<h4 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h4><p>계승에 맞도록 설계하고 문서화 하지 않은 클래스에 대한 하위클래스는 만들지 말라.<br>가장 쉬운 방법은 클래스를 final로 선언하거나 모든 생성자를 private나 package-private로 선언하고 생성자 대신 public 정적 팩터리 메서드를 추가하는것. 규칙 15에서 설명한 대로 이방법을 사용하면 클래스나 패키지 내부에서는 하위 클래스를 만들어 쓸수도 있으므로 편리하다.<br>계승을 반드시 허용해야 한다고 느껴지면 재정의 가능 메서드는 절대로 호출하지 않도록 하고 그 사실을 반드시 문서에 남겨라.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;계승을-위한-설계와-문서를-갖춘다는것은-무슨의미일까&quot;&gt;&lt;a href=&quot;#계승을-위한-설계와-문서를-갖춘다는것은-무슨의미일까&quot; class=&quot;headerlink&quot; title=&quot;계승을 위한 설계와 문서를 갖춘다는것은 무슨의미일까?&quot;&gt;&lt;/a&gt;계
    
    </summary>
    
      <category term="Language" scheme="http://KKimSangHeon.github.io/categories/Language/"/>
    
      <category term="Java" scheme="http://KKimSangHeon.github.io/categories/Language/Java/"/>
    
    
      <category term="Java" scheme="http://KKimSangHeon.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>규칙 16.계승하는 대신 구성하라</title>
    <link href="http://KKimSangHeon.github.io/2019/04/07/effective1/"/>
    <id>http://KKimSangHeon.github.io/2019/04/07/effective1/</id>
    <published>2019-04-07T03:51:41.000Z</published>
    <updated>2019-04-21T10:52:11.245Z</updated>
    
    <content type="html"><![CDATA[<p>계승은 코드 재사용을 돕는 강력한 도구지만 항상 최선은 아니다. 계승을 적절히 사용하지 못한 소프트웨어는 깨지기 쉽다. 계승은 상위 클래스와 하위 클래스 구현을 같을 프로그래머가 통제하는 단일 패키지 안에서 사용하면 안전하다. 또한 계승을 고려하여 설계되고 그에 맞는 문서를 갖춘 클래스에 사용하는것도 안전하다. 일반적인 객체 생성 가능 클래스라면 해당클래스가 속한 패키지 밖에서 계승을 시도하는 것은 위험하다.</p>
<h4 id="계승은-캡슐화-원칙을-위반한다"><a href="#계승은-캡슐화-원칙을-위반한다" class="headerlink" title="계승은 캡슐화 원칙을 위반한다."></a>계승은 캡슐화 원칙을 위반한다.</h4><p>하위 클래스가 정상 동작하기 위해서는 상의 클래스의 구현에 의존할수밖에 없다. 상위 클래스는 릴리즈가 계속되면서 바뀔 수 있는데 이때 하위클래스는 망가질 수 있다. 또한 하위클래스는 상위클래스의 변화에 발맞춰 진화해야 한다.</p>
<h4 id="HashSet-를-계승하여-요소가-몇개나-추가되었는지에-대한-코드를-작성한다-가정해보자"><a href="#HashSet-를-계승하여-요소가-몇개나-추가되었는지에-대한-코드를-작성한다-가정해보자" class="headerlink" title="HashSet 를 계승하여 요소가 몇개나 추가되었는지에 대한 코드를 작성한다 가정해보자."></a>HashSet<e> 를 계승하여 요소가 몇개나 추가되었는지에 대한 코드를 작성한다 가정해보자.</e></h4><figure class="highlight java"><figcaption><span>default</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentHashSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">	<span class="comment">//요소 삽입횟수</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> addCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">InstrumentedHashSet</span><span class="params">()</span></span>&#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">InstrumentedHashSet</span><span class="params">(<span class="keyword">int</span> initCap, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(initCap, loadFactor);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">		addCount++;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.add(e);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">		addCount+= c.size();</div><div class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.addAll(c);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAddCount</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> addCount;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위의 코드는 제대로 동작하지 않는다. 가령 다음과같은 코드를 실행한다 해보자.<br>InstrumentedHashSet<string> s = new InstrumentedHashSet<string>();<br>s.addAll(Arrays.asList(“A”,”B”,”C”));</string></string></p>
<p><u>addAll은 3을 반환하는것이 아니라 6을 반환한다.</u></p>
<p>HashSet의 addAll 메소드는 add메서드를 통해 구현되어 있기 때문이다. 이는 HashSet 문서에는 나와있지 않은 내용이다.<br><u>하위클래스에서 재정의한 addAll 메서드를 삭제하거나 addAll메서드가 반복하며 add를 호출하도록 하여 해결할 수 있지만 이는 addAll 메소드가 add 위에서 구현되었다는 사실에 의존적이다. 이 또한 add메서드가 private일 경우 사용할 수 없다.</u><br>또한 <u>상위 클래스에 새로운 메서드가 추가될 경우 하위클래스의 구현을 망가뜨릴 수 있다.</u><br>예를들어 특정 리스트에 데이터를 삽입할 때 “ksh” 라는 문자열이 붙도록 하는 메소드가 어느순간 추가되었을 때 삽입 작업만 호출하는 부모클래스의 메소드만을 호출할 때 ..</p>
<p>즉 InstrumentedHashSet 클래스는 깨지기 쉬운 클래스일수밖에 없다.</p>
<h4 id="구성과-전달을-활용해-위의-문제를-해결하는-방법"><a href="#구성과-전달을-활용해-위의-문제를-해결하는-방법" class="headerlink" title="구성과 전달을 활용해 위의 문제를 해결하는 방법"></a>구성과 전달을 활용해 위의 문제를 해결하는 방법</h4><p>기존 클래스를 계승하는 대신, <u>새로운 클래스에 기존 클래스 객체를 참조하는 privae 필드를 하나 두는것</u>. 이를 구성이라 하며 기존클래스가 새 클래스의 일부가 되는것을 말한다.<br>새로운 클래스에 포함된 각각의 메서드는 기존 클래스에 있는 메서드 가운데 필요한 것을 호출해서 결과를 반환하면 된다. 이러한 구현 기법을 <u>전달(forwarding)이라고 하고 전달 기법을 사용해 구현된 메소드를 전달메서드(forwarding method)라고 부른다</u>.<br>구성기법을 통해 구현된 클래스는 기존 클래스의 구현 세부사항에 종속되지 않기 때문에 견고하다.(기존 클래스에 또다른 메서드가 추가되더라도 새로운 클래스에 영향이 없음)</p>
<figure class="highlight java"><figcaption><span>default</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//계승 대신 구성을 사용하는 포장(wrapper) 클래스</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">instrumentedSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">ForadingSet</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> addCount = <span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">InstrumentedSet</span><span class="params">(Set&lt;E&gt; s)</span></span>&#123;</div><div class="line">		<span class="keyword">super</span>(s);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</div><div class="line">		addCount++;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.add(e);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Coolection&lt;? extends E&gt; c)</span></span>&#123;</div><div class="line">		addCount += c.size();</div><div class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.addAll(c);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAddCount</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> addCount;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//재사용 가능한 전달(forwarding) 클래스</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingSet</span>&lt;<span class="title">E</span>&gt; <span class="title">implemetns</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Set&lt;E&gt; s;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ForwardingSet</span><span class="params">(Set&lt;E&gt; s)</span> </span>&#123; <span class="keyword">this</span>.s = s; &#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;s.clear();&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;<span class="keyword">return</span> s.contains(o);&#125;</div><div class="line">	.....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>InstrumentedSet을 이렇게 설계할 수 있는것은 HashSet이 제공해야 할 기능을 규정하는 Set라는 인터페이스가 있기 때문이다. 이런 설계는 안정적일 뿐 아니라 유연성도 아주 높다.<br>이전의 예제중 계승을 한 것에서는 한 클래스에서만 적용이 가능하고 상위 클래스 생성자마다 별도의 생성자를 구현해야 했다.<br>하지만 포장 클래스 기법을 쓰면 어떤 Set 구현도 원하는대로 수정할 수 있고 이미 있는 생성자도 그대로 사용할 수 있다.</p>
<p>포장클래스의 단점이 별로 없으나 callback프레임워크와 함께 사용하기에는 적합하지 않다. 역호출 프레임워크에서 객체는 포장 객체에 대해서는 모르기 때문에, 자기 자신에 대한참조를 전달할 것이다. 따라서 역호출 과정에서 포장 객체는 제외된다. 이 문제는 SELF문제로 알려져있다.</p>
<h4 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h4><p>계승은 강령하지만 캡슐화 원칙을 침해하므로 문제를 발생시킬 소지가 있다. 상위, 하위 클래스가 IS-A 관계일 때만 사용하는것이 좋고 그렇지 않을때는 구성과 전달기법을 사용하는것이 좋다. 포장 클래스 구현에 적당한 인터페이스가 있다면 더욱 그렇다.<br>포장 클래스는 하위 클래스보다 견고할 뿐 아니라 더 강력하다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;계승은 코드 재사용을 돕는 강력한 도구지만 항상 최선은 아니다. 계승을 적절히 사용하지 못한 소프트웨어는 깨지기 쉽다. 계승은 상위 클래스와 하위 클래스 구현을 같을 프로그래머가 통제하는 단일 패키지 안에서 사용하면 안전하다. 또한 계승을 고려하
    
    </summary>
    
      <category term="Language" scheme="http://KKimSangHeon.github.io/categories/Language/"/>
    
      <category term="Java" scheme="http://KKimSangHeon.github.io/categories/Language/Java/"/>
    
    
      <category term="Java" scheme="http://KKimSangHeon.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>규칙 15.변경 가능성을 최소화하라</title>
    <link href="http://KKimSangHeon.github.io/2019/04/06/effective1/"/>
    <id>http://KKimSangHeon.github.io/2019/04/06/effective1/</id>
    <published>2019-04-06T04:39:07.000Z</published>
    <updated>2019-04-21T10:51:51.806Z</updated>
    
    <content type="html"><![CDATA[<p>변경 불가능 클래스는 그 객체를 수정할 수 없는 클래스이다. 객체 내부의 정보는 객체가 생성돌 때 주어진 것이며, 객체가 살아있는 동안 그대로 보존된다.<br>변경불가능 클래스를 만드는 이유는 변경 가능 클래스보다 설계하기 쉽고 구현하기 쉬우며, 사용하기도 쉽다. 오류 가능성도 적고, 더 안전하다.</p>
<h4 id="변경-불가능-클래스가-따라야-할-규칙"><a href="#변경-불가능-클래스가-따라야-할-규칙" class="headerlink" title="변경 불가능 클래스가 따라야 할 규칙"></a>변경 불가능 클래스가 따라야 할 규칙</h4><p>1.객체 상태를 변경하는 메서드를 제공하지 않는다.<br>2.계승(상속)할 수 없도록 한다. 보통 final을 붙인다.<br>3.모든 필드를 final로 선언한다. - 객체에 대한 참조가 동기화 없이 다른 스레드로 전달되어도 안전.<br>4.모든 필드를 private로 선언한다.<br>5.변경 가능 컴포넌트에 대한 독점적 접근권을 보장한다. - 클래스에 포함된 변경가능 객체에 대한 참조를 클라이언트는 획득할 수 없어야한다. 그런 필드는 클라이언트가 제공하는 객체로 초기화해서는 안되고 접근자 또한 그런 필드를 반환해서는 안된다. 따라서 생성자나 접근자, readObject 메서드 안에서는 방어적 복사본을 만들어야 한다.</p>
<h4 id="대부분의-변경-불가능-클래스는-함수형-접근법을-사용한다"><a href="#대부분의-변경-불가능-클래스는-함수형-접근법을-사용한다" class="headerlink" title="대부분의 변경 불가능 클래스는 함수형 접근법을 사용한다."></a>대부분의 변경 불가능 클래스는 함수형 접근법을 사용한다.</h4><p>특정 연산 후 this객체를 변경하는 대신 새로운 객체를 만들어 반환하는것을 함수형 접근법이라 한다. 이르 사용하는 이유는 피연산자를 변경하는 대신 연산을 적용한 결과를 새롭게 만들어 반환하기 때문이다.</p>
<h4 id="함수형-접근법의-장점"><a href="#함수형-접근법의-장점" class="headerlink" title="함수형 접근법의 장점"></a>함수형 접근법의 장점</h4><p>함수형 접근법은 불가능성을 보장하므로 장점이 많다.<br>1.변경불가능 객체는 단순하다. - 생성될 때 부여된 한 가지 상태만 갖는다. 따라서 생성자가 불변식을 확실히 따른다면 해당 객체는 불변식을 절대로 어기지 않게된다.</p>
<h4 id="변경-불가능-객체의-장단점"><a href="#변경-불가능-객체의-장단점" class="headerlink" title="변경 불가능 객체의 장단점"></a>변경 불가능 객체의 장단점</h4><p>1.변경 불가능 객체는 스레드에 안전할수밖에 없다. 어떤 동기화도 필요없으며 여러 스레드가 동시에 사용해도 상태가 훼손될 일이 없다. 그러므로 변경불가능한 객체는 자유롭게 공유할 수 있다.</p>
<p>변경 불가능 클래스는 클라이언트가 기존 객체를 재사용하도록 적극 장려해서 이런 장점을 충분히 살릴 필요가 있다. 그렇게 하는 가장 쉬운 한가지 방법은 자주 사용되는 값을 public static final 상수로 만들어 제공하는 것이다.<br>가령 Complex클래스는(변경 불가능클래스, 필드가 private final이며 생성자를 통해 한번만 초기화되고 setter또한 없다) 아래와 같이 제공될 수 있다.<br>public static final Complex ZERO = new Complex(0,0);</p>
<p>2.자주 사용하는 객체를 캐시하여 이미 있는 객체가 거듭 생성되지 않도록 하는 정적 팩터리를 제공할 수있다. - 기존 객체를 공유하므로 메모리 요구량,GC비용이 줄어든다.<br>3.변경 불가능 객체를 자유롭게 공유할 수 있다는점은 방어적 복사본을 만들 필요가 없다는 뜻이기도 하다. 사실 복사본을 만드는 메소드가 불필요하다.아니 만들면 안된다.(어차피 자기자신과 동일할테니)<br>4.변경 불가능한 객체는 그 내부도 공유할 수 있다. 다른 클래스가 변경불가능 객체내에 있는 배열필드를 사용해도 된다.<br>5.변경 불가능 객체는 다른 객체의 구성요소로도 훌륭하다. - 변경 불가능 객체는 맵의 키나 집합의 원소로 활용하기 좋다. (변하지 않으므로)</p>
<p>단점1.변경 불가능 객체의 유일한 단점은 값마다 별도의 객체를 만들어야 한다는 것이다.<br>이는 단계별로 새로운 객체를 만들고 결국에는 마지막 객체를 제외한 모든 객체를 버리는 연산을 수행해야 하는 경우 성능 문제는 커진다.<br>이를 해결하기 위한 방법은 두가지가 있다.<br>첫 번째 방법은 다단계 연산 가운데 자주 요구되는것을 기본연산으로 제공하는 것이다. (BigInteger클래스는 package-private로 선언된 변경 가능 동료클래스를 사용해 모듈라 멱승같은 연산의 속도를 높인다. 이는 다단계 연산이 어떻게 적용될지 확실하게 예측할 수 있을때 쓴다.)<br>두 번째 방법은 변경 가능한 public 동료 클래스를 제공하는것이다.</p>
<h4 id="변경-불가능-클래스의-두번째-구현방법"><a href="#변경-불가능-클래스의-두번째-구현방법" class="headerlink" title="변경 불가능 클래스의 두번째 구현방법"></a>변경 불가능 클래스의 두번째 구현방법</h4><p>보통은 하위 클래스 정의가 불가능하도록 하기 위해 final로 선언하지만 다른방법도 있다.<br>이는 모든 생성자를 private나 package-private로 선언하고 public 생성자 대신 public 정적 팩터리를 제공하는 것이다.</p>
<h4 id="방어적-복사"><a href="#방어적-복사" class="headerlink" title="방어적 복사?"></a>방어적 복사?</h4><p>BigInteger, BigDecimal은 클래스가 만들어질 당시 변경 불가능 클래스를 final로 선언해야 한다는 사실을 이해하지 못했기 때문에 final로 되어있지 않다. 즉 상속을 할 경우 해당 클래스는 변경이 가능할 수도 있다.<br>만일 신뢰할 수 없는 클라이언트가 전달한 BigInteger나 BigDecimal 인자의 변경 불가능성에 보안이 좌우되는 클래스를 작성할 때는 전달된 인자가 BigInteger나 BigDecimal의 하위 클래스가 아니라 진짜 BigInteger나 BigDecimal 클래스 인지 확인해야 한다. 만일 하위 클래스 객체라면 해당 객체가 변경 가능한 객체일지도 모른다는 가정하에 방어적복사를 시행해야 한다.<br><figure class="highlight java"><figcaption><span>default</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigInteger <span class="title">safeInstace</span><span class="params">(BigInteger val)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(val.getClass() !=BigInteger.class)</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> BigInteger(val.toByteArray());</div><div class="line">	<span class="keyword">return</span> val;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h4><p>변경 가능한 클래스로 만들 타당한 이유가 없다면 변경 불가능 클래스로 만들어라.<br>변경 불가능한 클래스로 만들 수 없다면, 변경 가능성을 최대한 제한하라.</p>
<p>특별한 이유가 없다면 생성자 이외의 public 초기화 메서드나 정적 팩터리 메서드를 제공하지 마라.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;변경 불가능 클래스는 그 객체를 수정할 수 없는 클래스이다. 객체 내부의 정보는 객체가 생성돌 때 주어진 것이며, 객체가 살아있는 동안 그대로 보존된다.&lt;br&gt;변경불가능 클래스를 만드는 이유는 변경 가능 클래스보다 설계하기 쉽고 구현하기 쉬우며,
    
    </summary>
    
      <category term="Language" scheme="http://KKimSangHeon.github.io/categories/Language/"/>
    
      <category term="Java" scheme="http://KKimSangHeon.github.io/categories/Language/Java/"/>
    
    
      <category term="Java" scheme="http://KKimSangHeon.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>규칙 14. public 클래스 안에는 public 필드를 두지 말고 접근자 메서드를 사용하라.</title>
    <link href="http://KKimSangHeon.github.io/2019/04/06/effective/"/>
    <id>http://KKimSangHeon.github.io/2019/04/06/effective/</id>
    <published>2019-04-06T04:37:42.000Z</published>
    <updated>2019-04-21T10:51:44.200Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><figcaption><span>default</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">double</span> x;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">double</span> y;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>데이터 필드를 직접 조작할 수 있어서 캡슐화의 이점을 누릴 수 없다. API를 변경하지 않고서는 내부 표현을 변경할 수 없고, 불변식도 강제할 수 없고, 필드를 사용하는 순간에 어떤 동작이 실행되도록 만들수도 없다. <u>이는 private 필드와 public 접근자 메서드로 바꿔야 한다.</u></p>
<p>public 클래스의 데이터 필드를 공개하게 되면, 그 내부 표현을 변경할 수 없게 된다. 변경하면 이미 작성된 클라이언트 코드를 깨뜨리게 되게 때문이다. 하지만 package-private 클래스나 priavte 중첩 클래스는 데이터 필드를 공개하더라도 잘못이라 말할 수 없다.</p>
<h4 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h4><p>public 클래스는 변경 가능 필드를 외부로 공개하면 안된다. 변경 불가능 필드인 경우에는 외부로 공개하더라도 많이 위험하진 않지만, 그럴 필요가 있을까? package-private나 private로 선언된 중첩 클래스의 필드는 그 변경 가능 여부와는 상관없이 외부로 공개하는것이 바람직할 때도 있다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight java&quot;&gt;&lt;figcaption&gt;&lt;span&gt;default&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div
    
    </summary>
    
      <category term="Language" scheme="http://KKimSangHeon.github.io/categories/Language/"/>
    
      <category term="Java" scheme="http://KKimSangHeon.github.io/categories/Language/Java/"/>
    
    
      <category term="Java" scheme="http://KKimSangHeon.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>규칙 13. 클래스와 멤버의 접근 권한은 최소화하라</title>
    <link href="http://KKimSangHeon.github.io/2019/04/04/effective/"/>
    <id>http://KKimSangHeon.github.io/2019/04/04/effective/</id>
    <published>2019-04-04T13:05:19.000Z</published>
    <updated>2019-04-21T10:51:39.143Z</updated>
    
    <content type="html"><![CDATA[<h4 id="정보은닉-캡슐화"><a href="#정보은닉-캡슐화" class="headerlink" title="정보은닉,캡슐화"></a>정보은닉,캡슐화</h4><p>잘 설계된 모듈과 그렇지 못한 모듈을 구분짓는 중요한 속성은 세부사항을 구현사항을 다른 모듈에 잘 감추느냐의 여부이다. 잘 설계된 모듈은 구현 세부사항을 전부 API 뒤쪽에 감춘다. 모듈들은 이를 API를 통해서만 서로 통신하며 각자 내부정으로 무슨짓을 하는지는 신경쓰지 않는다. 이를 바로 <u>정보은닉 또는 캡슐화</u>라고 알려져있다.. 이는 소프트웨어 설계의 기본적인 원칙 가운데 하나이다,.</p>
<h4 id="정보은닉의-중요성"><a href="#정보은닉의-중요성" class="headerlink" title="정보은닉의 중요성"></a>정보은닉의 중요성</h4><p>모듈사이의 의존성을 낮춰서(decouple), 각자 개별적으로 개발하고, 시험하고, 최적화하고, 이해하고, 변경할 수 있도록 한다는 사실에 기초한다. 이를통해 개발속도 향상, 병렬개발 가능, 유지보수 부담 저하, 모듈에 대한 쉬운이해가능, 다른 모듈에 영향없이 디버깅 진행가능이라는 장점이 있다. 또한 정보은닉 원칙이 좋은 성능을 자동적으로 보장하는 것은 안지만 효과적인 성능 튜닝을 가능하게 한다. 시스템이 완성된 다음에 어떤 모듈이 성능문제를 일으키는지 프로파일링 하기 용이하기 때문에,. 또한 이는 소프트웨어의 재사용 가능성을 높이고 대규모 시스템 과정의 위험성도 낮춘다(전체 시스템은 성공적이지 않더라도, 각각의 모듈은 성공적으로 구현 될수 있기 때문에)</p>
<h4 id="각-클래스와-멤버는-가능한-접근-불가능하도록-만들라"><a href="#각-클래스와-멤버는-가능한-접근-불가능하도록-만들라" class="headerlink" title="각 클래스와 멤버는 가능한 접근 불가능하도록 만들라."></a>각 클래스와 멤버는 가능한 접근 불가능하도록 만들라.</h4><p>개발중인 소프트웨어의 정상적인 동작을 보증하는 한도 내에서 가장 낮은 접근 권한을 설정할것.<br>최 상위 레벨 클래스와 인터페이스에 부여할 수 있는 접근 권한은 package-private(default)와 public 두 가지다.<br>최상위 레벨 클래스나 인터페이스에 public를 붙일 경우 해당 개체는 전역적 개체가 되고 public을 붙이지 않으면 해당패키지 안에서만 유효한 겍체가 된다. 최상위 레벨 클래스나 인터페잇는 가능한 package-private로 선언해야한다. 이를 통해 API 일부가 아니라 구현 세부사항에 속하게 되므로 다음번 릴리스에 클라이언트 코드를 깨뜨릴 걱정없이 자유로이 변경하거나 삭제하거나 대체할 수 있게된다. public으로 선언하게 되면 호환성을 보장하기 위해 해당객체를 계속 지원해야 한다.</p>
<p>package-private(default)로 선언된 최상위 레벨 클래스 혹은 인터페이스를 사용하는 클래스의 사용자 클래스가 하나라면 사용자 클래스의 private 중첩 클래스로 만들것을 고려해 보자. 이를 통해 하나의 클래스만이 해당 클래스의 접근 권한을 갖게된다.</p>
<h4 id="protected는-자제하자"><a href="#protected는-자제하자" class="headerlink" title="protected는 자제하자"></a>protected는 자제하자</h4><p>package-private에서 protected로 변경하면 멤버를 사용할수 있는 범위가 엄청 넓어진다. 이는 해당 protected멤버에 대해 해당클래스의 구현 세부사항에 대한 공개적 약속과도 같으며 공개 API로서 영원히 유지되어야 한다.</p>
<h4 id="원래-메서드의-접근보다-낮은-권한을-설정할-수없다"><a href="#원래-메서드의-접근보다-낮은-권한을-설정할-수없다" class="headerlink" title="원래 메서드의  접근보다 낮은 권한을 설정할 수없다."></a>원래 메서드의  접근보다 낮은 권한을 설정할 수없다.</h4><p>원래 안되는것이다. 넓힐순 있어도 좁힐 수는 없다. 이걸 어기면 컴파일 오류가 발생한다. 따라서 인터페이스를 구현하는 클래스를 만들 때는 인터페이스에 속한 모든 메서드를 해당 클래스의 public메서드로 선언해야 한다. 인터페이스의 모든 멤버는 원래 public이기 때문에</p>
<h4 id="겍체-필드는-절대로-public으로-하지마라"><a href="#겍체-필드는-절대로-public으로-하지마라" class="headerlink" title="겍체 필드는 절대로 public으로 하지마라"></a>겍체 필드는 절대로 public으로 하지마라</h4><p>public로 할 경우 메서드를 통해 값을 변경할 수 있게된다. 따라서 그 필드에 관계된 불변식을 강제할 수 없다. 또한 public 필드를 가진 필드는 다중 스레드에 안전하지도 않다.</p>
<h4 id="static으로-선언된-필드"><a href="#static으로-선언된-필드" class="headerlink" title="static으로 선언된 필드"></a>static으로 선언된 필드</h4><p>특정 상수들을 public static final 필드들로 선언하여 공개할 수 있다. 이런 필드들은 반드시 기본 자료형 값들을 갖거나, 변경 불가능한 객체를 참조해야 한다. 변경 불가능한 객체를 public static final 필드가 가르키게 되면 참조대상 객체가 변경될 경우 끔찍한 결과가 초래된다.</p>
<h4 id="public-static-final-배열필드는-정의하지-마라"><a href="#public-static-final-배열필드는-정의하지-마라" class="headerlink" title="public static final 배열필드는 정의하지 마라."></a>public static final 배열필드는 정의하지 마라.</h4><p>길이가 0이 아닌 배열은 언제나 변경 가능하므로 public static final 배열 필드를 두거나, 이를 반환하는 접근자를 정의하면 안된다. 이를 통해 배열 내용을 변경할 수 있게되므로, 보안에 문재가 생긴다.<br>public static final Thing[] VALUES={ … };     //보안 문제를 초래할 수 있는 코드<br>정의 했을경우 해결법.<br>1.public으로 선언했던 배열은 private로 바꾸고 변경이 불가능한 public 리스트를 하나 만든다,<br><figure class="highlight java"><figcaption><span>default</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] VALUES=&#123; ... &#125;;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] values( )&#123;</div><div class="line">	Collection.unmodifiableList(Arrays.asList(PRIVATE_VALUES));</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>2.어느 자료형으로 반환해야 클라이언트가 성능을 낼 수 있을까를 생각해보자.</p>
<h4 id="요약"><a href="#요약" class="headerlink" title="요약"></a>요약</h4><p>접근권한은 가능한 낮추고 최소한의 public API를 설계하고 다른 모든클래스, 인터페이스, 멤버는 API에서 제외하라. public static final 필드를 제외한 어느 필드도 public 필드로 선언하지 마라. 그리고 public static final 필드가 참조하는 객체는 변경 불가능 객체로 만들어라</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;정보은닉-캡슐화&quot;&gt;&lt;a href=&quot;#정보은닉-캡슐화&quot; class=&quot;headerlink&quot; title=&quot;정보은닉,캡슐화&quot;&gt;&lt;/a&gt;정보은닉,캡슐화&lt;/h4&gt;&lt;p&gt;잘 설계된 모듈과 그렇지 못한 모듈을 구분짓는 중요한 속성은 세부사항을 구현사항을 
    
    </summary>
    
      <category term="Language" scheme="http://KKimSangHeon.github.io/categories/Language/"/>
    
      <category term="Java" scheme="http://KKimSangHeon.github.io/categories/Language/Java/"/>
    
    
      <category term="Java" scheme="http://KKimSangHeon.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>규칙12. Comparable 구현을 고려하라.</title>
    <link href="http://KKimSangHeon.github.io/2019/04/02/effective1/"/>
    <id>http://KKimSangHeon.github.io/2019/04/02/effective1/</id>
    <published>2019-04-02T12:09:29.000Z</published>
    <updated>2019-04-21T10:51:26.853Z</updated>
    
    <content type="html"><![CDATA[<p>compareTo 메서드는 Comparable 인터페이스에 포함된 유일한 메서드이다. Object의 equals 메서드와 비슷하지만 단순한 동치성 검사 이외에 순서 비교가 가능하며 좀더 일반적이다.<br>compareTo 메서드의 일반 규약은 equals와 비슷하다.</p>
<h4 id="규약"><a href="#규약" class="headerlink" title="규약"></a>규약</h4><p>규약 <u>객체와 인자로 주어진 객체를 비교한다. 이 객체의 값이 인자로 주어진 객체보다 작으면 음수, 같으면 0, 크면 양수를 반환한다. </u>인자로 전달된 객체의 자료형이 비교불가능한 자료형일 땐 ClassCastException예외를 던진다.</p>
<p>규약1. compareTo를 구현할 때는 모든 x와 y에 대해 sgn(x.compareTo(y))== -sgn(y.compareTo(x))가 만족되도록 해야 한다. (y.compareTo(x)가 예외를 발생시킨다면 x.compareTo(y)도 그래야하고, 그 역도 성립해야 한다.<br>규약2. compareTo를 구현할 때는 추이성이 만족되도록 해야한다. (x.compareTo(y)&gt;0  &amp;&amp; y.compareTo(z) &gt;0 ) 이면 x.compareTo(z)&gt;0 이어야 한다.<br>규약3. 마지막으로 x.compareTo(y) == 0 이면 sgn(x.compareTo(z)) == sgn(y.compareTo(z))의 관계가 모든z에 대해 성립하도록 해야 한다.<br>sgn함수는 음수일때 -1, 0일때 0, 양수일때 1을 반환</p>
<p>또한 강력히 추천되지만 절대적으로 요구되는것이 아닌 조건으로 (x.compareTo(y) ==0) == (x.equals(y))이다. 일반적으로 <u>Compareble 인터페이스를 구현하면서 이 조건을 만족하지 않는 클래스는 반드시 그 사실을 명시해야 한다.</u></p>
<p><u>equals와 다르게 compareTo는 비교대상이 서로다를 경우 ClassCastException을 던지는것이 허용되어있다</u>. 그리고 통상적으로 반드시 이렇게 동작해야 한다. 규약에서 이를 강제하지는 않지만 1.6 에 속한 어떤 클래스도 이런 비교를 하지 않는다!</p>
<p>compareTo 규약을 준수하지 않는 클래스는 TreeSet, TreeMap, Arrays, Collection 같은 비교연산에 기반한 클래스들을 오작동 시킬 수 있다.</p>
<p><u>즉 compareTo 또한 반사성, 대칭성, 추이성을 만족해야 한다. 따라서 compareTo 규약을 만족하면서 클래스를 계승하여 새로운 값 컴포넌트를 추가할 방법은 없다.</u></p>
<p>Compareble 인터페이스를 구현하는 클래스에 값 요소를 추가하고 싶을 때는 원래 클래스를 계승하여 확장하는 대신, 원래 클래스 객체를 필드로 포함하는 새로운 클래스를 만들고, 원래 클래스의 객체를 반환하는 뷰메서드를 추가한다, 이렇게 하면 원하는대로 compareTo 메서드는 원하는 대로 정의할 수 있다.</p>
<h4 id="Comparable-인터페이스"><a href="#Comparable-인터페이스" class="headerlink" title="Comparable 인터페이스"></a>Comparable 인터페이스</h4><p>Comparable 인터페이스는 자료형을 인자로 받는 제네릭 인터페이스이므로 compareTo 메서드의 인자 자료형은 컴파일 시간에 정적으로 결정된다. 따라서 인자로 받은 객체의 자료형을 검사하거나 형 변환할 필요가 없다. 잘못된 자료형 객체를 인자로 넘길경우 컴파일이 불가능하기 호출이 불가능하다. 또한 null이 인자로들어왔을 때는 NullPointerException 예외를 발생시켜야 한다.<br>또한 객체참조 필드는 compareTo 메서드를 재귀적으로 호출하여 비교한다. 비교할 필드가 Comparable을 구현하지 않고 있거나 좀 특이한 순서 관계를 사용해야 할 경우에는 Comparator를 명시적으로 사용할 수 있다. Comparetor는 직접 작성할 수도 있고 아래의 compareTo 메서드에서처럼 이미 있는 Comparator를 사용할 수도 있다(String.CASE_INSENSITIVE_ORDER.compare(…..)같이).</p>
<h4 id="비교"><a href="#비교" class="headerlink" title="비교"></a>비교</h4><p>클래스에 선언된 중요 필드가 여러개인 경우 비교 순서가 중요하다. 가장 중요한 필드부터 차례로 비교해야 한다.<br>compareTo 메서드의 일반 규약이 반환값의 부호면 명시하고 그 크기에 대해서는 언급하고 있지않다. 이점을 이용해<br><figure class="highlight java"><figcaption><span>default</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(PhoneNumber pn)</span></span>&#123;</div><div class="line">	...</div><div class="line">	<span class="keyword">return</span> a-b;</div><div class="line">&#125;</div></pre></td></tr></table></figure><br>와같이 정의하는게 코드를 단순화하고 보다 빠르게 동작하도록 할 수 있다.<br>하지만 i가 큰 int값이고 j가 큰 음수 int 값일 때 (i-j)는 오버플로 되어 음수가 되어버리므로 부적절한 결과가 나온다.치명적 시스템 문제를 발생시키도 있으므로 주의하자.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;compareTo 메서드는 Comparable 인터페이스에 포함된 유일한 메서드이다. Object의 equals 메서드와 비슷하지만 단순한 동치성 검사 이외에 순서 비교가 가능하며 좀더 일반적이다.&lt;br&gt;compareTo 메서드의 일반 규약은 e
    
    </summary>
    
      <category term="Language" scheme="http://KKimSangHeon.github.io/categories/Language/"/>
    
      <category term="Java" scheme="http://KKimSangHeon.github.io/categories/Language/Java/"/>
    
    
      <category term="Java" scheme="http://KKimSangHeon.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>규칙 11. clone을 재정의할 떄는 신중하라</title>
    <link href="http://KKimSangHeon.github.io/2019/03/31/effective/"/>
    <id>http://KKimSangHeon.github.io/2019/03/31/effective/</id>
    <published>2019-03-31T12:14:01.000Z</published>
    <updated>2019-04-02T12:09:01.959Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Cloneable의-괴상함"><a href="#Cloneable의-괴상함" class="headerlink" title="Cloneable의 괴상함"></a>Cloneable의 괴상함</h4><p>Cloneable은 어떤 객체가 복제를 허용한다는 사실을 알리는 데 쓰려고 고안된 믹스인(mixin) 인터페이스이다. 해당 인터페이스에는 clone 메서드가 없으며 Object의 clone 메서드는 protected로 선언되어 있다.<br>Cloneabledms protected로 선언된 Object의 clone 메소드가 어떻게 동작할지 결정한다. 어떤 클래스가 Clonable을 구현하면 Object의 clone메서드는 해당 객체를 필드 다누이로 복사한 객체를 반환하고 Cloneable을 구현하지 않은 클래스라면 clone 메서드는 CloneNotSupportedException을 던진다.</p>
<h4 id="clone-메서드의-일반-규약"><a href="#clone-메서드의-일반-규약" class="headerlink" title="clone 메서드의 일반 규약"></a>clone 메서드의 일반 규약</h4><p>객체의 복사본을 만들어서 반환한다. 그리고 다음을 따른다.<br>x.clone() != x 의 조건은 참이어야 한다,</p>
<p>x.clone().getClass() == x.getClass()<br>위의 조건은 참이겠지만 반드시 그래야 하는 것은 아니다.</p>
<p>x.clone().equals(x)<br>위의 코드를 실행한 결과도 true가 되겠지만 반드시 그래야하는것은 아니다.</p>
<p>위의 코드를 실행한 결과도 true가 되겠지만 반드시 그래야 하는 것은 아니다.<br>객체를 복사하면 보통 같은 클래스의 새로운 객체가 만들어지는데, 내부 자료 구조까지 복사해야 될 수도 있다. 어떤 생성자도 호출되지 않는다.</p>
<h4 id="규약의-문제점"><a href="#규약의-문제점" class="headerlink" title="규약의 문제점"></a>규약의 문제점</h4><p>어떠한 생성자도 호출되지 않는다는 점은 심하다. 복사본의 내부 객체는 생성자로 만들 수도있다. 클래스가 final로 선언되어 있다면, 생성자로 만든 객체를 반환하도록 clone을 구현할 수도 있다. 하지만 클래스가 final이든 아니든 생성자로 객체를 반환한다면 이 경우 원하는 클래스가 아닐것이다. 즉 clone를 재정의 할 때는 반드시 super.clone을 호출 해 얻은 객체를 반환해야 한다.</p>
<h4 id="제대로된-사용방법"><a href="#제대로된-사용방법" class="headerlink" title="제대로된 사용방법"></a>제대로된 사용방법</h4><p>1.Cloneable인터페이스를 구현하는 클래스는 제대로 동작하는 public clone 메서드를 제공해야 하고 이를 위해서는 상위클래스들이 제대로된 public 또는 protected clone 메서드를 제공해야 한다.</p>
<p>2.clone() 메소드의 반환형은 적절한 형태로 반환하여 라이브러리가 할 수 있는 일을 클라이언트에게 미루지 말자. 즉 라이브러리가 형변환을 하고 클라이언트는 변환하여 사용하지 않도록 하자.</p>
<p>3.복제할 객체가 변경가능 객체에 대한 참조 필드를 가지고 있을경우 deepCopy를 통해 극복하도록 하자.(ex 링크드 리스트의 배열!) 이방법이 싫다면 super.clone 호출 결과로 반환된 객체의 모든 필드를 초기상태로 되돌려 놓은 다음에 상위레벨 메서드를 호출해서 객체상태를 다시 만드는것이다.</p>
<ol>
<li>다중스레드에 안전해야 하는 thread-safe 클래스를 Cloneable로 만들려면, clone 메서드에도 동기화 메커니즘을 적용해야 한다. Object.clone 메서드에는 동기화 메커니즘이 적용되어 있지 않으므로 설사 Object.clone 이 대체로 만족스럽다고 하더라도 super.clone()을 호출하는 동기화된 clone 메서드를 만들어야 할 것이다.</li>
</ol>
<h4 id="clone의-주의사항"><a href="#clone의-주의사항" class="headerlink" title="clone의 주의사항"></a>clone의 주의사항</h4><p>1.clone 메서드는 또 다른 형태의 생성자이다. 원래 객체를 손상시키지 않아야 하며 복사본의 불변식도 만족시켜야 한다.<br>2.clone 메서드는 복사본의 비-final 메서드, 즉 <u>재정의 가능 메서드를 복사 도중에 호출해서는 안된다</u>. 만일 하위 클래스에서 재정의한 메서드를 clone 안에서 호출하면 해당 메서드는 복사본의 상태가 완성되기 전에 호출될 것이며 복사본의 상태를 망가뜨릴것이다.</p>
<h4 id="정리하자면"><a href="#정리하자면" class="headerlink" title="정리하자면"></a>정리하자면</h4><p>계승을 위해 설계된 클래스에 clone을 재정의 할 때 Object.clone을 그대로 흉내내야 한다. protected로 선언하고, CloneNotSupportedException 예외를 던지고, Cloneable 인터페이스는 구현하지 않아야한다. 그래야 Object 클래스를 직접 계승한 클래스가 그렇듯, 하위 클래스가 Cloneable 구현 여부를 마음대로 정할 수 있다.</p>
<p>또한 Cloneable을 구현하는 모든 클래스는 반환값 자료형이 자기 자신은 public clone 메서드를 재정의 해야한다. 또한 처음에 super.clone을 호출해야한다. 그렇게 해서 만들어진 객체를 두고 수정해야 하는 필드를 수정한다.(deepCopy 등을 활용)</p>
<h4 id="반전의-결론"><a href="#반전의-결론" class="headerlink" title="반전의 결론"></a>반전의 결론</h4><p>객체복제를 지원하는 좋은 방법은, 복사 생성자나 복사 팩터리를 제공하는 것이다. 복사 생성자는 단순히 같은 클래스의 객체 하나를 인자로 받는 생성자이다. 복사 팩터리 또한 같은 클래스의 객체 하나를 인자로 받는것이다.<br>이는 Cloneable/clone보다 좋은점이 많다. 언어 외적 객체생성 수단에 의존하지 않으며 , 규약에 충실할 것을 요구하지도 않으며, final 필드 용법과 충돌하지도 않으며, 불필요한 예외를 검사하도록 요구하지도 않으며 형 변환도 필요없다.<br>또한 해당 메서드가 정의된 클래스가 구현하는 인터페이스를 인자로 받을 수 있다.<br>즉 Cloneable은 단점이 너무많다.. 쓰는것을 지양하자.. 배열의 clone메소드는 어쩔수 없이 쓰는경우가 있다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Cloneable의-괴상함&quot;&gt;&lt;a href=&quot;#Cloneable의-괴상함&quot; class=&quot;headerlink&quot; title=&quot;Cloneable의 괴상함&quot;&gt;&lt;/a&gt;Cloneable의 괴상함&lt;/h4&gt;&lt;p&gt;Cloneable은 어떤 객체가 복제를 
    
    </summary>
    
      <category term="Language" scheme="http://KKimSangHeon.github.io/categories/Language/"/>
    
      <category term="Java" scheme="http://KKimSangHeon.github.io/categories/Language/Java/"/>
    
    
      <category term="Java" scheme="http://KKimSangHeon.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
