<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kim Sang Heon&#39;s Bolg</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://KKimSangHeon.github.io/"/>
  <updated>2019-06-06T08:17:59.664Z</updated>
  <id>http://KKimSangHeon.github.io/</id>
  
  <author>
    <name>Kim Sang Heon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kube13</title>
    <link href="http://KKimSangHeon.github.io/2019/06/06/kube13/"/>
    <id>http://KKimSangHeon.github.io/2019/06/06/kube13/</id>
    <published>2019-06-06T08:17:59.000Z</published>
    <updated>2019-06-06T08:17:59.664Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>12. 사용자 관리와 RBAC(role-based access control)</title>
    <link href="http://KKimSangHeon.github.io/2019/06/06/kube12/"/>
    <id>http://KKimSangHeon.github.io/2019/06/06/kube12/</id>
    <published>2019-06-06T08:17:55.000Z</published>
    <updated>2019-06-06T08:27:54.525Z</updated>
    
    <content type="html"><![CDATA[<p>쿠버네티스 사용자마다 권한을 제어하는 것은 쿠버네티스 운영하는데 있어 보안을 확보하는 기본적인 방법이다.</p>
<p>쿠버네티스 사용자는 두 가지 개념으로 나뉜다.<br><code>일반사용자</code>: 클러스터 외부에서 쿠버네티스를 조작하는 사용자로 다양한 방법으로 인증을 거친다. 개발자 및 운영 실무자가 쿠버네티스를 조작하기 위해 사용하며 쿠버네티스 클러스터 외부로부터 들어오는 접근을 관리하기 위한 사용자이다.<br>배포와 관련된 서비스나 디플로이먼트의 접근 권한을 일부 사용자에게만 허용하거나 파드의 로그 열람 권한을 다른 일반 사용자에게도 허용하는 등의 정책을 일반 사용자 권한 부여로 실현할 수있다.</p>
<p><code>서비스 계정</code>: 쿠버네티스 내부적으로 관리되며 파드가 쿠버네티스 API를 다룰 때 사용하는 사용자.(kubectl또한 쿠버네티스 API와 통신해 작동함) 주어진 권한에 따라 쿠버네티스 리소스(파드, 디플로이먼트 등)를 다룰 수 있다.<br>서비스 계정은 어플리케이션을 통해 쿠버네티스 조작을 통제할 수 있다는 점이 장점이다. 클러스터 안에서 봇을 동작시키는 파드에 권한을 부여해두고, 이 봇으로 기존 디플로이먼트를 업데이트하거나 레플리카 수를 조절하는 식으로 활용할 수 있다.</p>
<p>서비스 계정 및 일반 사용자의 권한은 RBAC(role-based access control) 라는 메커니즘을 통해 제어된다. RBAC는 롤에 따라 리소스에 대한 권한을 제어하는 기능이자 개념이다.</p>
<p>Role, Cluster Role은 접근가능한것에 대한 범위이고 binding은 롤을 주는것을 의미한다고 판단.</p>
<p><code>롤</code> : 각 쿠버네티스 API의 사용권한을 정의. 네임스페이스 안에서만 유효<br><code>롤바인딩</code> : 일반 사용자 및 그룹/서비스 계정과 롤을 연결<br><code>클러스터롤</code>: 각 쿠버네티스 API의 사용 권한을 정의. 클러스터 전체에서 유효<br><code>클러스터롤바인딩</code>: 일반사용자 및 그룹/서비스 계정과 클러스터롤을 연결</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;쿠버네티스 사용자마다 권한을 제어하는 것은 쿠버네티스 운영하는데 있어 보안을 확보하는 기본적인 방법이다.&lt;/p&gt;
&lt;p&gt;쿠버네티스 사용자는 두 가지 개념으로 나뉜다.&lt;br&gt;&lt;code&gt;일반사용자&lt;/code&gt;: 클러스터 외부에서 쿠버네티스를 조작하는 
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="MSA" scheme="http://KKimSangHeon.github.io/categories/CS/MSA/"/>
    
    
      <category term="kubernetes" scheme="http://KKimSangHeon.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>11. 쿠버네티스 실전편(잡, 크론잡, 시크릿)</title>
    <link href="http://KKimSangHeon.github.io/2019/06/02/kube11/"/>
    <id>http://KKimSangHeon.github.io/2019/06/02/kube11/</id>
    <published>2019-06-02T08:11:52.000Z</published>
    <updated>2019-06-06T08:27:16.197Z</updated>
    
    <content type="html"><![CDATA[<p>파드, 레플리카세트, 디플로이먼트, 서비스, 인그레스는 데몬으로 동작하는 서버 어플리케이션을 구축할 때 사용되는 기본 리소스이다<br>쿠버네티스는 데몬으로 동작하는 서버 어플리케이션 외에도 배치 서버등 다양한 형태의 어플리케이션을 구축할 수 있다.</p>
<h3 id="잡"><a href="#잡" class="headerlink" title="잡"></a>잡</h3><p>잡은 하나 이상의 파드를 생성해 지정된 수의 파드가 정상 종료될 때까지 이를 관리하는 리소스다.<br>잡이 생성한 파드는 정상 종료된 후에도 삭제되지 않고 그대로 남아있기 때문에 작업이 종료된 후에 파드의 로그나 실행 결과를 분석할 수 있다. 그러므로 배치작업 위추의 어플리케이션에 적합하다.<br>잡은 파드 여러개를 병렬로 실행하는 방법으로 쉽게 스케일 아웃이 가능하다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">apiVersion: batch/v1</div><div class="line">kind: Job</div><div class="line">metadata:</div><div class="line">  name: pingpong</div><div class="line">  labels:</div><div class="line">    app: pingpong</div><div class="line">spec:</div><div class="line">  parallelism: 3    # 동시에 실행하는 파드의 수를 지정하는 속성. 파드를 병렬로 실행해야할 때 편리</div><div class="line">  template:</div><div class="line">    metadata:</div><div class="line">      labels:</div><div class="line">        app: pingpong</div><div class="line">    spec:</div><div class="line">      containers:</div><div class="line">      - name: pingpong</div><div class="line">        image: gihyodocker/alpine:bash</div><div class="line">        command: [&quot;/bin/sh&quot;]</div><div class="line">        args:</div><div class="line">          - &quot;-c&quot;</div><div class="line">          - |</div><div class="line">            echo [`date`] ping!</div><div class="line">            sleep 10</div><div class="line">            echo [`date`] pong!</div><div class="line">      restartPolicy: Never</div></pre></td></tr></table></figure>
<p>위의 코드를 yaml파일로 만들고 아래 명령어를 통해 확인해보자.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ kubectl apply -f test.yaml</div><div class="line">$ kubectl get pod -l app=pingpong --show-all</div></pre></td></tr></table></figure></p>
<p>parallelism와 replicas의 차이점은 무엇일까?<br>replicas가 3이면 동일한 파드를 3개 만들라는 것이고, parallelism이 이면 동시에 3개의 파드를 실행하는것인데… 확인해보니 parallelism도 파드를 3개 만들긴함.</p>
<p>잡 리소스는 restartPolicy 속성을 Never, OnFailure중 하나를 설정해야 한다.</p>
<h3 id="크론잡"><a href="#크론잡" class="headerlink" title="크론잡"></a>크론잡</h3><p>잡 리소스는 파드가 단 한번만 실행되는데 반해 크론잡 리소스는 스케줄을 지정해 정기적으로 파드를 실행할 수 있다. 즉 정기적으로 파드를 실행할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">apiVersion: batch/v1beta1</div><div class="line">kind: CronJob</div><div class="line">metadata:</div><div class="line">  name: pingpong</div><div class="line">spec:</div><div class="line">  schedule: &quot;*/1 * * * *&quot;</div><div class="line">  jobTemplate:</div><div class="line">    spec:</div><div class="line">      template:</div><div class="line">        metadata:</div><div class="line">          labels:</div><div class="line">            app: pingpong</div><div class="line">        spec:</div><div class="line">          containers:</div><div class="line">          - name: pingpong</div><div class="line">            image: gihyodocker/alpine:bash</div><div class="line">            command: [&quot;/bin/sh&quot;]</div><div class="line">            args:</div><div class="line">              - &quot;-c&quot;</div><div class="line">              - |</div><div class="line">                echo [`date`] ping!</div><div class="line">                sleep 10</div><div class="line">                echo [`date`] pong!</div><div class="line">          restartPolicy: OnFailure</div></pre></td></tr></table></figure></p>
<p>spec.schedule속성에 Cron과 같은 포맷으로 파드를 실행할 스케줄을 정의한다. 또한 spec.jobTemplate 아래에 잡 리소스와 마찬가지로 파드 정의가 들어가면 된다.<br>보통의 경우 리눅스 crontab으로 스케줄에 맞춰 스크립트를 실행하는게 대부분이었따. 하지만 크론잡 리소스를 이용하면 이 모든것을 컨테이너로 해결할 수 있다.</p>
<h3 id="시크릿"><a href="#시크릿" class="headerlink" title="시크릿"></a>시크릿</h3><p>쿠버네티스의 시크릿 리소스를 사용하면 기밀정보 문자열을 Base 인코딩으로 만들 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: Secret</div><div class="line">metadata:</div><div class="line">  name: nginx-secret</div><div class="line">type: Opaque</div><div class="line">data:</div><div class="line">  .htpasswd: eW91cl91c2VybmFtZTpyejc5SXpTalplaWZvCg==</div></pre></td></tr></table></figure>
<p>위 코드를 활용해 아래에 적용가능하다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: Service</div><div class="line">metadata:</div><div class="line">  name: basic-auth</div><div class="line">spec:</div><div class="line">  type: NodePort</div><div class="line">  selector:</div><div class="line">    app: basic-auth</div><div class="line">  ports:</div><div class="line">  - protocol: TCP</div><div class="line">    port: 80</div><div class="line">    targetPort: http</div><div class="line">    nodePort: 30060</div><div class="line"></div><div class="line">---</div><div class="line">apiVersion: apps/v1</div><div class="line">kind: Deployment</div><div class="line">metadata:</div><div class="line">  name: basic-auth</div><div class="line">  labels:</div><div class="line">    app: basic-auth</div><div class="line">spec:</div><div class="line">  replicas: 1</div><div class="line">  selector:</div><div class="line">    matchLabels:</div><div class="line">      app: basic-auth</div><div class="line">  template:</div><div class="line">    metadata:</div><div class="line">      labels:</div><div class="line">        app: basic-auth</div><div class="line">    spec:</div><div class="line">      containers:</div><div class="line">      - name: nginx</div><div class="line">        image: &quot;gihyodocker/nginx:latest&quot;</div><div class="line">        imagePullPolicy: Always</div><div class="line">        ports:</div><div class="line">          - name: http</div><div class="line">            containerPort: 80</div><div class="line">        env:</div><div class="line">          - name: BACKEND_HOST</div><div class="line">            value: &quot;localhost:8080&quot;</div><div class="line">          - name: BASIC_AUTH_FILE</div><div class="line">            value: &quot;/etc/nginx/secret/.htpasswd&quot;    </div><div class="line">        volumeMounts:</div><div class="line">          - mountPath: /etc/nginx/secret    # 이 경로에 .htpasswd가 생성된다.</div><div class="line">            name: nginx-secret</div><div class="line">            readOnly: true</div><div class="line">      - name: echo</div><div class="line">        image: &quot;gihyodocker/echo:latest&quot;</div><div class="line">        imagePullPolicy: Always</div><div class="line">        ports:</div><div class="line">          - containerPort: 8080</div><div class="line">        env:</div><div class="line">          - name: HTTP_PORT</div><div class="line">            value: &quot;8080&quot;</div><div class="line">      volumes:</div><div class="line">      - name: nginx-secret</div><div class="line">        secret:</div><div class="line">          secretName: nginx-secret</div></pre></td></tr></table></figure>
<p>인증정보를 환경 변수로 관리하는 기법또한 존재한다. 이는 259p를 참고하자.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;파드, 레플리카세트, 디플로이먼트, 서비스, 인그레스는 데몬으로 동작하는 서버 어플리케이션을 구축할 때 사용되는 기본 리소스이다&lt;br&gt;쿠버네티스는 데몬으로 동작하는 서버 어플리케이션 외에도 배치 서버등 다양한 형태의 어플리케이션을 구축할 수 있다
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="MSA" scheme="http://KKimSangHeon.github.io/categories/CS/MSA/"/>
    
    
      <category term="kubernetes" scheme="http://KKimSangHeon.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>10. 쿠버네티스의 스토리지</title>
    <link href="http://KKimSangHeon.github.io/2019/06/01/kube10/"/>
    <id>http://KKimSangHeon.github.io/2019/06/01/kube10/</id>
    <published>2019-06-01T04:17:08.000Z</published>
    <updated>2019-06-02T08:11:02.042Z</updated>
    
    <content type="html"><![CDATA[<p>마스터 슬레이브 형태로 MySQL을 구성하자.</p>
<h3 id="쿠버네티스의-스토리지"><a href="#쿠버네티스의-스토리지" class="headerlink" title="쿠버네티스의 스토리지"></a>쿠버네티스의 스토리지</h3><p>쿠버네티스에서는 호스트에서 분리할 수 있는 외부 스토리지를 볼륨으로 사용할 수 있다. 파드가 다른 호스트로 재배치 되어도 외부 스토리지 형태의 볼륨은 새로 배치된 호스트에 자동으로 할당된다. 그러므로 호스트와 데이터 볼륨의 결합이 느슨해지고 외부 스토리지를 사용하므로 퍼시스턴스 데이터를 다루는 애플리케이션을 컨테이너로 운영하기가 쉽다.<br>쿠버네티스에서 관련 리소스는 다음의 요소들이 있다.</p>
<ul>
<li>퍼시스턴트볼륨</li>
<li>퍼시스턴트볼륨클레임</li>
<li>스토리지클래스</li>
<li>스테이트풀세트</li>
</ul>
<h3 id="퍼시스턴트볼륨과-퍼시트턴트볼륨클레임"><a href="#퍼시스턴트볼륨과-퍼시트턴트볼륨클레임" class="headerlink" title="퍼시스턴트볼륨과 퍼시트턴트볼륨클레임"></a>퍼시스턴트볼륨과 퍼시트턴트볼륨클레임</h3><p>퍼시스턴트볼륨은 스토리지 자체이며 퍼시스턴트볼륨클레임은 추상화된 논리 리소스로 퍼시스턴볼륨과 달리 용량을 필요한 만큼 동적으로 확보 할 수 있는것이다.<br>퍼시스턴트볼륨클레임은 클러스터가 구축된 플랫폼을 지원하는 퍼시스턴스 볼륨을 생성하기 위해 사용된다.</p>
<p>다음은 퍼시스턴스볼륨클레임 리소스의 매니페스트 파일이다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: PersitentVolumeClaim</div><div class="line">metadata:</div><div class="line">  name: pvc-example</div><div class="line">spec:</div><div class="line">  accessModes:</div><div class="line">    - ReadWriteOnce</div><div class="line">  storageClassName: ssd</div><div class="line">  resource:</div><div class="line">    requests:</div><div class="line">      storage: 4Gi</div></pre></td></tr></table></figure></p>
<p>위의 <code>accessModes</code>는 파드가 스토리지에 접근한는 방식을 지정한다. ReadWriteOnce 는 마운트 될 수 있는 노드를 하나로 제한한다는 의미이다. 이 외에도 ReadOnlyMany 혹은 ReadWriteMany가 있다. 이들은 이러한 제약이 없으며 플랫폼에 따라 사용할 수 없는 경우가 있으므로 주의하<br><code>storageClassName</code>는 StorageClass리소스의 종류 즉 어떤 스토리지를 사용할지를 정의한다.</p>
<h3 id="스토리지클래스-StorageClass"><a href="#스토리지클래스-StorageClass" class="headerlink" title="스토리지클래스(StorageClass)"></a>스토리지클래스(StorageClass)</h3><p>스토리지클래스는 퍼시스턴트볼륨으로 확보한 스토리지 종류를 정의하는 리소스다. 앞에서의 storageClassName속성값의 실체가 이것이다. GCP의 경우 storageClassName의 종류는 표준,SSD가 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">kind: StorageClass</div><div class="line">apiVersion: storage.k8s.io/v1</div><div class="line">metadata:</div><div class="line">  name: ssd</div><div class="line">  annotations:</div><div class="line">    storageclass.kubernetes.io/is-default-class: &quot;false&quot;</div><div class="line">  labels:</div><div class="line">    kubernetes.io/cluster-service: &quot;true&quot;</div><div class="line">provisioner: kubernetes.io/gce-pd</div><div class="line">parameters:</div><div class="line">  type: pd-ssd</div></pre></td></tr></table></figure>
<p>SSD 스토리지를 사용하도록 스토리지 클래스의  name 속성을 ssd로 하고 provisioner는 GCP 의 퍼시스턴스 스토리지인 GCEPersistentDisk에 해당하는 gcd-pd로 지정한다. 그리고 파라미터의 type 속성값을 pd-ssd로 지정한다.</p>
<h3 id="스테이트풀세트-StatefulSet"><a href="#스테이트풀세트-StatefulSet" class="headerlink" title="스테이트풀세트(StatefulSet)"></a>스테이트풀세트(StatefulSet)</h3><p>디플로이먼트는 함께 포함된 파드 정의를 따라 파드를 생성하는 리소스로 하나만 있으면 되는 파드 혹은 퍼시스턴스 데이터를 갖지않는 즉 상태가 없는(stateless) 어플리케이션을 배포하는데 적합하다.<br><u>이에 비해 스테이트풀 세트는 데이터 스토어처럼 데이터를 계속 유지하는 상태가 있는 애플리케이션을 관리하는데 적합한 리소스다.</u></p>
<p>디플로이먼트에서 생성한 파드는 무작위로 생성된 식별자가 부여된다. <u>스테이트풀세트는 pod-1, pod-2, pod-2와 같이 일련번호가 붙는 유일한 식별자를 붙여 파드를 생성한다.</u><br>이 식별자는 파드를 재생성해도 유지되며, 스케일링 할 때도 식별자의 일련번호가 계속 이어진다.</p>
<p>파드가 재생성되어도 스토리지가 계속 같은 파드에 연결되어 파드의 데이터를 그대로 복원할 수 있다.</p>
<p>/</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;마스터 슬레이브 형태로 MySQL을 구성하자.&lt;/p&gt;
&lt;h3 id=&quot;쿠버네티스의-스토리지&quot;&gt;&lt;a href=&quot;#쿠버네티스의-스토리지&quot; class=&quot;headerlink&quot; title=&quot;쿠버네티스의 스토리지&quot;&gt;&lt;/a&gt;쿠버네티스의 스토리지&lt;/h3&gt;&lt;p&gt;쿠
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="MSA" scheme="http://KKimSangHeon.github.io/categories/CS/MSA/"/>
    
    
      <category term="kubernetes" scheme="http://KKimSangHeon.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>9. GCP 를 활용한 실습환경 구축</title>
    <link href="http://KKimSangHeon.github.io/2019/06/01/kube9/"/>
    <id>http://KKimSangHeon.github.io/2019/06/01/kube9/</id>
    <published>2019-06-01T04:15:34.000Z</published>
    <updated>2019-06-06T08:26:31.099Z</updated>
    
    <content type="html"><![CDATA[<p>온프레미스 환경 또는 퍼블릭 클라우드에서 쿠버네티스를 실제로 사용해 보자.<br>클라우드에서 Google Kubernetes Engine을이용하거나 온프레미스 환경에서 Kuberspray를 이용해 클러스터를 구축하자</p>
<p>GCP를 생성하고 구글 클라우드 SDK를 설치하자</p>
<p>아래의 링크에서 GCP 설치<br><a href="https://cloud.google.com/sdk/docs/quickstart-windows?hl=ko" target="_blank" rel="external">https://cloud.google.com/sdk/docs/quickstart-windows?hl=ko</a></p>
<p>환경변수에 다음 추가<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\Users\SangHeon\AppData\Local\Google\Cloud SDK\google-cloud-sdk\bin</div></pre></td></tr></table></figure></p>
<p>gcloud 버전 업데이트<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gcloud components update</div></pre></td></tr></table></figure></p>
<p>아래 입력 후 계정입력<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gcloud auth login</div></pre></td></tr></table></figure></p>
<p>아래를 입력하여 대상 프로젝트 ID 선택<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gcloud config set project xxxx</div></pre></td></tr></table></figure></p>
<p>아래 입력 하여 리전 설정<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gcloud config set compute/zone asia-northeast1-a</div></pre></td></tr></table></figure></p>
<h3 id="쿠버네티스-클러스터를-생성해보자"><a href="#쿠버네티스-클러스터를-생성해보자" class="headerlink" title="쿠버네티스 클러스터를 생성해보자"></a>쿠버네티스 클러스터를 생성해보자</h3><p> <a href="https://console.cloud.google.com/apis/api/container.googleapis.com/overview?project=xxxxxx" target="_blank" rel="external">https://console.cloud.google.com/apis/api/container.googleapis.com/overview?project=xxxxxx</a><br> 으로 접속해서 사용 설정가능토록 해주자</p>
<p>아래 명령어로 클러스터 생성<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gcloud container clusters create sangheon --cluster-version=latest --machine-type=n1-standard-1 --num-nodes=3</div></pre></td></tr></table></figure></p>
<p>–cluster-version 으로 클러스터 버전 지정<br>–num-nodes  으로 인스턴수 수 지정</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gcloud components install kubectl</div></pre></td></tr></table></figure>
<p>kubectl 에 인증정보 설정<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gcloud container clusters get-credentials sangheon</div></pre></td></tr></table></figure></p>
<p>잘되었나 확인해보자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ kubectl get nodes</div></pre></td></tr></table></figure></p>
<p>다음을 입력하여 로컬에서 접속해보자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kubectl proxy</div></pre></td></tr></table></figure></p>
<p>/</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;온프레미스 환경 또는 퍼블릭 클라우드에서 쿠버네티스를 실제로 사용해 보자.&lt;br&gt;클라우드에서 Google Kubernetes Engine을이용하거나 온프레미스 환경에서 Kuberspray를 이용해 클러스터를 구축하자&lt;/p&gt;
&lt;p&gt;GCP를 생성하고
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="MSA" scheme="http://KKimSangHeon.github.io/categories/CS/MSA/"/>
    
    
      <category term="kubernetes" scheme="http://KKimSangHeon.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>8. 인그레스</title>
    <link href="http://KKimSangHeon.github.io/2019/05/29/kube8/"/>
    <id>http://KKimSangHeon.github.io/2019/05/29/kube8/</id>
    <published>2019-05-29T10:23:51.000Z</published>
    <updated>2019-05-29T12:56:24.086Z</updated>
    
    <content type="html"><![CDATA[<p>NodePort의 경우 L4레벨까지 다룰수 있기 때문에 HTTP/HTTPS처럼 경로를 기반으로 서비스를 전환하는 L7레벨의 제어는 불가능하다.<br>이를 해결하기 위한것이 인그레스이다. 서비스를 이용한 쿠버네티스 외부에 대한 노출(NodePort)과 가상 호스트 및 경로 기반의 정교한 HTTP 라우팅(인그레스)을 양립시킬 수 있다.<br>(무슨말인지 이해가 되지 않는다면 아래 밑줄부분을 보자.)</p>
<p>클러스터 외부에서 온 HTTP 요청을 서비스로 라우팅 하기위해 다음을 입력하자.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.16.2/deploy/mandatory.yaml</div><div class="line">$ kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.16.2/deploy/provider/cloud-generic.yaml</div><div class="line"></div><div class="line">$ kubectl get pod,svc -n ingress-nginx</div></pre></td></tr></table></figure></p>
<p>서비스를 다음과 같이 생성하고 반영시켜보자.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: Service</div><div class="line">metadata:</div><div class="line">  name: echo</div><div class="line">spec:</div><div class="line">  selector:</div><div class="line">    app: echo</div><div class="line">  ports:</div><div class="line">    - name: http</div><div class="line">      port: 80</div></pre></td></tr></table></figure></p>
<p>다음과같이 인그레스를 정의하고 반영해보자.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">apiVersion: extensions/v1beta1</div><div class="line">kind: Ingress</div><div class="line">metadata:</div><div class="line">  name: echo</div><div class="line">spec:</div><div class="line">  rules:</div><div class="line">  - host: ch05.gihyo.local</div><div class="line">    http:</div><div class="line">      paths:</div><div class="line">      - path: /</div><div class="line">        backend:</div><div class="line">          serviceName: echo</div><div class="line">          servicePort: 80</div></pre></td></tr></table></figure></p>
<p>잘 생성되었는지 확인해보자.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ kubectl get ingress</div></pre></td></tr></table></figure></p>
<p><u>인그레스는 L7 라우팅이 가능하므로 가상 호스팅 기능처럼 지정된 호스트 혹은 경로와 일치하는 서비스로 요청을 전달할 수 있다</u> 가령 헤더에 Mobile라는 값이 포함될경우 특정 URL로 리다이렉트 할 수 있다.</p>
<h3 id="apiVersion"><a href="#apiVersion" class="headerlink" title="apiVersion??"></a>apiVersion??</h3><p>항상 맨위에 위치하는 apiVersion은 무엇일까?<br>쿠버네티스 리소스를 생성, 수정, 삭제하는 작업은 쿠버네티스 클러스터에 배포된 API가 수행한다. 이 API는 여러 API를 하나로 묶은 형태로 구성되는데 이 apiVersion은 해당 작업에 사용되는 API의 종류를 나타내는 것이다. 다음명령어를 통해 쿠버네티스에서 사용할 수 있는 명령어들을 볼 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ kubectl api-versions</div></pre></td></tr></table></figure></p>
<p>서비스나 파드는 쿠버네티스의 핵심 API인 v1, 디플로이먼트는 파드의 생성을 제어하는 API인 apps/v1에 해당한다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NodePort의 경우 L4레벨까지 다룰수 있기 때문에 HTTP/HTTPS처럼 경로를 기반으로 서비스를 전환하는 L7레벨의 제어는 불가능하다.&lt;br&gt;이를 해결하기 위한것이 인그레스이다. 서비스를 이용한 쿠버네티스 외부에 대한 노출(NodePort
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="MSA" scheme="http://KKimSangHeon.github.io/categories/CS/MSA/"/>
    
    
      <category term="kubernetes" scheme="http://KKimSangHeon.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>7. 서비스</title>
    <link href="http://KKimSangHeon.github.io/2019/05/29/kube7/"/>
    <id>http://KKimSangHeon.github.io/2019/05/29/kube7/</id>
    <published>2019-05-29T10:23:39.000Z</published>
    <updated>2019-05-29T10:24:38.043Z</updated>
    
    <content type="html"><![CDATA[<p>쿠버네티스 클러스터 안에서 파드의 집합(주로 레플리카세트)에 대한 경로나 서비스 디스커버리(API 주소가 동적으로 바뀌어도 클라이언트가 대상을 바꾸지않고 접근할 수 있음)를 제공하는 리소스이다. 서비스의 대상이 되는 파드는 서비스에서 정의하는 레이블 셀렉터로 정해진다. spec.selector 속성값으로 특정 파트의 레이블값을 설정하여 특정 파드만 접근할 수 있도록 yaml파일을 작성해보자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: Service</div><div class="line">metadata:</div><div class="line">  name: echo</div><div class="line">spec:</div><div class="line">  selector:     # 특정 파드만 접근할수 있도록 함.</div><div class="line">    app: echo</div><div class="line">    release: summer</div><div class="line">  ports:</div><div class="line">    - name: http</div><div class="line">      port: 80</div></pre></td></tr></table></figure>
<p>위의 서비스를 실행하고 컨테이너 안에 존재하는 아무 컨테이너에 들어가서 <code>curl http://echo</code> 를 입력하면 잘 동작하는것을 확인할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ kubectl exec -it 파드명 bash</div><div class="line"></div><div class="line">혹은</div><div class="line"></div><div class="line">$ kubectl run -i --rm --tty debug --image=gihyodocker/fundamental:0.1.0 --restart=Never -- bash -il</div><div class="line"></div><div class="line"></div><div class="line"># curl http://echo</div></pre></td></tr></table></figure></p>
<p>다음명령어를 통해 로그를 summer안에서 생기는 로그를 확인할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ kubeclt logs -f echo-summer-dtblk -c echo</div></pre></td></tr></table></figure></p>
<p>쿠버네티스 클러스터는 <code>서비스명.네임스페이스명.svc.local</code>로 연결해준다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ curl http://echo.default.svc.local</div><div class="line"></div><div class="line">$ curl http://echo.default</div><div class="line"># svc.local 생략가능</div><div class="line"></div><div class="line">$ curl http://echo  </div><div class="line"># 같은네임스페이스일 경우만 가능</div></pre></td></tr></table></figure>
<h3 id="ClusterIP-서비스"><a href="#ClusterIP-서비스" class="headerlink" title="ClusterIP 서비스"></a>ClusterIP 서비스</h3><p>서비스의 종류는 여러가지가 있고 기본값은 ClusterIP 서비스이다. ClusterIP를 통해 클러스터 내부 IP 주소에 서비스를 공개할 수 있다.</p>
<h3 id="NodePort-서비스"><a href="#NodePort-서비스" class="headerlink" title="NodePort 서비스"></a>NodePort 서비스</h3><p>이는 클러스터 외부에서 접근할 수 있는 서비스이다. ClusterIP를 만든다는 점은 ClusterIP 서비스와 같다. 각 노드에서 서비스 포트로 접속하기 위한 글로벌 포트를 개방하는것이 차이점이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: Service</div><div class="line">metadata:</div><div class="line">  name: echo</div><div class="line">spec:</div><div class="line">  type: NodePort  # 추가함</div><div class="line">  selector:     </div><div class="line">    app: echo</div><div class="line">    release: summer</div><div class="line">  ports:</div><div class="line">    - name: http</div><div class="line">      port: 80</div></pre></td></tr></table></figure>
<p>다음 명령어를 통해 포트를 알아내고 curl요청을 보낼 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ kubectl get svc echo</div></pre></td></tr></table></figure></p>
<h3 id="LoadBalancer-서비스"><a href="#LoadBalancer-서비스" class="headerlink" title="LoadBalancer 서비스"></a>LoadBalancer 서비스</h3><p>이는 각 클라우드 플랫폼에서 제공하는 로드밸런서와 연동하기 위해 사용된다.</p>
<h3 id="ExternalName-서비스"><a href="#ExternalName-서비스" class="headerlink" title="ExternalName 서비스"></a>ExternalName 서비스</h3><p>이는 셀렉터도 포트 정의도 없는 특이한 서비스다. 쿠버네티스 클러스터에서 외부 호스트를 네임 레졸루션 하기위한 별칭을 제공한다.<br>아래의 경우 gihyo.jp를 gihyo로 참조할 수 있게해준다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1</div><div class="line">kind: Service</div><div class="line">metadata:</div><div class="line">  name: gihyo</div><div class="line">spec:</div><div class="line">  type: ExternalName  # 추가함</div><div class="line">  externalName: gihyo.jp</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;쿠버네티스 클러스터 안에서 파드의 집합(주로 레플리카세트)에 대한 경로나 서비스 디스커버리(API 주소가 동적으로 바뀌어도 클라이언트가 대상을 바꾸지않고 접근할 수 있음)를 제공하는 리소스이다. 서비스의 대상이 되는 파드는 서비스에서 정의하는 레
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="MSA" scheme="http://KKimSangHeon.github.io/categories/CS/MSA/"/>
    
    
      <category term="kubernetes" scheme="http://KKimSangHeon.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>6.쿠버네티스의 주요 개념(리소스 개요,파드,네임스페이스,레플리카세트,디플로이먼트</title>
    <link href="http://KKimSangHeon.github.io/2019/05/27/kube6/"/>
    <id>http://KKimSangHeon.github.io/2019/05/27/kube6/</id>
    <published>2019-05-27T11:01:24.000Z</published>
    <updated>2019-05-29T10:21:11.518Z</updated>
    
    <content type="html"><![CDATA[<p><code>docker container prune</code><br>docker container prune [options]<br>도커를 오래 사용하다 보면 디스케이 컨테이너와 이미지가 점점 늘어나게 된다. 이런 경우 prune 명령을 사용해 필요없는 컨테이너를 일괄 삭제할 수 있다.</p>
<p>docker image prune [options]<br>도커를 오래 사용하다 보면 디스케이 컨테이너와 이미지가 점점 늘어나게 된다. 이런 경우 prune 명령을 사용해 필요없는 이미지를 일괄 삭제할 수 있다.</p>
<p>docker system prune [options]<br>사용하지 않는 도커 이미지 및 컨테이너,볼륨,네트워크 등 모든 리소스를 일괄적으로 삭제할 수 있다.</p>
<p>쿠버네티스로 실행하는 애펄리케이션은 애플리케이션을 구성하는 다양한 리소스가 함께 연동해 동작한다.</p>
<h3 id="리소스의-종류-및-용도"><a href="#리소스의-종류-및-용도" class="headerlink" title="리소스의 종류 및 용도"></a>리소스의 종류 및 용도</h3><p><code>노드</code> : 컨테이너가 배치되는 서버<br><code>네임스페이스</code> : 쿠버네티스 클러스터 안의 가상 클러스터.<br><code>파드</code> : 컨테이너의 집합 중 가장 작은 단위로 컨테이너 실행 방법을 정의한다.<br><code>레플리카 세트</code>: 같은 스펙을 갖는 파드를 여러개 생성하고 관리하는 역할을 한다.<br><code>디플로이먼트</code> : 레플리카 세트의 리비전을 관리한다.<br><code>서비스</code>: 파드의 집합에 접근하기 위한 경로를 정의한다.<br><code>인그레스</code>:서비스를 쿠버네티스 클러스터 외부로 노출시킨다.<br><code>컨피그맵</code> : 설정 정보를 정의하고 파드에 전달한다.<br><code>퍼시스턴트 볼륨</code> : 파드가 사용할 스토리지의 크기 및 종류를 정의.<br><code>퍼시스턴스 볼륨 클레임</code> : 퍼시스턴트 볼륨을 동적으로 확보.<br><code>스토리지 클래스</code> : 퍼시스턴트 볼륨이 확보하는 스토리지의 종류를 정의<br><code>스테이트풀 세트</code> : 같은 스펙으로 모두 동일한 파드를 여러개 생성하고 관리한다.<br><code>잡</code>: 상주 실행을 목적으로 하지 않는 파드를 여러개 생성하고 정상적인 종료를 보장한다.<br><code>크론잡</code>: 크론 문법으로 스케줄링되는 잡.<br><code>시크릿</code> : 인증 정보같은 기밀 데이터를 정의한다.<br><code>롤</code>: 네임스페이스 안에서 조작 가능한 쿠버네티스 리소스의 규칙을 정의한다.<br><code>롤바인딩</code>: 쿠버네티스 리소스 사용자와 롤을 연결 짓는다.<br><code>클러스터룰</code>: 클러스터 전체적으로 조작 가능한 쿠버네티스 리소스의 규칙을 정의한다.<br><code>클러스터롤바인딩</code>:쿠버네티스 리소스 사용자와 클러스터 롤을 연결 짓는다.<br><code>서비스 계정</code>: 파드가 쿠버네티스 리소스를 조작할 때 사용하는 계정</p>
<h3 id="쿠버네티스-클러스터와-노드"><a href="#쿠버네티스-클러스터와-노드" class="headerlink" title="쿠버네티스 클러스터와 노드"></a>쿠버네티스 클러스터와 노드</h3><p>쿠버네티스 리소스 중에서 가장 큰 개념은 노드이다. 쿠버네티스는 클러스터 전체를 관리하는 서버인 마스터가 적어도 하나 이상 있어야 하며 쿠버네티스 클러스터는 마스터와 노드의 그룹으로 구성된다.</p>
<h3 id="네임스페이스"><a href="#네임스페이스" class="headerlink" title="네임스페이스"></a>네임스페이스</h3><p>쿠버네티스는 클러스터 안에 가상 클러스터를 또 다시 만들 수 있다. 이를 네임스페이스라 한다. 클러스터를 처음 구축하면 default, docker, kube-public, kube-system의 네임스페이스 4개가 이미 만들어져 있다.</p>
<h3 id="파드"><a href="#파드" class="headerlink" title="파드"></a>파드</h3><p>파드는 컨테이너가 모인 집합체의 단위로 적어도 하나 이상의 컨테이너로 이루어진다. 쿠버네티스에서는 결합이 강한 컨테이너를 파드로 묶어 일괄 배포한다.<br>파드 하나는 여러 노드에 걸쳐 배치될 수 없다. 함께 배포해야 정합성을 유지할 수 있는 컨테이너 등에도 해당 컨테이너를 같은 파드로 묶어두는 전략이 유용하다.<br>쿠버네티스에서는 관리용 서버인 마스터가 클러스터 전체를 제어하며 마스터 노드는 관리용 컴포넌트가 담긴 파드만 배포된 노드이다. 어플리케이션에 사용되는 파드는 배포할 수 없다.</p>
<h3 id="파드생성-및-배포"><a href="#파드생성-및-배포" class="headerlink" title="파드생성 및 배포"></a>파드생성 및 배포</h3><p>파드생성은 kubectl만 사용해도 가능하지만, 버전관리 관점에서도 yaml파일로 정의하는것이 좋다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">apiVersion: v1  # 리소스의 유형을 지정하는 속성</div><div class="line">kind: Pod</div><div class="line">metadata:       # 리소스에 부여되는 메타데이터. metadata.name 속성의 값이 리소스의 이름이 된다.</div><div class="line">  name: simple-echo</div><div class="line">spec:           # 리소스를 정의하기 위한 속성.</div><div class="line">  containers:</div><div class="line">  - name: nginx # 컨테이너 이름</div><div class="line">    image: gihyodocker/nginx:latest # 도커 허브에 저장된 이미지 태그값</div><div class="line">    env:        # 환경변수</div><div class="line">    - name: BACKEND_HOST</div><div class="line">      value: localhost:8080</div><div class="line">    ports:      # 컨테이너가 노출시킬 포트를 지정 (도커파일에서 지정한 경우 따로 지정할필요 x)</div><div class="line">    - containerPort: 80</div><div class="line">  - name: echo</div><div class="line">    image: gihyodocker/echo:latest</div><div class="line">    ports:</div><div class="line">    - containerPort: 8080</div></pre></td></tr></table></figure>
<p>아래 명령어를 입력하여 클러스터에 배포할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ kubectl apply -f simple-pod.yaml</div><div class="line">$ kubectl get pod</div><div class="line">를 입력하여 파드 정보를 볼 수 있다. READY에 분모는 파드에 정의된 컨테이너 수이고 분자는 실행 상태의 컨테이너 수 이다.</div></pre></td></tr></table></figure></p>
<p>아래 명령어를 통해 파드안에 있는 컨테이너의 표준 출력을 화면에 출력할 수 있다.<br>뒤 -c는 컨테이너를 지정한것.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ kubectl logs -f simple-echo -c echo</div></pre></td></tr></table></figure></p>
<p>파드를 삭제하기 위해 다음명령어를 사용할 수 있다<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ kubectl delete pod simple-echo</div></pre></td></tr></table></figure></p>
<p>매니페스트 파일로도 파드를 삭제할 수 있다. 이 경우 메니패스트에 작성된 리소스 전체가 삭제된다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ kubectl delete -f simple-pod.yaml</div></pre></td></tr></table></figure>
<p>파드에는 각각 고유의 가상 IP주소가 할당된다. 이는 파드에 속하는 모든 컨테이너가 공유하며 이로인해 같은 파드 안의 모든 컨테이너의 가상 IP가 같기 때문에 컨테이너간 통신이 가능해진다.</p>
<h3 id="레플리카세트"><a href="#레플리카세트" class="headerlink" title="레플리카세트"></a>레플리카세트</h3><p>레플리카세트는 똑같은 정의를 갖는 파드를 여러개 생성하고 관리하기 위한 리소스다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">apiVersion: apps/v1</div><div class="line">kind: ReplicaSet</div><div class="line">metadata:</div><div class="line">  name: echo</div><div class="line">  labels:</div><div class="line">    app: echo</div><div class="line">spec:</div><div class="line">  replicas: 3</div><div class="line">  selector:</div><div class="line">    matchLabels:</div><div class="line">      app: echo</div><div class="line">  template: # template 아래는 파드 리소스 정의와 같음</div><div class="line">    metadata:</div><div class="line">      labels:</div><div class="line">        app: echo</div><div class="line">    spec:</div><div class="line">      containers:</div><div class="line">      - name: nginx</div><div class="line">        image: gihyodocker/nginx:latest</div><div class="line">        env:</div><div class="line">        - name: BACKEND_HOST</div><div class="line">          value: localhost:8080</div><div class="line">        ports:</div><div class="line">        - containerPort: 80</div><div class="line">      - name: echo</div><div class="line">        image: gihyodocker/echo:latest</div><div class="line">        ports:</div><div class="line">        - containerPort: 8080</div></pre></td></tr></table></figure>
<h3 id="디플로이먼트"><a href="#디플로이먼트" class="headerlink" title="디플로이먼트"></a>디플로이먼트</h3><p>레플리카세트보다 상위에 해당하는 리소스로 디플로이먼트가 있다. 디플로이먼트는 어플리케이션 배포의 기본단위가 되는 리소스이다.<br>디플로이먼트의 정의는 레플리카세트의 정의와 크게 다르지 않다. 차이가 있다면 디플로이먼트가 레플리카세트의 리비전 관리를 할 수 있다는 점 정도다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">apiVersion: apps/v1</div><div class="line">kind: Deployment</div><div class="line">metadata:</div><div class="line">  name: echo</div><div class="line">  labels:</div><div class="line">    app: echo</div><div class="line">spec:</div><div class="line">  replicas: 3</div><div class="line">  selector:</div><div class="line">    matchLabels:</div><div class="line">      app: echo</div><div class="line">  template: # template 아래는 파드 리소스 정의와 같음</div><div class="line">    metadata:</div><div class="line">      labels:</div><div class="line">        app: echo</div><div class="line">    spec:</div><div class="line">      containers:</div><div class="line">      - name: nginx</div><div class="line">        image: gihyodocker/nginx:latest</div><div class="line">        env:</div><div class="line">        - name: BACKEND_HOST</div><div class="line">          value: localhost:8080</div><div class="line">        ports:</div><div class="line">        - containerPort: 80</div><div class="line">      - name: echo</div><div class="line">        image: gihyodocker/echo:patched</div><div class="line">        env:</div><div class="line">        - name: HOGE</div><div class="line">          value: fuga</div><div class="line">        ports:</div><div class="line">        - containerPort: 8080</div></pre></td></tr></table></figure>
<h3 id="레플리카세트의-생애주기"><a href="#레플리카세트의-생애주기" class="headerlink" title="레플리카세트의 생애주기"></a>레플리카세트의 생애주기</h3><p>실제운영에서는 디폴로이먼트 매니페스트 파일을 통해 레플리카 세트를 다룬다.<br>디플로이먼트를 수정하면 레플리카세트가 새로 생성되고 기존 레플리카 세트와 교체된다.</p>
<h4 id="레플리카-세트의-다양한-경우의-수"><a href="#레플리카-세트의-다양한-경우의-수" class="headerlink" title="레플리카 세트의 다양한 경우의 수"></a>레플리카 세트의 다양한 경우의 수</h4><p>파드 개수만 수정할 경우 (replicas값을 3에서 4로) 레플리카세트가 새로 생성되지 않는다.</p>
<p>컨테이너 이미지가 수정된 경우 기존 파드는 단계적으로 정지된다. 또한 <code>kubectl rollout history deployment echo</code>를 입력해보면 새로운 리비전으로 변경된것을 확인할 수 있다.</p>
<h3 id="롤백하기"><a href="#롤백하기" class="headerlink" title="롤백하기"></a>롤백하기</h3><p>undo를 실행하면 디플로이먼트가 바로 직전 리비전으로 롤백된다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ kubectl rollout undo deployment echo</div></pre></td></tr></table></figure></p>
<p>디플로이먼트는 다음 명령어를 통해 삭제할 수 있다. 이와 관련된 레플리카세트와 파드가 함께 삭제된다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ kubectl delete -f simple-deployment.yaml</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;docker container prune&lt;/code&gt;&lt;br&gt;docker container prune [options]&lt;br&gt;도커를 오래 사용하다 보면 디스케이 컨테이너와 이미지가 점점 늘어나게 된다. 이런 경우 prune 명령을 사용해
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="MSA" scheme="http://KKimSangHeon.github.io/categories/CS/MSA/"/>
    
    
      <category term="kubernetes" scheme="http://KKimSangHeon.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>5.도커 운영과 관리를 위한 명령</title>
    <link href="http://KKimSangHeon.github.io/2019/05/26/kube5/"/>
    <id>http://KKimSangHeon.github.io/2019/05/26/kube5/</id>
    <published>2019-05-26T08:30:05.000Z</published>
    <updated>2019-05-27T12:19:49.742Z</updated>
    
    <content type="html"><![CDATA[<p><code>docker container prune</code><br>docker container prune [options]<br>도커를 오래 사용하다 보면 디스케이 컨테이너와 이미지가 점점 늘어나게 된다. 이런 경우 prune 명령을 사용해 필요없는 컨테이너를 일괄 삭제할 수 있다.</p>
<p>docker image prune [options]<br>도커를 오래 사용하다 보면 디스케이 컨테이너와 이미지가 점점 늘어나게 된다. 이런 경우 prune 명령을 사용해 필요없는 이미지를 일괄 삭제할 수 있다.</p>
<p>docker system prune [options]<br>사용하지 않는 도커 이미지 및 컨테이너,볼륨,네트워크 등 모든 리소스를 일괄적으로 삭제할 수 있다.</p>
<p><code>docker iamge prune</code><br>docker image prune [options]<br>이미지도 컨테이너와 마찬가지로 사용하지 않는 것이 점차 누적된다. 디스크 용량을 너무 차지하지 않도록 정기적으로 삭제 해줘야 한다. docker image prune명령은 태그가 붙지않은 모든 이미지를 삭제한다.</p>
<p><code>docker system prune</code><br>사용하지 않는 도커 이미지 및 컨테이너, 볼륨, 네트워크 등 모든 도커 리소스를 일괄적으로 삭제한다.</p>
<p><code>docker container stats</code><br>시스템 리소스 사용 현황을 컨테이너 단위로 확인할 때 사용한다. 유닉스 계열 운영 체제의 top 명령과 같은 역할을 한다고 보면 된다.<br>docker container stats [options] [대상_컨테이너ID]</p>
<p>80P부터</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;docker container prune&lt;/code&gt;&lt;br&gt;docker container prune [options]&lt;br&gt;도커를 오래 사용하다 보면 디스케이 컨테이너와 이미지가 점점 늘어나게 된다. 이런 경우 prune 명령을 사용해
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="MSA" scheme="http://KKimSangHeon.github.io/categories/CS/MSA/"/>
    
    
      <category term="kubernetes" scheme="http://KKimSangHeon.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>4.도커 컨테이너 다루기</title>
    <link href="http://KKimSangHeon.github.io/2019/05/26/kube4/"/>
    <id>http://KKimSangHeon.github.io/2019/05/26/kube4/</id>
    <published>2019-05-26T08:29:48.000Z</published>
    <updated>2019-05-26T08:32:04.209Z</updated>
    
    <content type="html"><![CDATA[<p>컨테이너는 파일 시스템과 어플리케이션이 함께 담겨있는 박스이다.</p>
<h3 id="컨테이너의-생명주기"><a href="#컨테이너의-생명주기" class="headerlink" title="컨테이너의 생명주기"></a>컨테이너의 생명주기</h3><p>도커 컨테이너는 실행 중, 정지, 파기의 3가지 상태를 갖는다. 이를 도커 컨테이너의 생애주기라고 한다. 각 컨테이너는 같은 이미지로 생성했더라도 다른 상태를 갖는다.</p>
<p><code>실행 중 상태</code> : docker container run 명령의 인자로 지정된 도커 이미지를 기반으로 컨테이너가 생성되면 이 이미지를 생성했던 Dockerfile에 포함된 CMD 및 ENTRYPOINT 인스트럭션에 정의된 어플리케이션이 실행된다. 이를 실행 중 상태라고 한다.<br>서버의 경우 실행 기간이 길지만 명령이 바로 실행되고 끝나는 명령행 도구 등의 컨테이너는 실행 중 상태가 길게 유지되지 않는다.</p>
<p><code>정지 상태</code><br>실행 중 상태에 있는 컨테이너를 사용자가 명시적으로 정지하거나 컨테이너에서 실행된 어플리케이션이 정상/오류 여부를 막론하고 자동으로 정지 상태가 된다.<br>정지시키면 가상 환경으로는 더 이상 동작하지 않지만, 종료되던 시점의 상태가 저장돼 남는다. 그러므로 정지시킨 컨테이너를 다시 실행할 수 있다.</p>
<p><code>파기상태</code><br>정 상태의 컨테이너는 명시적으로 파기하지 않는 이상 디스크에 그대로 남아있다. 한번 파기한 컨테이너는 다시는 실행할 수 없다.</p>
<p><code>docker container run</code><br>도커 이미지로부터 컨테이너를 생성하고 실행하는 명령이다. 도커 컨테이너를 싱행중 상태로 만들기 위해 사용한다.<br>docker container run [options] 이미지명[:태그] [명령] [명령인자..]<br>docker container run [options] 이미지ID [명령] [명령인자..]</p>
<p>docker container run -it alpine:3.7 uname -a<br>이 경우 Dockerfile에 정의되어있는 CMD 인스트럭션을 오버라이딩하여 uname -a가 실행되도록 할 수 있다.</p>
<p>컨테이너 이름 붙이기<br>컨테이너를 다루는 명령을 실행할 때는 ID등으로 컨테이너를 특정해줘야 한다. 매번 docker container ls를 통해 id나 이름을 확인하기 번거롭기 때문에 이름을 붙여 활용할 수 있다.<br>docker container run –name [컨테이너명] [이미지명]:[태그]</p>
<p><code>docker container ls</code><br><code>docker container ls [options]</code><br>실행 중이거나 종료된 컨테이너의 목록을 보여주는 명령</p>
<p>docker container ls -q 를 통해 컨테이너 ID만 추출할 수 있다.</p>
<p><code>docker container stop</code><br>docker container stop 컨테이너ID<em>또는</em>컨테이너명<br>실행중인 컨테이너를 정지하는 명령이다.</p>
<p><code>docker container restart</code><br>docker container restart 컨테이너ID<em>또는</em>컨테이너명<br>파기하지 않은 정지 상태의 컨테이너 재시작</p>
<p><code>docker container rm</code><br>docker container rm 컨테이너ID<em>또는</em>컨테이너명</p>
<p><code>docker container logs</code><br>현재 실행중인 특정 도커 컨테이너의 표준 출력 내용을 확인할 수 있다.<br>docker container logs [options] 컨테이너ID<em>또는</em>컨테이너명</p>
<p><code>docker container exec</code><br>docker container exec [options] 컨테이너ID<em>또는</em>컨테이너명 컨테이너에서<em>실행할</em>명령</p>
<p><code>docker container cp</code><br>컨테이너끼리 혹은 컨테이너와 호스트간에 파일을 복사하기 위한 명령이다. Dockerfile에 포함된 COPY 인스트럭션은 이미지를 빌드할 때 호스트에서 복사해 올 파일을 정의하기 위한것이고, docker container cp 명령은 실행중인 컨테이너와 파일을 주고받기 위한 명령이다.</p>
<p>컨테이너 안에 있는 /echo/main.go 파일을 호스트의 현재 작업 디렉터리로 복사하려면 다음과 같이 하면된다.<br>docker container cp echo:/echo/main.go .</p>
<p>호스트쪽에서 컨테이너로 파일을 복사하려면 다음과 같이 한다.<br>docker container cp dummy.txt echo:/tmp</p>
<p>/</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;컨테이너는 파일 시스템과 어플리케이션이 함께 담겨있는 박스이다.&lt;/p&gt;
&lt;h3 id=&quot;컨테이너의-생명주기&quot;&gt;&lt;a href=&quot;#컨테이너의-생명주기&quot; class=&quot;headerlink&quot; title=&quot;컨테이너의 생명주기&quot;&gt;&lt;/a&gt;컨테이너의 생명주기&lt;/h
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="MSA" scheme="http://KKimSangHeon.github.io/categories/CS/MSA/"/>
    
    
      <category term="kubernetes" scheme="http://KKimSangHeon.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>3. 도커 이미지 다루기</title>
    <link href="http://KKimSangHeon.github.io/2019/05/22/kube3/"/>
    <id>http://KKimSangHeon.github.io/2019/05/22/kube3/</id>
    <published>2019-05-22T11:48:50.000Z</published>
    <updated>2019-05-26T08:31:11.662Z</updated>
    
    <content type="html"><![CDATA[<p>도커이미지는 도커 컨테이너를 만들기 위한 템플릿이다<br>컨테이너의 템플릿 역할을 하는 이미지를 만드는 과정을 일반적으로 도커 이미지를 빌드한다고 한다. 그리고 컨테이너를 실행할 때 빌드된 이미지를 사용한다.</p>
<p><code>docker image build</code><br>도커파일에 기술된 구성을 따라 도커 이미지를 생성하는 명령.<br>docker image build -t 이미지명[:태그명] Dockerfile의 경로</p>
<p><code>docker search</code><br>docker search [options] 검색_키워드<br>도커 허브에 등록된 레파지토리를 검색할 수 있다.<br>docker search jenkins 를 하면<br>docker search library/jenkins와 같다.<br>공식 레파지토리의 네임스페이스는 일률적으로 library이다.</p>
<p><code>docker image pull</code><br>docker image pull [options] 리포지토리명[:태그명]<br>인자로 지정한 레포지토리명과 태그는 도커 허브에 이미 존재하야 한다.</p>
<p><code>docker image ls</code><br>호스트 운영체제에 저장된 도커 이미지의 목록을 보여준다.</p>
<p><code>docker image tag</code><br>도커 이미지의 특정 버전에 태그를 붙일 때 사용한다.<br>태그는 이미지의 특정 버전을 구별하기 위한것이다.<br>같은 태그에 여러 도커이미지를 빌드했을 때 최근 빌드된 이미지만 해당 태그를 갖고 나머지는 none가 된다.<br>태그는 이미지 ID에 태그명을 별명으로 붙이는 명령이다.<br>도커 이미지는 빌드할 때마다 다시 생성되는데 그 내용의 해시값을 이미지 ID로 삼기 때문에 내용이 바뀌면 이미지 ID도 새값으로 바뀐다.<br>docker image tag 기반이미지명[:태그] 새이미지명[:태그]</p>
<p><code>docker image push</code><br>도커 이미지를 도커 허브 등의 레지스트리에 등록하기 위해 사용<br>docker image push [options] 리포지토리명[:태그]</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;도커이미지는 도커 컨테이너를 만들기 위한 템플릿이다&lt;br&gt;컨테이너의 템플릿 역할을 하는 이미지를 만드는 과정을 일반적으로 도커 이미지를 빌드한다고 한다. 그리고 컨테이너를 실행할 때 빌드된 이미지를 사용한다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;docker 
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="MSA" scheme="http://KKimSangHeon.github.io/categories/CS/MSA/"/>
    
    
      <category term="kubernetes" scheme="http://KKimSangHeon.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>2.도커 컨테이너 실행</title>
    <link href="http://KKimSangHeon.github.io/2019/05/21/kube2/"/>
    <id>http://KKimSangHeon.github.io/2019/05/21/kube2/</id>
    <published>2019-05-21T10:16:49.000Z</published>
    <updated>2019-05-23T13:06:39.516Z</updated>
    
    <content type="html"><![CDATA[<p>도커에서 제공하는 스크립트로 설치</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo wget -qO- https://get.docker.com/ | sh</div><div class="line">$ sudo usermod -aG docker shkim</div></pre></td></tr></table></figure>
<p><code>도커 이미지</code> : 도커 컨테이너를 구성하는 파일 시스템과 실행할 어플리케이션 설정을 하나로 합친것으로, 컨테이너를 생성하는 템플릿 역할을 한다.</p>
<p><code>도커 컨테이너</code> : 도커 이미지를 기반으로 생성되며, 파일 시스템과 어플리케이션이 구체화돼 실행되는 상태.</p>
<p>Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?<br>이라는 에러 뜰 때</p>
<p>sudo systemctl start docker</p>
<p>실습<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker image pull gihyodocker/echo:latest</div></pre></td></tr></table></figure></p>
<p>위를 입력하여 이미지를 내려받자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker container run -t -p 9000:8080 gihyodocker/echo:latest</div></pre></td></tr></table></figure>
<p>를 입력하여 내부 8080포트로 포트포워딩이 가능토록 해보자</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ curl http://localhost:9000</div></pre></td></tr></table></figure>
<p>을 입력하면 정상적으로 동작함을 볼 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker container stop $(docker container ls -q)</div></pre></td></tr></table></figure>
<p>을 입력하여 컨테이너를 중지시킬 수 있다.</p>
<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p><code>FROM</code> : 도커 이미지의 바탕이 될 베이스 이미지. dOCKERFILE로 이미지를 빌드할 때 먼저 from 인스트럭션에 지정된 이미지를 내려받는다. 받아오는 이미지는 모두 도커 허브 레지스트리에 공개된 것이다. 콜론 뒤에 붙는것은 버전이라고 볼 수 있다.</p>
<p><code>RUN</code> : 도커 이미지를 실행할 때 컨테이너 안에서 실행할 명령을 정의하는 인스트럭션. 도커 안에서 실행할 명령을 그대로 기술한다.</p>
<p><code>COPY</code> : 도커가 동작중인 호스트 머신의 파일이나 디렉토리를 도커 컨테이너 안으로 복사하는 인스트럭션이다.</p>
<p><code>CMD</code> : 도커 컨테이너를 실행할 때 컨테이너 안에서 실행할 프로세스를 지정한다. RUN은 이미지를 빌드할 때 실행되고 CMD는 컨테이너를 시작할 때 한번 실행된다. RUN은 어플리케이션 업데이트 및 배치에, CMD는 어플리케이션 자체를 실행하는 명령이라고 생각하면된다.<br>CMD [“실행파일”,”인자1”,”인자2”] - 실행파일에 인자를 전달한다.<br>CMD 명령 인자1, 인자2 - 명령과 인자를 지정한다. 셸에서 실행되므로 셸에 정의된 변수를 참조할 수 있다.<br>CMD [“인자1”, “인자2”] - ENTRYPOINT에 지정된 명령에 사용할 인자를 전달한다.</p>
<p><code>ENTRYPOINT</code> : 컨테이너의 명령 실행 방식을 조정할 수 있다. CMD와 마찬가지로 컨테이너안에서 실행할 프로세스를 지정하는 인스트럭션인다. ENTRYPOINT를 지정하면 CMD의 인자가 ENTRYPOINT에서 실행하는 파일에 인자로 주어진다. 즉, ENTRYPOINT에 지정된 값이 기본 프로세스를 지정하는 것이다.</p>
<p><code>LAVEL</code> : 이미지를 만든 사람의 이름 등을 적을 수 있다.</p>
<p><code>ENV</code> : 도커 컨테이너 안에서 사용할 수 있는 환경변수를 지정한다.</p>
<p><code>ARG</code> : 이미지를 빌드할 때 정보를 함께 넣기위해 사용한다. 이미지를 빌드할 때만 사용할 수 있는 임시적인 환경변수 이다.<br>``</p>
<h3 id="도커-이미지-빌드"><a href="#도커-이미지-빌드" class="headerlink" title="도커 이미지 빌드"></a>도커 이미지 빌드</h3><p>도커파일 작성이 끝났으면 docker image build 명령으로 도커 이미지를 빌드할 수 있다.</p>
<p>문법은 다음과 같다.<br>-t 옵션으로 이미지명을 지정한다. 태그명도 지정할 수 있으며 생략시에는 latest태그가 붙는다.<br><u>-t 옵션과 이미지명은 반드시 지정해야 한다고 생각하는 편이 좋다. -t 옵션 없이도 빌드 자체는 가능하지만, 이미지명 없이는 해시값만으로 이미지를 구분해야 하므로 사용하기 번거롭다.</u></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker image build -t 이미지명[:태그명] Dockerfile의 경로</div></pre></td></tr></table></figure>
<p>실습을 진행해보자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker image build -t example/echo:lastest .</div></pre></td></tr></table></figure></p>
<p>example은 네임스페이스를 의미한다. 이미지명에 이렇게 사용자 네임스페이스를 추가할 수 있으며 이미지명의 충돌을 피하기 위해 네임스페이스를 붙이는것이 좋다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker image ls</div></pre></td></tr></table></figure>
<p>를 입력하여 생성된 이미지의 정보를 확인할 수 있다.</p>
<h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">FROM golang:1.10</div><div class="line"></div><div class="line">ENTRYPOINT [&quot;go&quot;]</div><div class="line">CMD [&quot;&quot;]</div></pre></td></tr></table></figure>
<p>위와같이 도커파일을 만들고 아래를 입력하여 빌드해보자</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker image build -t sh/golang:latest .</div></pre></td></tr></table></figure>
<p>아래 명령어는 컨테이너 안에 들어가 <code>go version</code>을 입력한 것과 같다.<br>즉 아래 명령어의 version이 도커파일의 CMD 부분에 대입되는것이다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker container run sh/golang:latest version</div></pre></td></tr></table></figure></p>
<p>이처럼 ENTRYPOINT는 이미지를 생성하는 사람이 컨테이너의 용도를 어느정도 제한하려는 경우에도 유용하다.</p>
<h3 id="도커-컨테이너-실행"><a href="#도커-컨테이너-실행" class="headerlink" title="도커 컨테이너 실행"></a>도커 컨테이너 실행</h3><p>다음 명령어로 실행 할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker container run example/echo:latest</div></pre></td></tr></table></figure></p>
<p>다음 명령어로 데몬으로 실행할 수 있다. 명령어의 결과로 나오는 값은 컨테이너의 id이다. 도커 명령으로 컨테이너를 조작할 때 사용된다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker container run -d example/echo:latest</div></pre></td></tr></table></figure></p>
<h3 id="포트-포트포워딩"><a href="#포트-포트포워딩" class="headerlink" title="포트 포트포워딩"></a>포트 포트포워딩</h3><p>HTTP 요청을 받는 애플리케이션은 컨테이너 밖에서 온 요청을 컨테이너 안에 있는 어플리케이션에 전달해줘야 한다. 이를 바로 포트 포워딩이라 한다. 포트 포워딩이란 호스트 머신의 포트를 컨테이너 포트와 연결해 컨테이너 밖에서 온 통신을 컨테이너 포트로 전달한다. 이 기능 덕분에 컨테이너 포트를 컨테이너 외부에서도 이용할 수 있다.</p>
<p>다음 명령어로 포트포워딩을 할 수 있다. 9000포트로 접속할 경우 컨테이너 내부 8080포트로 연결된다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ docker container run -d -p 9000:8080 example/echo:latest</div></pre></td></tr></table></figure></p>
<p>또는 아래와 같이 빈 포트로 자동할당되도록 할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$ docker container run -d -p 8080 example/echo:latest</div><div class="line">// 빈 포트가 에페메랄 포트로 자동 할당된다.</div><div class="line">$ docker container ls</div><div class="line">//포트를 확인해보자</div></pre></td></tr></table></figure></p>
<p>/</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;도커에서 제공하는 스크립트로 설치&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/d
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="MSA" scheme="http://KKimSangHeon.github.io/categories/CS/MSA/"/>
    
    
      <category term="kubernetes" scheme="http://KKimSangHeon.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>1.도커의 기초</title>
    <link href="http://KKimSangHeon.github.io/2019/05/18/kube1/"/>
    <id>http://KKimSangHeon.github.io/2019/05/18/kube1/</id>
    <published>2019-05-18T14:49:26.000Z</published>
    <updated>2019-05-20T13:39:41.371Z</updated>
    
    <content type="html"><![CDATA[<h3 id="도커-amp-쿠버네티스"><a href="#도커-amp-쿠버네티스" class="headerlink" title="도커 &amp; 쿠버네티스"></a>도커 &amp; 쿠버네티스</h3><p>도커와 쿠버네티스에 대해 더 공부해보고 싶어 아래책을 구매하였고 포스팅해 볼 예정이다.<br><img src="/2019/05/18/kube1/dockerandkube.jpg" alt="[도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문]" title="[도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문]"></p>
<h3 id="도커란-무엇인가"><a href="#도커란-무엇인가" class="headerlink" title="도커란 무엇인가"></a>도커란 무엇인가</h3><p>도커는 컨테이너형 가상화 기술을 구현하기 위한 상주 어플리케이션(dockered라는 데몬)과 이 어플리케이션을 조작하기 위한 명령행 도구로 구성되는 프로덕트이다. 어플리케이션 배포에 특화되어 있기 때문에 어플리케이션 개발 및 운영을 컨테이너 중심으로 할 수 있다.<br>로컬 환경에 도커만 설치하면 몇 줄짜리 구성 파일과 명령어 한줄로 어플리케이션이나 미들웨어가 이미 갖춰진 테스트용 가상환경을 빠르게 구축할 수 있다. 가상화 소프트웨어와 비교해도 오버헤드가 적이진다는 장점이 있다.</p>
<p>도커의 장점</p>
<ul>
<li>기존 가상화 소프트웨어보다 더 가볍다.</li>
<li>이식성이 뛰어나다.</li>
<li>설치가 번거로운 명령형 도구를 도커 컨테이너로 가져다 사용함으로써 호스트를 깔금하게 유지하면서도 바로 실행할 수 있다.</li>
<li>다양한 의존 라이브러리나 도구를 도커 컨테이너에 포함시켜 배포함으로써 실행 환경과 상관없이 스크립트의 동작 재현성을 높임.</li>
<li>도커 컨테이너를 HTTP  부하 테스트의 워커로 사용해  HTTP 요청 수를 증가시킴.</li>
</ul>
<p>컨테이너는 운영체제의 동작을 완전히 재현하지는 못하기 때문에 엄밀한 리눅스 계열 운영체제의 동작이 요구되는 가상환경을 구축해야 한다면 VMWare가 더 적합할 수 있다.</p>
<h3 id="컨테이너-가상화"><a href="#컨테이너-가상화" class="headerlink" title="컨테이너 가상화?"></a>컨테이너 가상화?</h3><p>도커는 컨테이너형 가상화 기술을 사용하는데 이를통해 가상화 소프트웨어 없이도 운여 체제의 리소스를 격리해 가상 운영체제로 만들 수 있다. 이 가상 운영 체제를 컨테이너라 한다.  컨테이너를 만들면서 발생하는 오버헤드는 다른 가상화 소프트웨어보다 더 적다. 빠르게 시작 및 종료할 수 있고 이에 들어가는 리소스도 작은 편이다.</p>
<h3 id="운영체제-가상화"><a href="#운영체제-가상화" class="headerlink" title="운영체제 가상화?"></a>운영체제 가상화?</h3><p>운영체제 위에서 가상화 소프트웨어를 사용해 하드웨어를 에뮬레이션 하는 방법으로 게스트 운영체제를 만드는 방식을 호스트 운영체제 가상화 라고 한다. 컨테이너형 가상화와 비교하면 구조적으로 오버헤드가 크다.</p>
<img src="/2019/05/18/kube1/image1.png" alt="운영체제 가상화 / 컨테이너 가상화" title="운영체제 가상화 / 컨테이너 가상화">
<p>컨테이너 가상화의 경우 하이퍼바이저와, Guest OS를 만들지 않는것을 확인할 수 있다.</p>
<p>그림에 대해 조금 더 알아보자</p>
<p>VMware, VirtualBox는 호스트 OS위에 게스트 OS 전체를 가상화 하여 사용하는 방식 도커는 게스트 OS를 설치하는 방식이 아닌 서버 운영을 위한 라이브러리만 이미지에 담아 설치하게 되므로 기존의 방법들(전가상화, 반가상화)보다 경량화 된 상태입니다. 즉, 하드웨어를 가상화하는 계층이 없어졌기 때문에 기존 가상머신에 대해 보다 빠른 속도를 제공합니다.<br><code>https://real-dongsoo7.tistory.com/60 참고</code></p>
<p>컨테이너는 하이퍼바이저와 다르다. 컨테이너는 하이퍼바이저와 가상화라는 같은 목표를 갖고 있다. 하지만 하이퍼바이저는 OS 및 커널이 통째로 가상화 되지만 컨테이너는 파일시스템만 가상화가 된다. 컨테이너는 호스트 PC의 커널을 공유한다. 따라서 init등의 프로세스가 떠 있을 필요가 없고 가상화 프록르ㅐㅁ과는 다르게 적은 메모리 사용량 적은 오버헤드를 보인다.</p>
<h3 id="도커를-사용하는-의의"><a href="#도커를-사용하는-의의" class="headerlink" title="도커를 사용하는 의의"></a>도커를 사용하는 의의</h3><p>변화하지 않는 실행환경으로 멱등성 확보<br>코드를 통한 실행환경 구축 및 어플리케이션 구성<br>실행환경과 어플리케이션의 일체화로 이식성 향상<br>시스템을 구성하는 어플리케이션 및 미들웨어의 관리 용이성</p>
<p>환경의 차이로 인해 발생하는 문제에 대해 나온것들<br>1.코드로 관리하는 인프라<br>코드 기반으로 인프라를 정의한다는 개념. 멱등성을 확보하기위해 어플리케이션이 의존하는 런타임이나 라이브러리 모두가 확실하게 특정 버전으로 설치되도록 해야한다. <u>멱등성 보장을 위해 항구적인 코드를 계속적으로 작성하는것은 운영 업무에 부담을 주기 쉽다. 또한 서버의 대수가 늘어날 수록 모든서버에 구성을 적용하는 시간도 늘어난다. 이러한 문제에 대한 대책이 불변인프라 개념이다.</u></p>
<p>2.불변인프라<br><u>불변 인프라는 어떤 시점의 서버 상태를 저장해 복제할 수 있게 하자는 개념이다. </u>제대로 설정된 상태의 서버를 항상 사용할 수 있단는 점이 가장 큰 장점이다. 서버에 변경을 가하고 싶은 경우에는 기존 인프라를 수정하는 대신 새로운 서버를 구축하고 그 상태를 이미지로 저장한 다음 그 이미지를 복제한다. 한번 설정된 서버는 수정없이 파기되므로 멱등성을 신경쓸 필요가 없다.</p>
<p>도커를 활용할 경우 위의 두 개념을 쉽고 낮은 비용으로 실현할 수 있다. 도커는 컨테이너형 가상화 기술을 사용하다. 가상 머신의 OS를 재현하는게아닌 운영체제 대부분을 호스트 운영체제와 공유한다. 실행에 걸리는 시간이 짧은만큼 인프라를 완전히 새로 만드는 불변 인프라와 궁합이 잘 맞는다.</p>
<p>도커 컴포즈가 단일 서버를 넘어 여러 서버에 걸쳐있는 여러 컨테이너를 관리할 수 있도록 한 도구가 도커 스웜이다. 여러컨테이너를 관리하는 것만이 목적인 도커 컴포즈와 달리 도커 스웜은 컨테이너 증가 혹은 감소는 물론이고 노드의 리소스를 효율적으로 활용하기 위한 컨테이너 배치 및 로드 밸런싱 기능 등 더욱 실용적인 기능을 갖추고 있다. 또한 롤링업데이트(오래된 컨테이너와 새로운 컨테이너를 단계적으로 서비스에 교체 투입하는것)가 가능하다. 이처럼 여러 서버에 걸쳐있는 여러 컨테이너를 관리하는 기법을 <code>컨테이너 오케스트레이션</code>이라 한다.</p>
<p>컨테이너 오케스트레이션 분야에서 사실상 표준으로 자리 잡은 것은 <code>쿠버네티스</code>이다.</p>
<p>도커를 통해 인프라와 어플리케이션이 모두 컨테이너 형태로 제공되면서 인프라와 어플리케이션의 설정을 모두 코드수준에서 쉽게 수정할 수 있게됐다. 기존에는 명확했던 인프라 엔지니어와 서버 사이드 엔지니어의 영역 구분이 점점 희미해지고 있다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;도커-amp-쿠버네티스&quot;&gt;&lt;a href=&quot;#도커-amp-쿠버네티스&quot; class=&quot;headerlink&quot; title=&quot;도커 &amp;amp; 쿠버네티스&quot;&gt;&lt;/a&gt;도커 &amp;amp; 쿠버네티스&lt;/h3&gt;&lt;p&gt;도커와 쿠버네티스에 대해 더 공부해보고 싶어 아
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="MSA" scheme="http://KKimSangHeon.github.io/categories/CS/MSA/"/>
    
    
      <category term="kubernetes" scheme="http://KKimSangHeon.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>(K8s) 6. 윈도우에서 실습해보기</title>
    <link href="http://KKimSangHeon.github.io/2019/05/06/kubernetes6/"/>
    <id>http://KKimSangHeon.github.io/2019/05/06/kubernetes6/</id>
    <published>2019-05-06T14:26:48.000Z</published>
    <updated>2019-05-06T14:28:07.985Z</updated>
    
    <content type="html"><![CDATA[<p>도커툴박스설치</p>
<p><a href="https://docs.docker.com/toolbox/overview/" target="_blank" rel="external">https://docs.docker.com/toolbox/overview/</a></p>
<p>virtual machine 가 없다면 체크하여 설치</p>
<p>PowerShell 관리자 권한으로 실행</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">$ ExecutionPolicy      &lt;-- 현재상태확인</div><div class="line">$ Set-ExecutionPolicy Unrestricted</div><div class="line"></div><div class="line"></div><div class="line">$ Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))</div><div class="line"></div><div class="line">$ choco install minikube kubernetes-cli</div><div class="line"></div><div class="line">$ kubectl run sangheonkim --image=gcr.io/google-samples/kubernetes-bootcamp:v1 --port=8080</div><div class="line"></div><div class="line"></div><div class="line">$ minikube dashboard</div></pre></td></tr></table></figure>
<p>파드 내부에서 출력하는 로그를 보자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ kubectl get pods</div><div class="line">를 통해 파드의 정보를 복사하자,</div><div class="line">$ kubectl logs $POD_NAME</div></pre></td></tr></table></figure></p>
<p>컨테이너로 들어가서 여러 명령어를 실행해보자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ kubectl exec $POD_NAME env</div><div class="line"></div><div class="line">$ kubectl exec -ti $POD_NAME bash</div></pre></td></tr></table></figure></p>
<p>서비스를 만들어보자</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ kubectl get services</div><div class="line">서비스를 확인해보자. 미니쿠베가 만든게 하나 존재한다.</div><div class="line"></div><div class="line">$ kubectl expose deployment/sangheonkim --type=&quot;NodePort&quot; --port 8080</div><div class="line">서비스를 노출시켜보자</div><div class="line"></div><div class="line">$ kubectl describe services/sangheonkim</div><div class="line">서비스를 자세히 보자</div></pre></td></tr></table></figure>
<p>Deployment를 자세히보자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ kubectl describe deployments</div></pre></td></tr></table></figure></p>
<p>보면 레이블이 있는것을 확인할 수 있는데 디플로이먼트는 저절로 레이블이 하나 생긴다.</p>
<p>레이블을 변경해보자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ kubectl label pod $POD_NAME app=v1</div><div class="line">를 입력하여 레이블을 app=v1 으로 변경하고</div><div class="line"></div><div class="line">$ kubectl describe pods $POD_NAME</div><div class="line">을 입력하여 확인해보자.</div><div class="line"></div><div class="line">$ kubectl get pods -l app=v1</div><div class="line">을 입력하여 잘반영되었나 확인해보자</div></pre></td></tr></table></figure></p>
<p>서비스를 삭제해보자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ kubectl delete service -l run=sangheonkim</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;도커툴박스설치&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/toolbox/overview/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://docs.docker.com/toolbox/overvie
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="MSA" scheme="http://KKimSangHeon.github.io/categories/CS/MSA/"/>
    
    
      <category term="kubernetes" scheme="http://KKimSangHeon.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>(K8s) 5. 여러 인스턴스를 실행하기. Scaling 하기</title>
    <link href="http://KKimSangHeon.github.io/2019/04/23/kubernetes5/"/>
    <id>http://KKimSangHeon.github.io/2019/04/23/kubernetes5/</id>
    <published>2019-04-23T12:08:06.000Z</published>
    <updated>2019-04-28T09:42:12.109Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Scaling"><a href="#Scaling" class="headerlink" title="Scaling"></a>Scaling</h4><p>애플리케이션 스케일링하기<br>이전 모듈에서 서비스를 만들고 퍼블릭하게 노출했다. 해당 디플로이멘트는 하나의 파드로 증가하도록 했다. 트래픽이 증가하면 사용자가 요구하는대로 어플리케이션을 실행할 필요 있다,.<br>스케일링은 디플러이먼트의 어플리케이션 replicas를 몇개할지 정하는것이다.</p>
<p>하나만 감싸고 있는 서비스를 여러노드에 거쳐 서비스를 스케일 아웃을 할 수 있다.<br>디플로이먼트를 스케일 아웃하면 신규 파드가 생성되어서 가용한 자원이 있는 노드에 스케줄된다. 스케일링 인은 파드개수를 줄이는것을 의미한다.</p>
<p>이는 또한 오토스케일링을 지원하기도 한다.(즉 들어오는 유동적으로 결정해주기도 함)<br>제로로 스케일링하는것도 가능한데 이는 디플로이먼트에 정의되어있는 파드를 모드 제거 하는것이다.</p>
<p>애플리케이션의 인스턴스를 복수로 구동하게 되면 트래픽을 해당 인스턴스 모두에 분산시킬 방법이 필요해진다. 서비스는 노출된 디플로이먼트의 모든 파드에 네트워크 트래픽을 분산시켜줄 통합된 로드밸런서를 갖는다. 서비스는 엔드포인트를 이용해서 구동중인 파드를 지속적으로 모니터링함으로써 가용한 파드에만 트래픽이 전달되도록 해준다.</p>
<p>일단 여러인스턴스가 실행되면 롤링 업데이트를 자동으로 할 수 있다.</p>
<p>kubectl get deployments<br>를 입력하여 디플로이 먼트 리스트를 보자<br>DESIRED는 설정에서 정의된 replicas 개수를 의미<br>CURRENT는 현재동작중인 개수<br>UP-TO-DATE 는 DESIRED를 맞추기 위해 뭐가 바뀌었는지<br>AVAILABLE 유저한테 가용할 수 있는 개수</p>
<p>replicas을 네개로 바꿔보자<br>kubectl scale deployments/kubernetes-bootcamp –replicas=4</p>
<p>kubectl get deployments<br>를 입력하여 4개가 도는지 확인해보자</p>
<p>파드는 각 다른 아이피를 갖는데<br>kubectl get pods -o wide<br>를 입력하여 4개에 대해 자세히 볼수 있다.</p>
<p>kubectl describe deployments/kubernetes-bootcamp<br>를 입력하여 변경사항을 기록한 로그를 확인할 수 있다.(replicas를 4개로 바꾼것 확인 가능)</p>
<p>kubectl describe services/kubernetes-bootcamp<br>를 입력하여 서비스가 어떤아이피로 제공하고 있는지 확인할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template=&apos;&#123;&#123;(index .spec.ports 0).nodePort&#125;&#125;&apos;)</div><div class="line">echo NODE_PORT=$NODE_PORT</div></pre></td></tr></table></figure>
<p>를 입력하여 포트를 확인해보자.</p>
<p>이번엔 아래를 입력하여 스케일 다운해보자 replicas를2개로 바꾸자<br>kubectl scale deployments/kubernetes-bootcamp –replicas=2</p>
<p>kubectl get deployments<br>를 입력하여 디폴로이 먼트의 파드 개수를 확인해보자.</p>
<p>kubectl get pods -o wide<br>를 입력하여 2개의 파드가 종료된것을 확인할 수 있다.</p>
<h4 id="Rolling-update"><a href="#Rolling-update" class="headerlink" title="Rolling update"></a>Rolling update</h4><p>유저는 어플리케이션을 항상 사용할수 있도록 원한다. 그리고 개발자는 하루에 여러번 배포할 수 있길 바란다. 이를 쿠버네티스에서 제공한느 롤링 업데이트를 통해 할 수 있다. 이는 디플로이먼트를 제로다운타임으로 점진적으로 파드를 업데이트 할 수 있다. 새파드는 가용한 리소스를 사용하여 새로운 파드가 만들어질 수 있다.</p>
<p>이전에는 여러 인스턴스를 에서 스케일링하는것을 배웠다. 기본적으로, 업데이트가 이루어지는 동안 이용 불가한 파드의 최대 개수와 생성 가능한 새로운 파드의 최대 개수는 하나다. 두 옵션은 기본적으로 업데이트할 때 파드 개수만큼 한번에 꺼버릴수있다. 그리고 최대갯수만큼 파드를 생성할 수있다.(즉 비율을 적용하여 할 수 있다.) 쿠버네티스에서 업데이트는 버전으로 관리되고 어떠한 디플로이먼트 업데이트라도 이전버전으로 원복이 가능하다.</p>
<p>어플리케이션 스케일링과 비슷하게 디플로이먼트가 노출되어있으면 서비는 가용한 파드한테만 보낸다.<br>롤링업데이트는 다음과 같은 행동을 허용한다.</p>
<ul>
<li>어플리케이션 환경 변경(컨테이너 이미지 변경방법)</li>
<li>이전버전으로 롤백</li>
<li>CI/CD 제로다운타임으로</li>
</ul>
<p>새버전으로 업데이트 하고 롤백해보자</p>
<p> kubectl get deployments<br> 를 입력하여 디폴로이 먼트들을 확인해보자(4개가 떠있다)</p>
<p> kubectl get pods<br> 를 입력하여 돌아가고 있는 파드들을 보자</p>
<p>kubectl describe pods<br>를 입력하여  이미지 버전을 보자</p>
<p>이미지를 version2로 바꾸기 위해 다음을 입력하자</p>
<p>kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2</p>
<p>kubectl get pods<br>를 입력하면 4개는 종료하고 러닝은 4개인것을 볼 수 있다.<br>즉 한번에 4개를 죽여버리고 4개를 실행<br>제로 다운타임이 아니다!!</p>
<p>kubectl describe services/kubernetes-bootcamp<br>를 입력하여 앱이 돌아가고 있는것과 아이피 포트를 확인하자</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template=&apos;&#123;&#123;(index .spec.ports 0).nodePort&#125;&#125;&apos;)</div><div class="line">echo NODE_PORT=$NODE_PORT</div></pre></td></tr></table></figure>
<p>를 입력하여 포트 설정 후</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl $(minikube ip):$NODE_PORT</div></pre></td></tr></table></figure>
<p>을 입력하여 잘 돌고있나 보자</p>
<p>kubectl rollout status deployments/kubernetes-bootcamp<br>를 입력하여 롤 아웃된것을 확인할 수 있다</p>
<p>kubectl describe pods<br>를 입력하여 현재 이미지 버전을 볼 수 있다.</p>
<p>kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=gcr.io/google-samples/kubernetes-bootcamp:v10<br>를 입력하여 이미지를 버전 10으로 바꾸자</p>
<p>kubectl get deployments<br>를 입력하여 디플로이먼트의 현재상황을 보자<br>하나가 문제가 생긴것을 확인할 수 있다.</p>
<p>kubectl get pods<br>를 하면 파드들을 더 자세히 볼 수 있다.</p>
<p>kubectl describe pods<br>를 입력하여 파드들의 상태를 보자. 이미지가 바뀐지 보자<br>봤는데 이미지가 바뀌지 않은것을 확인할 수 있다.<br>레파지토리에 v10 이 없어서 그렇다. 그러므로 롤백하자.</p>
<p>kubectl get pods<br>를 입력하여 4개가 잘 돌고있는지 보고</p>
<p>kubectl describe pods<br>를 입력하여 이미지가 잘 돌고있는지 보자</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Scaling&quot;&gt;&lt;a href=&quot;#Scaling&quot; class=&quot;headerlink&quot; title=&quot;Scaling&quot;&gt;&lt;/a&gt;Scaling&lt;/h4&gt;&lt;p&gt;애플리케이션 스케일링하기&lt;br&gt;이전 모듈에서 서비스를 만들고 퍼블릭하게 노출했다. 해당 디
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="MSA" scheme="http://KKimSangHeon.github.io/categories/CS/MSA/"/>
    
    
      <category term="kubernetes" scheme="http://KKimSangHeon.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>(K8s) 4. 서비스를 사용하여 앱을 외부로 공개하기 , 서비스 / 레이블</title>
    <link href="http://KKimSangHeon.github.io/2019/04/23/kubernetes4/"/>
    <id>http://KKimSangHeon.github.io/2019/04/23/kubernetes4/</id>
    <published>2019-04-23T12:08:01.000Z</published>
    <updated>2019-04-23T12:18:16.726Z</updated>
    
    <content type="html"><![CDATA[<h4 id="서비스를-사용하여-앱을-외부로-공개하기"><a href="#서비스를-사용하여-앱을-외부로-공개하기" class="headerlink" title="서비스를 사용하여 앱을 외부로 공개하기"></a>서비스를 사용하여 앱을 외부로 공개하기</h4><p><a href="https://kubernetes.io/ko/docs/tutorials/kubernetes-basics/expose/expose-intro/" target="_blank" rel="external">https://kubernetes.io/ko/docs/tutorials/kubernetes-basics/expose/expose-intro/</a></p>
<p>지금까지의 앱은 컨테이너 안에서 도는데 private하고 네트웍도 isolate되어있었다. 그러므로 proxy 를 붙여서 동작했었다</p>
<h4 id="쿠버네티스-서비스에-대한-개요"><a href="#쿠버네티스-서비스에-대한-개요" class="headerlink" title="쿠버네티스 서비스에 대한 개요"></a>쿠버네티스 서비스에 대한 개요</h4><p>파드는 언젠가 죽는것이다. 즉 라이프사이클이 있다. 어떤 워커노드가 죽으면 그 노드에서 돌고있는 파드도 죽는다.<br> 그렇게되면 ReplicationController 가 클러스터를 동적으로 새로운노드를 만듬으로서 복구한다. 예를들어 이미지 처리하는 백엔드가 3개의 어플리케이션을 갖고있다 해보자. 프론트엔드는 백엔드 파드가 없어지는것 생기는것에 대해 신경쓰지 말고 동작하여야 한다. 각 파드는 유니크한 아이피를 갖고있는데 애플리케이션이 계속해서 동작할 수 있도록 발생하는 변화들을 서로 감지하는 방법이 필요하다.</p>
<h3 id="서비스"><a href="#서비스" class="headerlink" title="서비스"></a>서비스</h3><p>쿠버네티스에 있는 서비스는 파드의 set을 논리적으로 정의 한것이고 그 파드들에게 어떻게 접근할 수 있는지에 대한 정책을 정의한것이다.<br>서비스는 파드들간에 커플링을 낮춘다. 서비스는 모든 쿠버네티스 오브젝트들과 같이 YAML (보다 선호하는) 또는 JSON을 이용하여 정의되고. 서비스가 대상으로 하는 파드 셋은 보통 LabelSelector에 의해 결정된다</p>
<h4 id="서비스-외부로-노출하기"><a href="#서비스-외부로-노출하기" class="headerlink" title="서비스 외부로 노출하기"></a>서비스 외부로 노출하기</h4><p>비록 각각의 파드가 제각각의 IP를 갖고있지만 서비스 없이는 클러스터 바깥으로 노출되지 않는다. 서비스는 어플리케이션이 트래픽을 받게할 수 있는데 ServiceSpec에 type을 지정하여 노출 할 수 있다.</p>
<h4 id="ServiceSpec의-type"><a href="#ServiceSpec의-type" class="headerlink" title="ServiceSpec의 type"></a>ServiceSpec의 type</h4><ul>
<li>ClusterIP (기본값) - 클러스터 내에서 내부 IP 에 대해 서비스를 노출해준다. 이 방식은 오직 클러스터 내에서만 서비스가 접근될 수 있도록 해준다.</li>
<li>NodePort - NAT가 이용되는 클러스터 내에서 각각 선택된 노드들의 동일한 포트에 서비스를 노출시켜준다. <nodeip>:<nodeport>를 이용하여 클러스터 외부로부터 서비스가 접근할 수 있도록 해준다. CluserIP의 상위 집합이다.</nodeport></nodeip></li>
<li>LoadBalancer - (지원 가능한 경우) 기존 클라우드에서 외부용 로드밸런서를 생성하고 서비스에 고정된 공인 IP를 할당해준다. NodePort의 상위 집합이다.</li>
<li>ExternalName - 프록시를 사용하지 않고 임의의 Name을 사용해서 expose 하는방법으로 externalName을 스펙에다 정의함(YAML 혹은 JSON)  kube-dns 1.7 이상 요구됨</li>
</ul>
<p>추가적으로 셀렉터를 지정하지 않는경우도 있는데 셀렉터를 지정하지 않은것은 엔드포인트를 오브젝트를 만들지 않을것이다. 그렇게 함으로써 유저들로 하여금 직접 서비스를 특정엔드포인트에 매핑할 수 있도록 해준다. selector를 생략하게 되는 또 다른 가능성은 여러분이 type: ExternalName을 이용하겠다고 확고하게 의도하는 경우이다.</p>
<h4 id="서비스와-레이블"><a href="#서비스와-레이블" class="headerlink" title="서비스와 레이블"></a>서비스와 레이블</h4><p>서비스는 파드들의 묶음인데 하나의 ip로 묶인다. 하나의 아이피는 외부에 노출되어 서비스안에 존재하는 파드들에 접근할 수 있게해준다. 서비스는 파드셋에다가 트래픽을 라우팅(쿠버네티스 서비스들에 의해 처리된다.)하는데 서비스는 파드가 애플리케이션에 영향을 주지않고 혼자 죽거나 살아날 수 있도록 한다.</p>
<p>파드 셋을 label이랑 selector을 사용하여 매치한다. label은 key / value 쌍이며 오브젝트에 붙어있고 여러가지 방식으로 사용될 수 있다.</p>
<ul>
<li>개발, 테스트, 그리고 상용환경에 대한 객체들의 지정</li>
<li>임베디드된 버전 태그들</li>
<li>태그들을 이용하는 객체들에 대한 분류</li>
</ul>
<p>레이블은 오브젝트가 만들어 질때 붙일수도 있고 나중에 붙일수있고 아무때나 수정할 수 있다.</p>
<p>kubectl get pods<br>를 입력하고 파드들을 확인해보자.</p>
<p>kubectl get services<br>를 입력하여 서비스를 확인해보자. 만들지도 않았는데 하나가 돌아가고 있는데 클러스터에서 미니큐브를 만들면 실행되는것이다.</p>
<p>새로운 서비스를 만들고 노출하려면 다음과 노트 포트를 파라미터로 줘야한다.<br>kubectl expose deployment/kubernetes-bootcamp –type=”NodePort” –port 8080<br>내부 8080포트에 붙으라는것.</p>
<p>kubectl get services<br>를 입력하여 서비스를 확인해보자.<br>하나가 더 추가가 된것을 알 수 있다.</p>
<p>서비스가 클러스터ip로 인터널, external 포트가 있다.</p>
<p>kubectl describe services/kubernetes-bootcamp<br>를 입력하여 자세히 살펴보자.</p>
<p>노드포트라는 환경변수를 만들자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template=&apos;&#123;&#123;(index .spec.ports 0).nodePort&#125;&#125;&apos;)</div><div class="line"></div><div class="line">echo NODE_PORT=$NODE_PORT</div></pre></td></tr></table></figure></p>
<p>아래를 입력하여 접근해보자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl $(minikube ip):$NODE_PORT</div></pre></td></tr></table></figure></p>
<p>디플로이먼트는 자동으로 레이블이 하나있다.<br>이를통해 파드리스트를 쿼리해보자.<br>kubectl get pods -l run=kubernetes-bootcamp<br>run=kubernetes-bootcamp이 label이다.</p>
<p>kubectl get services -l run=kubernetes-bootcamp<br>를 입력하여 run=kubernetes-bootcamp 이라는 레이블을 갖고있는 서비스를 조회해보자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export POD_NAME=$(kubectl get pods -o go-template --template &apos;&#123;&#123;range .items&#125;&#125;&#123;&#123;.metadata.name&#125;&#125;&#123;&#123;&quot;\n&quot;&#125;&#125;&#123;&#123;end&#125;&#125;&apos;)</div><div class="line">echo Name of the Pod: $POD_NAME</div></pre></td></tr></table></figure>
<p>를 입력하여 파드 네임을 환경변수에 넣어보자.</p>
<p>app=v1으로 새로운이름을 주자.<br>kubectl label pod $POD_NAME app=v1</p>
<p>kubectl describe pods $POD_NAME<br>레이블 확인해보자.</p>
<p>kubectl get pods -l app=v1<br>바뀐 레이블로 파드를 조회해보자.</p>
<p>kubectl delete service -l run=kubernetes-bootcamp<br>를 입력하여 서비스를 삭제하자.</p>
<p>kubectl get services<br>서비스를 확인해보자.</p>
<p>라우팅도 잘 안되나 확인해보자.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl $(minikube ip):$NODE_PORT</div></pre></td></tr></table></figure></p>
<p>파드안에서 동작하는 아래의 명령어를 통해 아직 파드가 동작는지 보자.<br>kubectl exec -ti $POD_NAME curl localhost:8080</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;서비스를-사용하여-앱을-외부로-공개하기&quot;&gt;&lt;a href=&quot;#서비스를-사용하여-앱을-외부로-공개하기&quot; class=&quot;headerlink&quot; title=&quot;서비스를 사용하여 앱을 외부로 공개하기&quot;&gt;&lt;/a&gt;서비스를 사용하여 앱을 외부로 공개하기&lt;/
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="MSA" scheme="http://KKimSangHeon.github.io/categories/CS/MSA/"/>
    
    
      <category term="kubernetes" scheme="http://KKimSangHeon.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>(K8s) 3. Pods and Nodes</title>
    <link href="http://KKimSangHeon.github.io/2019/04/23/kubernetes3/"/>
    <id>http://KKimSangHeon.github.io/2019/04/23/kubernetes3/</id>
    <published>2019-04-23T12:07:56.000Z</published>
    <updated>2019-04-23T12:14:58.383Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Pods"><a href="#Pods" class="headerlink" title="Pods"></a>Pods</h4><p><a href="https://kubernetes.io/ko/docs/tutorials/kubernetes-basics/explore/explore-intro/" target="_blank" rel="external">https://kubernetes.io/ko/docs/tutorials/kubernetes-basics/explore/explore-intro/</a></p>
<p>디플로이먼트를 만들면 쿠버네티스는 파드를 만들어 어플리케이션 인스턴스를 호스트 해준다. 파드는 쿠버네티스 인스턴스이며 하나 또는 여러 컨테이너(도커나 rkt) 그룹을 추상화한것이다. 컨테이너 뿐만아니라 컨테이너들이 사용하는 리소스도 포함해서 파드라고 한다.</p>
<p>리소스는 다음을 포함한다.</p>
<ul>
<li>볼륨과 같은, 공유 스토리지</li>
<li>클러스터 IP 주소와 같은, 네트워킹</li>
<li>컨테이너 이미지 버전 또는 사용할 특정 포트와 같이, 각 컨테이너가 동작하는 방식에 대한 정보</li>
</ul>
<p>파드는 어플리케이션에 특화된 논리적인 호스트를 모델링한것이고 다른 어플리케이션 컨테이너를 이 안에 담아놓을 수 있으며 비교적 관련있는것들 끼리 모아놓은것이다. 예를 들어 하나의 팟안에다 두개의 컨테이너를 하나에 파드에 넣을 수 있다, 하나의 파드안에 들은 컨테이너들은 IP와 포트를 공유한다. 그래서 항상 같이 존재하며 같이 스케줄링된다.</p>
<p>파드는 atomic unit 이다. 쿠버네티스에서 디플로이먼트를 만들었을때 디플로이먼트는 컨테이너를 갖고있는 파드를 만든다.(컨테이너를 직접 만드는것이 아님)<br>각각의 파드가 특정한 노드에 묶이게 되고 그 노드안에서 살게된다. 노드가 실패하면 동일한 파드를 또다른 클러스터에 있는 다른노드에서 실행한다.<br>즉 파드 단위로 옮겨다닌다.</p>
<h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><p>파드를 실행하는게 노드이며 노드는 쿠버네티스에서 워커머신이다.(쿠버네티스는 마스터, 워커노드가 존재) 노드는 버츄얼 피지컬 머신일 수 도있다. 노드는 마스터에서 관리되면 여러개의 파드를 갖고있으며 쿠버네티스 마스터는 자동으로 어떤 파드를 노드에 올릴지 클러스터링 한다. 마스터의 자동 스케줄링은 가용한 리소스를 고용해서..</p>
<p>모든 쿠버네티스 노드는 최소한 다음을 실행한다</p>
<ul>
<li><p>Kubelet(팀장님)은, 쿠버네티스 마스터(본부장님)와 노드 간 통신을 책임지는 프로세스이며, 하나의 머신 상에서 동작하는 파드와 컨테이너를 관리한다.</p>
</li>
<li><p>(도커, rkt)와 같은 컨테이너 런타임은 레지스트리에서 컨테이너 이미지를 가져와 묶여 있는 것을 풀고 애플리케이션을 동작시키는 책임을 맡는다.</p>
</li>
</ul>
<p>노드 개요<br>노드안에 파드가 여러개 들어갈 수 있고 파드는 각 아이피를 할당받는다. Kubelet이 노드들을 관리</p>
<p>kubectl을 통해서 배포된 앱들의 정보를 가져올 수 있다.<br>kubectl get - 자원을 나열한다<br>kubectl describe - 자원에 대해 상세한 정보를 보여준다.<br>kubectl logs - 파드 내 컨테이너의 로그들을 출력한다<br>kubectl exec - 파드 내 컨테이너에 대한 명령을 실행한다.</p>
<p>언제 애플리케이션이 배포되었으며, 현재 상태가 어떠한지, 그것의 구성은 어떠한지 등을 보기 위해 이러한 명령을 이용할 수 있다.</p>
<p>kubectl get pods<br>를 입력하여 파드가 있나 확인해보고 없으면 빌드를 다시해라</p>
<p>kubectl describe pods<br>를 입력하여 파드에 대한 자세한 정보를 보자.IP, Port, Event<br>결과물은</p>
<p>kubectl describe node<br>를 입력하여 노드 정보를 갖고올 수 있다.</p>
<p>파드가 isolate, private 네트웍에서 동작하기에 kubectl proxy를 써서 사용하였었다.</p>
<p>kubectl proxy<br>를 입력하여 프록시르 띄우자</p>
<p>파드네임과 쿼리를 갖고와 프록시를 해보자.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export POD_NAME=$(kubectl get pods -o go-template --template &apos;&#123;&#123;range .items&#125;&#125;&#123;&#123;.metadata.name&#125;&#125;&#123;&#123;&quot;\n&quot;&#125;&#125;&#123;&#123;end&#125;&#125;&apos;)</div><div class="line">echo Name of the Pod: $POD_NAME</div></pre></td></tr></table></figure></p>
<p>동작하고 있는 애플리케이션 정보를 보고싶다면<br>curl <a href="http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/proxy/" target="_blank" rel="external">http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/proxy/</a><br>를 입력하면 된다.</p>
<p>애플리케이션에서 보통 STDOUT로 내보내는데 그것이 로그가 된다. 이를 쿠버네티스 다음명령오로 가져올 수 있다.<br>kubectl logs $POD_NAME<br>(지금은 컨테이너가 파드안에 하나이기 때문에 지정하지 않아도 된다.)</p>
<p>파드가 동작하고 있으면 그안에 컨테이너에게 명령어를 실행할 수 있는데 다음과 같이 하면된다.<br>kubectl exec $POD_NAME env<br>(컨테이너 이름을 생략할수 있는것은 지금은 파드안에 컨테이너가 하나이기 때문에)</p>
<p>kubectl exec -ti $POD_NAME bash<br>를 입력하여 NodeJS 가 돌고있는 배쉬가 생겼다.<br>이를통해 컨테이너 안에서 명령들을 동작해볼 수 있다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Pods&quot;&gt;&lt;a href=&quot;#Pods&quot; class=&quot;headerlink&quot; title=&quot;Pods&quot;&gt;&lt;/a&gt;Pods&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/ko/docs/tutorials/kubernetes-ba
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="MSA" scheme="http://KKimSangHeon.github.io/categories/CS/MSA/"/>
    
    
      <category term="kubernetes" scheme="http://KKimSangHeon.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>(K8s) 2. 클러스터 생성 및 앱 배포, 마스터 / 노드</title>
    <link href="http://KKimSangHeon.github.io/2019/04/23/kubernetes2/"/>
    <id>http://KKimSangHeon.github.io/2019/04/23/kubernetes2/</id>
    <published>2019-04-23T12:07:53.000Z</published>
    <updated>2019-04-23T12:12:46.994Z</updated>
    
    <content type="html"><![CDATA[<h4 id="클러스터-생성-및-앱-배포"><a href="#클러스터-생성-및-앱-배포" class="headerlink" title="클러스터 생성 및 앱 배포"></a>클러스터 생성 및 앱 배포</h4><p>이번에는 쿠버네티스란 무엇인지, 미니큐브는 무엇인지에 대해 알아보자.</p>
<p><a href="https://kubernetes.io/ko/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/" target="_blank" rel="external">https://kubernetes.io/ko/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/</a> 참고</p>
<h4 id="쿠버네티스-클러스터"><a href="#쿠버네티스-클러스터" class="headerlink" title="쿠버네티스 클러스터"></a>쿠버네티스 클러스터</h4><p>쿠버네티스는 높은 가용성을 클러스터 하는것이다. 즉 하나의 유닛으로 일하는 여러 컴퓨터들의 클러스터를 의미한다. 도커이미지를 배포할 수 있는 클러스터이다.<br>특정 머신한테 배포 설정하는것이 아니라 쿠버네티스한테 배포하라고 던지면 쿠버네티스가 알아서 배포한다.</p>
<p>이를 사용하려면 어플리케이션은 특정 호스트에 묶이지 않은상태로 패키지 되어야 한다.</p>
<p>컨테이나이저 어플리케이션은 예전 배포모델보다 유연하다. (예전모델은 특정 머신에 의존성이 있었다.)</p>
<p>쿠버네티스는 좀더 효율적인 방법으로 클러스터에 어플리케이션을 어떻게 배포하고 스케줄링해야되는지에 대해 자동화함.</p>
<p>쿠버네티스는 오픈소스이며 클러스터 환경에서 쓸 수 있다.</p>
<p>쿠버네티스는 마스터, 노드로 구성된다.<br>(스웜으로 비교하자면 각각 매니저, 워커이다. 스웜에서는 매니저, 워커 둘다 컨테이너를 띄울 수 있었다. 쿠버네티스에서는 노드에서만 컨테이너를 띄울 수 있다.)</p>
<h4 id="쿠버네티스의-마스터-노드"><a href="#쿠버네티스의-마스터-노드" class="headerlink" title="쿠버네티스의 마스터, 노드"></a>쿠버네티스의 마스터, 노드</h4><p>마스터는 어플리케이션 스케줄링, 특정 상태로 만드는일, 스케일링하는일, 새 버전을 차곡차곡 배포해 나가는것을 관리함</p>
<p>노드들은 vm이거나 물리적인 컴퓨터인데 쿠버네티스에서 워커 머신역할을 한다.<br>각각의 노드는 큐블릿을 갖고있는데 이는 노드를 관리하기 위한 에이전트이고 쿠버네티스 매니저와 의사소통한다.</p>
<p>노드는 도커 혹은 rkt와 같은 컨테이너 오퍼레이팅 툴이 필요하다.</p>
<p>쿠버네티스 클러스터는 프로덕션 트래픽을 다룰 수 있는데 이를 위해 최소 3개 이상의 노드를 갖고있어야 한다.</p>
<h4 id="쿠버네티스의-배포과정"><a href="#쿠버네티스의-배포과정" class="headerlink" title="쿠버네티스의 배포과정"></a>쿠버네티스의 배포과정</h4><ul>
<li>애플리케이션을 쿠버네티스에 배포할 때 마스터한테 어플리케이션 클러스터를 실행하라고 한다.</li>
<li>그럼 마스터는 컨테이너들을 클러스터 노드들에게 실행하도록 스케줄링 한다.</li>
<li>그럼 노드는 쿠버네티스 API를 활용해 마스터와 의사소통해서 쿠버네티스 API를 호출할 수 있다.</li>
<li>엔드유저 또한 API를 사용할 수 있다.</li>
</ul>
<h4 id="미니큐브-활용"><a href="#미니큐브-활용" class="headerlink" title="미니큐브 활용"></a>미니큐브 활용</h4><p>쿠버네티스 클러스터는 vm 혹은 물리적 컴퓨터에도 배포할 수 있다. 배포를 위해서는 미니큐브를 사용하라. 이는 쿠버네티스 경량버전이며 vm이 하나만 있다. 로컬머신에 설치할 수 있고 노드가 하나이다.<br>즉 미니큐브는 vm을 만들어주는것이고 이 안에는 노드가 하나만 들어있다.</p>
<h4 id="실습"><a href="#실습" class="headerlink" title="실습"></a>실습</h4><p>미뉴큐브가 미리 설치되어있는 온라인 환경에서 진행한다.</p>
<p>minikube start<br>를 입력하여 미니큐브를 실행하자</p>
<p>kubectl version<br>을 입력하여 버전을 한번 보자.</p>
<p>kubctl cluster-info<br>를 입력해보자.</p>
<p>kubctl get nodes<br>를 입력하여 노드 정보를 보자.<br>아까 말한대로(미니큐브에서는 노드 하나만 들어있는) 하나가 떠있는것을 볼 수 있다.</p>
<h4 id="kubectl을-활용하여-애플리케이션-배포"><a href="#kubectl을-활용하여-애플리케이션-배포" class="headerlink" title="kubectl을 활용하여 애플리케이션 배포"></a>kubectl을 활용하여 애플리케이션 배포</h4><p>동작하는 쿠버네티스가 있으면 컨테나이저된 앱을 배포할 수 있는데 이를 위해 쿠버네티스 배포 설정을 만들어야 한다.<br><code>배포 설정</code>은 쿠버네티스가 어떻게 인스턴스를 만들고 갱신해야하는지에 대한 역할을 한다.</p>
<p>이를 만들면 마스터가 노드에 배포를 한다.</p>
<p>애플리케이션 인스턴스가 한번 만들어지면 쿠버네티스 배포 컨트롤러는 지속적으로 인스턴스를 모니터링 한다. 만약 노드가 다운되거나 삭제되면 다른 노드에 배포하게 함으로서 셀프 힐링 매커니즘을 제공한다.</p>
<p>오케스트레이션이 없던시절에서는 스크립트를 사용했었다. 머신에 문제가 있을때 처리방법은 없었다.  쿠버네티스는 애플리케이션 인스턴스를 만들고 노드에 계속 실행하는것으로서 이전과는 다르다.</p>
<p>kubectl을 통해 배포를 관리하고 만들 수 있다. 이는 쿠버네티스 API를 통해 소통한다(즉 마스터와 소통한다.) 배포를 만들때는 컨테이너 이미지를 적어야되고, 몇개의 어플리케이션을 실행하기 원하는지 적어줘야함.</p>
<p>kubectl get nodes<br>입력하여 노드를 확인</p>
<p>이제 앱 배포를 따라해보자</p>
<p>kubectl run은 배포를 새로만드는것이다.<br>이를 위해 앱 이름과, 위치를 알려줘야 한다. 도커허브에 올라가있는 이미지가 아닌경우 레파지토리 uri까지 줘야한다. 앱을 특정포트에서 실행하고 싶다면 포트 파라미터까지 줘야한다.</p>
<p>kubectl run kubernetes-bootcamp –image=gcr.io/google-samples/kubernetes-bootcamp:v1 –port=8080<br>을 입력하여 배포하자. deployment 를 만듦과 동시에 배포됨.<br>이를 통해 앱을 배포할 적절한 노드를찾았고 스케줄링을 했고 클러스터를 설정했다.</p>
<p>kubectl get deployments<br>를 입력하여 deployments정보를 얻어보자</p>
<p>파드란 쿠버네티스 안에서 도는것인데 private 하고 isolate하다. 기본적으로 쿠버네티스 안에있는 파드, 서비스들 끼리는 볼 수 있지만 쿠버네티스 클러스터 밖에서는 박에서 못본다, kubectl을 사용하여 api endpoint를 사용해서 어플리케이션과 의사소통할 수 있다.</p>
<p>어플리케이션을 쿠버네티스 클러스터에서 노출시키는 방법은 모듈 4에서 본다.</p>
<p>kubectl proxy<br>를 입력하여 프록시 다른탭에서 만들면 클러스터 wide , private network와 의사소통 할 수 있게된다. 프록시를 컨트롤 씨로 종료시킬 수도 있다</p>
<p>디폴리먼트 하나, 파드하나 , 레플리카 셋이 하나 있는것을 웹 프리뷰로 볼 수 있다.</p>
<p>이를 만들면 호스트와 쿠버네티스 클러스트간에 연결된것이고, 프록시를 사용하면 API 를 직접 사용할 수 있다.</p>
<p>여기서 말하는 API는 쿠버네티스 매니저의 API</p>
<p>API서버는 자동으로 endpoint 를 각각의 pod기반으로 만들어준다. 우리는 pod네임을 가져오려면 다음과 같이하면된다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export POD_NAME=$(kubectl get pods -o go-template --template &apos;&#123;&#123;range .items&#125;&#125;&#123;&#123;.metadata.name&#125;&#125;&#123;&#123;&quot;\n&quot;&#125;&#125;&#123;&#123;end&#125;&#125;&apos;)</div><div class="line">echo Name of the Pod: $POD_NAME</div></pre></td></tr></table></figure></p>
<p>curl <a href="http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/proxy/" target="_blank" rel="external">http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/proxy/</a><br>를 입력하여 pod의 api로 라우팅할수있다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;클러스터-생성-및-앱-배포&quot;&gt;&lt;a href=&quot;#클러스터-생성-및-앱-배포&quot; class=&quot;headerlink&quot; title=&quot;클러스터 생성 및 앱 배포&quot;&gt;&lt;/a&gt;클러스터 생성 및 앱 배포&lt;/h4&gt;&lt;p&gt;이번에는 쿠버네티스란 무엇인지, 미니큐브
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="MSA" scheme="http://KKimSangHeon.github.io/categories/CS/MSA/"/>
    
    
      <category term="kubernetes" scheme="http://KKimSangHeon.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>(K8s) 1. 쿠버네티스 개요</title>
    <link href="http://KKimSangHeon.github.io/2019/04/23/kubernetes1/"/>
    <id>http://KKimSangHeon.github.io/2019/04/23/kubernetes1/</id>
    <published>2019-04-23T12:07:19.000Z</published>
    <updated>2019-04-23T12:09:25.350Z</updated>
    
    <content type="html"><![CDATA[<h4 id="쿠버네티스-개요"><a href="#쿠버네티스-개요" class="headerlink" title="쿠버네티스 개요"></a>쿠버네티스 개요</h4><p><a href="https://kubernetes.io/ko/docs/tutorials/kubernetes-basics/" target="_blank" rel="external">https://kubernetes.io/ko/docs/tutorials/kubernetes-basics/</a> 참고</p>
<p>컨테이너화된 애플리케이션들을 관리할 수 있게 해준다.</p>
<ul>
<li>컨테이너화 된 어플리케이션을 클러스터에 배포하는가. 즉 도커이미지로 만든것을 클러스터 배포하는가. 이번엔 스웜이 아닌 쿠버네티스라는 클러스터에 배포하는것.</li>
<li>어떻게 스케일할것인가.</li>
<li>어떻게 새 버전을 배포할것인가</li>
<li>어떻게 디버깅할것인지</li>
</ul>
<p>카타코드를 사용하여 가상머신을 웹에서 실행 할 수 있다.<br>미니큐브는 작게 만든 쿠버네티스이며 아무곳에서나 설치할 수 있다.</p>
<h4 id="쿠버네티스로-할수-있는것"><a href="#쿠버네티스로-할수-있는것" class="headerlink" title="쿠버네티스로 할수 있는것."></a>쿠버네티스로 할수 있는것.</h4><p>모던한 서비스는 24시간 7일동안 무정지를 기대한다. 개발자들도 새버전을 하루에 몇번씩 배포 할 수 있다는것을 기대한다. 즉 배포에 대한 수준이 높아졌다.</p>
<p>커테나이제이션을 통해 위의 높아진 수준에 부응할 수 있다. 쿠버네티스는 컨테나이저된 어플리케이션을 어디서든 실행할 수 있도록 도와준다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;쿠버네티스-개요&quot;&gt;&lt;a href=&quot;#쿠버네티스-개요&quot; class=&quot;headerlink&quot; title=&quot;쿠버네티스 개요&quot;&gt;&lt;/a&gt;쿠버네티스 개요&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/ko/docs/tutoria
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="MSA" scheme="http://KKimSangHeon.github.io/categories/CS/MSA/"/>
    
    
      <category term="kubernetes" scheme="http://KKimSangHeon.github.io/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>(Docker) 4. Stacks</title>
    <link href="http://KKimSangHeon.github.io/2019/04/21/docker4/"/>
    <id>http://KKimSangHeon.github.io/2019/04/21/docker4/</id>
    <published>2019-04-21T10:40:15.000Z</published>
    <updated>2019-04-21T10:53:13.101Z</updated>
    
    <content type="html"><![CDATA[<p>docker-machine start $(docker-machine ls -q)<br>를 입력하여 도커머신들을 띄우자</p>
<h4 id="Swarm"><a href="#Swarm" class="headerlink" title="Swarm?"></a>Swarm?</h4><p><code>스웜</code>은 <u>도커를 실행하는 머신들의 클러스터이며 애플리케이션을 배포할 수 있다. 컨테이너를 실행하고 여러머신에서 실행할 수 있다.</u></p>
<h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack?"></a>Stack?</h4><p>이번에는 구조중 가장 맨위에 있는 스택을 다루겠다. <code>스택</code>은 <u>의존성을 공유하고 있는 관련있는 서비스들의 집합이다. 스택은 전체 어플리케이션과 어떻게 조화를 이루어야하는지 짤 수 있다. 복잡한 어플리케이션의 경우 여러개의 스택을 사용할 수 있다.</u></p>
<p>docker-machine ssh myvm1 “docker swarm init –advertise-addr <myvm1의 ip="">“<br>을 입력하여 스웜 매니저로 띄워주자<br>위를 입력하면 docker swarm join –token …..이라고 출력되는데 이는 스웜에 워커를 추가하고 싶으면 이렇게 입력하라는 것이다,</myvm1의></p>
<p>두번째 머신에 아래와 같이 입력하여 워커를 추가하자<br>docker-machine ssh myvm2 “위에서 출력된값 복붙”</p>
<p>이제 머신 두개를 띄웠다.<br>즉 스웜 매니저, 워커로 띄움</p>
<p>여러개의 멀티 머신에서 띄워보자.</p>
<p>yml 파일을 아래와 같이 수정하자.<br>이전것에서 visualizer 라는 서비스가 추가됨.<br>추가된것은 호스트에 있는 파일을 컨테이너 안에다 집어넣어놨다.(dockersamples/visualizer:stable 안에 /var/run/docker.sock:/var/run/docker.sock 파일 넣음)<br><figure class="highlight"><figcaption><span>default</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">version: "3"</div><div class="line">services:</div><div class="line">  web:</div><div class="line">    # replace username/repo:tag with your name and image details</div><div class="line">    image: username/repo:tag</div><div class="line">    deploy:</div><div class="line">      replicas: 5</div><div class="line">      restart_policy:</div><div class="line">        condition: on-failure</div><div class="line">      resources:</div><div class="line">        limits:</div><div class="line">          cpus: "0.1"</div><div class="line">          memory: 50M</div><div class="line">    ports:</div><div class="line">      - "80:80"</div><div class="line">    networks:</div><div class="line">      - webnet</div><div class="line">  visualizer:</div><div class="line">    image: dockersamples/visualizer:stable</div><div class="line">    ports:</div><div class="line">      - "8080:8080"</div><div class="line">    volumes:</div><div class="line">      - "/var/run/docker.sock:/var/run/docker.sock"</div><div class="line">    deploy:</div><div class="line">      placement:</div><div class="line">        constraints: [node.role == manager]</div><div class="line">    networks:</div><div class="line">      - webnet</div><div class="line">networks:</div><div class="line">  webnet:</div><div class="line">  </div></pre></td></tr></table></figure></p>
<p>docker-machine ev myvm1<br>을 입력하여 매니저와 연결하자.</p>
<p> docker stack deploy -c docker-compose.yml getstartedlab<br> 를 입력하자. (이는 myvm1에서 실행하는것이다.)</p>
<p> docker-machine ls를 입력하여 머신의 ip를 입력하고 8080포트로 접속해보자.</p>
<p>아래를 입력하여 레디스를 추가하자<br><figure class="highlight java"><figcaption><span>default</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">redis:</div><div class="line">  image: redis</div><div class="line">  ports:</div><div class="line">    - <span class="string">"6379:6379"</span></div><div class="line">  volumes:</div><div class="line">    - <span class="string">"/home/docker/data:/data"</span></div><div class="line">  deploy:</div><div class="line">    placement:</div><div class="line">      constraints: [node.role == manager]</div><div class="line">  command: redis-server --appendonly yes</div><div class="line">  networks:</div><div class="line">    - webnet</div><div class="line">    </div></pre></td></tr></table></figure></p>
<p> docker stack deploy -c docker-compose.yml getstartedlab<br> 를 입력하여 디플로이 하자.</p>
<p>레디스는 매니저에서만 실행되므로 동일한 파일 시스템을 쓴다.(워커것과 섞이지 않음)<br>영속화를 위해 볼륨파일을 로컬에서 갖다 쓰고 매니저에서만 돌린다.</p>
<p>docker service ls<br>를 입력해서 돌아가고 있는 서비스를 확인해보자.</p>
<p>docker container ls<br>를 입력해서 각 떠있는 컨테이너들을 확인하자.</p>
<h4 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h4><p>배포하는 방법은 CE(Cloud Provider),Enterprise(Cloud provier), Enterprise(On-Premise)가 있다</p>
<p>도커 클라우드를 써서 앱을 관리할 수 있다.<br>외부 클라우드에 배포하는 방법을 알아보자.</p>
<p>도커 클라우드는 스탠다드모드, 스웜모드로 쓸 수 있다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;docker-machine start $(docker-machine ls -q)&lt;br&gt;를 입력하여 도커머신들을 띄우자&lt;/p&gt;
&lt;h4 id=&quot;Swarm&quot;&gt;&lt;a href=&quot;#Swarm&quot; class=&quot;headerlink&quot; title=&quot;Swarm?&quot;&gt;&lt;
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="MSA" scheme="http://KKimSangHeon.github.io/categories/CS/MSA/"/>
    
    
      <category term="Docker" scheme="http://KKimSangHeon.github.io/tags/Docker/"/>
    
  </entry>
  
</feed>
