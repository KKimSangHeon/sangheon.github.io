<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kim Sang Heon&#39;s Bolg</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://KKimSangHeon.github.io/"/>
  <updated>2018-06-22T05:24:08.106Z</updated>
  <id>http://KKimSangHeon.github.io/</id>
  
  <author>
    <name>Kim Sang Heon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>std::stringstream aa 불완전한 형식은 사용할 수 없습니다.</title>
    <link href="http://KKimSangHeon.github.io/2018/06/22/cpperr/"/>
    <id>http://KKimSangHeon.github.io/2018/06/22/cpperr/</id>
    <published>2018-06-22T05:21:23.000Z</published>
    <updated>2018-06-22T05:24:08.106Z</updated>
    
    <content type="html"><![CDATA[<p>std::stringstream aa 불완전한 형식은 사용할 수 없습니다.라는 에러 발생할 경우</p>
<p>해당에러의 경우 sstream 을 include 하지 않았을 확률이 높다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#include &lt;sstream&gt;</div></pre></td></tr></table></figure></p>
<p>을 추가하여 다시 확인해보자</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;std::stringstream aa 불완전한 형식은 사용할 수 없습니다.라는 에러 발생할 경우&lt;/p&gt;
&lt;p&gt;해당에러의 경우 sstream 을 include 하지 않았을 확률이 높다.&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;
    
    </summary>
    
      <category term="C++" scheme="http://KKimSangHeon.github.io/categories/C/"/>
    
    
      <category term="c++, 에러" scheme="http://KKimSangHeon.github.io/tags/c-%EC%97%90%EB%9F%AC/"/>
    
  </entry>
  
  <entry>
    <title>임베디드를 배우기 전 간략한 C 이론 6</title>
    <link href="http://KKimSangHeon.github.io/2018/06/19/embedded6/"/>
    <id>http://KKimSangHeon.github.io/2018/06/19/embedded6/</id>
    <published>2018-06-19T08:20:21.000Z</published>
    <updated>2018-06-27T01:51:57.973Z</updated>
    
    <content type="html"><![CDATA[<p>임베디드를 배우기 전 간략한 C 이론 5</p>
<p>함수포인터를 만들 때 괄호를 추가하는것을 잊지말자.<br>int (*pf)(double, int);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int temp = 5;</div><div class="line">void* ptr = &amp;temp;     // void 형 포인터: 어떤 변수의 주소값도 저장이 가능한 변수</div><div class="line">((int*)ptr) = 7;</div></pre></td></tr></table></figure>
<p>Data 영역 - 전역, static<br>Heap영역 - 동적할당영역<br>Stack영역- 지역변수, 매개변수</p>
<p>정적할당(배열) - 컴파일 타임에 할당, 접근속도가 빠르다. 코드 유지보수성 낮다(데이터 추가, 삭제)<br>동적할당 - run time(실행타임), 접근속도가 느리다.코드유지보수성이 높다.(데이터 추가 삭제 쉽다.), 메모리 낭비 x, 메모리 자동 해제(x) -&gt;직접해제할것</p>
<p>void *malloc(size_t size);<br>여기서 size_t는 typedef unsigned int size_t 로 보면된다.<br>헤더는 stdlib.h을 불러오면 된다.</p>
<p>void <em> pNew = malloc(40); 이 있다고 했을 때 pNew는 힙영역에 할당되는 변수가 아니다.
</em>((int<em>))pNew) = 5;     //좋지 않은코드
</em>((int*)pNew+1) = 7;     //좋지 않은코드</p>
<p>int <em>pt = (</em>int)pNew;<br><em>pt = 5;   또는  pt[0]=5//권장
</em>(pt+1) = 7;    또는 pt[1]=7 //권장</p>
<p>int <em> pNew = (int</em>)malloc(40);</p>
<h3 id="구조체"><a href="#구조체" class="headerlink" title="구조체"></a>구조체</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct person&#123;</div><div class="line">    int name[30];</div><div class="line">    int age;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>위와 같이 쓸수도 있지만</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">    int name[30];</div><div class="line">    int age;</div><div class="line"></div><div class="line">&#125;PER;</div></pre></td></tr></table></figure>
<p>보통 이렇게 쓴다.<br>그럼 다음과같이 선언이 가능하다,.<br>PER p1;</p>
<p>p1.name =”kim”;      //안된다. 문자열 상수이므로. 이해가 안될경우 잘생각해보자.</p>
<p>구조체 멤버변수는 디폴트로 public</p>
<p>구조체에서 “.” 은 구조체 멤버 직접접근연산자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-&gt; 간접접근연산자</div><div class="line">. 직접접근연산자</div></pre></td></tr></table></figure></p>
<p>구조체는 멤버변수간 패딩바이트를 둬서 구조체의 사이즈를 측정하면 더 크게 나올 수 있다.</p>
<p>구조체 + 포인터변수</p>
<ol>
<li>구조체 변수를 참조하는 포인터</li>
<li>포인터 변수를 구조체 멤버변수로 포함</li>
</ol>
<p>(*ptr).age == ptr-&gt;age</p>
<p>PER arr[3];      //구조체 배열</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;임베디드를 배우기 전 간략한 C 이론 5&lt;/p&gt;
&lt;p&gt;함수포인터를 만들 때 괄호를 추가하는것을 잊지말자.&lt;br&gt;int (*pf)(double, int);&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
    
    </summary>
    
      <category term="임베디드" scheme="http://KKimSangHeon.github.io/categories/%EC%9E%84%EB%B2%A0%EB%94%94%EB%93%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>임베디드를 배우기 전 간략한 C 이론 5</title>
    <link href="http://KKimSangHeon.github.io/2018/06/18/embedded4/"/>
    <id>http://KKimSangHeon.github.io/2018/06/18/embedded4/</id>
    <published>2018-06-18T08:59:01.000Z</published>
    <updated>2018-06-27T01:52:00.453Z</updated>
    
    <content type="html"><![CDATA[<p>*(pa+0) == pa[0]</p>
<p>포인터 배열 - 포인터를 묶어놓은 배열이다.</p>
<p>더블포인터 - 싱글포인터의 주소를 저장하는 용도로써 사용된다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">int arr_m[3][4] = &#123;</div><div class="line">    &#123;5,6,7,8&#125;,</div><div class="line">    &#123;9,10,11,12&#125;,</div><div class="line">    &#123;13,14,15,16&#125;</div><div class="line">&#125; //2차원 배열 선언과 동시 초기화</div><div class="line"></div><div class="line">int row,col;</div><div class="line"></div><div class="line">for (row = 0;row&lt;3; row++)</div><div class="line">&#123;</div><div class="line">    for(col = 0;col&lt;4;col++)</div><div class="line">          printf(&quot;arr_m[%d][%d]:%d&quot;, row, col, arr_m[row][col]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>위의 경우에서 arr_m[2] == arr_m+2 == arr_m[2][0]</p>
<p>int (<em>pa)[3];     //길이가 3인 int형 2차원 배열을 가르키는 포인터 변수(배열포인터)<br>int </em>pa[3];     //포인터 배열</p>
<p>포인터배열 배열포인터를 헷갈리지 말자<br>배열 포인터는 - 2차원 배열을 가르키는 포인터<br>포인터 배열을 - 포인터를 배열로 만들어 놓은것.</p>
<p>char *(str)[50]; 일 때<br>str[0]+1 != str+1<br>좌측은 50만큼 증가하고 우측은 1바이트씩 증가</p>
<p>자료형 앞에 register 을 넣으면 변수가 register 변수에 저장이 된다. 빠르다!</p>
<p>static의 생존기간은 전역변수와 같지만 메모리 존재범위은 블록 내에서만!</p>
<h3 id="함수포인터"><a href="#함수포인터" class="headerlink" title="함수포인터"></a>함수포인터</h3><p>함수명은 함수의 시작주소이다.</p>
<p>함수 포인터를 만드려고 하니<br>int <em>ptr(int a, int b); 와같은 형태가 나왔다,<br>이는 리턴타입이 int </em> 이라는 함수선언과 같으므로<br>괄호를 씌워 int (*ptr)(int a, int b); 로 함수포인터를 만든다.</p>
<p>배열포인터와 유사한 형태로 만들어졌다.<br>배열 포인터 또한 int <em>arr[3] 으로 만들라 했으나 이는 포인터 배열과 일치하므로 괄호를 추가해 int (</em>arr)[3]으로 처리했다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int Add(int a, int b);</div><div class="line"></div><div class="line">int (*ptr)(int a, int b) = Add;</div></pre></td></tr></table></figure></p>
<p>위와같이 사용한다.</p>
<p>ptr(2,3) // 간접호출<br>Add(2,3) //직접호출</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">int temp = 5;</div><div class="line">int * ptr = &amp;temp;</div><div class="line">void* pv = &amp;temp;     //가능하다.</div><div class="line"></div><div class="line">*pv = 8;     //불가능하다(시작부터 몇바이트를 읽을지는 pv의 자료형으로 판단하는데 몇바이트로 접근해야할지 알 수 없다)</div><div class="line">*((int*)pv) = 8 //가능</div></pre></td></tr></table></figure>
<p>void형 포인터는 모든 변수의 주소값을 저장할 수 있다.</p>
<p>주소값을 표현할 땐 다음과 같이<br><em>((volatile unsigned int</em>)0x80000000) = 0xFF000000;     //나중에 다시한번 배운다.</p>
<p>volatile 은 주소값의 데이터가 변경되는것을 막는다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;*(pa+0) == pa[0]&lt;/p&gt;
&lt;p&gt;포인터 배열 - 포인터를 묶어놓은 배열이다.&lt;/p&gt;
&lt;p&gt;더블포인터 - 싱글포인터의 주소를 저장하는 용도로써 사용된다.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr
    
    </summary>
    
      <category term="임베디드" scheme="http://KKimSangHeon.github.io/categories/%EC%9E%84%EB%B2%A0%EB%94%94%EB%93%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>임베디드를 배우기 전 간략한 C 이론 3</title>
    <link href="http://KKimSangHeon.github.io/2018/06/15/embedded3/"/>
    <id>http://KKimSangHeon.github.io/2018/06/15/embedded3/</id>
    <published>2018-06-15T04:19:26.000Z</published>
    <updated>2018-06-27T01:52:03.488Z</updated>
    
    <content type="html"><![CDATA[<p>변수와 상수는 다른것이다.<br>연산자는 사칙연산, 비트연산, 논리연산, 비교연산이 있다.<br>자료형은 char short int float double가 있다.</p>
<p>배열명은 배열의 시작주소를 의미한다.<br>&amp;data[0] == data</p>
<p>배열명은 주소를 바꿀 수 없는 포인터 상수이다.</p>
<p>조건부 컴파일<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#if(0)</div><div class="line">    1번로직</div><div class="line">#else</div><div class="line">    2번로직</div><div class="line">#endif</div></pre></td></tr></table></figure></p>
<p>2번로직이 실행된다.</p>
<p>C 라이브러리 모음<br><a href="http://www.soen.kr/" target="_blank" rel="external">http://www.soen.kr/</a></p>
<p>LR 복귀주소를 저장(함수가 종료되고 다시 시작되어야할 주소)<br>LR들은 스택에 저장되게 되는데 최근 이동해야 할 곳을 가르키고 있는 포인터를 스택 포인터라함.<br>보통 스택이 4단계 이상 쌓이면 설계를 다시해보는것을 고려해 봐야 한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int Add(int a)</div><div class="line">&#123;</div><div class="line">    return tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>함수 명 Add가 함수의 시작주소이다.</p>
<p>ISR 인터럽트 서비스 루틴 - 특정인터럽트가 발생했을 때 처리해라.</p>
<p>폴링 인터럽트 둘다 이벤트가 발생했을 때 ISR로 가서 처리하고 메인으로 돌아온다.<br>폴링은 함수를 호출해야하고 인터럽트는 호출 없이 서비스 로직이 실행된다.</p>
<p>0 == false == off == 0v == clear == low<br>1 == true == on == 5v == set == high</p>
<p>워치독 타이머 : 컴퓨터의 오작동을 탐지하고 복구하기 위해 쓰이는 전자 타이머이다. 정상 작동 중의 컴퓨터는 시간이 경과하거나 “타임아웃”이 되는 것을 막기 위해, 정기적으로 워치독 타이머를 재가동 시킨다.(내부적으로 소프트웨어를 리셋시키는 타이머)</p>
<p>지역변수 - 해당 함수안에서만 접근, 해당함수 시작과 동시에 메모리에 올라갔다 함수 종료시 소멸된다.</p>
<p>지역변수는 m_를 붙여서 처리하기도 한다.</p>
<p>call by value - 복사대입에 의한 호출<br>call by address (pointer) - 포인터를 이용하여 호출<br>call by reference - 참조자를 이용하는것</p>
<p>모든 포인터 변수는 32비트 시스템에서 4바이트로 동일하다</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;변수와 상수는 다른것이다.&lt;br&gt;연산자는 사칙연산, 비트연산, 논리연산, 비교연산이 있다.&lt;br&gt;자료형은 char short int float double가 있다.&lt;/p&gt;
&lt;p&gt;배열명은 배열의 시작주소를 의미한다.&lt;br&gt;&amp;amp;data[0] =
    
    </summary>
    
      <category term="임베디드" scheme="http://KKimSangHeon.github.io/categories/%EC%9E%84%EB%B2%A0%EB%94%94%EB%93%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>임베디드를 배우기 전 간략한 C 이론 2</title>
    <link href="http://KKimSangHeon.github.io/2018/06/13/embeded2/"/>
    <id>http://KKimSangHeon.github.io/2018/06/13/embeded2/</id>
    <published>2018-06-13T06:54:56.000Z</published>
    <updated>2018-06-27T01:52:06.825Z</updated>
    
    <content type="html"><![CDATA[<p>변수선언-&gt; 자료형 변수명;<br>변수사용-&gt; 변수명<br>오버플러우 : 할당할 수 있는 범위를 넘어선 입력</p>
<p>빅 앤디안 : 낮은 어드레스에 높은 바이트를 넣는다<br>리틀 앤디안 : 낮은 어드레스에 낮은 바이트를 넣는다(ARM, Intel이 사용한다)</p>
<p>내 컴퓨터가 리틀앤디안인지 빅앤디안인지 알아봐라<br>포인터로 한바이트만 읽어서 체크해보자</p>
<p>팬아웃 : 신호가 변질되는것 방지하는것 . 버퍼를 달아서 구현할 수 있다.</p>
<p>Not-G (inverter) : 역으로 변경<br>X-Or Gate : 다를 때 참<br>3-State Buffer  : B에 신호가 1이여야 A에서 X로 출력됨. B 신호가 0이면 A에서 X로 아무것도 출력되지 않는 고저항상태가 된다.</p>
<p>char의 범위 -127~128</p>
<p>비트연산<br>| : 비트 or<br>&amp; : 비트 And<br>~ : 비트 Not<br>&lt;&lt; : 비트 왼쪽시프트</p>
<blockquote>
<blockquote>
<p>: 비트 오른쪽시프트<br>^ : 비트 xor</p>
</blockquote>
</blockquote>
<p>MSB만 역으로 만들기 위한방법<br>res&amp; = ~(0x01&lt;<7); <figure="" class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">my_strcpy(char* ps, char* pb)</div><div class="line">&#123;</div><div class="line">    while(*ps!=&apos;\0&apos;)</div><div class="line">     &#123;</div><div class="line">           *pb = *ps;</div><div class="line">            pb++;</div><div class="line">            ps++;</div><div class="line">     &#125;</div><div class="line">    *pb = &apos;\0&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></7);></p>
<p>연산자가 많이 들어갈 경우 괄호로 묶어주도록 하자</p>
<p>case문을 이용할 때 break문을 잘 사용하자</p>
<p>polling: 계속적으로 반복해서 돌아가는것<br>인터럽트: 갑작스럽게 이벤트가 발생했을 때 처리함<br>임베디드는 폴링과 인터럽트로 구성된다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;변수선언-&amp;gt; 자료형 변수명;&lt;br&gt;변수사용-&amp;gt; 변수명&lt;br&gt;오버플러우 : 할당할 수 있는 범위를 넘어선 입력&lt;/p&gt;
&lt;p&gt;빅 앤디안 : 낮은 어드레스에 높은 바이트를 넣는다&lt;br&gt;리틀 앤디안 : 낮은 어드레스에 낮은 바이트를 넣는다(A
    
    </summary>
    
      <category term="임베디드" scheme="http://KKimSangHeon.github.io/categories/%EC%9E%84%EB%B2%A0%EB%94%94%EB%93%9C/"/>
    
    
      <category term="c, embedded" scheme="http://KKimSangHeon.github.io/tags/c-embedded/"/>
    
  </entry>
  
  <entry>
    <title>임베디드를 배우기 전 간략한 C 이론 1</title>
    <link href="http://KKimSangHeon.github.io/2018/06/11/embeded/"/>
    <id>http://KKimSangHeon.github.io/2018/06/11/embeded/</id>
    <published>2018-06-11T14:53:29.000Z</published>
    <updated>2018-06-27T01:52:09.788Z</updated>
    
    <content type="html"><![CDATA[<p>컴파일 : 컴퓨터가 아는 언어로 변경하는것 원시코드를 오브젝트로 (syntax에러 확인)<br>컴파일러 : 이를 실행시켜주는것<br>링커 : 라이브러리를 묶어주고 실행파일을 만든다.</p>
<p>전처리기 : 컴파일 전에 처리</p>
<p>함수는 라이브러리, 사용자 정의 함수로 나뉜다.</p>
<p>함수는 함수원형, 호출, 정의부로 나뉘는데 원형은 함수의 뼈대라고 보면 되고 , 정의는 함수의 동작을 정의한는 부분으로 보면된다.</p>
<p>int main(int argc, char * argv[])<br>argc는 - arg counter 로 생각하자<br>두번째 포인터 배열이지만 더블포인터로 볼 수 있다.</p>
<p>메인함수의 경우 vs에서 return을 하지 않을경우 에러가 발생하지 않는데 이는 잘못된것이다.<br>리턴타입이 int인데 return이 없는것은 잘못된것을 알고있자.</p>
<p>반환형이 void인 함수의 return은 함수의 종료를 의미한다.</p>
<p>return은 함수의 값 반환, 함수의 종료역할을 한다.</p>
<p>ARM 프로세서에는<br>byte(1byte) / half-word(2byte) / word(4byte) 이란게 있다. 일단 알아만 두자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if ( temp = 5) &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>위와같은 코드는 절대 짜지말자. if문이 뭐 저래</p>
<p>헷갈릴수 있는 개념<br>더블 포인터 - 포인터의 주소를 저장하는 변수<br>포인터배열 - 포인터를 모아놓은 포인터<br>배열포인터 - 2차원 배열의 조소를 저장해놓은 변수<br>함수포인터 - 함수의 주소를 저장해 놓은 변수<br>구조체 - 다른 형태의 변수를 배열처럼 저장하기 위해 만들었다.</p>
<p>서식문자<br>%d - 정수<br>%c - 문자<br>%s - 문자열<br>%f - float 자료형<br>%lf - double형 자료형<br>%u - unsigned<br>%x - hex</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;컴파일 : 컴퓨터가 아는 언어로 변경하는것 원시코드를 오브젝트로 (syntax에러 확인)&lt;br&gt;컴파일러 : 이를 실행시켜주는것&lt;br&gt;링커 : 라이브러리를 묶어주고 실행파일을 만든다.&lt;/p&gt;
&lt;p&gt;전처리기 : 컴파일 전에 처리&lt;/p&gt;
&lt;p&gt;함수는 
    
    </summary>
    
      <category term="임베디드" scheme="http://KKimSangHeon.github.io/categories/%EC%9E%84%EB%B2%A0%EB%94%94%EB%93%9C/"/>
    
    
      <category term="c, embedded" scheme="http://KKimSangHeon.github.io/tags/c-embedded/"/>
    
  </entry>
  
  <entry>
    <title>string does not name a type</title>
    <link href="http://KKimSangHeon.github.io/2018/05/07/cpperror6/"/>
    <id>http://KKimSangHeon.github.io/2018/05/07/cpperror6/</id>
    <published>2018-05-07T05:22:47.000Z</published>
    <updated>2018-06-08T03:53:32.033Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">분명히 string을 include 했을때도 발생한다면 namespace를 붙여줬는지 확인해보자</div><div class="line">아니면 using namespace std; 을 선언하자</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;c
    
    </summary>
    
      <category term="C++" scheme="http://KKimSangHeon.github.io/categories/C/"/>
    
    
      <category term="c++, 에러" scheme="http://KKimSangHeon.github.io/tags/c-%EC%97%90%EB%9F%AC/"/>
    
  </entry>
  
  <entry>
    <title>conflicting declaration ‘std::string tempJsonData’</title>
    <link href="http://KKimSangHeon.github.io/2018/05/07/cpperror5/"/>
    <id>http://KKimSangHeon.github.io/2018/05/07/cpperror5/</id>
    <published>2018-05-07T05:22:17.000Z</published>
    <updated>2018-06-08T03:53:33.101Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">변수명이 겹치는것이 존재하는경우 발생하는 에러이다.</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;lin
    
    </summary>
    
      <category term="C++" scheme="http://KKimSangHeon.github.io/categories/C/"/>
    
    
      <category term="c++, 에러" scheme="http://KKimSangHeon.github.io/tags/c-%EC%97%90%EB%9F%AC/"/>
    
  </entry>
  
  <entry>
    <title>분명히 inlcude를 했는데  was not declared in this scope 라고 뜨는경우</title>
    <link href="http://KKimSangHeon.github.io/2018/05/07/cpperror4/"/>
    <id>http://KKimSangHeon.github.io/2018/05/07/cpperror4/</id>
    <published>2018-05-07T05:20:20.000Z</published>
    <updated>2018-06-08T03:53:33.806Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">이 경우 다른 파일의 헤더와 겹치는 경우일 수 있다.</div><div class="line">#ifndef _AA_H</div><div class="line">#define _AA_H 라고 헤더를 정의했을 때 다른파일도 헤더를 AA로 선언했을 가능성이 높다.</div><div class="line"></div><div class="line">무분별한 복붙을 지양하자..</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/di
    
    </summary>
    
      <category term="C++" scheme="http://KKimSangHeon.github.io/categories/C/"/>
    
    
      <category term="c++, 에러" scheme="http://KKimSangHeon.github.io/tags/c-%EC%97%90%EB%9F%AC/"/>
    
  </entry>
  
  <entry>
    <title>no matching function for call to ‘~~~, &lt;unresolved overloaded function type&gt;, ~~~)’</title>
    <link href="http://KKimSangHeon.github.io/2018/05/07/cpperror3/"/>
    <id>http://KKimSangHeon.github.io/2018/05/07/cpperror3/</id>
    <published>2018-05-07T05:20:12.000Z</published>
    <updated>2018-06-08T03:53:34.376Z</updated>
    
    <content type="html"><![CDATA[<p>함수 호출부의 2번째 인자를 확인해보자</p>
<p>대표적으로 값을 반환하는 함수를 호출하는데 ()를 붙이지 않았을 경우 발생</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;함수 호출부의 2번째 인자를 확인해보자&lt;/p&gt;
&lt;p&gt;대표적으로 값을 반환하는 함수를 호출하는데 ()를 붙이지 않았을 경우 발생&lt;/p&gt;

    
    </summary>
    
      <category term="C++" scheme="http://KKimSangHeon.github.io/categories/C/"/>
    
    
      <category term="c++, 에러" scheme="http://KKimSangHeon.github.io/tags/c-%EC%97%90%EB%9F%AC/"/>
    
  </entry>
  
  <entry>
    <title>definition of implicitly-declared ‘DataBuffer::DataBuffer()’ 에러</title>
    <link href="http://KKimSangHeon.github.io/2018/05/06/cpperror2/"/>
    <id>http://KKimSangHeon.github.io/2018/05/06/cpperror2/</id>
    <published>2018-05-06T13:47:39.000Z</published>
    <updated>2018-06-08T03:53:14.317Z</updated>
    
    <content type="html"><![CDATA[<p>헤더파일에 해당 생성자를 선언하지 않았을 경우 발생</p>
<p>생성자를 다시한번 살펴보자</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;헤더파일에 해당 생성자를 선언하지 않았을 경우 발생&lt;/p&gt;
&lt;p&gt;생성자를 다시한번 살펴보자&lt;/p&gt;

    
    </summary>
    
      <category term="C++" scheme="http://KKimSangHeon.github.io/categories/C/"/>
    
    
      <category term="c++, 에러" scheme="http://KKimSangHeon.github.io/tags/c-%EC%97%90%EB%9F%AC/"/>
    
  </entry>
  
  <entry>
    <title>‘size_t’ does not name a type 에러가 발생했을 때</title>
    <link href="http://KKimSangHeon.github.io/2018/05/05/cpperror/"/>
    <id>http://KKimSangHeon.github.io/2018/05/05/cpperror/</id>
    <published>2018-05-05T13:19:09.000Z</published>
    <updated>2018-06-09T14:29:36.893Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">다음중 아무거나 include하자</div><div class="line">Defined in header &lt;cstddef&gt;         </div><div class="line">Defined in header &lt;cstdio&gt;      </div><div class="line">Defined in header &lt;cstring&gt;         </div><div class="line">Defined in header &lt;ctime&gt;       </div><div class="line">Defined in header &lt;cwchar&gt;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/di
    
    </summary>
    
      <category term="C++" scheme="http://KKimSangHeon.github.io/categories/C/"/>
    
    
      <category term="c++, 에러" scheme="http://KKimSangHeon.github.io/tags/c-%EC%97%90%EB%9F%AC/"/>
    
  </entry>
  
  <entry>
    <title>터미널을 종료해도 서버가 켜져있도록 유지</title>
    <link href="http://KKimSangHeon.github.io/2018/05/01/angular/"/>
    <id>http://KKimSangHeon.github.io/2018/05/01/angular/</id>
    <published>2018-05-01T08:46:42.000Z</published>
    <updated>2018-05-03T13:43:03.736Z</updated>
    
    <content type="html"><![CDATA[<p>터미널을 종료해도 서벼가 켜져있도록 유지하는 방법</p>
<p>npm으로 forever을 설치 후<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">forever start node_modules/@angular/cli/bin/ng serve --host=0.0.0.0</div><div class="line">forever stopall</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;터미널을 종료해도 서벼가 켜져있도록 유지하는 방법&lt;/p&gt;
&lt;p&gt;npm으로 forever을 설치 후&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;
    
    </summary>
    
      <category term="Web" scheme="http://KKimSangHeon.github.io/categories/Web/"/>
    
      <category term="Angular2" scheme="http://KKimSangHeon.github.io/categories/Web/Angular2/"/>
    
    
      <category term="Angular2" scheme="http://KKimSangHeon.github.io/tags/Angular2/"/>
    
      <category term="Web" scheme="http://KKimSangHeon.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>C++ 함수에서의 참조자의 활용</title>
    <link href="http://KKimSangHeon.github.io/2018/04/16/cpp1/"/>
    <id>http://KKimSangHeon.github.io/2018/04/16/cpp1/</id>
    <published>2018-04-15T23:19:55.000Z</published>
    <updated>2018-06-09T14:29:31.937Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="C++" scheme="http://KKimSangHeon.github.io/categories/C/"/>
    
    
      <category term="c++, 참조자" scheme="http://KKimSangHeon.github.io/tags/c-%EC%B0%B8%EC%A1%B0%EC%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV 설치</title>
    <link href="http://KKimSangHeon.github.io/2018/04/05/opencv-exam1/"/>
    <id>http://KKimSangHeon.github.io/2018/04/05/opencv-exam1/</id>
    <published>2018-04-04T23:23:32.000Z</published>
    <updated>2018-04-09T23:52:28.571Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://webnautes.tistory.com/1030" target="_blank" rel="external">http://webnautes.tistory.com/1030</a><br>참고로 나는 마지막 pkg_config 관련해서 vi ~/.bash_profile을 입력후<br>export PKG_CONFIG_PATH=”$LIB_DIR/opencv/lib64/pkgconfig” 을 입력했다</p>
<p>컴파일 방법<br>g++ -o facedetect facedetect.cpp $(pkg-config –libs –cflags opencv)<br>g++ -o facedetect facedetect.cpp ‘pkg-config –libs –cflags opencv’</p>
<p>참고할만한 예제<br><a href="http://hanmin-dev.tistory.com/13" target="_blank" rel="external">http://hanmin-dev.tistory.com/13</a> (이미지의 픽셀 RGB 구하는법 알려줌 Makefile 구성방법 알려줌)<br><a href="http://eehoeskrap.tistory.com/34?category=537364" target="_blank" rel="external">http://eehoeskrap.tistory.com/34?category=537364</a>  ( 픽셀 소금뿌리기)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://webnautes.tistory.com/1030&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://webnautes.tistory.com/1030&lt;/a&gt;&lt;br&gt;참고로 나는 마지막 pkg_config
    
    </summary>
    
      <category term="기타" scheme="http://KKimSangHeon.github.io/categories/%EA%B8%B0%ED%83%80/"/>
    
      <category term="아무거나" scheme="http://KKimSangHeon.github.io/categories/%EA%B8%B0%ED%83%80/%EC%95%84%EB%AC%B4%EA%B1%B0%EB%82%98/"/>
    
    
  </entry>
  
  <entry>
    <title>리눅스 개인폴더에 설치된 디렉토리 사용하기</title>
    <link href="http://KKimSangHeon.github.io/2018/03/30/linux-bash-profile/"/>
    <id>http://KKimSangHeon.github.io/2018/03/30/linux-bash-profile/</id>
    <published>2018-03-29T23:29:17.000Z</published>
    <updated>2018-04-09T23:18:30.222Z</updated>
    
    <content type="html"><![CDATA[<p>서버에 curl이 설치되어 있고 내 로컬에도 curl이 설치되어 있을 때 내 curl을 사용하기 위한 방법</p>
<p>vi ~/.bash_profile을 열고 아래를 입력하고</p>
<p>export CURL_DIR=”$HOME/apps/usr/curl/bin”<br>export PATH=$CURL_DIR:$PATH</p>
<p>source ~/.bash_profile을 입력</p>
<p>curl -V를 통해 잘 적용되었나 확인</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;서버에 curl이 설치되어 있고 내 로컬에도 curl이 설치되어 있을 때 내 curl을 사용하기 위한 방법&lt;/p&gt;
&lt;p&gt;vi ~/.bash_profile을 열고 아래를 입력하고&lt;/p&gt;
&lt;p&gt;export CURL_DIR=”$HOME/apps/usr
    
    </summary>
    
      <category term="Linux" scheme="http://KKimSangHeon.github.io/categories/Linux/"/>
    
      <category term="관련정보" scheme="http://KKimSangHeon.github.io/categories/Linux/%EA%B4%80%EB%A0%A8%EC%A0%95%EB%B3%B4/"/>
    
    
      <category term="Linux" scheme="http://KKimSangHeon.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>아파치 모듈추가</title>
    <link href="http://KKimSangHeon.github.io/2018/03/23/apache-add-module/"/>
    <id>http://KKimSangHeon.github.io/2018/03/23/apache-add-module/</id>
    <published>2018-03-23T11:39:06.000Z</published>
    <updated>2018-04-15T09:38:25.926Z</updated>
    
    <content type="html"><![CDATA[<h3 id="아파치-모듈-추가"><a href="#아파치-모듈-추가" class="headerlink" title="아파치 모듈 추가"></a>아파치 모듈 추가</h3><p>/home/sangheon/apps/apache 이라는 경로에 아파치가 설치되어있다고 가정.</p>
<ol>
<li><code>./apxs -n modulename -g</code> 로 모듈추가. 그럼 현재 위치(bin)에 modulename디렉토리가 생성된다.</li>
<li>/home/sangheon/apps/apache/conf 경로로 이동하여 httpd.conf를 열자</li>
<li>약 150라인 정도 다음을 추가하자.<br><code>LoadModule modulename_module modules/mod_modulename.so
&lt;Location /modulename&gt;
SetHandler modulename
&lt;/Location&gt;</code><br>위의 내용은 mod_modulename.c 파일을 참고하여 작성가능</li>
<li>/home/sangheon/apps/apache/bin 디렉토리에 이동하여 <code>./apxs -c -i /home/sangheon/apps/apache/bin/modulename/mod_modulename.c</code> 를 입력하자. 여기서 특정 라이브러리를 이용할 경우 뒤에 -l라이브러리 이름을 입력하자. curl을 이용할 경우 -lcurl을 입력</li>
<li>bin 디렉토리에서<code>./apachectl restart</code> 입력</li>
</ol>
<h2 id="만약-c-파일을-수정했을-경우엔-4번-5번을-다시-실행하면-된다"><a href="#만약-c-파일을-수정했을-경우엔-4번-5번을-다시-실행하면-된다" class="headerlink" title="만약 c 파일을 수정했을 경우엔 4번 5번을 다시 실행하면 된다."></a>만약 c 파일을 수정했을 경우엔 4번 5번을 다시 실행하면 된다.</h2><p>권한문제(sudo permission)로 서버를 실행시킬 수 없을 때 다음과 같이 입력하자.<br><code>sudo /bin/chown root.sangheon /home/sangheon/apps/apache/bin/httpd
sudo /bin/chmod 4755 /home/sangheon/apps/apache/bin/httpd</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;아파치-모듈-추가&quot;&gt;&lt;a href=&quot;#아파치-모듈-추가&quot; class=&quot;headerlink&quot; title=&quot;아파치 모듈 추가&quot;&gt;&lt;/a&gt;아파치 모듈 추가&lt;/h3&gt;&lt;p&gt;/home/sangheon/apps/apache 이라는 경로에 아파치가 설치
    
    </summary>
    
      <category term="기타" scheme="http://KKimSangHeon.github.io/categories/%EA%B8%B0%ED%83%80/"/>
    
      <category term="아무거나" scheme="http://KKimSangHeon.github.io/categories/%EA%B8%B0%ED%83%80/%EC%95%84%EB%AC%B4%EA%B1%B0%EB%82%98/"/>
    
    
      <category term="아파치 모듈추가" scheme="http://KKimSangHeon.github.io/tags/%EC%95%84%ED%8C%8C%EC%B9%98-%EB%AA%A8%EB%93%88%EC%B6%94%EA%B0%80/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://KKimSangHeon.github.io/2018/03/20/mytip/"/>
    <id>http://KKimSangHeon.github.io/2018/03/20/mytip/</id>
    <published>2018-03-19T15:00:00.000Z</published>
    <updated>2018-04-10T23:50:46.417Z</updated>
    
    <content type="html"><![CDATA[<p>vi 관련</p>
<p>코드 정렬하기<br>ggvG=<br>gg는 파일 처음으로이동하고<br>v는 비쥬얼 모드로 전환하고<br>G는 끝까지 드래그<br>=는 정렬</p>
<p>함수 정의를 찾아가고싶을 때<br>ctag 를 사용하자<br><a href="http://bowbowbow.tistory.com/15" target="_blank" rel="external">http://bowbowbow.tistory.com/15</a></p>
<p> ~/.vimrc<br>set hlsearch<br>set nu<br>set autoindent<br>set scrolloff=2<br>set wildmode=longest,list<br>set ts=4<br>set sts=4<br>set sw=1<br>set autowrite<br>set autoread<br>set cindent<br>set bs=eol,start,indent<br>set history=256<br>set laststatus=2<br>set shiftwidth=4<br>set showmatch<br>set smartcase<br>set smarttab<br>set smartindent<br>set softtabstop=4<br>set tabstop=4<br>set ruler<br>set incsearch<br>highlight Comment term=bold cterm=bold ctermfg=4<br>set tags=/home1/irteam/sangheon/getimage/tags</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vi 관련&lt;/p&gt;
&lt;p&gt;코드 정렬하기&lt;br&gt;ggvG=&lt;br&gt;gg는 파일 처음으로이동하고&lt;br&gt;v는 비쥬얼 모드로 전환하고&lt;br&gt;G는 끝까지 드래그&lt;br&gt;=는 정렬&lt;/p&gt;
&lt;p&gt;함수 정의를 찾아가고싶을 때&lt;br&gt;ctag 를 사용하자&lt;br&gt;&lt;a hr
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2장. 규칙3 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계해라</title>
    <link href="http://KKimSangHeon.github.io/2018/03/19/effectiveJava4/"/>
    <id>http://KKimSangHeon.github.io/2018/03/19/effectiveJava4/</id>
    <published>2018-03-18T23:00:36.000Z</published>
    <updated>2018-03-18T23:39:16.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="규칙3-생성자나-enum-자료형은-싱글턴-패턴을-따르도록-설계해라"><a href="#규칙3-생성자나-enum-자료형은-싱글턴-패턴을-따르도록-설계해라" class="headerlink" title="규칙3 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계해라"></a>규칙3 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계해라</h2><p><code>싱글턴 : 객체를 하나만 만들 수 있는 클래스. 창관리자, 파일 시스템 같은 것들이 그 예다.</code><br> 싱글턴을 구현하는 방법은 두가지인데 두 방법 다 생성자는 private로 선언하고, 싱글턴 객체는 정적(static)멤버를 이용한다. 첫번째 방법의 경우 정적멤버는 final로 선언한다. 두 번째 방법은 public으로 선언된 정적 팩터리 메서드를 이용하는 것이다. 두 방법 다 리플렉션 기능을 통해 private 생성자를 호출할 수 있다는 점에 주의해야 한다.</p>
<p> 싱글턴을 구현하는 또다른 한가지의 방법은 원소가 하나뿐인 enum 자료형을 정의하는 것이다. 이는 좀 더 간결하며, 직렬화가 자동으로 처리된다. 또한 직렬화가 복잡하게 이루어져도 여러 객체가 생길일이 없으며 리플렉션을 통한 공격에도 안전하다.<br> 책에서는 이 방법이 싱글턴을 구현하는 가장 좋은 방법이라 추천한다.</p>
<h3 id="참고-URL"><a href="#참고-URL" class="headerlink" title="참고 URL"></a>참고 URL</h3><p>직렬화 : <a href="http://woowabros.github.io/experience/2017/10/17/java-serialize.html" target="_blank" rel="external">http://woowabros.github.io/experience/2017/10/17/java-serialize.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;규칙3-생성자나-enum-자료형은-싱글턴-패턴을-따르도록-설계해라&quot;&gt;&lt;a href=&quot;#규칙3-생성자나-enum-자료형은-싱글턴-패턴을-따르도록-설계해라&quot; class=&quot;headerlink&quot; title=&quot;규칙3 생성자나 enum 자료형은 싱
    
    </summary>
    
      <category term="Java" scheme="http://KKimSangHeon.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://KKimSangHeon.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>2장. 규칙2 생성자 인자가 많을 때는 Builder 패턴 적용을 고려하라.</title>
    <link href="http://KKimSangHeon.github.io/2018/03/15/effectiveJava3/"/>
    <id>http://KKimSangHeon.github.io/2018/03/15/effectiveJava3/</id>
    <published>2018-03-15T10:27:56.000Z</published>
    <updated>2018-03-18T09:57:03.232Z</updated>
    
    <content type="html"><![CDATA[<h2 id="규칙2-생성자-인자가-많을-때는-Builder-패턴-적용을-고려하라"><a href="#규칙2-생성자-인자가-많을-때는-Builder-패턴-적용을-고려하라" class="headerlink" title="규칙2. 생성자 인자가 많을 때는 Builder 패턴 적용을 고려하라."></a>규칙2. 생성자 인자가 많을 때는 Builder 패턴 적용을 고려하라.</h2><p>보통 생성자의 인자 혹은 정적팩터리의 인자가 많을 땐 점층적 생성자 패턴(telescping constructor pattern)을 적용한다. 17p<br><code>점층적 생성자 패턴 : 필수인자만 받는 생성자를 하나 정의하고, 선택적 인자를 하나 받는 생성자를 추가하고, 거기에 두 개의 선택적 인자를 받는 생성자를 추가하는 식으로 생성자들을 쌓아 올리듯 추가하는 것. 하지만 점층적 생성자 패턴은 설정할 필요가 없는 필드에도 인자를 전달해야하는 경우가 생긴다. 즉 인자수가 늘어나면 클라이언트 코드를 작성하기 어려워지고 읽기 어려워진다.</code></p>
<p>생성자의 인자가 많을 때 사용할 수 있는 두번째 방법은 자바빈(JavaBeans) 패턴이다. 18p<br><code>자바빈 패턴: 인자없는 생성자를 호출하여 객체부터 만든 다음, 설정메서드(setter)들을 호출하여 필수 필드뿐아니라 선택적 필드값 까지 채우는 것이다. 자바빈 패턴은 1회의 함수 호출로 객체 생성을 끝낼 수 없으므로 객체 일관성이 일시적으로 깨질 수 있다. 또한 변경 불가능(immutable)클래스를 만들 수 없다는점, 스레드 안정성을 제공하기 위해 해야할 일도 많아진다.</code></p>
<p>점층적 생성적 생성자 패턴의 안정성 , 자바빈 패턴의 가독성을 결합한 것이 바로 빌더(Builder)패턴이다.<br>필요한 객체를 직접 생성하는 대신 클라이언트는 먼저 필수인자들을 생성자 또는 정적 팩터리 메서드에 전부 전달하여 빌더객체(Builder object)를 만든다. 그런 다음 빌더 객체에 정의된 설정 메서드들을 호출하여 선택적 인자들을 추가 해 나간다. 그리고 마지막으로 아무런 인자 없이 build 메서드를 호출하여 변경 불가능 객체를 만든다.</p>
<h3 id="빌더패턴의-장점"><a href="#빌더패턴의-장점" class="headerlink" title="빌더패턴의 장점"></a>빌더패턴의 장점</h3><ol>
<li>작성하기 쉽고, 읽기 쉽다.</li>
<li>인자에 불변식(invariant)을 적용할 수 있다.</li>
<li>여러개의 varargs 인자(가변인자)를 받을수 있다.</li>
<li>하나의 빌더 객체로 여러 객체를 만들 수 있어 유연하다.</li>
</ol>
<h3 id="빌더패턴의-단점"><a href="#빌더패턴의-단점" class="headerlink" title="빌더패턴의 단점"></a>빌더패턴의 단점</h3><ol>
<li>객체를 생성하기 위해 빌더 객체를 생성해야한다. 오버헤드의 문제가 될 소지는 적지만 성능이 중요한 상황에서는 문제가 될 수 있다.</li>
</ol>
<h3 id="요약하자면"><a href="#요약하자면" class="headerlink" title="요약하자면"></a>요약하자면</h3><p>대부분의 인자가 선택적 인자이거나 인자가 많은 생성자나 정적 팩터리가 필요한 클래스를 설계할 때 유용하다. 가독성은 점층적 생성자 패턴보다 향상되며 자바빈을 사용할 때 보다 안전하다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;규칙2-생성자-인자가-많을-때는-Builder-패턴-적용을-고려하라&quot;&gt;&lt;a href=&quot;#규칙2-생성자-인자가-많을-때는-Builder-패턴-적용을-고려하라&quot; class=&quot;headerlink&quot; title=&quot;규칙2. 생성자 인자가 많을 때는
    
    </summary>
    
      <category term="Java" scheme="http://KKimSangHeon.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="http://KKimSangHeon.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
