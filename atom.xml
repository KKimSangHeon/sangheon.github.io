<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kim Sang Heon&#39;s Bolg</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://KKimSangHeon.github.io/"/>
  <updated>2019-02-22T14:07:13.829Z</updated>
  <id>http://KKimSangHeon.github.io/</id>
  
  <author>
    <name>Kim Sang Heon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>16.프로세스 동기화의 다른 도구인 모니터 사용</title>
    <link href="http://KKimSangHeon.github.io/2019/02/22/operating-system16/"/>
    <id>http://KKimSangHeon.github.io/2019/02/22/operating-system16/</id>
    <published>2019-02-22T13:51:04.000Z</published>
    <updated>2019-02-22T14:07:13.829Z</updated>
    
    <content type="html"><![CDATA[<h3 id="모니터"><a href="#모니터" class="headerlink" title="모니터"></a>모니터</h3><p>동기화 도구로 세마포어를 배웠다. 세마포어는 조금 오래된 동기화 도구인데 지금은 모니터를 많이쓴다. 주로 자바에서 많이쓴다.<br>즉 세마포 이후 프로세스 동기화 도구 이며 세마포 보다 고수준 개념</p>
<h3 id="세마포어의-구조"><a href="#세마포어의-구조" class="headerlink" title="세마포어의 구조"></a>세마포어의 구조</h3><p>정수변수, 큐, P(acquire)동작, V(release)동작</p>
<h3 id="모니터의-구조"><a href="#모니터의-구조" class="headerlink" title="모니터의 구조"></a>모니터의 구조</h3><p>공유자원 , 공유자원 접근함수 , 2개의 큐</p>
<p>2개의 큐?<br>하나는 배타동기. 즉 한쓰레드만 공유자원에 접근할 수 있도록 하는 큐<br>하나는 조건동기를 위한 큐</p>
<p>베타동기를 위한큐 | 다양한 함수 | 조건동기를 위한큐</p>

<p>1.쓰레드 한개만 공유자원 접근 함수에 접근할 수 있다. 즉 들어오고 싶어하는 애들은 베타동기를 위한 큐에서 기다려야 한다.<br>2.진입 쓰레드가 조건을 만족하면(wait를 콜) 조건동기 큐로 들어가는데 이땐 블록된다. 그러면 새 쓰레드가 진입가능<br>3.새 쓰레드는 조건동기로 블록된 쓰레드를 notify를 호출하여 깨울 수 있다<br>4.깨워진 쓰레드는 현재 쓰레드가 나가면 재진입할 수 있다.<br>(하나의 쓰레드만 접근 가능하므로)</p>
<p>세마포어에 비해 복잡하나 사용하기 편리하다.</p>
<p><code>배타동기</code>: synchronized 키워드 사용하여 지정<br><code>조건동기</code>: wait(), notify(), notifyAll() 메소드 사용</p>
<p>베타동기: 하나만 특정함수에 들어갈 수 있다. 자바에서는 함수 정의 앞에 synchronized 키워드를 붙인다.<br>조건동기는 wait 함수를 호출하여 조건동기를 위한 큐에 갇히게 할 수 있고 notify(하나깨우기) 혹은 notify all(전체깨우기) 을 호출하여 깨울 수 도 있다.</p>
<h4 id="상호배제-용도로-사용"><a href="#상호배제-용도로-사용" class="headerlink" title="상호배제 용도로 사용"></a>상호배제 용도로 사용</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankAccount</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> balance;</div><div class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">int</span> amt)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> temp = balance + amt;</div><div class="line">		System.out.print(<span class="string">"+"</span>);</div><div class="line">		balance = temp;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> amt)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> temp = balance - amt;</div><div class="line">		System.out.print(<span class="string">"-"</span>);</div><div class="line">		balance = temp;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> balance;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>위처럼 하면 동기화가 가능하다. 세마포어 보다 쉽다!</p>
<h4 id="Ordering-용도로-사용"><a href="#Ordering-용도로-사용" class="headerlink" title="Ordering 용도로 사용"></a>Ordering 용도로 사용</h4><p>P1은 공백/ S1/notify();<br>P2는 wait/S2/공백</p>
<p>P1이 입금, P2가 출금 로직이라고 가정하고 생각해보자.</p>
<p>P1,P2 반복해서 출력되게 하려면 boolean 변수 하나를 둬서 처리<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">int</span> balacne = <span class="number">0</span>;</div><div class="line"><span class="keyword">boolean</span> p_turn;</div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">int</span> amt)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> temp = balance + amt;</div><div class="line">	balance = temp;</div><div class="line">	notify();</div><div class="line">	p_turn = <span class="keyword">false</span>;</div><div class="line">	wait();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> amt)</span> </span>&#123;</div><div class="line">	<span class="keyword">while</span>(p_turn)</div><div class="line">		wait();</div><div class="line"></div><div class="line">	<span class="keyword">int</span> temp = balance - amt;</div><div class="line">	balance = temp;</div><div class="line">	p_turn = <span class="keyword">true</span>;</div><div class="line">	notify();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">---</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span>[] buf;</div><div class="line">	<span class="keyword">int</span> size, count, in, out;</div><div class="line">	Buffer(<span class="keyword">int</span> size) &#123;</div><div class="line">		buf = <span class="keyword">new</span> <span class="keyword">int</span>[size];</div><div class="line">		<span class="keyword">this</span>.size = size;</div><div class="line">		count = in = out = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> item)</span> </span>&#123;</div><div class="line">	<span class="keyword">while</span> (count == size)</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		wait();</div><div class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</div><div class="line">	buf[in] = item;</div><div class="line">	in = (in+<span class="number">1</span>)%size;</div><div class="line">	notify();</div><div class="line">	count++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">while</span> (count == <span class="number">0</span>)</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		wait();</div><div class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</div><div class="line">	<span class="keyword">int</span> item = buf[out];</div><div class="line">	out = (out+<span class="number">1</span>)%size;</div><div class="line">	count--;</div><div class="line">	notify();</div><div class="line">	<span class="keyword">return</span> item;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">---</div><div class="line">교착상태에 대한 고려는 되지 않음.</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chopstick</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> inUse = <span class="keyword">false</span>;</div><div class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">		<span class="keyword">while</span> (inUse)</div><div class="line">		wait();</div><div class="line">		inUse = <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</div><div class="line">		inUse = <span class="keyword">false</span>;</div><div class="line">		notify();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;모니터&quot;&gt;&lt;a href=&quot;#모니터&quot; class=&quot;headerlink&quot; title=&quot;모니터&quot;&gt;&lt;/a&gt;모니터&lt;/h3&gt;&lt;p&gt;동기화 도구로 세마포어를 배웠다. 세마포어는 조금 오래된 동기화 도구인데 지금은 모니터를 많이쓴다. 주로 자바에서 많이
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>15.교착상태 필요조건, 교착상태의 해결법</title>
    <link href="http://KKimSangHeon.github.io/2019/02/22/operating-system15/"/>
    <id>http://KKimSangHeon.github.io/2019/02/22/operating-system15/</id>
    <published>2019-02-22T13:50:56.000Z</published>
    <updated>2019-02-22T13:56:55.165Z</updated>
    
    <content type="html"><![CDATA[<h3 id="교착상태"><a href="#교착상태" class="headerlink" title="교착상태"></a>교착상태</h3><p>발생이유 : 프로세스들이 자원을 많이 필요로 한다. 하지만 누가 사용하고 있으면 기다려야한다.<br>이러한 형태가 원을 이루면 교착상태가 발생한다.</p>
<h3 id="교창상태-필요조건"><a href="#교창상태-필요조건" class="headerlink" title="교창상태 필요조건."></a>교창상태 필요조건.</h3><p>Mutual exclusion (상호배타) : 자원을 서로 공유하지 못함<br>Hold and wait (보유 및 대기) : 하나를 잡고있으면서 다른것을 원함<br>No Preemption (비선점) : 다른것을 강제로 뺏어오지 못함.<br>Circular wait (환형대기) : 자원을 갖고있으면서 기다리는데 원형형태</p>
<p><u>네가지가 만족되면 일어날 수 있다. 반드시 일어나는것은 아님</u></p>
<h3 id="교착상태-처리"><a href="#교착상태-처리" class="headerlink" title="교착상태 처리"></a>교착상태 처리</h3><p>교착상태 처리는 크게 네가지가 있다.<br>1.교착상태 방지<br>Deadlock Prevention</p>
<p>2.교착상태 회피<br>Deadlock Avoidance</p>
<p>3.교착상태 검출 및 복구<br>Deadlock Detection &amp; Recovery</p>
<p>4.교착상태 무시<br>Don’t Care</p>
<h3 id="1-교착상태-방지"><a href="#1-교착상태-방지" class="headerlink" title="1.교착상태 방지"></a>1.교착상태 방지</h3><p><code>설명</code> : 필요조건 중 네가지 조건중에 하나라도 깨도록 하는것.<br><code>상호베타 조건을 깨기</code>: 이를 위해 공유가 가능하게 해야한다. 현실적으로 어렵다. 읽어내기만 하는 파일 같은 경우에는 가능하지만 일반적으로는 부적절</p>
<p><code>보유 및 대기 깨기</code>: 동시에 젓가락 갖게하기. 왼쪽 젓가락 잡고 오른쪽 젓가락 잡을라 했는데 누가 오른쪽을 갖고있으면 왼쪽도 놓기. 이는 굶어 죽을 확률이 생김. 자원의 활용도가 떨어진다. 상호베타 조건깨는것보다는 쉽다.<br>자원을 가지고 있으면서 다른 자원을 기다리지 않게 즉 자원이 없는 상태에서 모든 자원 대기; 일부 자원만 가용하면 보유 자원을 모두 놓아주기<br>단점: 자원 활용률 저하, 기아 (starvation)</p>
<p><code>비선점 깨기</code>: CPU의 경우에는 일부 가능하겠으나 일반적으로 불가능</p>
<p><code>환형대기 깨기</code> : 자원에다 번호 부여하고 자원의 오름차순으로 자원을 요청토록 함. 즉 R1,R2,R3 가 있을때 R1, R2 요청/ R2,R3 요청/ R1,R3요청처럼 구현. 자원의 활용도가 떨어진다.</p>
<p>보통 보유 및 대기 깨기 혹은 환형대기 깨기를 사용한다.</p>
<h3 id="2-교착상태-회피"><a href="#2-교착상태-회피" class="headerlink" title="2.교착상태 회피"></a>2.교착상태 회피</h3><p><code>설명</code> : 자원을 할당할 때 위험한 할당이 되지 않도록 하는것.<br>자원을 프로세스 한테 골고루 나눠주는것을 OS가 한다. 이를 리소스 매지저 / 올로케이터라 한다.<br>교착상태는 자원요청에 대한 잘못된 승인에 기인한다고 본다.</p>
<p>불안전한 할당 (Unsafe allocation)<br>운영체제는 자원을 할당할 때 불안전 할당 되지 않도록<br>불안전 할당 → 교착상태 유발<br>대출전문 은행과 유사: Banker’s Algorithm</p>
<h3 id="3-교착상태-검출-및-복구"><a href="#3-교착상태-검출-및-복구" class="headerlink" title="3.교착상태 검출 및 복구"></a>3.교착상태 검출 및 복구</h3><p><code>설명</code> : 프로세스가 필요한 대로 자원을 나눠주고 데드락이 발생하면 OS의 프로세스 복구.<br>교착상태가 일어나는 것을 허용 그리고 주기적 검사진행. 주기적 검사는 이를 하기 위한 오버헤드가 크다.<br>교착상태 발생 시 복구하기위해 주기적으로 이전의 상태를 기억하고 있어야 한다.<br>이를 위해 한 프로세스를 강제로 종료시키거나 혹은 자원을 선점하여 일부 프로세스에게 할당.</p>
<h3 id="4-교착상태-무시"><a href="#4-교착상태-무시" class="headerlink" title="4. 교착상태 무시"></a>4. 교착상태 무시</h3><p><code>설명</code> : 교착상태는 실제로 잘 일어나지 않으므로 그냥 무시해버린다.<br>교착상태 발생 시 재시동.</p>
<p>컴퓨터에서 가장 중요한것은 메모리 관리이다. 이를 프로세스 매니지먼트 부서가 하는데 이는 CPU 스케줄링 부서, 프로세스 싱크로나이즈 부서로 구성된다. 싱크로나이즈에서는 데드락관리또한 중요.</p>
<p>메인메모리 관리가 메모리 매니지 부서가 있다. 다음부터 공부한다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;교착상태&quot;&gt;&lt;a href=&quot;#교착상태&quot; class=&quot;headerlink&quot; title=&quot;교착상태&quot;&gt;&lt;/a&gt;교착상태&lt;/h3&gt;&lt;p&gt;발생이유 : 프로세스들이 자원을 많이 필요로 한다. 하지만 누가 사용하고 있으면 기다려야한다.&lt;br&gt;이러한 형태
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>14.읽기-쓰기 문제, 식사하는 철학자 문제</title>
    <link href="http://KKimSangHeon.github.io/2019/02/22/operating-system14/"/>
    <id>http://KKimSangHeon.github.io/2019/02/22/operating-system14/</id>
    <published>2019-02-22T13:50:49.000Z</published>
    <updated>2019-02-22T13:53:18.540Z</updated>
    
    <content type="html"><![CDATA[<p>읽기-쓰기 문제, 식사하는 철학자 문제</p>
<h3 id="Reader-amp-Writer"><a href="#Reader-amp-Writer" class="headerlink" title="Reader &amp; Writer"></a>Reader &amp; Writer</h3><p>DB 읽기만 하는 프로세스 DB를 바꾸는 프로세스</p>
<p>A가 DB를 읽고 있을 때 B가 읽을 수 있다.<br>즉 한 프로세스가 DB를 읽을 때 다른 프로세스도 읽을 수 있게 허용해줘야 한다.</p>
<p>The first R/W problem (readers-preference)<br>리더가 있으면 라이터가 미뤄지는것</p>
<p>The second R/W problem (writers-preference)<br>라이터가 먼저 우선순위가 주어지는것</p>
<p>The Third R/W problem<br>아무한테도 주지 않는것</p>
<p><code>정리</code> : 즉 리더가 들어왔는데 라이터가 들어오려면 블록되어야 하고<br>라이터가 들어왔는데 리더가 들어오려면 블록되어야 하고<br>리더가 들어와있는데 리더가 들어오면 허용해야한다</p>
<h3 id="Dining-Philosopher-Problem"><a href="#Dining-Philosopher-Problem" class="headerlink" title="Dining Philosopher Problem"></a>Dining Philosopher Problem</h3><p><code>다음 프로그램 설명</code><br>철학자 5명이 둥근탁상에 앉아있다. 젓가락은 5개뿐. 즉 자신의 왼쪽 오른쪽에 젓가락이 위치.<br>젓가락을 세마포어로 만들고 초기화를 1로한다.<br>무한루프를 돌면서 왼쪽젓가락, 오른쪽 젓가락을 acquire 하고. 먹고 다시 왼쪽 오른쪽 젓가락을 release한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> id; <span class="comment">// philosopher id</span></div><div class="line">	Semaphore lstick, rstick; <span class="comment">// left, right chopsticks</span></div><div class="line">	Philosopher(<span class="keyword">int</span> id, Semaphore lstick, Semaphore rstick) &#123;</div><div class="line">		<span class="keyword">this</span>.id = id;</div><div class="line">		<span class="keyword">this</span>.lstick = lstick;</div><div class="line">		<span class="keyword">this</span>.rstick = rstick;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">				lstick.acquire();</div><div class="line">				rstick.acquire();</div><div class="line">				eating();</div><div class="line">				lstick.release();</div><div class="line">				rstick.release();</div><div class="line">				thinking();</div><div class="line">			&#125;</div><div class="line">		&#125;<span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">eating</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"["</span> + id + <span class="string">"] eating"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"["</span> + id + <span class="string">"] thinking"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">5</span>; <span class="comment">// number of philosphers &amp; chopsticks</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> i;</div><div class="line">		<span class="comment">/* chopsticks */</span></div><div class="line">		Semaphore[] stick = <span class="keyword">new</span> Semaphore[num];</div><div class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;num; i++)</div><div class="line">			stick[i] = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</div><div class="line"></div><div class="line">		<span class="comment">/* philosophers */</span></div><div class="line">		Philosopher[] phil = <span class="keyword">new</span> Philosopher[num];</div><div class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;num; i++)</div><div class="line">			phil[i] = <span class="keyword">new</span> Philosopher(i, stick[i], stick[(i+<span class="number">1</span>)%num]);</div><div class="line"></div><div class="line">		<span class="comment">/* let philosophers eat and think */</span></div><div class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;num; i++)</div><div class="line">			phil[i].start();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>위의 프로그램은 쭉 가다가 정지된다. 그 이유는 <u>기아상태</u> 유발<br>모든사람이 각자의 왼쪽 젓가락을 들었을 때 해당상황이 발생<br>이를 <u>교착상태</u>라 한다.</p>
<p>운영체제에서 중요한것은 프로세스 관리. 이중 중요한것이 CPU 스케줄링, 동기화 문제이다.<br>동기화에서 중요한건 크리티컬 섹션문제, 효율성 증대 즉 ordering 인데 ordering를 잘못하면 <u>교착상태(Deadlock)</u>에 빠지게 된다.</p>
<h3 id="교착상태-Deadlocks"><a href="#교착상태-Deadlocks" class="headerlink" title="교착상태(Deadlocks)"></a>교착상태(Deadlocks)</h3><p>프로세스가 실행되기 위해서는 하드웨어 자원이 필요하다. 이를 리소스 즉 자원이라 한다. 자원을 사용하는 애플리케이션 즉 프로세스가 있고 중간에 OS가 있다. OS는 애플리케이션한테 자원을 잘 나눠줘야 한다. 자원은 한정되어 있는데 이를 사용하고자 하는 프로세스는 많다. 여기서 잘 나눠주지 못하면 교착상태가 발생한다.</p>
<p>어떤 자원은 갖고 있으나 다른 자원은 갖지 못할 때 (e.g., 다른 프로세스가 사용 중) 대기해야 한다.<br>다른 프로세스 역시 다른 자원을 가지려고 대기할 때 교착상태 가능성 발생</p>
<p>교착상태는 어떤자원을 갖고있을 때 다른 자원을 갖고자 할 때 발생</p>
<h3 id="교착상태-필요-조건-Necessary-Conditions"><a href="#교착상태-필요-조건-Necessary-Conditions" class="headerlink" title="교착상태 필요 조건 (Necessary Conditions)"></a>교착상태 필요 조건 (Necessary Conditions)</h3><p>Mutual exclusion (상호배타) : 리소스가 상호 배타적이다. 즉 한프로세스가 A를 쓰고 있다면 다른 프로세스는 A를 쓰지 못한다.<br>Hold and wait (보유 및 대기) : 왼쪽 젓가락 잡고있으면서 오른쪽 젓가락을 기다리는것.<br>No Preemption (비선점) : 다른사람의 젓가락 하나를 강제로 뺏을 수 없다.<br>Circular wait (환형대기) : 대기하는 형태가 원을 이룸.</p>
<h3 id="교착상태"><a href="#교착상태" class="headerlink" title="교착상태"></a>교착상태</h3><p>OS에서는 데드락이 일어나지 않도록 미리 조취를 해야한다.</p>
<h4 id="자원의-사용"><a href="#자원의-사용" class="headerlink" title="자원의 사용"></a>자원의 사용</h4><p><u>요청 (request) → 사용 (use) → 반납 </u><br>프로세스가 자원을 쓰려면 OS에게 요청을 한다. 그 요청이 올바르면 OS는 그것을 허용하고 프로세스가 자원을 다 쓰면 OS에게 반납한다.</p>
<h4 id="동일-자원"><a href="#동일-자원" class="headerlink" title="동일 자원"></a>동일 자원</h4><p>동일 형식 (type) 자원이 여러 개 있을 수 있다 (instance) - 예: 동일 CPU 2개, 동일 프린터 3개 등</p>
<h3 id="자원-할당도-Resource-Allocation-Graph"><a href="#자원-할당도-Resource-Allocation-Graph" class="headerlink" title="자원 할당도 (Resource Allocation Graph)"></a>자원 할당도 (Resource Allocation Graph)</h3><p><u>시스템 내에 어느 자원이 있고 어떤 프로세스에게 할당되었는가에 대한 그래프</u><br>어떤 자원이 어떤 프로세스에게 할당되었는가?<br>어떤 프로세스가 어떤 자원을 할당 받으려고 기다리고 있는가?<br><u>자원: 사각형, 프로세스: 원, 할당: 화살표</u></p>
<p>그래프 강의는 37분부터 보자</p>
<h4 id="교착상태-필요조건"><a href="#교착상태-필요조건" class="headerlink" title="교착상태 필요조건"></a>교착상태 필요조건</h4><p>자원 할당도 상에 원이 만들어져야 (환형대기) - 충분조건은 아님!<br>자원에서 프로세스를 가르키면 프로세스가 자원을 할당받은 상태<br>프로세스에서 자원을 가르키면 자원을 요청한 상태</p>
<p>짝수번 철학자는 왼쪽들고 오른쪽 들고<br>홀수번 철학자는 오른쪽들고 왼쪽거 들기. 그러면 원형이 깨지게 되어 교착상태가 발생하지 않게된다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;읽기-쓰기 문제, 식사하는 철학자 문제&lt;/p&gt;
&lt;h3 id=&quot;Reader-amp-Writer&quot;&gt;&lt;a href=&quot;#Reader-amp-Writer&quot; class=&quot;headerlink&quot; title=&quot;Reader &amp;amp; Writer&quot;&gt;&lt;/a&gt;Read
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>13.전통적 동기화 문제, 생산자-소비자 문제</title>
    <link href="http://KKimSangHeon.github.io/2019/02/21/operating-system13/"/>
    <id>http://KKimSangHeon.github.io/2019/02/21/operating-system13/</id>
    <published>2019-02-21T13:10:14.000Z</published>
    <updated>2019-02-22T13:52:46.125Z</updated>
    
    <content type="html"><![CDATA[<p>OS에서 가장중요한게 프로세스 관리<br>이중 CPU 스케줄링, 프로세스 동기화가 중요하다.<br>이때 임계구역 처리를 잘해야한다.</p>
<h3 id="전통적-동기화-예제"><a href="#전통적-동기화-예제" class="headerlink" title="전통적 동기화 예제"></a>전통적 동기화 예제</h3><p>1.Producer and Consumer Problem(생산자-소비자 문제, 유한버퍼 문제 (Bounded Buffer Problem))<br>2.Readers-Writers Problem(공유 데이터베이스 접근)<br>3.Dining Philosopher Problem(식사하는 철학자 문제)</p>
<hr>
<h3 id="Producer-Consumer-Problem"><a href="#Producer-Consumer-Problem" class="headerlink" title="Producer-Consumer Problem"></a>Producer-Consumer Problem</h3><h4 id="생산자-소비자-문제"><a href="#생산자-소비자-문제" class="headerlink" title="생산자-소비자 문제"></a>생산자-소비자 문제</h4><p>생산자가 데이터를 생산하면 소비자는 그것을 소비<br>예: 컴파일러 &gt; 어셈블러, 파일 서버 &gt; 클라이언트, 웹 서버 &gt; 웹 클라이언트</p>
<h4 id="Bounded-Buffer"><a href="#Bounded-Buffer" class="headerlink" title="Bounded Buffer"></a>Bounded Buffer</h4><p>보통 생산소비와 소비속도는 다르다.<br>그래서 보통 창고(버퍼)에 저장하고 컨슈머가 조금씩 빼먹는다.</p>
<p>생산된 데이터는 버퍼에 일단 저장 (속도 차이 등)<br>현실 시스템에서 버퍼 크기는 유한<br>생산자는 버퍼가 가득 차면 더 넣을 수 없다.<br>소비자는 버퍼가 비면 뺄 수 없다</p>
<p>버퍼가 가득차면 생산자는 버퍼가 비워질때까지 기다려야한다.<br>버퍼가 비면 소비자는 빼갈것이 없다.</p>
<p>생산자가 10000번 넣고 소비자가 10000번 넣으면 0이되지 않을 수 있다.<br><code>이유</code> : 공통변수 count, buf[] 에 대한 동시 업데이트<br>공통변수 업데이트 구간(= 임계구역)에 대한 동시 진입</p>
<p><code>해결법</code> : 임계구역에 대한 동시 접근 방지 (상호배타)<br>세마포를 사용한 상호배타 (mutual exclusion, mutex)</p>
<h3 id="Busy-wait"><a href="#Busy-wait" class="headerlink" title="Busy-wait"></a>Busy-wait</h3><p>바쁘게 기다린다.<br>생산자: 버퍼가 가득 차면 기다려야 == 빈(empty) 공간이 있어야 한다<br>소비자: 버퍼가 비면 기다려야 == 찬(full) 공간이 있어야 한다</p>
<p>이때 무한루프를 돌면서 기다리면 CPU는 다른일을 못하고 잡히게 된다. -&gt; 비효율적<br><code>해결법</code> : 두개의 세마포어를 사용. empty의 초깃값은 BUF_SIZE 만큼 full의 초깃값은 0으로 하여 사용<br>생산자 :<br>empty.acquire();<br>PRODUCE;<br>full.release();</p>
<p>소비자 :<br>full.acquire();<br>CONSUME;</p>
<h2 id="empty-release"><a href="#empty-release" class="headerlink" title="empty.release();"></a>empty.release();</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OS에서 가장중요한게 프로세스 관리&lt;br&gt;이중 CPU 스케줄링, 프로세스 동기화가 중요하다.&lt;br&gt;이때 임계구역 처리를 잘해야한다.&lt;/p&gt;
&lt;h3 id=&quot;전통적-동기화-예제&quot;&gt;&lt;a href=&quot;#전통적-동기화-예제&quot; class=&quot;headerlink
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>12.세마포를 사용한 프로세스 동기화</title>
    <link href="http://KKimSangHeon.github.io/2019/02/20/operating-system12/"/>
    <id>http://KKimSangHeon.github.io/2019/02/20/operating-system12/</id>
    <published>2019-02-20T14:16:51.000Z</published>
    <updated>2019-02-20T14:17:22.281Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h3 id="프로세스-관리에서-중요한것들"><a href="#프로세스-관리에서-중요한것들" class="headerlink" title="프로세스 관리에서 중요한것들"></a>프로세스 관리에서 중요한것들</h3><p>CPU 스케줄링 : 이전포스팅 참고</p>
<p>프로세스(쓰레드) 동기화<br><code>필요이유</code> : 보통컴퓨터 안에있는 프로세스들은 독립적이지 않고 협조적이므로 즉 공통된 자원에 접근함<br><code>동기화가 되지 않으면?</code> : 누군가는 계속 입금하고 누군가는 출금하는 로직이 있을 때 다 더한값이 0이 아닐 수 있다.<br><code>임계구역</code> : 공통적으로 사용되는 부분</p>
<p><code>임계구역 문제 해결</code> : 상호베타, 진행, 유한대기 ( 모르겠으면 이전포스팅 보자)<br>우리가 원하는대로 프로세스 순서를 맞추는것.</p>
<h3 id="동기화-툴"><a href="#동기화-툴" class="headerlink" title="동기화 툴"></a>동기화 툴</h3><p><code>세마포어</code> : acquire P동작 release V동작이 있음<br>누가 CPU 서비스를 받다가 acquire를 호출했는데 if문이 만족하면 세마포어 큐안에 잡혀들어간다. 이 후 누가 wake를 시켜주면 다시 레디큐로 들어가게 된다.<br>세마포어는 Mutual exclusion을 위해 사용한다. 즉 크리티컬 섹션에는 한명만 들어갈 수 있다.</p>
<p>세마포어의 일반적 사용은 <u>Mutual exclusion</u> 그리고 <u>Ordering</u>으로 나뉜다.<br>그 중 Ordering를 구현하기 위해서는 다음과 같이 하면 된다.</p>
<p>P1    P2<br>S1    S2</p>
<p><code>P1, P2가 있을 때 P1을 먼저 실행하고자 할 때(Ordering)</code> : 세마포어의 value를 0으로 셋팅한다. 그 후 P2 앞에 sem.acquire를 호출한다.<br>이러면 P1이 먼저 호출되면 우리가 원하던 대로 되는것이고 그렇지 않고 P2가 먼저 실행될 경우 세마포어 큐에 들어가서 block이 된다. 아무튼 P1이 먼저 실행되게 되고 실행을 완료하면 release를 호출하여 P2가 실행 될 수 있도록 한다.<br>즉 다음과 같은 형태</p>
<p>P1        P2<br>        acquire<br>S1        S2<br>release</p>
<h3 id="세마포어-정리"><a href="#세마포어-정리" class="headerlink" title="세마포어 정리"></a>세마포어 정리</h3><p>세마포어는 임계구역 문제 해결, 프로세스 실행 순서 제어를 한다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h3 id=&quot;프로세스-관리에서-중요한것들&quot;&gt;&lt;a href=&quot;#프로세스-관리에서-중요한것들&quot; class=&quot;headerlink&quot; title=&quot;프로세스 관리에서 중요한것들&quot;&gt;&lt;/a&gt;프로세스 관리에서 중요한것들&lt;/h3&gt;&lt;p&gt;CPU 스케줄링 : 이전
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>11.임계구역 문제, 동기화 도구</title>
    <link href="http://KKimSangHeon.github.io/2019/02/19/operating-system11/"/>
    <id>http://KKimSangHeon.github.io/2019/02/19/operating-system11/</id>
    <published>2019-02-19T11:04:12.000Z</published>
    <updated>2019-02-20T14:16:20.363Z</updated>
    
    <content type="html"><![CDATA[<h3 id="임계구역-문제-critical-section-problem"><a href="#임계구역-문제-critical-section-problem" class="headerlink" title="임계구역 문제(critical-section problem)"></a>임계구역 문제(critical-section problem)</h3><p>여러개의 쓰레드로 이뤄진 시스템에서 각각의 쓰레드는 코드영역을 갖고있는데 이를 크리티컬 섹션이라한다. 또한 쓰레드로 부터 공통으로 사용되고 변경될 수 있는 부분을 의미한다.</p>
<p><u>어떤 복수개의 쓰레드들이 공통적으로 사용하는 부분.</u></p>
<h3 id="임계영역-해결"><a href="#임계영역-해결" class="headerlink" title="임계영역 해결"></a>임계영역 해결</h3><p>이를 해결하기 위해 다음 세가지가 만족되어야 한다.</p>
<p><code>Mutual exclusion (상호배타)</code>: 오직 한 쓰레드만 진입<br><code>Progress (진행)</code>: 진입 결정은 유한 시간 내. 즉 누가 먼저 들어가야되는지 유한시간내에 결정해야 한다.<br><code>Bounded waiting (유한대기)</code>: 어느 쓰레드라도 유한 시간 내 크리티컬 섹션안에 들어갈 수 있어야한다. 기다리는 시간이 한계가 정해져 있다.</p>
<h3 id="동기화의-목적"><a href="#동기화의-목적" class="headerlink" title="동기화의 목적"></a>동기화의 목적</h3><p><u>우리가 원하는대로 프로세스 혹은 쓰레드의 실행 순서를 결정 지을 수 있는것.</u></p>
<p>O/S 가 가진 여러 매니지먼트(프로세스 매니지먼트,메모리 매니지먼트,파일 시스템 매니지먼트, I/O 매니지먼트) 중 가장 중요한것은 프로세스 매니지먼트. 프로세스 매니지먼트는 두 가지로 나뉘는데 하나는 <u>CPU Scheduling, Synchronization</u></p>
<h3 id="Synchronization를-위한도구"><a href="#Synchronization를-위한도구" class="headerlink" title="Synchronization를 위한도구"></a>Synchronization를 위한도구</h3><p>세마포어 모니터가 있다.</p>
<p><code>Semaphores</code> : 기차역에서 출발신호를 의미하는 깃발이다. 네덜란드사람 딕스트라가 만듦.<br>내부구조는 정수 하나와 동작 두개로 구성된다. <u>하나는 P 동작 하나는 V 동작</u><br>P: Proberen (test) 즉 acquire()  검사<br>V: Verhogen (increment) 즉 release() 증가.</p>
<p>스택에는 푸쉬, 팝이라는 동작이 있다. 마찬가지로 세마포어도 내부에 정수가 있고 P,V가 존재한다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> </span>&#123;</div><div class="line">  value--;</div><div class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>) &#123;</div><div class="line">        add <span class="keyword">this</span> process/thread to list;  <span class="comment">// 누가 호출하면 큐안에 넣는다.</span></div><div class="line">        block;</div><div class="line">      &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</div><div class="line">  value++;</div><div class="line">    <span class="keyword">if</span> (value &lt;= <span class="number">0</span>) &#123;</div><div class="line">        remove a process P from list; <span class="comment">//누군가 갇혀있으면 깨워준다.</span></div><div class="line">        wakeup P;</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>저번에 배웠듯이 레디큐에서 CPU의 서비스를 받기 위해 기다리던 프로세스들이 CPU 서비스를 받다 IO를 만나면 IO서비스를 받으려 하는데 누가 IO서비스를 받고있다면 IO Queue(Device Queue)에서 대기하다 IO서비스를 받고 끝나면 다시 레디큐로 돌아온다.</p>
<p>타임쉐어링 시스템의 경우엔 IO를 만나지 않더라도 시간이 지나면 다시 레디큐로 돌아간다.</p>
<p>이는 프로세스의 큐잉 모델 즉 줄서서 기다리는 모델이다.</p>
<p>세마포어는 정수값도 있고 세마포어 큐도 있다. 어떤 프로세스가 레디큐에 있다 CPU를 쓰다가 acquire를 호출했는데 if문이 맞으면 갇혀버린다.(like 감옥) 이후에 누가 release를 해주면 감옥에서 탈출하여 다른 레디큐로 갈 수 있다.</p>
<p>위에서 value는 권한의 갯수로 생각하면 된다.</p>
<h3 id="세마포어는-Mutual-exclusion-상호베타를-위해-동작한다"><a href="#세마포어는-Mutual-exclusion-상호베타를-위해-동작한다" class="headerlink" title="세마포어는 Mutual exclusion 상호베타를 위해 동작한다."></a>세마포어는 Mutual exclusion 상호베타를 위해 동작한다.</h3><p>세마포어의 초깃값이 1이라 하자. 이때 레디큐에 A, B가 있다고 하자.<br>먼저 A가 acquire(); 을 호출하면 0이 되고 크리티컬 섹션 안으로 들어간다.(블록 걸리지 않음)<br>이때 컨텍스트 스위칭이 되고 B가 acquire를 호출하면 이때는 value가 -1이므로 세마포어 큐에 갇히게 된다.  (크리티컬 섹션 안으로 못들어간다). 그 후 A가 작업을 마치고 release를 호출하게 되면 value를 늘리고 세마포어 큐에 갇혀있는 B를 깨워 다시 레디큐로 들어가게 한다.</p>
<p> 이를 상호베타라 한다.</p>
<p><code>Monitors</code> :</p>
<p>메모리 매니지먼트라<br>파일 시스템 매니지먼트<br>I/O 매니지먼트</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;임계구역-문제-critical-section-problem&quot;&gt;&lt;a href=&quot;#임계구역-문제-critical-section-problem&quot; class=&quot;headerlink&quot; title=&quot;임계구역 문제(critical-section pro
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>10.프로세스 동기화의 중요성, 은행계좌 문제</title>
    <link href="http://KKimSangHeon.github.io/2019/02/18/operating-system10/"/>
    <id>http://KKimSangHeon.github.io/2019/02/18/operating-system10/</id>
    <published>2019-02-18T13:31:45.000Z</published>
    <updated>2019-02-18T13:34:32.742Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-쓰레드란"><a href="#1-쓰레드란" class="headerlink" title="1. 쓰레드란?"></a>1. 쓰레드란?</h3><p>프로그램 내부의 흐름, 맥</p>
<p>맥이 하나만 있는 프로그램 : 싱글쓰레드<br>여러개있는것: 멀티(다중)쓰레드</p>
<p>쓰레드가 여러개가 빠르게 동시에(왔다갔다하면서) 실행됨. 우리는 CPU하나임을 가정하고 공부하기 때문에</p>
<h3 id="1-1-쓰레드-구조"><a href="#1-1-쓰레드-구조" class="headerlink" title="1.1 쓰레드 구조"></a>1.1 쓰레드 구조</h3><p>프로세스의 메모리 공간 공유 : (code, data)<br>프로세스의 자원 공유 : (file, i/o, …)<br>비공유: 개별적인 PC, SP, registers, stack</p>
<p>운영체제의 프로세스 관리부서에서 중요한것은 프로세스 동기화 또는 쓰레드 동기화이다.</p>
<h3 id="프로세스는-크게-두가지로-나뉜다"><a href="#프로세스는-크게-두가지로-나뉜다" class="headerlink" title="프로세스는 크게 두가지로 나뉜다."></a>프로세스는 크게 두가지로 나뉜다.</h3><p>Independent process : p1, p2가 영향이 없다<br>Cooperating process : p1, p2가 영향을 주던지 받던지 한다. 이런경우가 훨씬 많다.<br>프로세스간 통신: 전자우편, 파일 전송<br>프로세스간 자원 공유: 메모리 상의 자료들, 데이터베이스 등<br>명절 기차표 예약, 대학 온라인 수강신청, 실시간 주식거래</p>
<h3 id="2-프로세스-쓰레드-동기화"><a href="#2-프로세스-쓰레드-동기화" class="headerlink" title="2. 프로세스(쓰레드) 동기화"></a>2. 프로세스(쓰레드) 동기화</h3><p><code>공통데이터에 접근하는것은 문제가 발생할 수 있다. (공유되는 프로세스가 동시에 접근할 때.)</code><br>동기화가 제대로 이뤄지지 않으면 똑같은 자리에 두명이상이 배정된다던가 하는 문제가 생긴다.</p>
<p><u>프로세스간에 순서를 잘 지정해서 이상한 상태에 빠지지 않도록 하여 데이터의 일관성을 유지</u></p>
<h3 id="2-1-BankAccount-Problem-은행계좌문제"><a href="#2-1-BankAccount-Problem-은행계좌문제" class="headerlink" title="2.1 BankAccount Problem (은행계좌문제)"></a>2.1 BankAccount Problem (은행계좌문제)</h3><p>부모님은 은행계좌에 입금; 자녀는 출금<br>입금(deposit)과 출금(withdraw) 은 독립적으로 일어난다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-쓰레드란&quot;&gt;&lt;a href=&quot;#1-쓰레드란&quot; class=&quot;headerlink&quot; title=&quot;1. 쓰레드란?&quot;&gt;&lt;/a&gt;1. 쓰레드란?&lt;/h3&gt;&lt;p&gt;프로그램 내부의 흐름, 맥&lt;/p&gt;
&lt;p&gt;맥이 하나만 있는 프로그램 : 싱글쓰레드&lt;br&gt;여러
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>9.다중 큐 스케쥴링, 프로세스 생성과 소멸, 쓰레드</title>
    <link href="http://KKimSangHeon.github.io/2019/02/18/operating-system9/"/>
    <id>http://KKimSangHeon.github.io/2019/02/18/operating-system9/</id>
    <published>2019-02-18T13:29:58.000Z</published>
    <updated>2019-02-18T13:31:23.624Z</updated>
    
    <content type="html"><![CDATA[<h3 id="다중-큐-스케쥴링-프로세스-생성과-소멸-쓰레드"><a href="#다중-큐-스케쥴링-프로세스-생성과-소멸-쓰레드" class="headerlink" title="다중 큐 스케쥴링, 프로세스 생성과 소멸, 쓰레드"></a>다중 큐 스케쥴링, 프로세스 생성과 소멸, 쓰레드</h3><h3 id="다양한-CPU-스케줄링-알고리즘"><a href="#다양한-CPU-스케줄링-알고리즘" class="headerlink" title="다양한 CPU 스케줄링 알고리즘"></a>다양한 CPU 스케줄링 알고리즘</h3><p>First-Come, First-Served (FCFS)<br>Shortest-Job-First (SJF)<br>Priority<br>Round-Robin (RR)<br>Multilevel Queue<br>Multilevel Feedback Queue</p>
<h3 id="1-Multilevel-Queue-Scheduling"><a href="#1-Multilevel-Queue-Scheduling" class="headerlink" title="1. Multilevel Queue Scheduling"></a>1. Multilevel Queue Scheduling</h3><h3 id="1-1-Process-groups-프로세스는-그룹별로-묶일-수-있다"><a href="#1-1-Process-groups-프로세스는-그룹별로-묶일-수-있다" class="headerlink" title="1.1 Process groups : 프로세스는 그룹별로 묶일 수 있다."></a>1.1 Process groups : 프로세스는 그룹별로 묶일 수 있다.</h3><p>System processes : 가장 긴급하고 먼저 처리되어야 하는것.<br>Interactive processes : 대화형 프로세스<br>Interactive editing processes : ex 워드프로세스<br>Batch processes : 인터액션이 따로 없다.<br>Student processes</p>
<p>성격이 다양한것을 동일한 큐에 세우는것이 맞지 않다라고 판단.<br>입출금은 빠르게 끝나는데 대출은 오래 끝나니까!<br>이를 위해 <u>큐를 여러개를 두자 이를 멀티레벨 큐</u>.</p>
<h3 id="1-2-Single-ready-queue-→-Several-separate-queues"><a href="#1-2-Single-ready-queue-→-Several-separate-queues" class="headerlink" title="1.2 Single ready queue → Several separate queues"></a>1.2 Single ready queue → Several separate queues</h3><p>각각의 Queue 에 절대적 우선순위 존재<br>또는 CPU time 을 각 Queue 에 차등배분<br>각 Queue 는 독립된 scheduling 정책</p>
<p>큐가 여러개이므로 우선순위를 둬서 차등반영한다.<br>또한 각 큐별로 다른 스케줄링 기법을 사용한다.</p>
<h3 id="2-Multilevel-Feedback-Queue-Scheduling"><a href="#2-Multilevel-Feedback-Queue-Scheduling" class="headerlink" title="2. Multilevel Feedback Queue Scheduling"></a>2. Multilevel Feedback Queue Scheduling</h3><p>큐를 여러개 둔다는점은 Multilevel Queue Scheduling와 같은데 <code>하나의 입구로 진입해서 거의 실행되지 않는다면 다른큐로 이동한다.</code></p>
<h3 id="2-1-다른-Queue-로의-점진적-이동"><a href="#2-1-다른-Queue-로의-점진적-이동" class="headerlink" title="2.1 다른 Queue 로의 점진적 이동"></a>2.1 다른 Queue 로의 점진적 이동</h3><p>모든 프로세스는 하나의 입구로 진입<br>너무 많은 CPU time 사용 시 다른 Queue 로<br>기아 상태 우려 시 우선순위 높은 Queue 로</p>
<p>상용운영체제는 여러 큐를 갖고있어 다양한 스케줄링 정책을 두어 적절히 활용한다.</p>
<h3 id="3-Process-Creation"><a href="#3-Process-Creation" class="headerlink" title="3. Process Creation"></a>3. Process Creation</h3><p>프로세스는 사람과 비슷하다. <u>프로세스는 프로세스에 의해 만들어진다.</u></p>
<p><code>그렇다면 제일 첫번째 프로세스는 어떻게 만들어졌을까??</code><br>O/S가 메모리로 올라가고 초기화 작업을 하면 제일 처음 프로세스를 만든다. 제일 첫번째 프로세스 이름을 유닉스의 경우 init프로세스(OS마다 다름)라 한다. 이 프로세스가 다른 프로세스를 만든다.</p>
<h3 id="3-1-Process-Identifier-PID"><a href="#3-1-Process-Identifier-PID" class="headerlink" title="3.1 Process Identifier (PID)"></a>3.1 Process Identifier (PID)</h3><p>사람의 주민등록번호와 같은것.<br>처음 만들어지는 프로그램은 0이다.<br>PPID? 부모 PID</p>
<h3 id="3-2-프로세스-생성"><a href="#3-2-프로세스-생성" class="headerlink" title="3.2 프로세스 생성"></a>3.2 프로세스 생성</h3><p>fork() system call - 새로운 프로세스 만드는것.<br>exec() - 만들어진 프로세스의 실행파일을 메모리로 갖고오는것.</p>
<h3 id="3-3-프로세스-종료"><a href="#3-3-프로세스-종료" class="headerlink" title="3.3 프로세스 종료"></a>3.3 프로세스 종료</h3><p>exit() system call - 해당 프로세스가 가졌던 모든 자원은 OS에게 반환 (메모리, 파일, 입출력장치 등)</p>
<h3 id="4-쓰레드"><a href="#4-쓰레드" class="headerlink" title="4. 쓰레드"></a>4. 쓰레드</h3><p><u>프로그램 내부의 흐름, 맥이라고 한다.</u></p>
<h3 id="4-1-다중-쓰레드-Multithreads"><a href="#4-1-다중-쓰레드-Multithreads" class="headerlink" title="4.1 다중 쓰레드(Multithreads)"></a>4.1 다중 쓰레드(Multithreads)</h3><p><u>하나의 프로그램에 맥이 2개이상 있는것.</u><br>맥이 빠른 시간 간격으로 스위칭 된다 →  여러 맥이 동시에 실행되는 것처럼 보인다<br>Web browser : 화면 출력하는 쓰레드 + 데이터 읽어오는 쓰레드<br>Word processor : 화면 출력하는 쓰레드 + 키보드 입력 받는 쓰레드 + 철자/문법오류 확인 쓰레드</p>
<p>이전강의까지는 P1이 끝나면 P2로 넘어간다 했는데 그건 예전의 OS이다.<br>즉 <u>현재의 컴퓨터는 컨텍스트 스위칭 단위가 프로세스가 아니라 쓰레드 단위이다</u>.</p>
<p>각 쓰레드는 코드와 데이터 공유하고 스택은 공유하지 않는다.</p>
<p>한 프로세스에는 기본 1개의 쓰레드 : <code>단일 쓰레드 (single thread) 프로그램</code><br>한 프로세스에 여러 개의 쓰레드 : <code>다중 쓰레드 (multi-thread) 프로그램</code></p>
<h3 id="4-2-쓰레드-구조"><a href="#4-2-쓰레드-구조" class="headerlink" title="4.2 쓰레드 구조"></a>4.2 쓰레드 구조</h3><p>프로세스의 메모리 공간 공유 : (code, data)<br>프로세스의 자원 공유 : (file, i/o, …)<br>비공유: 개별적인 PC, SP, registers, stack</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;다중-큐-스케쥴링-프로세스-생성과-소멸-쓰레드&quot;&gt;&lt;a href=&quot;#다중-큐-스케쥴링-프로세스-생성과-소멸-쓰레드&quot; class=&quot;headerlink&quot; title=&quot;다중 큐 스케쥴링, 프로세스 생성과 소멸, 쓰레드&quot;&gt;&lt;/a&gt;다중 큐 스케쥴링
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>8.SJF, Priority, RR 스케쥴링</title>
    <link href="http://KKimSangHeon.github.io/2019/02/16/operating-system8/"/>
    <id>http://KKimSangHeon.github.io/2019/02/16/operating-system8/</id>
    <published>2019-02-16T04:17:07.000Z</published>
    <updated>2019-02-17T11:46:28.048Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CPU-스케줄링-알고리즘"><a href="#CPU-스케줄링-알고리즘" class="headerlink" title="CPU 스케줄링 알고리즘"></a>CPU 스케줄링 알고리즘</h3><p><u>CPU 스케줄링은 레디큐에서 프로세스들이 CPU의 작업을 기다리고있을 때 누가 먼저 들어갈것인가에 대한것.</u></p>
<p>FCFS는 이전포스트 참고</p>
<p><code>AWT</code>를 평균대기시간이라 함.<br><code>ATT</code>를 Average turnaround time 반환시간이라함.</p>
<h3 id="SJF"><a href="#SJF" class="headerlink" title="SJF"></a>SJF</h3><p><u>가장 짧은것을 먼저하는것.</u><br>P1 6<br>P2 8<br>P3 7<br>P4 3<br>의 프로세스가있을 때 대기시간.</p>
<p>p4, p1,p3,p2의 순서로 진행된다.<br>평균 대기시간은 (3+16+9+0)/4 = 7 이다.<br>FCFS로 하면<br>(0+6+14+21) /4 = 10.25 이다.</p>
<p>실제로 프로세스가 얼마나 사용할지는 모른다. 해봐야 한다.<br>대기시간을 줄이기 위해 적절한 방법이긴 한데 CPU 사용시간을 예측을 해야한다.(이를 정확하게 예측하기 위해서는 과거를 기억해야 하는등 계산하는데 오버헤드가 발생한다.)</p>
<p>실제로 적용하기엔 어렵다!</p>
<p>Preemptive or Nonpreemtive 둘다 적용가능하다.</p>
<h3 id="Priority-Scheduling"><a href="#Priority-Scheduling" class="headerlink" title="Priority Scheduling"></a>Priority Scheduling</h3><p><u>우선순위가 높은것을 먼저 처리</u></p>
<p>우선순위는 내부적요소, 외부적 요소로 결정된다.<br>내부요소: 타임 리밋이 짧은것을 높게주기, 메모리 적게잡는놈 높게주기, IO가 길고 CPU burst가 짧은거 높게주기 등등<br>외부요소: 돈 많이 낸사람, 정치적요소</p>
<p>일반적으로 많이 사용된다.</p>
<p>이 또한 Preemptive or Nonpreemtive 둘다 적용가능하다.</p>
<p>문제점: 기아상태<br>우선순위가 낮은 프로세스가 기다리는데 우선순위 높은것들이 자꾸 들어온다면 아무리 기다려도 자기 차례가 오지 않는다.<br>해결방법 : againg 어떤 프로세스가 오래머물러 있다면 점진적으로 우선순위를 높여준다</p>
<h3 id="Round-Robin"><a href="#Round-Robin" class="headerlink" title="Round Robin"></a>Round Robin</h3><p><u>시간을 쪼개서 진행</u><br>Time quantum 시간양자 = time slice (보통 10 ~ 100msec으로 잡는)<br>Preemptive scheduling</p>
<p>타임퀀텀을 얼마로 잡느냐에 따라 AWT가 달라진다.<br>즉 Time quantum에 의존적이다<br>Time quantum을 무한대로 주면 FCFS와 동일하다</p>
<p>반대로 Time quantum을 0으로 주면 동시에 도는것과 같이느낄 수있다,<br>context switching overhead 가 발생함.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CPU-스케줄링-알고리즘&quot;&gt;&lt;a href=&quot;#CPU-스케줄링-알고리즘&quot; class=&quot;headerlink&quot; title=&quot;CPU 스케줄링 알고리즘&quot;&gt;&lt;/a&gt;CPU 스케줄링 알고리즘&lt;/h3&gt;&lt;p&gt;&lt;u&gt;CPU 스케줄링은 레디큐에서 프로세스들이 
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>7.스케쥴링 척도, FCFS</title>
    <link href="http://KKimSangHeon.github.io/2019/02/15/os7/"/>
    <id>http://KKimSangHeon.github.io/2019/02/15/os7/</id>
    <published>2019-02-15T12:27:56.000Z</published>
    <updated>2019-02-17T11:45:42.025Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CPU-스케쥴링"><a href="#CPU-스케쥴링" class="headerlink" title="CPU 스케쥴링"></a>CPU 스케쥴링</h3><p>프로그램은 하드디스크안에 들어있고 아무런 동작도 하지안흔다. 메인메모리에 올라가서 실행이 되면 활동한다.</p>
<p>활동중에 있는 프로그램을 프로세스라함.</p>
<p>프로세스에 대한 것들을 PCB안에 넣어놓는다.</p>
<p>컴퓨터 안에는 여러가지 큐가 있는데 <code>job queue, ready queue, device queue</code>가 있다.</p>
<p>메인메모리에 여러 프로그램이 올라와있는게 멀티 프로그래밍<br>프로그램이 몇개인가에 대한것이 Degree of multiprogramming</p>
<p><u>잡스케줄러가 하는일은 i/o-bound 를 CPU-bound process 적절히 분배하는것.</u></p>
<p><code>short-term scheduler</code> : <u>메모리에 올라온 프로세스들은 CPU를 받기위해 줄서있는데 어느놈을 선택해서 서비스해줄지에 대한것</u><br><code>Long-term scheduler</code> : 하드디스크에서 메인메모리에 올라가기 위해 <u>job queue에 대기하는 프로그램중 어느놈을 먼저 올려야하는지에 대한것</u></p>
<p>메인메모리에 올라온 프로세스중에 일정시간동안 사용되지 않는것을 물리적인 하드디스크에 Swap out 한다.<br><code>Medium-term scheduler</code> : Swap out 리스트중 어느것을 Swap in 할지에 대한것을 의미함.</p>
<p>하드디스크는 파일시스템목적, Backing store(물리적인 하드디스크에 Swap out할 때 목적지) 용도로 사용된다.</p>
<h3 id="Context-switching"><a href="#Context-switching" class="headerlink" title="Context switching"></a>Context switching</h3><p>CPU가 p1을 실행하다 p2로 넘어가는데 이를 문맥교환이라 한다.</p>
<h3 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h3><p>레디큐에 있는 놈 중 어느놈을 CPU로 보내줄까에 대한것.<br>지금있는 프로세스가 끝나면 어느놈을 선택할것인가에 대한것.<br>O/S안에 들어있는 컴퓨터 프로그램이다.</p>
<h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><p><u>스케줄러가 선택한 프로세스를 실행하도록 여러가지 상태를 변경해주는것.<br>p2가 선택되었다면 p2를 돌리기 위해 p1의 현재상태 프로그램카운터,스택포인터,레지스터,베이스레지스터 등을 P1의 PCB 에 저장해 놓아야한다.</u><br>즉 p1의 현재상태를 pcb1에 저장해놓는다. p2의 PCB에저장된 값을 복원(restore)<br>이런일을 하는것이 디스패처라 한다.<br>이런일을 하는것은 오버헤드(부담)이 발생하게 된다. 이를 Context Switching Overhead라고 한다.</p>
<p>즉 컨텍스트 스위칭을 자주하는것은 손해이다.<br>Dispatcher는 주로 어셈블리어와같은 low 레벨로 짜서 효율을 높인다.</p>
<h3 id="CPU스케줄링"><a href="#CPU스케줄링" class="headerlink" title="CPU스케줄링"></a>CPU스케줄링</h3><p>현재 실행중인 프로세스가 끝나면 어느것을 실행해줄까</p>
<h3 id="Preemptive-vs-Non-preemptive"><a href="#Preemptive-vs-Non-preemptive" class="headerlink" title="Preemptive vs Non-preemptive"></a>Preemptive vs Non-preemptive</h3><p><code>Preemptive</code> : CPU가 어떤일을 하고 있는데 IO를 만나거나 끝나지도 않았는데 강제로 끝내고 들어갈 수 있는것<br><code>Non-preemptive</code> : 이미 어떤프로세스가 실행중이면 끝나거나 IO를 만나지 않으면 변경되지 않는것</p>
<h3 id="Scheduling-criteria-척도"><a href="#Scheduling-criteria-척도" class="headerlink" title="Scheduling criteria(척도)"></a>Scheduling criteria(척도)</h3><p>특정 Scheduling 기법을 판단하는 기준</p>
<ul>
<li><p>CPU Utilization (CPU 이용률) : CPU가 놀지않고 얼마나 열심히 일하는가. a방법은 100%로 돌고 b방법은 80%로 들 때 a방법을 채택</p>
</li>
<li><p>Throughput (처리율) : 시간당 몇개의 작업을 처리하는가.</p>
</li>
<li><p>Turnaround time (반환시간) : 작업이 ready queue로 들어가 작업을 끝내고 나오는 시간.</p>
</li>
<li><p>Waiting time (대기시간) : CPU를 받기위해 ready queue에서 얼마나 기다려야 하는가. 당연히 짧을수록 좋다.</p>
</li>
<li><p>Response time (응답시간) : interactive 환경에서 중요하다. 처음 응답이 나올때 까지 걸리는 시간. 주로 대화형 컴퓨터에서 척도로 삼음</p>
</li>
</ul>
<p>기타 요소 존재….</p>
<hr>
<h3 id="First-Come-First-Served-FCFS"><a href="#First-Come-First-Served-FCFS" class="headerlink" title="First-Come, First-Served (FCFS)"></a>First-Come, First-Served (FCFS)</h3><p><u>먼저온놈을 먼저 처리해준다.</u>  - Non-preemptive schedulling<br>레디큐에 프로세스가 대기중이다.</p>
<p>p1은 burst time 24<br>p2는 3<br>p3는 3 일때</p>
<p>평균적으로 기다린 시간은 (0 +24 + 27)/3 = 17 이다.</p>
<p>P3,P2,P1 순으로 들어왔다고 할 경우 (0+3+6)/3 = 3 이라고 할 수 있다.<br>당연히 아래방식이 더 좋다.</p>
<p>간트차트 추가</p>
<p>즉 이런방식으로 해주면 평균 대기시간을 고려할 때 그리 좋은방법이 아니다.</p>
<p>Convoy Effect (호위효과) : CPU를 많이 잡아먹는놈이 앞에있으면 뒤에놈들이 오래 기다려야 한다.</p>
<h3 id="Shortest-Job-First-SJF"><a href="#Shortest-Job-First-SJF" class="headerlink" title="Shortest-Job-First (SJF)"></a>Shortest-Job-First (SJF)</h3><p><u>짧은 작업을 먼저 처리해준다.</u></p>
<h3 id="Shortest-Remaining-Time-First"><a href="#Shortest-Remaining-Time-First" class="headerlink" title="Shortest-Remaining-Time-First"></a>Shortest-Remaining-Time-First</h3><h3 id="Priority"><a href="#Priority" class="headerlink" title="Priority"></a>Priority</h3><h3 id="Round-Robin-RR"><a href="#Round-Robin-RR" class="headerlink" title="Round-Robin (RR)"></a>Round-Robin (RR)</h3><h3 id="Multilevel-Queue"><a href="#Multilevel-Queue" class="headerlink" title="Multilevel Queue"></a>Multilevel Queue</h3><h3 id="Multilevel-Feedback-Queue"><a href="#Multilevel-Feedback-Queue" class="headerlink" title="Multilevel Feedback Queue"></a>Multilevel Feedback Queue</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CPU-스케쥴링&quot;&gt;&lt;a href=&quot;#CPU-스케쥴링&quot; class=&quot;headerlink&quot; title=&quot;CPU 스케쥴링&quot;&gt;&lt;/a&gt;CPU 스케쥴링&lt;/h3&gt;&lt;p&gt;프로그램은 하드디스크안에 들어있고 아무런 동작도 하지안흔다. 메인메모리에 올라가서 
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>6.프로세스의 정의, CPU 스케쥴러, 멀티프로그래밍</title>
    <link href="http://KKimSangHeon.github.io/2019/02/15/os6/"/>
    <id>http://KKimSangHeon.github.io/2019/02/15/os6/</id>
    <published>2019-02-15T12:24:01.000Z</published>
    <updated>2019-02-22T14:32:45.181Z</updated>
    
    <content type="html"><![CDATA[<h3 id="프로세스-관리"><a href="#프로세스-관리" class="headerlink" title="프로세스 관리"></a>프로세스 관리</h3><p>CPU를 프로세스한테 어떻게 잘 나눠주는가에 대한것.</p>
<p>Process<br>실행중인 프로그램.</p>
<p>프로그램은 무덤속에 있는것. 프로세스는 살아있는것.<br>program in execution: text + data + stack, pc, sp, registers, …</p>
<h3 id="프로세스의-상태"><a href="#프로세스의-상태" class="headerlink" title="프로세스의 상태"></a>프로세스의 상태</h3><p>new - 메인 메모리로 올라온 상태.<br>ready - 실행할 준비가 모두 다 된상태 ( waiting이 끝나도 ready로 돌아옴)<br>running - CPU가 실행중인 상태 (CPU를 잡게된 상태)<br>waiting - 기다리는 상태. ( hwp 프로그램이 프린터를 요청하고 기다림. 즉 IO를 만나는 경우에도 wating상태가 된다,)<br>terminated - 끝난상태.</p>
<p>ready, running, wating의 반복으로 프로세스가 동작</p>
<p>타임쉐어링 시스템은 일정시간이 지나면 바로 ready 상태로 간다</p>
<h3 id="PCB-Process-Control-Block"><a href="#PCB-Process-Control-Block" class="headerlink" title="PCB(Process Control Block )"></a>PCB(Process Control Block )</h3><p>Task == Process<br>프로세스 제어 블록이며 Task Control Block (TCB) 이라고도 함.</p>
<p>PCB는 프로세스에 대한 모든 정보를 담고있다.<br><u>하나의 프로세스에 대해 PCB를 갖고있다. 다른 프로세스로 처리가 넘어가다러도 다시 돌아올 수 있도록 관리.</u><br>상태정보, PC(지금은 몇번지인지. 번지정보), registers, MMU info (base, limit), CPU time(CPU 이용시간), process id, list of open files(얘가 지금 어떤파일을 사용하고 있는지)…</p>
<p>PCB는 OS의 프로세스 관리 부서(프로세스 매니지먼트,모르겠으면 이전포스팅 참고) 안에 들어있다.</p>
<p>모든프로그램은 원래 하드디스크 안에 들어있다.  </p>
<h3 id="여러가지-Queue"><a href="#여러가지-Queue" class="headerlink" title="여러가지 Queue"></a>여러가지 Queue</h3><p>하드디스크에서 메모리로 올라가기 위해서는 줄서서 기다려야한다. 그런것을 <code>Job queue</code>라고 한다.</p>
<p>메인메모리에 올라와서 CPU를 받으려면 줄서야 하는데 이를 <code>Ready queue</code>라고 한다.</p>
<p>I/O를 사용하려 해도 줄서서 기다려야 한다. 이를 <code>Device queue</code> 라고 한다.</p>
<p>I/O를 끝내면 ready상태로 가는데 여기서도 줄서서 기다려야 한다.</p>
<hr>
<img src="/2019/02/15/os6/image1.png" alt="여러가지의 Queue" title="여러가지의 Queue">
<h3 id="Job-scheduling-Long-term-scheduler"><a href="#Job-scheduling-Long-term-scheduler" class="headerlink" title="Job scheduling(Long-term scheduler)"></a>Job scheduling(Long-term scheduler)</h3><p>하드디스크에서 메인메모리에 올라가기 위해 <u>job queue에 대기하는 프로그램중 어느놈을 먼저 올려야하는지에 대한것</u>을 <code>Job scheduling(Long-term scheduler)</code>라 한다. 잡 스케줄링은 역시 O/S 안에 프로세스 관리안에 존재한다.<br>일반적으로 프로세스가 끝나고 메모리가 비워져야 일어나기 때문에 Long-term scheduler 라고도 한다. 즉 스케줄러가 일어나는 시간이 몇분이 걸린다.</p>
<h3 id="CPU-Scheduler-Short-term-scheduler"><a href="#CPU-Scheduler-Short-term-scheduler" class="headerlink" title="CPU Scheduler( Short-term scheduler )"></a>CPU Scheduler( Short-term scheduler )</h3><p><u>메모리에 올라온 프로세스들은 CPU를 받기위해 줄서있는데 어느놈을 선택해서 서비스해줄지에 대한것</u>을 <code>CPU Scheduler( Short-term scheduler )</code>이라 한다.<br>메인 메모리에 여러 프로그램이 있는데 스위칭이 빠르게 일어난다. 1초에 수십번,수백번도 발생한다.  그래서 Short-term scheduler 라고도 부른다. <u>다른 스케줄링 보다도 가장 중요한 스케줄링이다.</u></p>
<h3 id="Device-Scheduler"><a href="#Device-Scheduler" class="headerlink" title="Device Scheduler"></a>Device Scheduler</h3><p>디바이스 서비스를 받기위해 기다리는것을 <code>Device Scheduler</code>이라 한다.</p>
<h3 id="멀티프로그래밍"><a href="#멀티프로그래밍" class="headerlink" title="멀티프로그래밍"></a>멀티프로그래밍</h3><p><u>메인메모리에 하나의 프로그램, 프로세스를 올리는것이 아니라 여러개를 올리는것.</u></p>
<p><code>Degree of multiprogramming</code> - 멀티프로그래밍의 정도 ( 메인메모리에 몇개의 프로세스가 올라와있는가)</p>
<h3 id="프로세스의-구분"><a href="#프로세스의-구분" class="headerlink" title="프로세스의 구분"></a>프로세스의 구분</h3><p>프로세스는 크게 두가지로 나눌 수 있다,<br>i/o-bound : 프로세스가 하는게 주로 I/O를 사용하는것(ex. 워드프로세서)<br>CPU-bound process  : 프로세스가 주로 cpu를 사용함.(ex. 일기예보와 같은 계산)</p>
<p>O/S는 작업을 적당히 섞어서 잡 스케줄링결과로 CPU 혹은 IO에만 작업이 치중해 한쪽이 놀지 않도록 한다.</p>
<h3 id="Medium-term-scheduler"><a href="#Medium-term-scheduler" class="headerlink" title="Medium-term scheduler"></a>Medium-term scheduler</h3><p>서버컴퓨터에 여러명이 사용중이라 가정하자. B라는 사람이 심심해서 커피를 마시러 갔다하자. 그동안 B를 위한 메모리는 올라와있지만 CPU는 아무역할도 하지 않는다. 즉 낭비다. B를 위한 자원을 쫒아내는것이 이득인데 이를 위해 디스크로 쫒아내고 비어있는 메모리공간을 확보한다. 여기서 쫒아내는 것을 <code>Swap out</code>라고 한다. 이처럼 디스크를 프로세스 이미지를 쫒아내는 목적으로 사용하는것을 <code>swap device</code> 라고 한다. 다시 B가 커피를 마시고 돌아와 마우스를 움직이면 Swap device로 갔던 프로세스를 불러들이는데 이를 <code>Swap in</code>이라 한다. swap device로 swap in되고 swap out 되는것을 Swapping 이라 한다.</p>
<p>이때 쫒겨났을때 쫒겨난 자리로 그대로 들어가는것을 보장하지는 않는다.</p>
<p>즉 Medium-term scheduler 는 현재 사용되고 있지 않은 어떤놈을 쫒아낼지 결정하는것이다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;프로세스-관리&quot;&gt;&lt;a href=&quot;#프로세스-관리&quot; class=&quot;headerlink&quot; title=&quot;프로세스 관리&quot;&gt;&lt;/a&gt;프로세스 관리&lt;/h3&gt;&lt;p&gt;CPU를 프로세스한테 어떻게 잘 나눠주는가에 대한것.&lt;/p&gt;
&lt;p&gt;Process&lt;br&gt;실행
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>5.운영체제의 주요 서비스 프로세스, 메모리, 파일관리, 시스템 호출</title>
    <link href="http://KKimSangHeon.github.io/2019/02/14/operating-system/"/>
    <id>http://KKimSangHeon.github.io/2019/02/14/operating-system/</id>
    <published>2019-02-14T13:01:23.000Z</published>
    <updated>2019-02-17T11:02:54.527Z</updated>
    
    <content type="html"><![CDATA[<h3 id="운영체제-서비스"><a href="#운영체제-서비스" class="headerlink" title="운영체제 서비스"></a>운영체제 서비스</h3><p>지금은 서버컴퓨터 하나에 여러명이 동시에 사용하는 구조.<br>이러한 구조에선 한사람이 잘못된 것을 할 경우 해악이 될 수있다.</p>
<p>다중유저시스템, 다중프로그래밍시스템에서 필요한 보호들</p>
<p>1.입출력장치 보호<br>A,B가 바로 하드웨어에 접근하지 못하도록 함<br>어떻게? In(입력),Out(출력) 명령을 특권명령으로 만들어 A,B는 이를 실행하지 못하고 O/S에게 부탁하여 실행토록 함.<br>그러면 O/S가 프린터를 구동시켜줌</p>
<p>2.메모리 보호<br>자기에게 넘어간 메모리 접근을 못하도록 하는것.<br>유저1이 OS영역이나 다른사람 영역을 못들어가도록 함.<br><code>어떻게?</code> MMU를 활용하여 base, limit 값을 넘지 못하도록한다. 넘을경우 인터럽트를 발생시켜 프로그램 강제종료</p>
<p>3.CPU 보호<br>while(a=1)…<br>위의 경우 CPU가 한 사용자에 독점되게 된다.<br><code>어떻게?</code> 타이머를 걸어서 일정시간이 지나면 인터럽트를 걸도록 한다.<br>인터럽트 서비스 루틴에는 CPU가 골고루 돌아가고 있는지. 한 프로그램에만 돌아가고 있지 않은지 파악하도록 짠다.<br>인터럽트 &gt; 운영체제 &gt; 다른 프로그램으로 강제 전환</p>
<h3 id="운영체제가-하는일"><a href="#운영체제가-하는일" class="headerlink" title="운영체제가 하는일"></a>운영체제가 하는일</h3><p>정부가 하는일과 비슷하다.<br>자원을 효율적으로 나눠주는 시스템을 OS라 한다.<br>모든애플리케이션은 하드웨어를사는데 이 하드웨어를 적절하게 분배하는것을 OS라 한다.</p>
<h4 id="프로세스-매니지먼트"><a href="#프로세스-매니지먼트" class="headerlink" title="프로세스 매니지먼트"></a>프로세스 매니지먼트</h4><p>이 중 CPU를 나눠주는 부분이 프로세스 매니지먼트</p>
<p>프로세스는 ? <u>메인 메모리에서 실행중인 프로그램. 실행상태에 있는 프로그램</u><br>하드디스크에는 많은 프로그램이 있지만 메인메모리로 올라와 있는 것을 프로세스라 함.<br>그래서 프로그램 매니지먼트라 하지않고 프로세스 매니지먼트라 함.</p>
<p>프로세스들이 많아지만 교착상태가 발생할 수 있는데 이를 프로세스 관리부분이 처리해준다.</p>
<h4 id="메인메모리-매니지먼트"><a href="#메인메모리-매니지먼트" class="headerlink" title="메인메모리 매니지먼트"></a>메인메모리 매니지먼트</h4><p>주기억장치를 나눠주는 부분이 메인메모리 매니지먼트</p>
<p>프로세스한테 메인메모리를 할당한다.<br>메모리의 어느 부분이 어느 프로세스에게 할당되었는가 추적 및 감시<br>프로세스 종료 시 메모리 회수 (deallocation)<br>메모리의 효과적 사용<br>가상 메모리: 물리적 실제 메모리보다 큰 용량 갖도록</p>
<h4 id="파일-매니지먼트"><a href="#파일-매니지먼트" class="headerlink" title="파일 매니지먼트"></a>파일 매니지먼트</h4><p>하드디스크 안에 파일을 관리하는것이 파일 매니지먼트</p>
<p>판 위에 트랙을 만들고 이를 잘라서 섹터라 한다. 즉 트랙, 섹터의 집합</p>
<p>파일을 만들기도 하고 없애기도 하고 디렉토리 생성 삭제에 관여<br><u>파일에 대한 기본동작(open, close, read, write, create, delete) 지원</u><br>백업(backup)</p>
<h4 id="보조기억장치관리-Secondary-storage-management"><a href="#보조기억장치관리-Secondary-storage-management" class="headerlink" title="보조기억장치관리(Secondary storage management)"></a>보조기억장치관리(Secondary storage management)</h4><p>보조기억장치는 트랙, 섹터의 집합인데 이를 어떻게 관리할것인가</p>
<p>하드 디스크, 플래시 메모리 등</p>
<p>섹터들을 모아서 block이라 하는데 block들에 데이터를 저장하게 되는데 빈 공간 관리, 저장공간 할당, 디스크 스케쥴링을 제공한다.</p>
<h4 id="입출력-장치-관리"><a href="#입출력-장치-관리" class="headerlink" title="입출력 장치 관리"></a>입출력 장치 관리</h4><p>장치드라이브 관리(웹켐, 사운드카드 등)<br>입출력 장치의 성능향상을 위해 버퍼링, 캐싱, 스풀링을 활용한다</p>
<p>스풀링 메모리 대신 하드디스크를 중간 매체로 사용한다.<br>스풀링 : 프린터는 일반적으로 느리기때문에 씨피유에 저장하기 보다는 씨피유보다 느리고 프린터 보다 빠른 하드디스크에 저장하는것.<br>빈 공간 관리 (free space management)<br>저장공간 할당 (storage allocation)<br>디스크 스케쥴링 (disk scheduling)</p>
<h4 id="네트워킹"><a href="#네트워킹" class="headerlink" title="네트워킹"></a>네트워킹</h4><h4 id="보호"><a href="#보호" class="headerlink" title="보호"></a>보호</h4><h4 id="기타-등등…"><a href="#기타-등등…" class="headerlink" title="기타 등등…"></a>기타 등등…</h4><h3 id="시스템-콜"><a href="#시스템-콜" class="headerlink" title="시스템 콜"></a>시스템 콜</h3><p><u>O/S가 제공하는 여러가지 기능을 받기 위해 호출하는것.</u></p>
<p>OS에는 여러가지 관리 부서가 있다.<br>또한 여러가지 프로그램이 메모리로 올라가 여러 프로세스가 존재한다,<br>각 프로세스는 OS가 제공하는 관리 기능들이 필요한데 이때 이를 사용하기 위한것이 시스템 콜이라 한다.</p>
<h3 id="주요-시스템-콜"><a href="#주요-시스템-콜" class="headerlink" title="주요 시스템 콜"></a>주요 시스템 콜</h3><p>– Process: end, abort, load, execute, create, terminate, get/set<br>attributes, wait event, signal event<br>– Memory: allocate, free<br>– File: create, delete, open, close, read, write, get/set attributes<br>– Device: request, release, read, write, get/set attributes, attach/detache devices<br>– Information: get/set time, get/set system data<br>– Communication: socket, send, receive</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;운영체제-서비스&quot;&gt;&lt;a href=&quot;#운영체제-서비스&quot; class=&quot;headerlink&quot; title=&quot;운영체제 서비스&quot;&gt;&lt;/a&gt;운영체제 서비스&lt;/h3&gt;&lt;p&gt;지금은 서버컴퓨터 하나에 여러명이 동시에 사용하는 구조.&lt;br&gt;이러한 구조에선 한사
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>4.사용자모드와 관리자모드, 하드웨어 보호</title>
    <link href="http://KKimSangHeon.github.io/2019/02/11/os4/"/>
    <id>http://KKimSangHeon.github.io/2019/02/11/os4/</id>
    <published>2019-02-11T12:29:11.000Z</published>
    <updated>2019-02-15T12:27:37.482Z</updated>
    
    <content type="html"><![CDATA[<h3 id="이중모드-하드웨어-보호"><a href="#이중모드-하드웨어-보호" class="headerlink" title="이중모드, 하드웨어 보호"></a>이중모드, 하드웨어 보호</h3><p>한 컴퓨터를 여러 사람이 동시에 사용하는 환경이다.<br>한사람의 실수가 전체에 영향을 끼칠 수  있으므로 일반유저는 STOP, HALT, RESET 등과같은 명령어는 일반 유저가 이용할 수 없도록 하는것. 이를 <code>이중모드</code>라 한다.</p>
<p>이를 <u>사용자(user)모드, 관리자(supervisor) 모드</u> 라고 한다.<br>관리자 모드 = 시스템 모드 = 모니터 모드 = 특권 모드<br>특권 명령(ex. STOP, HALT, RESET, SET_TIMER, SET_HW 등은 관리자 모드에서만 사용 가능)</p>
<h3 id="이중모드-동작방식"><a href="#이중모드-동작방식" class="headerlink" title="이중모드 동작방식"></a>이중모드 동작방식</h3><p>CPU안에 레지스터 ALU, 제어유닛이 있다,</p>
<p>레지스터는 비트들의 모음(32bit의 경우 32개가 있다.)<br>레지스터 비트는 carry,zero, negative, overflow 와 같은 플래그도 갖고있다,<br><u>또한 이중모드를 나타내기 위한 플래그(모니터 비트라 함) 또한 레즈스터에 존재한다.</u></p>
<p>모니터 비트가 1이면 시스템모드 0이면 유저모드이다.</p>
<h3 id="가령-게임을-실행하고-저장한다고-가정해보자"><a href="#가령-게임을-실행하고-저장한다고-가정해보자" class="headerlink" title="가령 게임을 실행하고 저장한다고 가정해보자."></a>가령 게임을 실행하고 저장한다고 가정해보자.</h3><p>1.처음 파워를 키면 부팅이 일어난다 이때는 모니터 비트가 1이다.(시스템 모드)<br>2.OS의 부트가 끝나고 특정 게임을 실행한다고 하자, 그럼 디스크에서 게임을 메모리로 갖고올 것이다.<br>3.그리고 실행이 게임으로 넘어갈 때 모니터 비트는 0 (유저모드)로 변경된다.<br>4.다시 게임내용을 하드디스크에 저장할 때는 OS에게 부탁(SWI,소프트웨어 인터럽트)하여 OS가 저장하게 한다(다른파일을 덮어쓰는지와 같은 부정한 행위를 하는지에 대한 판단을 하고 저장하게 해줌). 이때는 모니터 비트가 다시 1이된다. //물론 게임 자체적으로 디스크에 저장할 수 있지만 보안상의 이슈 존재!<br>5.저장을 완료하면 다시 게임 프로그램으로 돌아오고 모니터 비트가 0이된다.</p>
<p>운영체제 서비스 실행될 때는 관리자 모드<br>사용자 프로그램 실행될 때는 사용자 모드<br>하드웨어/소프트웨어 인터럽트 발생하면 관리자 모드<br>운영체제 서비스가 끝나면 다시 사용자 모드</p>
<h3 id="하드웨어-보호"><a href="#하드웨어-보호" class="headerlink" title="하드웨어 보호"></a>하드웨어 보호</h3><p>1.입출력장치에 대한 보호</p>
<p>하드웨어에 대한 적절한 보호가 없을 때의 경우<br>내가 프린트하는데 누가 방해할라고 그놈도 계속 프린트 명령을 보내는상황이 발생했을 때.<br>내가원하는 출력물, 상대가 원하는 출력물이 섞여서 나오는 경우가 생길 수 있다.</p>
<p>어떻게?<br><code>아무유저나 In,Out 명령을 내리지 못하도록 특권명령으로 한다.</code></p>
<h3 id="사용자가-입출력-명령을-직접-내린-경우"><a href="#사용자가-입출력-명령을-직접-내린-경우" class="headerlink" title="사용자가 입출력 명령을 직접 내린 경우?"></a>사용자가 입출력 명령을 직접 내린 경우?</h3><p>Privileged instruction violation 이라 하며 해당 프로그램을 강제로 중지시킨다.</p>
<h3 id="메모리-보호"><a href="#메모리-보호" class="headerlink" title="메모리 보호"></a>메모리 보호</h3><p>멀티프로그래밍, 타임쉐어링 프로그래밍에서는 동시에 여러프로그램이 돌고있다.<br>특정 프로그램이 돌면서 다른 프로그램 혹은 OS의 영역에 기웃거리지 못하게 한다.</p>
<p>어떻게?<br>메모리에 접근하려면 어드레스 버스를 통해야하는데 어드레스 버스에 문지기를 두어 자기것에만 접근하는지 확인한다.<br>확인할 때는 base, limit 를 참고한다. 잘못된 범위를 읽을 땐 인터럽트를 O/S로 보낸다. 잘못된 번지를 읽을 때 보내는 신호를 보통 <u>Segment violation</u> 라고 부른다.</p>
<p>여기서 문지기를 <code>MMU(Memory Management Unit)라고 한다. base 와 limit 사이에 들어오는지 확인하며 base와 limit는 OS가 관리한다. 또한 base와 limit는 아무나 설정하면 안되므로 특권명령으로 관리된다.</code></p>
<p>3.CPU 보호</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;이중모드-하드웨어-보호&quot;&gt;&lt;a href=&quot;#이중모드-하드웨어-보호&quot; class=&quot;headerlink&quot; title=&quot;이중모드, 하드웨어 보호&quot;&gt;&lt;/a&gt;이중모드, 하드웨어 보호&lt;/h3&gt;&lt;p&gt;한 컴퓨터를 여러 사람이 동시에 사용하는 환경이다.
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>3.최근의 고급운영체제, 인터럽트에 기반한 현대 운영체제</title>
    <link href="http://KKimSangHeon.github.io/2019/02/11/os3/"/>
    <id>http://KKimSangHeon.github.io/2019/02/11/os3/</id>
    <published>2019-02-11T10:49:46.000Z</published>
    <updated>2019-02-15T12:27:37.793Z</updated>
    
    <content type="html"><![CDATA[<h3 id="다중-프로세서-시스템"><a href="#다중-프로세서-시스템" class="headerlink" title="다중 프로세서 시스템"></a>다중 프로세서 시스템</h3><p>메모리는 하난데 CPU가 여러개이다. 이를 병렬 시스템이라고도 한다.<br>장점 :</p>
<ul>
<li>병렬 시스템을 통한 성능향상을 목표</li>
<li>비용 : 하나의 강한 CPU 보다 여러개의 저렴한 CPU로 구성하는것이 일반적으로 저렴하다.</li>
<li>신뢰성 제공 : 하나가 고장나도 다른 CPU로 돌릴 수 있다.</li>
</ul>
<p>CPU가 여러개일 때 운영체제를 다중 프로세서 운영체제라 한다. 또한 강결합이라 한다.</p>
<h3 id="분산-시스템"><a href="#분산-시스템" class="headerlink" title="분산 시스템"></a>분산 시스템</h3><p>멀티컴퓨터 시스템이라고도 하며 네트워크(LAN) 등으로 연결되어 있다.<br>이는 메인메모리가 따로있고 랜으로 연결되어있으므로 소결합이라 한다.<br>OS도 서로 다 따로따로 있다. 이를 분산 운영체제라 한다.</p>
<h3 id="다중프로세서-시스템-분산시스템의-공통점"><a href="#다중프로세서-시스템-분산시스템의-공통점" class="headerlink" title="다중프로세서 시스템, 분산시스템의 공통점"></a>다중프로세서 시스템, 분산시스템의 공통점</h3><p>신뢰성, 성능, 비용절감을 목표로 한다.</p>
<h3 id="실시간-시스템"><a href="#실시간-시스템" class="headerlink" title="실시간 시스템"></a>실시간 시스템</h3><p>특정 시간내에 반드시 연산이 끝나야 하는것.<br>시간제약 즉 Deadline를 정해둔다. 실시간 시스템은 네비게이션에서도 쓰인다. 실시간 경로안내할때 그 지점에 도착하기 전에 계산이 끝나야하기 때문에<br>주로 공장자동화, 군사, 항공, 우주 분야에서도 쓰인다.<br>실시간 시스템을 위한 운영체제는 실시간 운영체제(Real-time OS = RTOS)라 한다.</p>
<h3 id="인터럽트"><a href="#인터럽트" class="headerlink" title="인터럽트"></a>인터럽트</h3><p>현대 운영체제는 인터럽트 기반 시스템이다.</p>
<p>컴퓨터를 키면 ROM에 있는 부트로더가 디스크에서 O/S를 메모리로 갖고온다. 이를 부팅이라 한다.<br>이 후 운영체제는 메모리에 상주하게 된다.<br>이 다음에는 아이콘이 나타나고 깜빡거린다.<br>이러다 <u>우리가 마우스를 움직이면 전기신호가 발생하고 CPU에 인터럽트 선을 통해 전기신호를 올려준다</u>.<br>그럼 CPU는 지금하던일을 중지하고 OS안에 마우스가 어떤 전기신호를 보냈을 때 어떤 행동을 하라고 정의되어있는지(<u>mouse interrupt service routine</u>)에 따라 처리한다.</p>
<h3 id="하드웨어-인터럽트"><a href="#하드웨어-인터럽트" class="headerlink" title="하드웨어 인터럽트"></a>하드웨어 인터럽트</h3><p>인터럽트 결과 운영체제 내의 특정코드를 실행한다.(ISR)<br>interrupt Service Routine 종료 후 다시 대기</p>
<h3 id="소프트웨어-인터럽트"><a href="#소프트웨어-인터럽트" class="headerlink" title="소프트웨어 인터럽트"></a>소프트웨어 인터럽트</h3><p>SWI 명령어는 인터럽트가 걸리는것이다. 보통 인터럽트는 하드웨어가 걸리는데</p>
<p>SWI(Software interrupt) - ARM에서의 소프트웨어 인터럽트 명령<br>INT - 팬티엄에서의 인터럽트 명령</p>
<p>hwp 프로그램이 실행되다가 하드디스크에 있는 내용을 읽어온다고 가정하자.<br>하드디스크를 읽어오는 루틴은 O/S안에 존재한다. 이것또한 ISR이다. 아무튼 <u>하드디스크 내용을 읽기위해 소프트웨어 인터럽트가 걸리게 되고 O/S안에 있는 하드디스크를 읽어오는 루틴을 실행하고 원래 실행중인 곳으로 돌아온다.</u></p>
<h3 id="운영체제는-평소에는-대기상태이다"><a href="#운영체제는-평소에는-대기상태이다" class="headerlink" title="운영체제는 평소에는 대기상태이다"></a>운영체제는 평소에는 대기상태이다</h3><p><u>운영체제는 평소에는 대기상태이다. 그러나 하드웨어 인터럽트, 소프트웨어 인터럽트, 내부인터럽트에 의해 운영체제 코드를 실행한다.</u></p>
<p>내부 인터럽트는 5를 0으로 나누는것과 같은 논리적인 오류가 있을 때 발생하는 인터럽트이다. 이 땐 divide by zero를 처리하는 ISR이 호출된다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;다중-프로세서-시스템&quot;&gt;&lt;a href=&quot;#다중-프로세서-시스템&quot; class=&quot;headerlink&quot; title=&quot;다중 프로세서 시스템&quot;&gt;&lt;/a&gt;다중 프로세서 시스템&lt;/h3&gt;&lt;p&gt;메모리는 하난데 CPU가 여러개이다. 이를 병렬 시스템이라고도
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>2.일괄처리부터 시분할시스템까지 운영체제 변천 역사</title>
    <link href="http://KKimSangHeon.github.io/2019/02/10/os2/"/>
    <id>http://KKimSangHeon.github.io/2019/02/10/os2/</id>
    <published>2019-02-10T13:33:13.000Z</published>
    <updated>2019-02-15T12:27:36.853Z</updated>
    
    <content type="html"><![CDATA[<h3 id="컴퓨터의-역사"><a href="#컴퓨터의-역사" class="headerlink" title="컴퓨터의 역사"></a>컴퓨터의 역사</h3><p>2차세계 대전 중 1940년대 말 만들어졌다.</p>
<p><code>1.초기에는 운영체제가 존재하지 않았다.</code></p>
<p><code>2.이후엔 Batch processing system(일괄처리)이 나왔다</code><br>이는 최초의 O/S로 볼 수 있다.</p>
<p><code>3.Multiprogramming system</code><br>가령 수를 더해서 출력하고 다시 이를 특정 수를 반복해서 더하는 프로그램이 있다고 해보자.<br>수를 더하는것은 CPU가 할 것이고 출력은 입출력 장치가 하게될것이다.<br>이 때 CPU가 작업을 마치고 출력을 위해 입출력 장치가 출력을 실행하게 되면 느린 i/o의 성능으로 인해 CPU가 idle(노는시간) 즉 기다리는 시간이 생기게 된다. 이를 개선하기 위해 메모리에 여러 프로그램을 올리고 실행중인 프로그램이 <u>i/o</u>를 만나면 다른 프로그램을 실행토록 한다.</p>
<p><u>이를 통해 CPU가 노는 시간이 없도록한다.</u><br>이와 관련하여 <u>CPU scheduling</u>가 나오게된다. 어떤 순으로 실행하여 성능을 좋게할까에 대한 알고리즘이다.<br><u>메모리 관리</u>또한 나오게된다. 이는 적절하게 프로그램을 메모리에 배치하기 위한 기법이다.<br><u>보호</u>개념또한 등장하게 되는데 메모리에서 다른 프로그램의 영역에 침범하면 안되므로!</p>
<p><code>4.Time-sharing system</code><br>여러사람이 한 컴퓨터로 들어와 자신의 프로그램을 사용한다고 가정하자. 이 때 여러사람들은 Multiprogramming system에서는 동시에 사용하기란 불가능하다.(이는 I/O를 만나야 다른 프로그램을 동작시키는 로직이므로..)<br>그래서 <u>아주 짧은시간으로 나눠 여러 유저의 작업을 번갈아가며 CPU가 처리해주도록</u> 한다.</p>
<p>이러한 시스템이 등장하며 특정유저가 다른 유저에게 데이터를 주고받는것이 즉 <u>프로세스간 통신</u>이 가능해졌다.<br>또한 누가 먼저 앞서고 뒤서는지에 대한 <u>동기</u>라는 개념이 등장한다.<br>또한 하드디스크의 일부를 메인메모리인냥 사용하는 기술인 <u>가상 메모리</u> 또한 등장하게된다.</p>
<h3 id="OS-기술-천이"><a href="#OS-기술-천이" class="headerlink" title="OS 기술 천이"></a>OS 기술 천이</h3><p>컴퓨터의 규모별 분류는 다음과 같다.<br><code>과거의 분류 :</code><br>  Supercomputer &gt; Mainframe &gt; Mini &gt; Micro<br><code>현재의 분류 :</code><br>  Supercomputer &gt; Server &gt; Workstation &gt; PC &gt; Handheld &gt; Embedded<br>워크스테이션 : PC에서 처리못하는 조금 큰 작업 처리</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;컴퓨터의-역사&quot;&gt;&lt;a href=&quot;#컴퓨터의-역사&quot; class=&quot;headerlink&quot; title=&quot;컴퓨터의 역사&quot;&gt;&lt;/a&gt;컴퓨터의 역사&lt;/h3&gt;&lt;p&gt;2차세계 대전 중 1940년대 말 만들어졌다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1.초기에는 운영체제
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>1.	운영체제의 정의와 역할</title>
    <link href="http://KKimSangHeon.github.io/2019/02/10/os/"/>
    <id>http://KKimSangHeon.github.io/2019/02/10/os/</id>
    <published>2019-02-10T12:03:53.000Z</published>
    <updated>2019-02-22T14:15:21.308Z</updated>
    
    <content type="html"><![CDATA[<p>운영체제 포스팅은 <a href="http://www.kocw.net/home/search/kemView.do?kemId=978503" target="_blank" rel="external">http://www.kocw.net/home/search/kemView.do?kemId=978503</a> (KOCW) 를 참고하여 작성됩니다.</p>
<h3 id="운영체제가-없는-PC는-어떨까"><a href="#운영체제가-없는-PC는-어떨까" class="headerlink" title="운영체제가 없는 PC는 어떨까?"></a>운영체제가 없는 PC는 어떨까?</h3><p>야생마와 같다. 프로그램 실행과 같은 동작을 할 수 없게된다.<br>하드디스크에 있는 파일을 메모리에 올릴수 없다.<br>즉 하드디스크에 있는 파일을 운영체제가 올려주는것!</p>
<h3 id="운영체제란"><a href="#운영체제란" class="headerlink" title="운영체제란?"></a>운영체제란?</h3><p>하드웨어를 잘 관리하는것.(하드웨어: 프로세서, 메모리, 디스크…)<br>이를 통해 <code>성능을</code> 올리고 사용자에게 <code>편의성</code>을 제공</p>
<h3 id="부팅"><a href="#부팅" class="headerlink" title="부팅"></a>부팅</h3><p>메모리는 램, 롬으로 나뉜다. 대부분은 램으로 구성된다. 롬은 많아야 수백키로바이트밖에 되지 않는다,<br><code>그렇다면 ROM이 필요한 이유는?</code> 전원을 껐다 켜면 램의 데이터는 다 날라가는데 ROM은 그렇지 않다.</p>
<p>컴퓨터를 부팅하면 프로세서는 ROM에 있는 코드를 읽어온다.<br>그렇다면 <code>ROM에는 어떤 프로그램이 있으며 부팅과정은?</code><br>1.POST(Power On Self Test) 프로그램을 ROM에서 가져와 실행<br>  <code>POST?</code>  모니터는 끼워져있는가, 키보드는 꽂아져 있나, 메모리는 얼마인가 등을 확인하는 프로그램<br>2.부트로더(Boot loader)를 ROM에서 가져와 실행.<br>  <code>부트로더는?</code> 하드디스크를 뒤져서 os를 메인메모리(RAM)로 갖고온다. 이를 부팅이라 한다.</p>
<p>메모리에 올라온 OS는 컴퓨터가 종료될때 까지 지워지지 않는다. 하지만 다른 응용프로그램들은 프로그램 종료에 따라 지워지게된다. 그래서 OS를 <code>메모리 Resident</code>라고 한다.</p>
<img src="/2019/02/10/os/image1.png" alt="커널과 쉘" title="커널과 쉘">
<h3 id="커널과-쉘"><a href="#커널과-쉘" class="headerlink" title="커널과 쉘"></a>커널과 쉘</h3><p>OS는 하드웨어를 감싸고 있는데 하드웨어를 제외한 부분을 <code>kernel</code>이라고 한다. 또한 OS의 바깥부분을 <code>(shell,command interpreter)</code>이라 한다.</p>
<p>어떤 명령을 내릴 수 있도록 만드는것을 (<code>shell,command interpreter</code>)이라고 한다.<br>다시말해 <u>OS바깥부분에 위치해서 사용자의 명령을 받아들이는 곳. 그 명령을 인터프리터(해석해서) 명령을 실행해주는 것!</u></p>
<p><code>커널</code>은 실제로 <u>Cpu,메모리, 디스크를 관리하는것.</u></p>
<h3 id="응용프로그램-동작"><a href="#응용프로그램-동작" class="headerlink" title="응용프로그램 동작?"></a>응용프로그램 동작?</h3><p>응용프로그램은 O/S위에서 동작한다.<br>즉 맥킨토시 app을 윈도우에서 실행하면 동작하지 않는다.</p>
<h3 id="OS-는-정부와-비슷하다"><a href="#OS-는-정부와-비슷하다" class="headerlink" title="OS 는 정부와 비슷하다."></a>OS 는 정부와 비슷하다.</h3><p>주어진 자원을 어떻게 활용할까에 대한 고민을 하는것이 유사!</p>
<p>정부에도 여러가지 부서가 있듯이 OS안에도 많은 부서가 존재!</p>
<p>프로세스 매니지먼트 - 프로세스 관리부서<br>메모리 매니지먼트 - 메모리 관리<br>IO 매니지먼트 - 프린트, 키보드 관리<br>파일 매니지먼트 - 파일관리<br>네트워크 매니지먼트 - 네트워크 관리<br>시큐어티 매니지먼트 - 보안관리<br>…..<br>이런부분을 모두 운영체제의 커널로 불린다.</p>
<p>가장중요한것은 프로세스 매니지먼트! CPU가 가장비싸니까 가장 중요하고 프로그램 동작에 핵심이다.<br>그다음으로 중요한것이 메모리 매니지먼트</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;운영체제 포스팅은 &lt;a href=&quot;http://www.kocw.net/home/search/kemView.do?kemId=978503&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.kocw.net/home/searc
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>oneM2M, OMA-DM 생각정리..</title>
    <link href="http://KKimSangHeon.github.io/2019/02/08/mine/"/>
    <id>http://KKimSangHeon.github.io/2019/02/08/mine/</id>
    <published>2019-02-08T10:53:12.000Z</published>
    <updated>2019-02-10T08:02:03.813Z</updated>
    
    <content type="html"><![CDATA[<h3 id="oneM2M"><a href="#oneM2M" class="headerlink" title="oneM2M"></a>oneM2M</h3><p>iot 솔루션을 제공함에 있어 여러 벤더를 맞추기란 힘들다… oneM2M이라는 표준을 만들고 이를 여러 벤더가 맞춤으로써 응용개발사 또한 iot시스템을 개발함에 있어 개발공수를 낮출 수 있게된다.<br>oneM2M에는 CSE라는게 있는데 공통서비스를 제공하는것이다. 가령 데이터 저장, 요금청구 등등 다양하게 있다..</p>
<p>CSE는 REST 형태로 제공되어 편리하다는 장점이 있으며 최근에는 일반 응용개발에 oneM2M을 적용하여 CSE를 적절히 활용하는 경우도 있다. 이를 Distributed Platform 형태 라고 한다<br>통신사업자는 oneM2M 표준을 기반으로 CSE를 사용하는 플랫폼을 만들고 일반에 공개하게 되면 일반 개발자들은 통신사업자가 만든 플랫폼을 사용할 수 있게된다.(?? 맞는지 모르겠다.)</p>
<h3 id="OMA-DM"><a href="#OMA-DM" class="headerlink" title="OMA-DM"></a>OMA-DM</h3><p>이는 이동통신장치 관리표주으로서 내부 데이터에 접근하고 제어하는 표준이라 이해했다. xml기반 마크업 언어 SyncML 기반으로 명령과 결과를 주고받으며 심지어 운영체제 설치 그리고 응용프로그램의 파라미터 까지 변경이 가능하다고 한다. 여기서 관리할수 있는 자원을 <code>관리객체(MO, Management Object)</code>라고 한다.</p>
<h3 id="TR-069"><a href="#TR-069" class="headerlink" title="TR-069"></a>TR-069</h3><p>CPE WAN Management Protocol (CWMP) 이라 불리며 CPE 즉 사용자 단말을 관리하는 프로토콜인것같다.</p>
<h3 id="oneM2M과-OMA-DM의-상관관계"><a href="#oneM2M과-OMA-DM의-상관관계" class="headerlink" title="oneM2M과 OMA-DM의 상관관계???"></a>oneM2M과 OMA-DM의 상관관계???</h3><p>아래부터 개인적인생각입니다. 참고하지도 마세요!<br>oneM2M은 장치에서 받은 데이터를 활용하고 정제 저장하는 표준이라고 생각한다. 즉 디바이스의 정보를 뭐 제어하거나 어떻게 가져오는건 아니라 생각한다.<br>하지만 OMA-DM는 내부데이터 관리와 같은 디바이스 내부로 들어가는 표준인것같다.</p>
<p>아래 그림처럼 구분되나보다<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;oneM2M&quot;&gt;&lt;a href=&quot;#oneM2M&quot; class=&quot;headerlink&quot; title=&quot;oneM2M&quot;&gt;&lt;/a&gt;oneM2M&lt;/h3&gt;&lt;p&gt;iot 솔루션을 제공함에 있어 여러 벤더를 맞추기란 힘들다… oneM2M이라는 표준을 만들고 이를
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="IOT" scheme="http://KKimSangHeon.github.io/categories/CS/IOT/"/>
    
    
  </entry>
  
  <entry>
    <title>onem2m</title>
    <link href="http://KKimSangHeon.github.io/2019/02/08/onem2m/"/>
    <id>http://KKimSangHeon.github.io/2019/02/08/onem2m/</id>
    <published>2019-02-08T09:44:50.000Z</published>
    <updated>2019-02-08T10:39:25.022Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.youtube.com/watch?v=tBQ085PvR9E" target="_blank" rel="external">https://www.youtube.com/watch?v=tBQ085PvR9E</a> 요약</p>
<h3 id="IOT의-4계층"><a href="#IOT의-4계층" class="headerlink" title="IOT의 4계층"></a>IOT의 4계층</h3><p>Application layer - 스마트홈, 스마트카, 헬스케어<br>Service layer - IoT 서비스 개발이 용이하도록 공통으로 요구되는 기능 제공 <code>oneM2M, AllJoyn, OIC</code><br>Network layer - 장치 간 또는 서비스간 연결, 정보전달 <code>HTTP, CoAP, MQTT, Wi-Fi ...</code><br>Device layer - 센서 또는 다른 하드웨어</p>
<h3 id="oneM2M"><a href="#oneM2M" class="headerlink" title="oneM2M ?"></a>oneM2M ?</h3><p>IoT 응용 개발이 용이하도록 공통 기능을 제공하는 국제표준 플랫폼 기술</p>
<p>데이터관리, 연결 제어, 구독/통지, 보안, 그룹관리 ….</p>
<p>등을 제공하는데 응용 개발자는 이를 적절히 활용하여 개발공수를 줄일 수 있다.</p>
<h3 id="oneM2M발생이유"><a href="#oneM2M발생이유" class="headerlink" title="oneM2M발생이유"></a>oneM2M발생이유</h3><p>기존엔 응용이 특정한 디바이스를 타겟으로 개발되었다. 이를 개선할 수 있는것이 oneM2M</p>
<h3 id="oneM2M-1"><a href="#oneM2M-1" class="headerlink" title="oneM2M"></a>oneM2M</h3><p>먼저 Use Case를 기반으로 요구사항을 도출해봤더니 다음과 같았다.<br><code>일반요구사항:</code> 성능, 네트워크 연결지원에 따른 다양한 IoT장치 지원, QoS 기반 메시지 전달, 과금관리…<br><code>장치관리요구사항:</code> <u>OMA DM</u>/ BBF TR-069, 펌웨어, 소프트웨어 제어, 고장제어<br><code>보안 요구사항:</code>요청자에 대한 인증/권한 부여, 기반 네트워크 보안기능 활용</p>
<p>이를 기반으로 공통기능 CSE를 도출해냄<br>데이터관리 : 장치가 데이터를 저장할 수 없을때 플랫폼이 저장해준다<br>연결제어 : 레이턴시는 10ms 이하여야 한다.(예시)<br>구독. 통지 : 온도가 40도 이상이면 문자보내줘<br>과금 : 통신플랫폼의 사업자 이므로 이 또한 가능<br>이종 플랫폼 연동<br>사업자간 로밍 : 나의 커넥티드 카가 해외로 넘어가게 되면 로밍을 제공<br>기타 많은 공통기능 제공</p>
<p>oneM2M 안드로이드 플랫폼이랑 유사하다. CSE는 공통기능이 포함된 엔티티다.</p>
<p>AE를 카카오톡이라고 보면 좋다. 카톡은 안드로이드에 존재하는 간단한 API를 호출해 메세지를 보낸다.<br>즉 AE개발자는 CSE를 적절히 활용하면 된다.</p>
<p>여러플랫폼이 서로 연결되어 큰 iot를 만들어 낼 수 있게된다.</p>
<h3 id="Distributed-Platform-형태인-oneM2M"><a href="#Distributed-Platform-형태인-oneM2M" class="headerlink" title="Distributed Platform 형태인 oneM2M"></a>Distributed Platform 형태인 oneM2M</h3><p>IOT의 호출순서는 다음과 같다고 가정 하자.<br><code>디바이스 - 게이트웨이 - 클라우드 - 게이트웨이 - 디바이스</code><br>과거에는 클라우드에만 CSE를 탑재하여 호출하였지만 최근에는 게이트웨이, 디바이스에도 이를 탑재하여 분산처리를 한다.<br>물론 하드웨어의 용량이 부족할 경우 플랫폼 기능을 배제하기도 한다. 이 경우 <u>Constrained Device Support</u> 라고 한다.</p>
<h3 id="그렇다면-CSE를-어떻게-호출할까"><a href="#그렇다면-CSE를-어떻게-호출할까" class="headerlink" title="그렇다면 CSE를 어떻게 호출할까?"></a>그렇다면 CSE를 어떻게 호출할까?</h3><p>과거에는 RPC(Remote Procedure Call)을 활용하였지만 REST 기반 API구조를 사용한다.<br>CSE의 기능들을 REST 형태로 개방한다. 즉 URI만 갖고있으면 웹브라우저에서 기능을 호출할 수 있다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=tBQ085PvR9E&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.youtube.com/watch?v=tBQ085PvR9E&lt;/a&gt; 요약&lt;/
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="IOT" scheme="http://KKimSangHeon.github.io/categories/CS/IOT/"/>
    
    
  </entry>
  
  <entry>
    <title>TR-069</title>
    <link href="http://KKimSangHeon.github.io/2019/02/08/TR-069/"/>
    <id>http://KKimSangHeon.github.io/2019/02/08/TR-069/</id>
    <published>2019-02-08T05:52:45.000Z</published>
    <updated>2019-02-10T08:35:10.602Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TR-069"><a href="#TR-069" class="headerlink" title="TR-069"></a>TR-069</h3><p>customer-premises equipment (CPE, 말단 사용자 장치)<br>Auto Configuration Servers (ACS, 자동 설정 서버)</p>
<p>TR-069 (Technical Report 069)는 DSL 포럼 (이후 Broadband 포럼으로 변경)의 기술 명세서이다. 이 문서의 정식 명칭은 CPE WAN Management Protocol (CWMP)이다. 이 문서는 말단 사용자 장치를 관리하기 위한 사용자 계층 프로토콜을 정의하고 있다.</p>
<p><code>TR-069 프로토콜은 양방향 SOAP/HTTP 을 기반으로 customer-premises equipment (CPE, 말단 사용자 장치) 와 Auto Configuration Servers (ACS,자동 설정 서버) 간 통신을 가능하게 한다.</code> 또한 안전한 자동 설정 기능을 제공하며 통합 환경 내에서 다른 CPE 관리 함수를 제어하고 동작시킬 수 있도록 해준다.</p>
<h3 id="등장배경"><a href="#등장배경" class="headerlink" title="등장배경"></a>등장배경</h3><p> 브로드밴드 시장이 활성화 되면서 여러개의 다른 종류의 인터넷 접속 또한 많이 생겨났다. ( 모뎀, 라우터, 게이트웨이, 세트톱박스, VoIP-phone 등). <code>또한 동시에 이러한 장비들을 설정하는 것은 더욱 복잡해졌다. 말단 사용자에게는 이러한 설정이 더욱 어려운데 이러한 이유로 TR-069 표준이 개발되었다. TR-069 표준은 여러가지 접속 방법에 대한 자동 설정을 제공한다.</code> 이에대한 구체적인 기술적인 사항은 Broadband 포럼에서 관리하고 발행하고 있다.<code>TR-069을 이용해서 말단 장비들은 자동 설정 서버 (Auto Configuration Servers) (ACS)에 접속하고 필요한 설정을 자동으로 받아오게 된다. 이렇게 함으로써 사용자가 따로 설정하지 않아도 필요한 서비스를 사용하는 것이 가능해진다.</code> TR-069는 DSL broadband 시장에서 터미널을 활성화하기 위해 현재 사용중인 표준이다.</p>
<h3 id="CPE-WAN-Management-Protocol-CWMP"><a href="#CPE-WAN-Management-Protocol-CWMP" class="headerlink" title="CPE WAN Management Protocol (CWMP)??"></a>CPE WAN Management Protocol (CWMP)??</h3><p>서비스 프로바이더가 ACS를 통해 CPE를 원격으로 데이터 모델을 관리할 수 있게 해준다. 제공기능은 다음과 같다.</p>
<p>자동 구성 및 동적 서비스 프로비저닝<br>소프트웨어 / 펌웨어 이미지 관리<br>소프트웨어 모듈 관리 상태 및 성능 모니터링 진단</p>
<h3 id="TR-069-아키텍처"><a href="#TR-069-아키텍처" class="headerlink" title="TR-069 아키텍처"></a>TR-069 아키텍처</h3><img src="/2019/02/08/TR-069/image1.png" alt="TR-069 아키텍처" title="TR-069 아키텍처">
<p><u>All CWMP sessions begin with the CPE making the Inform RPC on the ACS.</u> This is also referred to as “sending an Inform” or “an Inform message”. An Inform RPC, and consequently, a CWMP session, is always made for a specific reason, called an Event. These Events drive CWMP operation.</p>
<h4 id="TR-069-초기-세션"><a href="#TR-069-초기-세션" class="headerlink" title="TR-069 초기 세션"></a>TR-069 초기 세션</h4><p>ACS와 연결하기 위해서는 다음의 데이터가 필요하다.</p>
<ul>
<li>ACS URL : ACS에 접속하기 위한 URL</li>
<li>주기적인 알림 : ACS와 주기적인 소통이 정의되어야 한다.</li>
<li>Username and password - 옵션데이터이나 보안을 위해 하는것이 좋다.</li>
</ul>
<img src="/2019/02/08/TR-069/image2.png" alt="TR-069의 초기 세션" title="TR-069의 초기 세션">
<p>1.First, the CPE initiates a TCP session with ACS and negotiates a secure connection.<br>2.The CPE begins every session by sending an Inform RPC to the ACS, with arguments that include the Event that caused the session. This is done over an HTTP Post.<br>3.In the HTTP Response, the the ACS sends an InformResponse. Once processed by the CPE, this means that the Inform RPC is complete.<br>4.There’s probably no other RPCs that CPE wishes to make on the ACS, so it sends an empty HTTP Post to indicate that it is finished. This may happen at any time during the session.<br>5.The ACS begins to send remote procedure calls to the CPE, such as the GetParamterValues RPC.<br>6.The CPE sends its GetParameterResponse in an HTTP Post, with the information the ACS was looking for. This ends the GetParameterValues RPC.<br>7.The ACS makes any other RPCs it needs to during this session, such as SetParameterValues to change the state of the CPE, or SetParameterAttributes to set up a notification.<br>8.When the ACS has no more RPCs to make, it sends an empty HTTP Response, just like the CPE did earlier. When both the CPE and the ACS have done this, the session is over and it’s time to tear down the connection.</p>
<h3 id="전송방식"><a href="#전송방식" class="headerlink" title="전송방식"></a>전송방식</h3><p>CWMP는 텍스트 기반 프로토콜입니다. 장치 (CPE)와 자동 구성 서버 (ACS)간에 전송 된 주문은 HTTP 혹은 HTTPS 를 통해 전송됩니다. 이 수준 (HTTP)에서 CPE는 클라이언트 역할을하며 ACS는 HTTP 서버 역할을합니다.</p>
<hr>
<h2 id="별첨"><a href="#별첨" class="headerlink" title="별첨"></a>별첨</h2><h4 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h4><p>SOAP(Simple Object Access Protocol)은 일반적으로 널리 알려진 HTTP, HTTPS, SMTP 등을 통해 XML 기반의 메시지를 컴퓨터 네트워크 상에서 교환하는 프로토콜이다. SOAP은 웹 서비스에서 기본적인 메시지를 전달하는 기반이 된다.</p>
<hr>
<h3 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h3><p><a href="https://www.qacafe.com/tr-069-training/" target="_blank" rel="external">https://www.qacafe.com/tr-069-training/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;TR-069&quot;&gt;&lt;a href=&quot;#TR-069&quot; class=&quot;headerlink&quot; title=&quot;TR-069&quot;&gt;&lt;/a&gt;TR-069&lt;/h3&gt;&lt;p&gt;customer-premises equipment (CPE, 말단 사용자 장치)&lt;br&gt;Auto C
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="IOT" scheme="http://KKimSangHeon.github.io/categories/CS/IOT/"/>
    
    
  </entry>
  
  <entry>
    <title>OMA-DM</title>
    <link href="http://KKimSangHeon.github.io/2019/02/08/oma-dm/"/>
    <id>http://KKimSangHeon.github.io/2019/02/08/oma-dm/</id>
    <published>2019-02-08T01:29:08.000Z</published>
    <updated>2019-02-10T08:41:54.697Z</updated>
    
    <content type="html"><![CDATA[<h4 id="OMA-Open-Mobile-Alliance"><a href="#OMA-Open-Mobile-Alliance" class="headerlink" title="OMA(Open Mobile Alliance)"></a>OMA(Open Mobile Alliance)</h4><p>이동통신 서비스 애플리케이션 표준화 기구이며 일부 애플리케이션 프로토콜을 다루고 있는 산업 포럼의 증진에 응하기 위해 2002년 6월 설립되었다.</p>
<h4 id="Device-Management-DM"><a href="#Device-Management-DM" class="headerlink" title="Device Management(DM) ?"></a>Device Management(DM) ?</h4><p><code>장치 관리 기술이란 직접 수익을 창출하는 기술은 아니지만, 사업자가 응용 서비스를 시작하고 개선하고 관리하는 과정에서 겪는 문제점들을 해결해 줄 수 있는 효과적인 기술로서 이들 서비스를 통한 수익 창출에 효과적인 솔루션이다.</code><br>WAP, 3G Partnership Project(3GPP), Open Service Gateway Initiative(OSGi), Telemanagement Forum(TMF)등은 그들이 개발한 응용 서비스를 관리해 줄 수 있는 기술, 그들이 개발한 서비스 관리 기법을 가능하게 해줄 기술을 필요로 하게 되었다.</p>
<h4 id="OMA-DM"><a href="#OMA-DM" class="headerlink" title="OMA-DM"></a>OMA-DM</h4><p><code>장치(단말기) 안에 존재하는 데이터를 서버가 원격으로 접근할 수 있도록 하는 Technology와 규격을 OMA가 제정함</code></p>
<p>OMA 장치 관리 기술은 범세계적인 이동 통신 시장의 특별한 Use Case와 요구 사항을 고려하여 개발되고 있으며, 특히 이동 단말기의 종류, 운영체제, 지역, 네트워크 기술에 제한되지 않은 열린 기술이기 때문에 결국 기존의 일부 특정 네트워크와 단말기에 국한된 장치 관리 기술들을 통합하거나 대체할 수 있는 기술이다.</p>
<p>OMA-DM 은 초기 설정, 소프트웨어 및 펌웨어 관리, 원 격 제어, 진단 및 모니터링 등의 기능을 가지고 있으며, 스마트폰 등의 모바일 단말을 대 상으로 관리 서비스를 제공한다.</p>
<h4 id="OMA-DM-프로토콜"><a href="#OMA-DM-프로토콜" class="headerlink" title="OMA-DM 프로토콜"></a>OMA-DM 프로토콜</h4><p>두 통신 상대가 장치 관리 서비스를 제공하는 서버와 장치 관리 서비스를 받아 처리하는 클라이언트의 관계를 갖는다는 관점에서 비대칭 구조를 갖는 프로토콜이다.<br>장치 관리 서버의 역할은 클라이언트에게 장치 관리 명령을 내리는 것이고 클라이언트의 역할은 주어진 명령을 수행하는 것이다. 장치 관리 서버는 장치 관리 명령을 통해 장치에 설치된 응용 서비스의 파라미터를 변경할 수 있으며, 새로운 파라미터를 생성하도록 할 수 있으며, 장치 내부의 정보를 읽어낼 수 있으며, 응용 소프트웨어를 장치에 설치하고, 그것들의 실행을 원격으로 제어할 수 있을 뿐 아니라 운용체제(OS)를 다시 설치할 수도 있다. <u>결국, OMA Device Management 프로토콜이란 장치의 자원을 장치 관리 서버가 원격으로 접근할 수 있게하는 프로토콜이며, 장치 관리 프로토콜을 통해 관리할 수 있는 이러한 자원을 관리 객체(Management Object) 라고 부른다</u></p>
<p>서버와 클라이언트간의 장치 관리 <u>명령과 결과는 원격으로 XML에 기반한 마크업(Markup) 언어인 SyncML 메시지를 HTTP, WSP, OBEX 등의 유선, 무선, 또는 적외선 전송 프로토콜을 통해 서로 전송된다</u>. 뿐만 아니라, Device Management(DM) Tree라는 장치 관리 프로토콜만의 파일 시스템을 정의하고 각 노드를 URI를 통해 접근할 수 있도록 하였다. 그리고, 장치 고유의 데이터 베이스 또는 파일 시스템은 DM Tree와 메핑을 통해 장치 관리 서버에게 투사된다. 그러므로 어떤 장치는 결국 장치 관리 서버에게 있어서 하나의 DM Tree로 나타나게 되는 셈이다. 또한 동일한 장치라도 주어진 접근 권한에 따라 서로 다른 서버에게 다른 형태로 나타나게 된다.</p>
<h4 id="OMA-Device-Management-기술-규격의-구성"><a href="#OMA-Device-Management-기술-규격의-구성" class="headerlink" title="OMA Device Management 기술 규격의 구성"></a>OMA Device Management 기술 규격의 구성</h4><p>아래 그림의 규격 구성에 깔린 의도는 첫째로, <u>기본 규격(Base Protocol)을 다른“Silo”규격들과 분리함으로써 기본 규격이 오랜 기간동안 변하지 않고 꾸준한 안정화 과정을 지날 수 있도록 한다는 것이다.</u> 안정적인 기본 프로토콜의 바탕 위에 변화하는 이동 통신 시장의 요구를 충족시키기 위한 독립적인“Silo”프로토콜들을 정의하도록 함으로써 최소한의 노력으로 안정된 토대 위에서 시장이 필요로 하는 규격을 공급할 수 있는 방안을 마련하였다. 이것은, 각“Silo”규격들이 오직 기본 프로토콜에만 의존적이면서 서로 간에 독립적인 구조를 갖는 프로토콜이기 때문이기도 하다. 둘째로, <u>자료 동기 프로토콜과 SyncML 파서와 SyncML Toolkit을 공유함으로써 기존 SyncML Toolkit에 기반한 네트워크 인프라를 보호하고 재활용할 수 있도록 하기 위함이다.</u></p>
<img src="/2019/02/08/oma-dm/image1.PNG" alt="OMA Device Management 규격의 구성" title="OMA Device Management 규격의 구성">
<h4 id="Management-Object-MO"><a href="#Management-Object-MO" class="headerlink" title="Management Object (MO)"></a>Management Object (MO)</h4><p>OMA-DA의 관리 서버는 기기 내의 관리 객체(Management Object: MO)를 액세스함으로써 장치를 관리하도록 되어 있다. MO 에는 다음과 같은 것들이 있다.</p>
<p><code>FUMO(Firmware Update Management Object):</code> 펌웨어 업데이트 관리<br><code>SCOMO(Software Management):</code> 소프트웨어 컴포넌트 설치, 삭제, 관리<br><code>DiagMon MO(Diagnostics and Monitoring):</code> 배터리, 메모리, 라디오, QoS 파라메터 상태를 수집, 진단<br><code>ConnMo(Connectivity):</code> 베어러나 프록시 등 설정<br><code>DCMO(Device Capabilities):</code> 카메라, 블루투스, USB 등 주변기기를 원격으로 활성 화/비활성화하는 권한<br><code>LAWMO(Lock and Wipe):</code> 분실, 도난시 기기를 잠그거나 완전 삭제<br><code>BMO(Browser):</code> 브라우저 설정 관리: VirMO(Virtualization): 원격에 있는 가상 머신을 관리<br><code>Management Policy MO:</code> 어떤 이벤트가 발생하면 어떤 동작을 수행할 수 있도록 하는 정책을 배포 및 관리: OMA-DM 은 HTTP RESTful 메소드를 이용하며, XML 및 JSON 기반의 메시지를 이 용하고, SSL/TLS 보안 기술을 이용.</p>
<h4 id="OMA-DM의-가상시나리오"><a href="#OMA-DM의-가상시나리오" class="headerlink" title="OMA-DM의 가상시나리오"></a>OMA-DM의 가상시나리오</h4><p>어느 한 통신 사업자의 네트워크 관리자가 신규 가입자가 가입할 때 신청한 서비스 내역을 검토한 후 알맞은 응용 프로그램을 가입자 단말기에게 설치하도록 장치 관리 서버에게 요청한다.<br>장치 관리 서버는 Connectionless WAP Push방식으로 DM Notification메시지를 가입자 장치로 전송한다.<br>DM Notification 메시지는 장치 관리 서버의 전자 서명이 포함된 메시지이며 보통 장치 관리 클라이언트에 의해 처리되고 장치 관리 클라이언트가 서버에게 장치 관리 세션을 요청하도록 한다. 장치 관리 세션이 만들어 지면 장치 관리 서버는 응용 프로그램을 장치 관리 명령을 통해 주어진 응용 프로그램을 장치로 다운로드 한 뒤 그 응용 프로그램이 정상적으로 동작할 수 있도록 사용자 계정, 비밀 번호 등 서비스에 필요한 설정값을 구성하여 사용자가 요구한 대로 동작할 수 있도록 한다.<br>마지막으로, 장치 관리 서버는 역시 장치 관리 명령을 통해 장치의 화면에 앞서 일어난 과정에 대해 설명하는 문구를 나타내어 사용자에게 알려 준다. 사용자는 설치된 응용 프로그램을 이용하여 서비스를 이용한다.</p>
<h4 id="OMA-DM의-ACL"><a href="#OMA-DM의-ACL" class="headerlink" title="OMA-DM의 ACL"></a>OMA-DM의 ACL</h4><p>OMA Device Management 프로토콜은 하나의 장치에 대해 여러 장치 관리 서버가 접근할 수 있도록 설계되었다. 예를 들어, 회사 업무용 소프트웨어를 설치한 단말기의 경우 그 회사의 장치 관리 서버를 구축하여 그 소프트웨어에 대한 사용자명, 비밀 번호, 게이트웨이 등 을 설정하여 회사 내 기밀 자원에 접근할 수 있도록 설정할 수 있으며, 다른 일반 서비스 즉, MMS 서비스 등의 관리를 위해선 외부 통신 사업자의 장치 관리 서버를 통해 장치에 접근하도록 하는 경우를 생각할 수 있다. 이를 위해 OMA Device management 프로토콜은 장치 내부에 존재하는 객체에 대한 관리 권한을 Access Control List(ACL)를 통해 제한하고 있다. ACL를 통해 클라이언트는 어떤 장치 관리 서버가 요청한 장치 관리 명령에 대한 수행 여부를 판단할 수 있다. 이러한 판단 기준은 특정 서버의 특정 장치 관리 명령에 대해 명시할 수가 있다.</p>
<h4 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h4><p>OMA 표준화 동향 - OMA Device Management [LG전자 이동통신기술연구소 김 태 현]<br>TTA저널 제 96호</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;OMA-Open-Mobile-Alliance&quot;&gt;&lt;a href=&quot;#OMA-Open-Mobile-Alliance&quot; class=&quot;headerlink&quot; title=&quot;OMA(Open Mobile Alliance)&quot;&gt;&lt;/a&gt;OMA(Open Mobi
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="IOT" scheme="http://KKimSangHeon.github.io/categories/CS/IOT/"/>
    
    
  </entry>
  
</feed>
