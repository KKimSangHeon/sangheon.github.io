<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kim Sang Heon&#39;s Bolg</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://KKimSangHeon.github.io/"/>
  <updated>2019-03-24T04:07:38.416Z</updated>
  <id>http://KKimSangHeon.github.io/</id>
  
  <author>
    <name>Kim Sang Heon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>규칙 5.불필요한 객체는 만들지 말라</title>
    <link href="http://KKimSangHeon.github.io/2019/03/24/effectivejava-1/"/>
    <id>http://KKimSangHeon.github.io/2019/03/24/effectivejava-1/</id>
    <published>2019-03-24T04:06:59.000Z</published>
    <updated>2019-03-24T04:07:38.416Z</updated>
    
    <content type="html"><![CDATA[<p>기능적으로 동일한 객체는 매번 만드는것보다 재사용하는 편이 낫다.<br>가령 String s = new String(“test”);라는 문장을 반복문안에 넣을경우 매번 String 객체가 생성된다.<br>이는 String s = “test”; 로 대체하는것이 낫다. 이는 실행할 때마다 객체를 만드는 대신 동일한 String 객체를 사용하며 같은 JVM안에서는 해당 객체를 재사용하게 된다.<br>생성자와 정적팩터리 메서드를 함께 제공하는 변경 불가능 클래스의 경우 생성자 대신 정적 팩터리 메소드를 이용하면 불필요한 객체 생성을 피할 수 있을 때가 많다. (Boolean(String) 보다는 Boolean.valueOf(String)쪽이 더 바람직하다. 생성자는 호출할 때마다 객체를 만들지만 정적 팩터리 메서드는 그러지 않는다.) 변경 불가능한 객체 뿐 아니라 변경가능한 객체도 재사용할 수 있다.</p>
<p>..<br>public boolean isIn( ){<br>    Calendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone(“GMT”));</p>
<pre><code>gmtCal.set(.....);
Date strart = gmtCal.getTime();

gmaCal.set(...);
Date end = gmtCal.getTime();
...
</code></pre><p>}<br>와 같은 코드가 존재할 때 isIn메서드는 호출될 때 마다 Caendar, TimeZone,Date객체 두개를 쓸데없이 만들어낸다.<br>이는 <code>정적 초기화 블록</code>을 통해 개선하는것이 좋다.</p>
<p>private static final Date START;<br>private static final Date END;</p>
<p>public boolean isIn( ) {<br>    static{<br>        Calendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone(“GMT”));<br>        gmtCal.set(…..);<br>        START = gmtCal.getTime();</p>
<pre><code>    gmaCal.set(...);
    END = gmtCal.getTime();
}
</code></pre><p>}</p>
<p>이렇게 할 경우 Caendar, TimeZone,Date <u>객체는 클래스가 초기화 될 때 한번만 만들어진다</u>. 이를통해 성능향상, 코드가 명료해진다(START, END가 상수라는것을 한눈에 알 수 있다)</p>
<p>만약 isIn() 메소드가 호출되지 않는다면 쓸데없는 초기화 과정이 진행된것인데 이는 <u>초기화 지연기법</u>을 사용하면 피할 수있다. 즉 isIn() 메서드가 처음 호출될 때 초기화한다. 이는 구현이 복잡해지고 성능을 개선시키기 어려워 질 수 있는상황을 만들수있다,</p>
<p><code>객체를 무작정 만들지 말라는것은 아니고 코드의 명확성, 단순성을 높이고 프로그램의 능력을 향상시킬 수 있을 때 만들라는것!</code><br>객체 풀을 만들어 객체 생성을 피하는 기법 또한 객체생성 비용이 극단적으로 높지않다면 사용하지 말라.(DB접속 할때는 허용) 최신 JVM은 고도로 최적화된 GC를 갖고있으므로 풀보다 월등한 성능을 보여준다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;기능적으로 동일한 객체는 매번 만드는것보다 재사용하는 편이 낫다.&lt;br&gt;가령 String s = new String(“test”);라는 문장을 반복문안에 넣을경우 매번 String 객체가 생성된다.&lt;br&gt;이는 String s = “test”; 로
    
    </summary>
    
      <category term="Language" scheme="http://KKimSangHeon.github.io/categories/Language/"/>
    
      <category term="Java" scheme="http://KKimSangHeon.github.io/categories/Language/Java/"/>
    
    
      <category term="Java" scheme="http://KKimSangHeon.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>규칙 4. 객체 생성을 막을 때는 private 생성자를 사용해라</title>
    <link href="http://KKimSangHeon.github.io/2019/03/24/effectivejava/"/>
    <id>http://KKimSangHeon.github.io/2019/03/24/effectivejava/</id>
    <published>2019-03-24T04:06:27.000Z</published>
    <updated>2019-03-24T04:06:54.108Z</updated>
    
    <content type="html"><![CDATA[<p>###<br>정적 메서드나 필드만 모은 클래스가 필요한 경우는 다음 세가지로 볼 수 있다.<br>1.자바의 기본 자료형 값 또는 배열에 적용되는 메서드를 한군데 모아둘 때.(java.lang.Math, java.lang.Arrays)<br>2.특정 인터페이스를 구현하는 개체를 만드는 팩터리 메서드 등의 정적 메서드를 모아놓을 때(java.util.Collection)<br>3.final 클래스에 적용할 메서드들을 모아놓을 때(상속하여 메서드 추가가 불가능하므로)</p>
<p><code>위의 경우에 객체를 생성하는건 이상하다!.</code><br>하지만 생성자를 생략하면 디폴트 생성자가 만들어진다. 이로인해 자신이 생각도 못한사이에 API에 추가되어 있을 수 있다<br>그렇다고 abstract로 선언하는것도 바보같은일이다. 상속으로 인해 객체 생성이 가능하므로…<br><u>객체생성을 막기위해서는 private 생성자를 생성하자</u><br>이를 통해 하위 클래스 또한 만들 수 없게 할수 있다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;###&lt;br&gt;정적 메서드나 필드만 모은 클래스가 필요한 경우는 다음 세가지로 볼 수 있다.&lt;br&gt;1.자바의 기본 자료형 값 또는 배열에 적용되는 메서드를 한군데 모아둘 때.(java.lang.Math, java.lang.Arrays)&lt;br&gt;2.특
    
    </summary>
    
      <category term="Language" scheme="http://KKimSangHeon.github.io/categories/Language/"/>
    
      <category term="Java" scheme="http://KKimSangHeon.github.io/categories/Language/Java/"/>
    
    
      <category term="Java" scheme="http://KKimSangHeon.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>190323. Write the docs 밋업 참가</title>
    <link href="http://KKimSangHeon.github.io/2019/03/23/writethedocs/"/>
    <id>http://KKimSangHeon.github.io/2019/03/23/writethedocs/</id>
    <published>2019-03-23T05:06:12.000Z</published>
    <updated>2019-03-24T04:22:53.399Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Write-the-docs"><a href="#Write-the-docs" class="headerlink" title="Write the docs"></a>Write the docs</h3><p>밋업도 열고 구인구지도 하고 문서화에 대한 다양한 이야기를 진행한다.</p>
<h3 id="글쓰는-개발자-모임-글또"><a href="#글쓰는-개발자-모임-글또" class="headerlink" title="글쓰는 개발자 모임, 글또"></a>글쓰는 개발자 모임, 글또</h3><p>변성윤님(쏘카 데이터 그룹 머신러닝 엔지니어)</p>
<p>네이버 블로그를 통해 글을 꾸준히 쓰던 습관 형성<br>까먹는게 싫어서 개발 블로그 시작</p>
<p><code>글또?</code>- 글쓰는 똘아이가 세상을 바꾼다<br>10마넌을 넣어넣고 주니어개발자들 끼리 진행했다. 글을 안쓰면 마넌씩 삭감<br>여러가지의 규칙을 만들어 놓고 진행해나감..(월 2개의 포스팅을 작성, 800자이상 등…)</p>
<p><code>어떤글을올렸나?</code><br>에러가 왜 발생했을까? 해결방안만 올리지 않고 원인을 정리, 프로젝트 진행하는것, 회고(1년 주기로) 등..</p>
<p>13명의 글을 2주마다 피드백을 통해 더 나은 글을 목표로함<br>점검은 오타, 전개바식, 이해 가능성, 가독성, 이미지 품질.</p>
<p>지금까지 낙오자 없이 잘 끝났다!</p>
<p><code>성과</code> : 구성원들의 글쓰기 역량 향상! 높은 충성도! 이직할때 도움(실제로 도움을 받았다고 하심!)! 양질의 글로 개발 생태계에 기여 사람을 만날수 있는 연결고리!<br><code>결론</code> : 글을 쓰는건 쉽지 않지만 함꼐하면 꾸준히 할수 있따! 물론 예치금이 중요하지만 ㅋㅋ</p>
<hr>
<h3 id="기술블로그-생존전략-구글시대의-글쓰기"><a href="#기술블로그-생존전략-구글시대의-글쓰기" class="headerlink" title="기술블로그 생존전략: 구글시대의 글쓰기"></a>기술블로그 생존전략: 구글시대의 글쓰기</h3><p>김대권님(당근마켓 인프라 클라우드 개발)<br>44bits.io 운영 중</p>
<p><code>우리는 왜 글을 쓸까요?</code> 읽히기 위해서!<br><code>사람들을 어떤 경로를 통해 블로그로 접근할까?</code><br>Social, Organic Search 검색이 주요 유입원.<br>SNS의 경우 생명령이 짧다. 짧으면 3일 길어봤자 1주일… 그렇지만 즉각적인 반응이 장점!<br>물론 팔로워가 없으면 효과가 떨어짐…<br>방치된 블로그의 경우 Organic Search 가 주요 유입원이다.</p>
<p>즉 블로그는 소셜보다 오랫동안 읽혀질 확률이 높다!! 하지만 이는 예측이 어렵다..(즉각적인 반응이 없다)<br>또한 티끌모아 태산이다!! 신뢰성을 쌓게되면 검색에서의 결과로 뜰 수 있어진다.!!</p>
<p>컨텐츠가 더 잘 발견되기 위해서는 장기적으로 봤을때 검색유입을 목표로 하자<br><code>구글을 어떻게 검색결과를 보여줄까???</code><br> 정밀도, 재현도를고려한다는데 이해하기 어렵다… 검색엔진은 백과사전이 아니라 거대한 추천시스템이다.  즉 수집한 문서들 중 검색 키워드 중 가장 추천할 만한 글을 정렬해서 보여준다.</p>
<p><code>어떻게 해야 내 글이 검색될까?</code><br>문서와 웹 사이트<br>문서 - 검색엔진이 검색한것은 웹사이트가 아니라 <u>문서</u>이다! 사이트를 잘만드는것도 중요하지만 구성요소 즉 문서를 단단히 하는것이 중요하다.<br>메타데이터보다는 제목과 본문이 중요하다. 좋은 제목은 아무리 강조해도 지나치지 않음. 핵심 키워드가 포함되고, 본문을 잘 드러내야 한다. 그리고 본문의 질이 좋아야 한다.<br>구글을 글을 보고 질 좋은 컨텐츠를 알아볼 수 있다. 그러므로 메타데이터는 중요하지 않다고 한것!</p>
<p><code>질좋은 컨텐츠를 위핸 제언</code><br>1.완성된 글을 작성한다.  </p>
<ul>
<li>이상한 글을 쓰면 블로그의 신뢰도를 떨어뜨린다.(예를들어 한줄짜리, 자신의 메모, 완성되지 않은 문장, 설명보다 코드가 긴 글, 링크만 모아놓은 글, 개인노트를 그대로 공개한 글, 직접 작성한 내용이 없는 글)<br>2.적당한 분량의 글을 작성한다.</li>
<li>7분정도 읽히는글(5600자 정도 즉 7페이지)이 가장 좋다!</li>
<li>그림의 유무 여백에 따라서 다르지만 600~1200자 정도가 적당!!!!!!!</li>
<li>짧은 뉴스는 2000~3000 긴글을 20000~30000 이것보다 길면 나눠서 쓰자!</li>
</ul>
<p><code>블로그에 쓸 수 있는글</code><br>튜토리얼, 하우투, 해설, 뉴스기사, 에세이</p>
<p><code>Page Rank</code><br>과거에는 페이지의 랭크를 구글에서 제공했다. 페이지의 신뢰도를 쌓아라. 나무위키의 경우에도 잘못된 정보들이 많지만 랭커는 높다.<br>장기적인 관점에서 잘 운영하는것이 중요하다!!!</p>
<p><code>처음 블로그를 시작하려면</code><br>관심사 -&gt; 키워드 -&gt; 글쓰기 -&gt; 공유<br>1.관심사들을 정리하고 키워드를 정하여 구글에서 검색해보자. 아직 좋은 글이 별로없는, 적당한 범위의 키워드를 정하자.<br>2.5000자 이상의 글을 작성하자. 제목에는 반드시 키워드를 포함하자.<br>3.게시하고 공유하고 기다려라.</p>
<hr>
<h3 id="지식-공유를-시작하려는-개발자"><a href="#지식-공유를-시작하려는-개발자" class="headerlink" title="지식 공유를 시작하려는 개발자"></a>지식 공유를 시작하려는 개발자</h3><p>홍연의님(LINE+ Developer Realations 팀)</p>
<p><code>Developer Realations팀에 어떻게 가게 되었나요?</code> IT출판사에서 IT도서 기획 편집자로 일을 시작했다.<br>다양한 커뮤니티 활동을 진행했다. 또한 책을 만들어내기 위해 저자의 전문지식을 잘 가공해서 지식공유를 돕는일을 진했했었다. DE팀에서 라인 개발자달의 전문성을 세상사람이 알 수 있게 해는것.</p>
<p><code>하는일</code> : 사내개발자 기고 글관리 등…개발자 대상 행사 주최. 라인의 개발자와 개발자 문화를 세상에 알릴 수 있는 모든 일. 라인의 개발자가 쉽게 지식 공유할 수 있도록 돕는 일</p>
<p><code>지식공유를 시작하려는 개발자에게...</code><br>블로그, 책, 영상, 강의, 발표등을 통해 지식고유를 할 수 있지만 쉽지만은 않다. 지식공유를 통해 인생의 또다른 기회를 갖게될 수 있따. 기회뿐만이 아니라 누군가에게 도움이 된다는 뿌듯함을 얻을 수도 있다.</p>
<hr>
<h3 id="사용자를-외면하지-않는-릴리스-노트"><a href="#사용자를-외면하지-않는-릴리스-노트" class="headerlink" title="사용자를 외면하지 않는 릴리스 노트"></a>사용자를 외면하지 않는 릴리스 노트</h3><p>조은별님(시큐아이, 보안회사 테크니컬 라이터)</p>
<p><code>테크니컬 라이터는 어떤 일은 하나요?</code><br>기술사업 분야에서 특정사용자를 대상으로 기술적인 정보를 제공하는 문서를 제작.<br>사용자메뉴얼, 릴리스노트, API문서, 화이트 페이퍼, UI용어/메시지 등….</p>
<p><code>릴리스 노트의 정의</code><br>문제를 정의하고 해결점을 기술한 문서. 즉 소프트웨어가 업데이트 될때 마다 업데이트 정보를 제공하기 위해 요약되어 작성되는 문서<br>신규기능, 개선된기능, 오류수정..</p>
<p><code>릴리스 노트의 필요성</code><br>앱스토어에서도 자주 보여진다. 자세하게 어떤부분이 어떻게 업데이트 되었는지 알려주는것이 매력적이다.<br>함축적이고 연관된 이슈에 대해 알려주는것도 좋은방법이라 할 수 있다.</p>
<p><code>릴리스 노트의 포멧</code><br>신규기능을 나누고 신규기능에 대한 설명을 통해 직관성을 제공하는것이 좋다.<br>ex:<br>[신규기능]<br>ㅁㅁ메뉴에 xx추가했습니다.</p>
<p>[개선된기능]<br>보기의 ㅇㅇ을 ㅇㅇ할수있도록 개선했습니다.</p>
<p><code>릴리스 노트 작성 시 고려할것</code><br>1.제품/사용자 특성 : 누가 읽는것인지?<br>2.일관된 문서 포맷: 어떻게 읽는 것인지?</p>
<h2 id="3-세-줄-요약-무엇을-익는-것인지"><a href="#3-세-줄-요약-무엇을-익는-것인지" class="headerlink" title="3.세 줄 요약 : 무엇을 익는 것인지?"></a>3.세 줄 요약 : 무엇을 익는 것인지?</h2><h3 id="개발자는-왜-블로그를-해야하나요"><a href="#개발자는-왜-블로그를-해야하나요" class="headerlink" title="개발자는 왜 블로그를 해야하나요?"></a>개발자는 왜 블로그를 해야하나요?</h3><p>이동욱님(우아한 형제들, 백엔드 개발자, jojuldu 블로그 운영)</p>
<p>마크타운 파일을 티스토리에 올릴 수 있는 플러그인 개발</p>
<p>플로그를 좋아하고 개선하고 혜택을 받음<br><code>블로그를 하면 좋은이유</code><br>한달에 1000달러 정도… 출판제의, 신간제의 등 부수익 창출기회. 다른 회사의 wiki에 내 블로그에 링크된다. 멀리서 세미나 발표로, 책으로 보기만 했던 개발자분의 채용추천. 사내 기술 블로그 작성 요청에 부담이 적음.</p>
<p><code>왜 블로그를 해야하나요</code><br>연봉/회사/직위/재산 빼면 나를 표현할 수 있는게 뭐가있을까? 블로그는 자신을 표현할 수 있다.<br>블로그는 아이덴티티라고 생각한다.</p>
<h3 id="개발-관련-기술-블로그-운영하기"><a href="#개발-관련-기술-블로그-운영하기" class="headerlink" title="개발 관련 기술 블로그 운영하기"></a>개발 관련 기술 블로그 운영하기</h3><p>변정훈님(Outsider’s Dev Story 운영)<br><code>글 작성</code><br>3일에 글 1개 작성목표, 글 1개에 짧게는 2~4시간 길게는 2~3일, 퇴고는 잘 하지 않는다.</p>
<p><code>글의 주제</code><br>개발하면서 적을 수 있는건 전부<br>새로운 도구, 환경 설치/절정<br>새로 알게된 라이브러리.도구의 사용법<br>최근에 겪고 해결한 장애와 처리방법<br>개발관련 공유할 만한 내용</p>
<p><code>왜 개발 블로그를 운영하는가</code><br>공부할게 많으니까. 글쓰는것 공부하는것을 같은것으로 본다.<br>처음엔 배운걸 자꾸 잊어버려서, 전에 겪어본것들인데 기억이 안나서.<br>회고와 비슷하다.</p>
<p><code>어디에 적어놓았는가</code><br>개인노트, TIL(Today I learned), 공개블로그</p>
<p><code>글을 공개로 쓸 때의 장점</code><br>글을 정리하려면 잘 알고 있어야 한다. 또한 글로 정리하면서 다시 고민해 볼 수 있다. 명성이 오른다.</p>
<p><code>글을 흐름</code><br>1.하고자 했던일을 적는다.(Context, 왜 웹사이트를 만들고 싶은지, 왜 이기술을 쓰고싶은지, 어떻게 하다가 해당 장애를 만났는지)<br>2.경험한 문제 상황 정리(격리된 상황, )<br>3.시도해본 방법(내가아는 지식, )<br>4.왜 동작이 안되는가? 왜 동작하는가?(가설)<br>5.문제상황 재현</p>
<p><code>MCVE</code><br>최소한의, 완성된, 입증가능한 예제<br>(Minimum, Complete, and Verifiable Example)<br>해결책을 받고싶으면 스택오버플로우에서 이런식으로 질문을 올려라는것!<br>블로그도 마찬가지이다.!</p>
<p><code>블로그를 하는 이유?</code><br>공유문화를 좋아한다.<br>일하면서도 글을 많이 작성한다.(Slack, Issue tracker, Wiki)</p>
<p><code>글을 지속적으로 쓰려면 어떻게 해야 하나요?</code><br>블로그를 만들기만 하는 개발자들이 많다. 새로운 스킨적용 스킨 변경의 반복….<br>열심히 해라 지속적으로 하다보면 근육처럼 붙게된다. 하다보면 어느순간 도움이 된다는것을 깨달을 수 있다.</p>
<p><code>사람들이 많이 보는 글</code><br>자잘한 팁</p>
<p><code>돈이 되나요?</code><br>안됩니다. 돈이 목표라면 기술블로그 보다는 다른영역으로 해라</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Write-the-docs&quot;&gt;&lt;a href=&quot;#Write-the-docs&quot; class=&quot;headerlink&quot; title=&quot;Write the docs&quot;&gt;&lt;/a&gt;Write the docs&lt;/h3&gt;&lt;p&gt;밋업도 열고 구인구지도 하고 문서화에 대
    
    </summary>
    
    
      <category term="Write the docs," scheme="http://KKimSangHeon.github.io/tags/Write-the-docs/"/>
    
  </entry>
  
  <entry>
    <title>운영체제 핵심!</title>
    <link href="http://KKimSangHeon.github.io/2019/03/18/operating-system/"/>
    <id>http://KKimSangHeon.github.io/2019/03/18/operating-system/</id>
    <published>2019-03-18T13:11:03.000Z</published>
    <updated>2019-03-24T04:23:07.112Z</updated>
    
    <content type="html"><![CDATA[<p>운영체제란<br>부팅<br>커널, 쉘?<br>배치프로세싱시스템<br>멀티프로그래밍 시스템<br>타임쉐어링 시스템<br>다중프로세서 시스템<br>분산시스템<br>실시간 시스템<br>인터럽트- 하드웨어인터럽트 , 소프트웨어인터럽트<br>ISR<br>이중모드-모니터비트<br>MMU<br>운영체제의 매니지먼트들 - 프로세스 메인메모리 파일 보조기억장치 입출력장치<br>프로세스의 상태-new ready running wating terminated<br>PCB-상태정보, PC(지금은 몇번지인지. 번지정보), registers, MMU info (base, limit), CPU time(CPU 이용시간), process id, list of open files(얘가 지금 어떤파일을 사용하고 있는지)</p>
<p>job queue , ready queue, device queue<br>Job scheduling(Long-term scheduler)</p>
<p>CPU Scheduler( Short-term scheduler )</p>
<p>Device Scheduler<br>Medium-term scheduler<br>프로세스는 크게 두가지로 나눌 수 있다,<br>i/o-bound<br>CPU-bound process</p>
<p>context switching<br>Dispatcher<br>CPU스케줄링<br>Preemptive vs Non-preemptive<br>Scheduling criteria(척도)</p>
<ul>
<li>응답시간, 대기시간, 반환시간, 처리율,cpu 이용율</li>
</ul>
<p>fcfs,sjf,Shortest-Remaining-Time-First<br>Priority,<br>Round-Robin (RR),<br>Multilevel Queue,<br>Multilevel Feedback Queue,</p>
<p>쓰레드<br>쓰레드 구조<br>프로세스의 메모리 공간 공유 : (code, data)<br>프로세스의 자원 공유 : (file, i/o, …)<br>비공유: 개별적인 PC, SP, registers, stack</p>
<p>프로세스(쓰레드) 동기화<br>임계영역 해결을 위한 방법 3가지<br>상호베타 진행 유한대기</p>
<p>동기화<br>세마포어 모니터(2개의 큐?)<br>odering 상호베제 용도로 쓰임</p>
<p>교착상태<br>교착상태 필요조건<br>상호베타 점유및대기 비선점 환형대기</p>
<p>메모리 낭비방지기법<br>1.Dynamic Loading<br>2.Dynamic Linking<br>3.Swapping</p>
<p>외부단편화<br>first fit<br>best fit<br>worst fit</p>
<p>외부단편화 해결: compaction, 페이징<br>페이지테이블(mmu의 집합,TLB에 저장)<br>내부단편화 해결 : 세그멘테이션</p>
<p>페이지, 세그멘테이션의 보호적인 측면의 차이</p>
<p>가상메모리<br>요구페이징<br>pure demand paging vs prepaging<br>Page Replacement Algorithms: FIFO,OPT,LRU<br>Belady’s Anomaly<br>Global vs Local Replacement<br>쓰레싱(Thrashing</p>
<p>프레임 할당은 크게 정적할당 동적할당으로 나뉜다.</p>
<p>정적 할당 (static allocation) 또한 균등할당, 비례할당으로 나뉜다.</p>
<p>block device<br>character device<br>연속 할당 (Contiguous Allocation) - 장단점<br>연결 할당 (Linked Allocation) - 장단점 및 디렉토리 / FAT<br>색인 할당 (Indexed Allocation) - linked,multi level, combined</p>
<p>디스크 스케줄링<br>fcfs, sstf, scan scheduling(cscan,look,c-look)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;운영체제란&lt;br&gt;부팅&lt;br&gt;커널, 쉘?&lt;br&gt;배치프로세싱시스템&lt;br&gt;멀티프로그래밍 시스템&lt;br&gt;타임쉐어링 시스템&lt;br&gt;다중프로세서 시스템&lt;br&gt;분산시스템&lt;br&gt;실시간 시스템&lt;br&gt;인터럽트- 하드웨어인터럽트 , 소프트웨어인터럽트&lt;br&gt;ISR&lt;br&gt;
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>다시돌아온 간략한 스프링정리시간</title>
    <link href="http://KKimSangHeon.github.io/2019/03/12/spring1/"/>
    <id>http://KKimSangHeon.github.io/2019/03/12/spring1/</id>
    <published>2019-03-12T07:48:03.000Z</published>
    <updated>2019-03-13T12:33:16.618Z</updated>
    
    <content type="html"><![CDATA[<h3 id="IoC"><a href="#IoC" class="headerlink" title="IoC?"></a>IoC?</h3><p>의존성이 뒤바뀐것. 어떻게 바뀐거야?<br>내가 만드는것이 아니라 밖에서 넣어주는 형태<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShController</span> </span>&#123;    </div><div class="line">   <span class="keyword">private</span> ShRepository repo;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ShController</span><span class="params">(ShRepository repo)</span> </span>&#123;        </div><div class="line">     <span class="keyword">this</span>.repo = repo;    </div><div class="line">   &#125;  </div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h3 id="IoC-컨테이너"><a href="#IoC-컨테이너" class="headerlink" title="IoC 컨테이너"></a>IoC 컨테이너</h3><p>ApplicationContext 는 IoC 컨테이너로써 우리가 직접 쓸 일은 거의 없다(Spring boot에서)<br>빈들을 만들고 빈들의 의존성을 엮어주는 역할을 한다. (객체생성 관리등…)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Autowired</span></div><div class="line">ApplicationContext applicationContxt;</div><div class="line">.....</div><div class="line">applicationContxt.getBean(A.class); <span class="comment">//객체를 가져올 수 있다.</span></div></pre></td></tr></table></figure>
<h3 id="빈"><a href="#빈" class="headerlink" title="빈"></a>빈</h3><p>스프링 IoC가 관리하는 객체이다. 즉 ApplicationContext안에서 관리되는 객체<br>인터페이스도 빈이 될수 있을까? 그렇다.</p>
<h3 id="빈을-등록하는-방법은"><a href="#빈을-등록하는-방법은" class="headerlink" title="빈을 등록하는 방법은?"></a>빈을 등록하는 방법은?</h3><p>빈을 쓰기위해서는 그것(클래스) 또한 빈이어야 한다.<br>why? 빈만 빈을 쓸 수 있다/</p>
<p><code>1.@ComponentScan</code><br>얘가 @Component인 애들을 찾아 빈으로 등록한다. @Controller은 왜 빈으로 인식되는거야? @컨트롤러 코드를 열어보면 @Componet로 되어있다. 즉 같은것으로 볼 수 있다.</p>
<p><code>2.XML이나 자바 설정 파일에 등록</code></p>
<p><code>3.직접 등록하는 방법</code></p>
<p><u>이때는 @Configuration 이라는 애노테이션을 갖고있는 클래스에서 등록이 이뤄져야 한다.</u><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Configuration</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeanTest</span></span>&#123;</div><div class="line">  <span class="meta">@Bean</span></div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">sh</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"sh"</span>;</div><div class="line">  &#125;</div><div class="line"><span class="comment">//String type의 빈을 하나 등록.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AController</span></span>&#123;</div><div class="line">  <span class="meta">@Autowired</span></div><div class="line">  String sh;  <span class="comment">//sh가 들어간다        </span></div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<h3 id="의존성-주입"><a href="#의존성-주입" class="headerlink" title="의존성 주입"></a>의존성 주입</h3><p>@Autowired , @Inject이라는 어노테이션을 활용하여 의존성을 주입한다.</p>
<p>어떤 빈에 생성자가 하나만있고 생성자의 매개변수 타입이 빈으로 등록되어있다면 빈을 주입해준다.@Autowired가 없더라도..즉 아래와 같은 형태</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AController</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ARepository aRepository;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BRepository bRepository;</div><div class="line"></div><div class="line">  <span class="comment">//방법 1</span></div><div class="line">  <span class="comment">//@Autowired 없어도 됨.(있어도 됨)</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AController</span><span class="params">(ARepository aRepository,BRepository aRepository)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.aRepository = aRepository;</div><div class="line">    <span class="keyword">this</span>.bRepository = bRepository;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>의존성 주입하는 두번째 방법<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AController</span></span>&#123;</div><div class="line">  <span class="meta">@Autowired</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ARepository aRepository;</div><div class="line"></div><div class="line">  <span class="meta">@Autowired</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BRepository bRepository;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>즉 위의 두가지 모두 의존성이 주입된다고 볼 수 있다.</p>
<h3 id="Autowired-Inject은-어디에-붙이는것이-좋은가"><a href="#Autowired-Inject은-어디에-붙이는것이-좋은가" class="headerlink" title="@Autowired , @Inject은 어디에 붙이는것이 좋은가?"></a>@Autowired , @Inject은 어디에 붙이는것이 좋은가?</h3><p><code>클래스에 반드시 필요한 객체</code>일경우 생성자로 의존성주입하는것이 좋다.<br><code>세터가 있다면</code> 세터에 붙이고<br><code>세터가 없다면</code> 필드에 붙이는것이 좋다.</p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>흩어진 코드를 한곳으로 모아라</p>
<h3 id="AOP를-구현하는-기법"><a href="#AOP를-구현하는-기법" class="headerlink" title="AOP를 구현하는 기법"></a>AOP를 구현하는 기법</h3><ol>
<li><p>바이트 코드를 조작하는방법<br>컴파일을 하면 .class가 나오는데 이를 조작하는것. 컴파일된 코드안에 공통되는 부분을 끼워넣는 방법</p>
</li>
<li><p>프록시 패턴을 사용하는 방법<br>A 클래스를 상속받아<br>class AProxy extends A{ }<br>안에서 공통되는 부분을 호출하는것.</p>
</li>
</ol>
<p>사방으로 흩어진 코드를 한곳으로 모으고 다른 클래스들은 자신의 일만 하도록 하는것<br>즉 Single Response Principle에 적합하게 코딩하도록 도와주는 코딩기법.</p>
<h3 id="PSA-Portable-Sevice-Abstract"><a href="#PSA-Portable-Sevice-Abstract" class="headerlink" title="PSA Portable Sevice Abstract"></a>PSA Portable Sevice Abstract</h3><p>잘만든 인터페이스라 보자.<br>어떤 기술에 특화되어있는 코드, 확장성이 좋지 않은 코드를 쓰면 테스트를 만들기도 어렵고 기술이 변경될 때 마다 코드를 변경해야 한다. 잘만든 인터페이스를 활용한다면 테스트하기도 좋고 바꿔끼기도 좋다.</p>
<p>어노테이션의 정의가 바뀌더라도 우리는 그대로 쓸 수 있다!</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;IoC&quot;&gt;&lt;a href=&quot;#IoC&quot; class=&quot;headerlink&quot; title=&quot;IoC?&quot;&gt;&lt;/a&gt;IoC?&lt;/h3&gt;&lt;p&gt;의존성이 뒤바뀐것. 어떻게 바뀐거야?&lt;br&gt;내가 만드는것이 아니라 밖에서 넣어주는 형태&lt;br&gt;&lt;figure clas
    
    </summary>
    
      <category term="Web/App" scheme="http://KKimSangHeon.github.io/categories/Web-App/"/>
    
      <category term="Spring" scheme="http://KKimSangHeon.github.io/categories/Web-App/Spring/"/>
    
    
      <category term="Spring" scheme="http://KKimSangHeon.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>29. SCAN 알고리즘 및 변종</title>
    <link href="http://KKimSangHeon.github.io/2019/03/06/operating-system29/"/>
    <id>http://KKimSangHeon.github.io/2019/03/06/operating-system29/</id>
    <published>2019-03-06T13:40:17.000Z</published>
    <updated>2019-03-06T13:45:55.148Z</updated>
    
    <content type="html"><![CDATA[
<p>프로세스 관리(CPU 스케줄링,동기화), 메인메모리 관리(디멘딩 페이지), 파일관리(연속,연결,색인할당)</p>
<p>디스크의 헤더의 움직이는데 오래걸린다. 물론 ms는 느린게 아니지만 컴퓨터의 수준에서 느린것이다.<br>200개의 실린더가 있을 때 어떻게 조금만 움직일 수 있을까?<br>맨안에 원이 트랙1 그다음이 2…</p>
<p>다중프로그래밍 환경에서의 디스크 큐(disk queue)에는 많은 요청(request)들이 쌓여있다.<br>요청들을 어떻게 처리하면 탐색시간을 줄일 수 있을까?</p>
<h3 id="FCFS-First-Come-First-Served"><a href="#FCFS-First-Come-First-Served" class="headerlink" title="FCFS (First-Come First-Served)"></a>FCFS (First-Come First-Served)</h3><p> 온 순서대로 처리해준다.</p>
<h3 id="SSTF-Scheduling"><a href="#SSTF-Scheduling" class="headerlink" title="SSTF Scheduling"></a>SSTF Scheduling</h3><p>현재위치를 기준으로 헤더를 조금움직이기 위해 위한것.<br>이는 Starvation문제가 발생할 수 있다. 큐에 줄서있는 순서대로 제공하는것이 아니라 가까운놈 순으로 제공하기 때문에 멀리있는놈은 가까운놈들이 계속 들어올 때 기아상태가 된다..<br>SSTF가 가장 좋은것인가???? 아니다…</p>
<p>200 cylinder disk, 0 .. 199<br>Disk queue: 98 183 37 122 14 124 65 67<br>Head is currently at cylinder 53</p>
<p>SSTF의 경우 Total head movement = 236 cylinders<br>일 때<br>최적의 경우: 53 - 37 - … = 208 cyl으로 최적으로 돌릴 수 있다.</p>
<h3 id="SCAN-Scheduling"><a href="#SCAN-Scheduling" class="headerlink" title="SCAN Scheduling"></a>SCAN Scheduling</h3><p>디스크 헤더가 전체에걸쳐 들어갔다 나왔다 한다.</p>
<p>200 cylinder disk, 0 .. 199<br>Disk queue: 98 183 37 122 14 124 65 67<br>Head is currently at cylinder 53 (moving toward 0) - Total head movement = 53+183 cylinders (less time)</p>
<p>디스크 헤더를 끝까지 넣었다가 뺐다가 하는것.<br>53-37-14-0-65-67-….183<br>53부터~0 까지 + 0부터 ~183까지</p>
<p>스캔 알고리즘을 적용할 때 방향이 중요하다. 최적은 왼쪽으로 갔다 오른쪽으로 간다. 왼쪽으로 갔다 오른쪽으로 갔다면 걸린 시간이 다르다.</p>
<p>프로세스의 개수가 많으면 골고루 요청이 분포되어 있을것이다.</p>
<h3 id="SCAN의-변종-1-C-SCAN"><a href="#SCAN의-변종-1-C-SCAN" class="headerlink" title="SCAN의 변종 1.C-SCAN"></a>SCAN의 변종 1.C-SCAN</h3><p>53부터~0 까지 처리했으면 53부터 ~183까지 처리하는것이 더욱 효율적일것이다. 이를 Circular SCAN</p>
<h3 id="SCAN의-변종-2-LOOK"><a href="#SCAN의-변종-2-LOOK" class="headerlink" title="SCAN의 변종 2.LOOK"></a>SCAN의 변종 2.LOOK</h3><p>처음 53부터 0에서 제일 가까운 14까지만 가고 헤더를 옮겨 다시 53에서 183까지 가는것.<br>The head goes only as far as the final request in each direction<br>Look for a request before continuing to move in a given direction</p>
<h3 id="SCAN의-변종-3-C-LOOK"><a href="#SCAN의-변종-3-C-LOOK" class="headerlink" title="SCAN의 변종 3.C-LOOK"></a>SCAN의 변종 3.C-LOOK</h3><p>처음 53부터 0에서 제일 가까운 14까지만 가고 헤더를 옮겨 183부터 65까지 이동</p>
<h3 id="스캔알고리즘을-엘리베이터-알고리즘이라-한다"><a href="#스캔알고리즘을-엘리베이터-알고리즘이라-한다" class="headerlink" title="스캔알고리즘을 엘리베이터 알고리즘이라 한다."></a>스캔알고리즘을 엘리베이터 알고리즘이라 한다.</h3><p>올라가면서 서비스하고 내려오면서 쭉 서비스를 제공하기 때문에</p>
]]></content>
    
    <summary type="html">
    
      
&lt;p&gt;프로세스 관리(CPU 스케줄링,동기화), 메인메모리 관리(디멘딩 페이지), 파일관리(연속,연결,색인할당)&lt;/p&gt;
&lt;p&gt;디스크의 헤더의 움직이는데 오래걸린다. 물론 ms는 느린게 아니지만 컴퓨터의 수준에서 느린것이다.&lt;br&gt;200개의 실린더가 있
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>28.색인할당, 디스크 탐색시간, FCFS, SSTF</title>
    <link href="http://KKimSangHeon.github.io/2019/03/05/operating-system28/"/>
    <id>http://KKimSangHeon.github.io/2019/03/05/operating-system28/</id>
    <published>2019-03-05T13:03:20.000Z</published>
    <updated>2019-03-06T13:44:50.323Z</updated>
    
    <content type="html"><![CDATA[<p>보조기억장치중 하드디스크를 배운다<br>동심원이 있고 원판이 있다. 원판에 자성물질을 발라서 디스크 헤더에 전기를 흘려 기록을 하고 읽을 때는 고속으로 회전시켜 코일에 전류가 유도되는데 이를통해 읽는다.<br>이를 트랙이라 하고 보통 디스크는 앞 뒤로 쓰는데 트랙이라는 용어보다는 실린더라는 용어를 많이 쓰고 있다.<br>트랙을 쪼개서 섹터라 한다 섹터는 512b정도 된다. 이를 네개정도 모아서 블록이라고 한다.<br>하드디스크를 포멧하면 내용을 다지우고 나면 poll of block이라 한다.</p>
<h3 id="연속할당"><a href="#연속할당" class="headerlink" title="연속할당"></a>연속할당</h3><p>블록 하나가 1kb라고 가정하자 3.6kb파일을 하나 만들었을때 블록을 연속적으로 만들어주면 내부단편화가 발생한다.<br>하지만 헤더가 많이 안움직여도 되므로 빠르다.  디스크 헤더의 이동 최소화 = 빠른 i/o 성능<br>하지만 데이터를 지웠을 때 외부단편화가 발생한다.(곳곳에 흩어지는 holes로 인해)</p>
<h3 id="연결할당"><a href="#연결할당" class="headerlink" title="연결할당"></a>연결할당</h3><p>디렉토리라는것은 메인메모리에 저장되고 OS에서 관리된다. 파일 이름, 만들어진날짜 등등을 보관한다. 하지만 우리눈엔 안보이고 커널에만 보이는것이 있는데 파일의 위치가 그것이다. 파일의 시작위치를 지정해두고 파일이 연결리스트 형태로 이어진다. 포인터 저장을 위해 4바이트가 필요하다는점, 헤더가 많이 움직여야한다는점, 중간부터 읽을 수 없다는점이 단점이다.</p>
<h3 id="FAT"><a href="#FAT" class="headerlink" title="FAT"></a>FAT</h3><p>연결할당의 단점을 해결하기 위해 포인터만을 모은 테이블(FAT)을 만든것.</p>
<h3 id="색인할당-Indexed-Allocation"><a href="#색인할당-Indexed-Allocation" class="headerlink" title="색인할당 (Indexed Allocation)"></a>색인할당 (Indexed Allocation)</h3><p><u>3.6kb 파일을 만드려면 한 블록이 1kb일때 4개가 필요한데 인덱스 테이블을 특정한 블록에 저장하고 디렉토리에는 파일의 인덱스 블록의 주소를 갖고있다. 즉 인덱스 블록은 포인터의 모음이며 하나의 파일당 하나씩 갖고있다.</u></p>
<p>데이터가 들어있는것은 데이터블록 주소가 들어있는것은 인덱스 블록이며 파일 하나당 인덱스 블록이 필요하다.<br><u>Direct access 가능하고 외부 단편화 없다.</u></p>
<p>인덱스 블록을 위해 블록을 할당해야 하는것이 단점이다. 1바이트 짜리를 저장하는데도 블록의 크기만큼(예를들었을 경우 1kb)만큼 할당해줘야 한다.</p>
<p><code>파일의 최대크기</code>: 1블록의 크기가 512바이트라 가정해보자. 주소를 표현하는데는 4바이트 이므로 128개의 인덱스를 갖을 수 있다. 여기서 512바이트 * 128을 계산하면 64kb이다. 즉 파일의 최대 크기는 64kb이다.</p>
<p>예제: 1블록 = 1KB = 4바이트 x 256개 인덱스<br>즉 256 * 1KB = 256KB</p>
<img src="/2019/03/05/operating-system28/image1.png" alt="Linked" title="Linked">
<p><code>해결방법1:</code> Linked : 이를 개선하기 위해 인덱스를 갖는 블록이 다른 인덱스 블록을 가르키는것.</p>
<img src="/2019/03/05/operating-system28/image2.png" alt="Multilevel index" title="Multilevel index">
<p><code>해결방법2:</code> Multilevel index : 하나의 인덱스 블록이 여러개의 인덱스 블록을 가르키는것.</p>
<img src="/2019/03/05/operating-system28/image3.png" alt="Combined" title="Combined">
<p><code>해결방법3:</code> Combined : 처음 인덱스 블록에서 앞쪽은 실제로 데이터를 가르키고 나머지 블록은 인덱스 블록을 가르키고..이는 유닉스에서 쓰임..</p>
<h3 id="디스크-스케줄링"><a href="#디스크-스케줄링" class="headerlink" title="디스크 스케줄링."></a>디스크 스케줄링.</h3><p>대표적인 보조기억장치는 하드디스크이다. 디스크는 원판에 트랙이 있고 디스크를 움직여서 해당되는 트랙으로 이동한다. 제일 오래 걸리는 시간이 헤더를 움직이는 Seek time이 오래걸린다, 디스크가 도는 시간은  rotational delay(1분에 7200번돈다) 트랙이 헤더를 지나가면서 읽히는 시간이 transfer time이라 한다.</p>
<p>다중 프로그래밍 환경에서 여러개의 프로세스가 동시에 돌아간다. <u>여러프로세스가 디스크를 사용하려면 디스크 큐에 들어가야한다. 이때 어떻게 하면 탐색시간 즉 디스크 헤더를 가장 적게 움직일 수 있을까…</u></p>
<h3 id="디스크-스케줄링-1-FCFS"><a href="#디스크-스케줄링-1-FCFS" class="headerlink" title="디스크 스케줄링 1. FCFS"></a>디스크 스케줄링 1. FCFS</h3><p>먼저온놈한테 먼저 서비스를 제공.<br>200 cylinder disk, 0 .. 199<br>Disk queue: 98 183 37 122 14 124 65 67<br>Head is currently at cylinder 53<br>Total head movement = 640 cylinders</p>
<p>극혐이다,….</p>
<h3 id="디스크-스케줄링-2-SSTF"><a href="#디스크-스케줄링-2-SSTF" class="headerlink" title="디스크 스케줄링 2. SSTF"></a>디스크 스케줄링 2. SSTF</h3><p>Shortest-Seek-Time-First 의 약어로서 최소화 되는것을 먼저하는것.</p>
<p>즉 지금위치를 기준으로 했을 때 가장 짧은곳을 먼저 가는것.<br>200 cylinder disk, 0 .. 199<br>Disk queue: 98 183 37 122 14 124 65 67<br>Head is currently at cylinder 53<br>Total head movement = 236 cylinders</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;보조기억장치중 하드디스크를 배운다&lt;br&gt;동심원이 있고 원판이 있다. 원판에 자성물질을 발라서 디스크 헤더에 전기를 흘려 기록을 하고 읽을 때는 고속으로 회전시켜 코일에 전류가 유도되는데 이를통해 읽는다.&lt;br&gt;이를 트랙이라 하고 보통 디스크는 앞
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>27.연속할당, 연결할당의 장단점</title>
    <link href="http://KKimSangHeon.github.io/2019/03/05/operating-system27/"/>
    <id>http://KKimSangHeon.github.io/2019/03/05/operating-system27/</id>
    <published>2019-03-05T13:02:56.000Z</published>
    <updated>2019-03-06T13:49:55.622Z</updated>
    
    <content type="html"><![CDATA[<p>하드디스크는 poll of free blocks 즉 빈 블록들의 집합이다.</p>
<p>한블록이 1kb이고 파일A 5kb, 파일B 3kb, 파일C 4kb 일때 어느블록에 넣을까?<br>0~19까지의 블록이 있을때 어떤식으로 배치할 수 있을까??</p>
<h3 id="연속할당"><a href="#연속할당" class="headerlink" title="연속할당"></a>연속할당</h3><p><u>각 파일에 대해 디스크 상의 연속된 블록을 할당</u><br>즉 A는 0~4까지 할당, B는 5~7 , C는 8~11 까지 연속적으로 할당하는 방법<br>60~70년대에 사용되는 방법</p>
<p><code>장점</code> : 일고 쓸때 디스크 헤더의 움직임을 최소화 할 수 있다. 이는 빠른 i/o 성능과 직결<br>동영상, 음악, VOD 등에 적합<br>sequential access 순차접근이라고 한다.<br>특정 부분을 바로 읽을 수도 있다 (direct access 직접접근)</p>
<p><code>단점</code> : 파일을 지울 경우 문제가 된다. A,C를 지우고 6kb의 데이터를 넣으려고 하면 못넣는다. 외부단편화가 발생!<br><u>즉 외부 단편화로 인한 디스크 공간 낭비</u><br>이를 방지하기 위해 hole을 모으는 Compaction을 하면 되지만 시간이 오래걸린다.<br>또한 <u>파일을 생성할 때 파일의 크기를 예측 할 수 없기 때문에 어디에 할당해야 할지 알 수 없다. 또한 파일의 크기가 계속증가할 수 있기때문에 기존의 hole로는 배치가 불가능하게 될 수 있다.</u></p>
<h3 id="연결할당"><a href="#연결할당" class="headerlink" title="연결할당"></a>연결할당</h3><p>연속할당을 개선하기 위해 나온것이 연결할당</p>
<img src="/2019/03/05/operating-system27/image.png" alt="하드디스크 디렉토리의 관계" title="하드디스크 디렉토리의 관계">
<p>각 블록들에 포인터를 달아놓고 이어지는 블록을 가르킨다. 처음 블록 위치는 파일 디렉토리가 갖고 있다. 각 블록은 포인터 저장을 위한 4바이트 또는 이상 소모. 이는 외부단편화를 없앨 수 있다.<br>디렉토리라는것은 메인메모리에 저장되고 OS에서 관리된다. 파일 이름, 만들어진날짜 등등을 보관한다. 하지만 우리눈엔 안보이고 커널에만 보이는것이 있는데 파일의 위치가 그것이다</p>
<p><code>단점</code> : 연속할당의 경우 블록의 위치를 가늠할 수 있지만 연결할당의 경우 중간부터 읽기는 어려움이 있다. 즉 Direct access가 불가하고 동영상의 중간부터 보기가 불가능하다는것이다. 포인터 저장을 위해서 4바이트 이상이 손실한다, 또한 포인터가 끊어질 경우 접근이 불가능하므로 신뢰성이 낮다. 외부단편화는 없지만 데이터들이 흩어져있기 때문에 헤더가 계속 움직여야하기 때문에 io시간이 오래걸린다.</p>
<p>연속할당의 문제(단편화)를 해결했지만 이 또한 문제가 있다.</p>
<h3 id="연결할당을-개선한-FAT-파일-시스템"><a href="#연결할당을-개선한-FAT-파일-시스템" class="headerlink" title="연결할당을 개선한 FAT 파일 시스템"></a>연결할당을 개선한 FAT 파일 시스템</h3><p>USB메모리가 주로 FAT32를 쓰는데 뭔지 알아보자<br>연결할당의 변종으로서 File Allocation Table 파일 시스템이다. MS-DOS, OS/2, Windows 등에서 사용한다,</p>
<p>포인터들을 따로 모아서 포인터 테이블을 디스크 블록에 따로 저장한다. 포인터들만 모인 테이블을 FAT라고 한다. 이를 통해 블록을 읽지 않고 테이블만 읽음으로써 direct access 또한 가능하게 된다. 주기적으로 FAT에 변동사항을 넣어주고 하나의 블록이 깨지더라도 FAT 내용만 살아있다면 나머지를 읽을 수 있다. 즉 신뢰성 향상. FAT가 고장나면 큰일나기 때문에 보통 FAT 카피본을 저장하고 있다. FAT 는 일반적으로 메모리 캐싱</p>
<p>즉 direct access , 신뢰성(FAT 손실 시 복구 위해 이중 저장)을 높였다.<br>FAT를 얼마나 할당할까? 32비트를 할당하면 2^32 개의 주소를 저장할 수 있다. 이를 FAT32라고 한다.</p>
<h3 id="색인할당"><a href="#색인할당" class="headerlink" title="색인할당."></a>색인할당.</h3><p>다음 포스팅에..</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;하드디스크는 poll of free blocks 즉 빈 블록들의 집합이다.&lt;/p&gt;
&lt;p&gt;한블록이 1kb이고 파일A 5kb, 파일B 3kb, 파일C 4kb 일때 어느블록에 넣을까?&lt;br&gt;0~19까지의 블록이 있을때 어떤식으로 배치할 수 있을까??&lt;
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>26. 파일할당</title>
    <link href="http://KKimSangHeon.github.io/2019/03/05/operating-system26/"/>
    <id>http://KKimSangHeon.github.io/2019/03/05/operating-system26/</id>
    <published>2019-03-05T13:02:47.000Z</published>
    <updated>2019-03-06T13:44:45.174Z</updated>
    
    <content type="html"><![CDATA[<p>OS 프로세스관리 배웠고/ 메인메모리 관리 배웠고/ 파일시스템중 파일 할당에 대해 배운다</p>
<p>OS는 컴퓨터 자원을 관리한다.<br>CPU: 프로세스 관리 (CPU 스케쥴링, 프로세스 동기화)<br>주기억장치: 메인 메모리 관리 (페이징, 가상 메모리)<br>보조기억장치: 파일 시스템 관리</p>
<p>파일이 어떻게 할당되어지는가에 대해 알아보자.<br><code>하드디스크는 구조</code>: 원판에 자성물질을 바르고 모터를 달아서 돌린다.  데이터는 동심원 상에 저장된다. 또한 헤더가 존재하는데 헤더에는 코일이 감겨있고 여기에 전기를 흘리면 데이터가 기록된다. 데이터를 읽을 때는 판을 빨리 돌리면 판이 지나가면서 전기가 유도되는데 이 값을 통해 데이터를 읽어낸다.<br>하드디스크에는 트랙이 있고 이를 잘라 섹터라 한다. 실린더는 하나의 하드디스크 안에 여러 판을 넣을 수 있다. 즉 <u>실린더란 같은 거리에 있는 트랙들의 집합<u>을 의미한다. 즉 원통같은것을 의미.</u></u></p>
<p>보통 한섹터는 512 bytes이고 섹터를 모아놓은것을 block이라 한다. 하드디스크에 읽고 쓰는것은 블록 단위로 이뤄지는데 이때문에 하드디스크를 <u>block device</u>라고 한다. 이와 반대되는것을 <u>character device</u>라 하는데 대표적인것이 키보드가 있다.</p>
<p>메모장을 켜서 한글자를 입력하고 저장만 하고 속성을 들어가보자, 이때 크기는 1바이트인데 디스크 할당크기는 4바이트이다. 이를 통해 한 블록 크기가 4바이트인것을 알 수 있다.(억울하다,,,) 블록 크기는 운영체제 설계자가 정한다,</p>
<p>디스크는 pool of free blocks 즉 free 블록들의 모음이다. 각각의 파일에 대해 free block을 어떻게 할당해줄까???<br>연속적으로 할당할 수 도 있고 떨어져있는것들로 할수도있고.. 어떤것이 더 좋을까/???</p>
<p>이는 3가지로 나뉘는데 연속 할당 (Contiguous Allocation) /연결 할당 (Linked Allocation) / 색인 할당 (Indexed Allocation)<br>이 존재한다. 이에 대해서는 다음포스팅에서 알아보자.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OS 프로세스관리 배웠고/ 메인메모리 관리 배웠고/ 파일시스템중 파일 할당에 대해 배운다&lt;/p&gt;
&lt;p&gt;OS는 컴퓨터 자원을 관리한다.&lt;br&gt;CPU: 프로세스 관리 (CPU 스케쥴링, 프로세스 동기화)&lt;br&gt;주기억장치: 메인 메모리 관리 (페이징,
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>25.프레임 할당, 정적/동적 할당, 쓰레싱, 페이지 크기</title>
    <link href="http://KKimSangHeon.github.io/2019/03/04/operating-system25/"/>
    <id>http://KKimSangHeon.github.io/2019/03/04/operating-system25/</id>
    <published>2019-03-04T13:33:17.000Z</published>
    <updated>2019-03-06T13:47:13.899Z</updated>
    
    <content type="html"><![CDATA[<p>프로세스 매니지먼트에서는 CPU 스케줄링, 프로세스 동기화가 중요하다,<br>메인메모리 매니지먼트에서는 페이징, 가상주소(요구페이징, 요구 세그먼트 페이징이 있다)가 중요하다.</p>
<p>요구페이징을 하다보면 언젠가는 페이지가 가득차는데 어떤 페이지를 희생자로 택할것인가를 페이지 리플레이스먼트 알고리즘이다. 여기서 FIFO, Optimal 알고리즘이 있다. Optimal은 비현실적이여서 LRU가 많이 사용된다.</p>
<p>지금은 Allocation of Frames를 배운다. 어느프로세스에게 얼마만큼의 프레임을 줄것인가에 대한것.</p>
<p>페이징은 프로세스를 페이징 단위로 잘라서 메모리에 올린다. 이를 디맨딩 페이지라 한다.</p>
<p>다시말해 Allocation of Frames는 <u>3개의 프로세스가 있고 페이지가 100개가 있을 때 각각 얼마씩 나눠줄까에 대한것.</u></p>
<p>정적할당 동적할당이 있는데 동적할당은 프로그램이 더 크면 크게줄 경우 이를 비례할당이라 하고 그냥 33개씩 동등하게 나눠주는것을 균등할당이라 한다.<br>하지만 균등할당은 말이 안되고 비례할당 또한 말이 안된다. 프로그램이 크다고 해서 우리가 해당프로그램의 모든 기능을 다 쓰는것은 아니기 때문에… 즉 실행해봐야 얼마나 필요한지 알수있는데 이를 동적할당이라 한다.</p>
<h3 id="동적프레임-할당"><a href="#동적프레임-할당" class="headerlink" title="동적프레임 할당"></a>동적프레임 할당</h3><h4 id="동적프레임-할당-1-Working-set-model"><a href="#동적프레임-할당-1-Working-set-model" class="headerlink" title="동적프레임 할당 1.Working set model"></a>동적프레임 할당 1.Working set model</h4><p>시간대별로 이용하는 페이지들을 나열해 봤을 때 특정 시간에 이용하는 프레임들을 봤을 때 이용되는 프레임들의 셋을 Locality라고 한다. locality들을 기반으로 어떤 페이지들이 사용되었는지 예측하는것이 좋은데 과거의 것들을 working set이라고 한다. 또한 과거의 어느정도까지 볼것인가에 대한 것을 Working set window이라 하는데 이는 OS만드는 사람이 결정한다. 결국 Working set window가 3ms 라 했을때 현재시점부터 과거 3ms까지의 locality들의 집합이 working set이며 이를 기반으로 프레임을 할당한다.</p>
<h4 id="동적프레임-할당-2-Page-Fault-Frequency-PFF"><a href="#동적프레임-할당-2-Page-Fault-Frequency-PFF" class="headerlink" title="동적프레임 할당 2.Page-Fault Frequency (PFF)"></a>동적프레임 할당 2.Page-Fault Frequency (PFF)</h4><p>Working set model보다 간단한 방법으로 가로축이 할당된 프로세스의 갯수 세로축이 page fault rate라 했을 때 반비례 그래프가 나온다. OS는 Page fault 발생 비율의 상한/하한선을 기억해두고 페이지 폴트가 상한선 초과 프로세스인 경우에 더 많은 프레임 할당하고 하한선 이하인경우 프로세스의 프레임은 회수한다.</p>
<h3 id="페이지-크기"><a href="#페이지-크기" class="headerlink" title="페이지 크기"></a>페이지 크기</h3><p>디멘드 페이징이나 페이징할때 페이지는 어떤 크기로 자를까???<br>일반적 크기: 4KB ~ 4MB</p>
<p>페이지의 크기는 커지는중.. 프로세스의 크기도 커지고있으므로</p>
<p><code>페이지 사이즈는 큰게 좋을까 작은게 좋을까????</code><br>-내부단편화 측면에서는 페이지 사이즈는 작은게 좋다.<br>-페이지 폴트가 발생했을 때 페이지 인 아웃의 시간이 오래걸리는데 이때 페이지 크기는 큰것이 유리하다. 백킹스토어에서 헤더가 움직이고 데이터를 읽어오는것은 꽤 많은 시간이 들기 때문에…<br>-CPU가 내는 주소를 변환하기 위해 존재하는 페이지 테이블의 크기가 작으면 SRAM의 비용이 덜 들어가고 이를 위해서는페이지의 크기가 커야한다.<br>-Memory resolution입장에서는 우리가 필요한것만 위치하게 되는데 이를 위해 페이지 크기가 작은게 좋다. 페이지 크기가 필요없는것도 왕창 들어있을테니까.<br>-페이지 폴트가 적게 일어나기 위해서는 페이지의 크기가 클 수 록 좋다. CPU가 100번지를 읽으면 그다음에는 104번지,108번지 읽는데 넓게 갖고오면 당분간은 페이지 폴트가 발생하지 않는데 이를 위해 처음부터 크게 갖고오는것이 좋다.</p>
<p><u>즉 관점에 따라 메모리 크기는 큰게 좋을 수도 작은게 좋을 수도 있다.</u><br>일반적으로는 메모리, 프로그램의 크기는 점차 크지므로 점점 커지고 있다.</p>
<h3 id="페이지-테이블의-위치"><a href="#페이지-테이블의-위치" class="headerlink" title="페이지 테이블의 위치"></a>페이지 테이블의 위치</h3><p>페이지 테이블은 CPU도 아니고 메모리에도 넣지 않고 TLB캐시라는곳에 넣고 있다.<br>하지만 최근은 반도체가 좋아지다 보니까 별도의 칩으로 하지않고 TLB 그리고 여러 캐시 메모리가 CPU안에 들어가게 되었다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;프로세스 매니지먼트에서는 CPU 스케줄링, 프로세스 동기화가 중요하다,&lt;br&gt;메인메모리 매니지먼트에서는 페이징, 가상주소(요구페이징, 요구 세그먼트 페이징이 있다)가 중요하다.&lt;/p&gt;
&lt;p&gt;요구페이징을 하다보면 언젠가는 페이지가 가득차는데 어떤 
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>24.FIFO, OPT, LRU, 전역/지역교체</title>
    <link href="http://KKimSangHeon.github.io/2019/03/04/operating-system24/"/>
    <id>http://KKimSangHeon.github.io/2019/03/04/operating-system24/</id>
    <published>2019-03-03T23:22:17.000Z</published>
    <updated>2019-03-04T13:33:39.613Z</updated>
    
    <content type="html"><![CDATA[<p>메모리 용량이 작을수록 페이지 폴트가 자주일어난다</p>
<h3 id="Belady’s-Anomaly"><a href="#Belady’s-Anomaly" class="headerlink" title="Belady’s Anomaly"></a>Belady’s Anomaly</h3><p>메모리 용량이 늘어나느데도 페이지 폴트가 발생하는 이상한 현상이 발생한다.<br>언제? FIFO를 사용할때!</p>
<h3 id="Optimal-OPT"><a href="#Optimal-OPT" class="headerlink" title="Optimal (OPT)"></a>Optimal (OPT)</h3><p>2를 몰아냈는데 2가 필요한 경우가 생길 수 있다. 즉 억울한 경우<br>이런일이 안일어나게 하기위해 <u>앞으로 사용되지 않을것을 희생자로 선택한다.</u><br><u>이는 비현실적이다. 앞으로 뭐가 사용안될지 잘 모르는것이다,</u><br>SJF와 비슷하다. 이 또한 어떤놈이 제일 짧은지 알 수 없다.</p>
<h3 id="Least-Recently-Used-LRU"><a href="#Least-Recently-Used-LRU" class="headerlink" title="Least-Recently-Used (LRU)"></a>Least-Recently-Used (LRU)</h3><p><u>최근에 가장 적게 사용된놈을 희생양으로 삼는다. 대부분의 컴퓨터가 사용하는 방식.</u><br>가장 좋은것은 앞으로 사용안될것을 희생양으로 삼는게 좋겠지만 현실적으로 판단하기 어려움으로,</p>
<h3 id="Global-vs-Local-Replacement"><a href="#Global-vs-Local-Replacement" class="headerlink" title="Global vs Local Replacement"></a>Global vs Local Replacement</h3><p><code>Global replacement</code> - 희생자를 선택할 때 메모리 상의 모든 프로세스 페이지에 대해 교체<br><code>Local replacement</code>- 희생자를 선택할 때 메모리 상의 자기 프로세스 페이지에 대해 교체</p>
<p><code>성능 비교</code> - Global replacement 가 더 효율적일 수 있다.</p>
<hr>
<p>CPU utilization vs Degree of multiprogramming</p>
<p>CPU utilization - CPU 이용률<br>Degree of multiprogramming - 메인메모리에 올라와있는 프로세스의 갯수</p>
<p>메모리 안에프로세스를 많이 올리니까 일정범위를 넘어서면 CPU의 이용률이 감소했다.<br><code>왜그럴까?</code> : 너무 많은 프로세스로 인해 빈번한 page in/out가 발생한다. 즉 디스크 IO가 많아져서 CPU이용율이 떨어진다. 이를 <u>쓰레싱(Thrashing)</u>라고 한다.</p>
<p><code>쓰레싱???</code> : 일정범위를 넘어서면 CPU이용율이 떨어지는데 이범위를 쓰레싱이라 한다.</p>
<h3 id="쓰레싱을-극복하기-위한-방법"><a href="#쓰레싱을-극복하기-위한-방법" class="headerlink" title="쓰레싱을 극복하기 위한 방법."></a>쓰레싱을 극복하기 위한 방법.</h3><p>Global replacement 보다는 local replacement 활용<br>프로세스당 충분한/적절한 수의 메모리(프레임) 할당</p>
<h3 id="프레임-할당-Allocation-of-Frames"><a href="#프레임-할당-Allocation-of-Frames" class="headerlink" title="프레임 할당(Allocation of Frames)"></a>프레임 할당(Allocation of Frames)</h3><p><u>프레임 할당은 크게 <u>정적할당 동적할당</u>으로 나뉜다.</u></p>
<h4 id="정적-할당-static-allocation-또한-균등할당-비례할당으로-나뉜다"><a href="#정적-할당-static-allocation-또한-균등할당-비례할당으로-나뉜다" class="headerlink" title="정적 할당 (static allocation) 또한 균등할당, 비례할당으로 나뉜다."></a>정적 할당 (static allocation) 또한 균등할당, 비례할당으로 나뉜다.</h4><p><code>균등 할당 (Equal allocation)</code> : 메인메모리에 프레임 수가 100개고 프로세스 수가 3개면 각 프레세스에 프레임을 33개씩 할당해주는것. 조금 적절하지 않다. hwp와 메모장이 올라와 있을 때 동일하게 분배한다는것은 옳지않다!! hwp는 조금더 무겁잖아<br><code>비례 할당 (Proportional allocation)</code> : 사이즈가 큰놈한텐 많이 나눠주고 작은놈한텐 적게 나눠주는것.</p>
<p>사실 hwp에서 특별한 기능은 많이 쓰지 않으므로 정적할당은 올바르지 않다,</p>
<h4 id="동적-할당-dynamic-allocation-또한-Working-set-model-Page-fault-frequency-등으로-나뉜다"><a href="#동적-할당-dynamic-allocation-또한-Working-set-model-Page-fault-frequency-등으로-나뉜다" class="headerlink" title="동적 할당 (dynamic allocation) 또한 Working set model , Page fault frequency 등으로 나뉜다."></a>동적 할당 (dynamic allocation) 또한 Working set model , Page fault frequency 등으로 나뉜다.</h4><p><code>Working set model</code> :<br><code>Page fault frequency</code> :</p>
<p>다음 포스팅에서….</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;메모리 용량이 작을수록 페이지 폴트가 자주일어난다&lt;/p&gt;
&lt;h3 id=&quot;Belady’s-Anomaly&quot;&gt;&lt;a href=&quot;#Belady’s-Anomaly&quot; class=&quot;headerlink&quot; title=&quot;Belady’s Anomaly&quot;&gt;&lt;/a&gt;Bel
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>23.페이지 교체 필요성, 희생 페이지 설정 원칙</title>
    <link href="http://KKimSangHeon.github.io/2019/02/28/operating-system23/"/>
    <id>http://KKimSangHeon.github.io/2019/02/28/operating-system23/</id>
    <published>2019-02-28T05:39:51.000Z</published>
    <updated>2019-02-28T05:40:18.477Z</updated>
    
    <content type="html"><![CDATA[<h3 id="가상메모리"><a href="#가상메모리" class="headerlink" title="가상메모리"></a>가상메모리</h3><p>프로세스를 페이지 크기로 쪼개서 메인메모리로 올리는데 당장 필요한 것들만 올리고 보자</p>
<p>그러다 메모리가 꽉차게 되면 한놈을 쫒아내고 필요한놈을 불러온다,</p>
<h3 id="Demand-Paging"><a href="#Demand-Paging" class="headerlink" title="Demand Paging"></a>Demand Paging</h3><p>프로세스 이미지는 backing store 에 저장<br>프로세스는 페이지의 집합</p>
<h3 id="가상메모리를-위한-하드웨어-지원"><a href="#가상메모리를-위한-하드웨어-지원" class="headerlink" title="가상메모리를 위한 하드웨어 지원"></a>가상메모리를 위한 하드웨어 지원</h3><p>valid 비트 추가된 페이지 테이블<br>backing store (= swap device)</p>
<h3 id="Memory-full"><a href="#Memory-full" class="headerlink" title="Memory full!"></a>Memory full!</h3><p>메모리가 가득 차면 추가로 페이지를 가져오기 위해<br>어떤 페이지는 backing store 로 몰아내고 (page-out)<br>그 빈 공간으로 페이지를 가져온다 (page-in) -  용어: victim page</p>
<h3 id="어느-페이지를-몰아낼-것인가"><a href="#어느-페이지를-몰아낼-것인가" class="headerlink" title="어느 페이지를 몰아낼 것인가?"></a>어느 페이지를 몰아낼 것인가?</h3><p>i/o 시간 절약을 위해 기왕이면 modify 되지 않은 페이지를 victim 으로 선택<br>방법: modified bit (= dirty bit)</p>
<h3 id="Page-reference-string"><a href="#Page-reference-string" class="headerlink" title="Page reference string"></a>Page reference string</h3><p>CPU 가 내는 주소: 100 101 102 432 612 103 104 611 612<br>Page size = 100 바이트라면<br>페이지 번호 = 1 1 1 4 6 1 1 6 6<br>Page reference string = 1 4 6 1 6</p>
<p><code>설명</code>: fault가 발생하면 100바이트씩 (한페이지씩) 갖고오게 되기 떄문에 100번지를 못찾을경우 100~199까지 갖고오므로 그다음의 101은 fault가 발생하지 않는다. 즉 연속적일 때 앞에서 한번만 갖고오게 한다.</p>
<h3 id="Page-Replacement-Algorithms"><a href="#Page-Replacement-Algorithms" class="headerlink" title="Page Replacement Algorithms"></a>Page Replacement Algorithms</h3><p><code>FIFO (First-In First-Out)</code> : 메인메모리에 먼저 올라온놈을 내보낸다.<br><code>OPT (Optimal)</code> :<br><code>LRU (Least-Recently-Used)</code></p>
<h3 id="FIFO-기법"><a href="#FIFO-기법" class="headerlink" title="FIFO 기법"></a>FIFO 기법</h3><p><code>Idea</code>: 초기화 코드는 더 이상 사용되지 않을 것이라는 생각을 바탕으로 만들어짐! 가장 간단하다.</p>
<p><code>예제</code><br>페이지 참조열 = 7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1<br>of frames = 3<br>15 page faults</p>
<h3 id="Optimal-OPT"><a href="#Optimal-OPT" class="headerlink" title="Optimal(OPT)"></a>Optimal(OPT)</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;가상메모리&quot;&gt;&lt;a href=&quot;#가상메모리&quot; class=&quot;headerlink&quot; title=&quot;가상메모리&quot;&gt;&lt;/a&gt;가상메모리&lt;/h3&gt;&lt;p&gt;프로세스를 페이지 크기로 쪼개서 메인메모리로 올리는데 당장 필요한 것들만 올리고 보자&lt;/p&gt;
&lt;p&gt;그러다
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>22.가상메모리 개요와 원리</title>
    <link href="http://KKimSangHeon.github.io/2019/02/27/operating-system22/"/>
    <id>http://KKimSangHeon.github.io/2019/02/27/operating-system22/</id>
    <published>2019-02-26T22:48:09.000Z</published>
    <updated>2019-03-06T13:46:43.737Z</updated>
    
    <content type="html"><![CDATA[<p>일정크기로 자르는 페이징<br>논리적 크기로 자르는 세그멘테이션</p>
<p><code>보호와 공유적인 측면에서는 페이징보다 세그먼트가 낫다.</code></p>
<p>세그먼트는 코드,데이터,스택이라고 잘랐을 때 각 크기는 다르다. 다른 데이터를 남는부분에 넣을라 하면 들어갈 수가 없다. 즉 외부단편화가 발생한다. 치명적인 문제! 외부단편화는 너무 치명적이다.</p>
<p><code>그럼 세그멘테이션과 페이징을 합치면 좋지않을까?</code><br>1.처음에는 코드,데이터,스택으로 나누어 세그먼트로 자르고<br>2.각 세그먼트를 일정한크기(페이지로) 자른다.</p>
<p>이를 Paged segmentation이라 한다.</p>
<p>하지만 이 경우 CPU - 세그먼트 테이블 - 페이지 테이블 - 메모리 를 거치게 되는데 두가지의 테이블을 거치기 때문에 느려진다.</p>
<h3 id="가상메모리"><a href="#가상메모리" class="headerlink" title="가상메모리"></a>가상메모리</h3><p>물리적인 메모리 크기의 한계를 극복하기 나옴,.<br>내 컴퓨터의 메모리가 1gb이면 2gb의 프로세스를 올리지는 못한다.</p>
<p>요즘 나오는 컴퓨터는 모두 가상메모리 기법이 적용되어 있다.</p>
<p><code>어떤원리로?</code>: 오류처리, 배열 등 지금은 불필요한것들은 올리지 않고 나중에 필요할 때 올린다. 동적 적재 (dynamic loading)과 비슷한 개념. 즉 각 프로세스를 페이지단위로 자르고 지금필요한것만 올린다. 이를 <u>요구페이징(Demand Paging)</u>이라고 한다.</p>
<h3 id="Demand-Paging"><a href="#Demand-Paging" class="headerlink" title="Demand Paging"></a>Demand Paging</h3><p>프로세스 이미지는 backing store 에 저장<br>프로세스는 페이지의 집합<br><u>지금 필요한 페이지만 메모리에 올린다(load) - 요구되는 (demand) 페이지만 메모리에 올린다</u></p>
<p>CPU가 페이지 테이블에 접근했을 때 자기가 읽고자 하는것의 valid 비트가 invalid 일 경우 인터럽트가 걸리게되고 CPU는 하던일을 정지하고 오류처리(필요한것을 들고오는 루틴)를 실행한다.</p>
<p>가상메모리를 만드는 방법은 Demand paging , virtual memory가 있다.</p>
<h3 id="Page-Fault"><a href="#Page-Fault" class="headerlink" title="Page Fault"></a>Page Fault</h3><p>Demand Paging에서 페이지를 읽으려 했는데 페이지가 없다!<br>이에따른 Page Falult Routine가 필요하다.</p>
<h3 id="pure-demand-paging-vs-prepaging"><a href="#pure-demand-paging-vs-prepaging" class="headerlink" title="pure demand paging vs prepaging"></a>pure demand paging vs prepaging</h3><p><code>pure demand paging</code> : 프로그램 실행할 때 아무것도 들고오지 않음. 그러므로 처음시작부터 page fault가 발생하여 처음부터 필요한것을 갖고온다. 즉 이로 인해속도가 느려진다. 하지만 필요한것만 불러오므로 메모리가 절약된다.</p>
<p><code>prepaging</code>: 미리 필요한것을 예측하여 들고온다. 메모리는 낭비될 수 있으나 page fault가 적게일어나므로 속도적인 측면에서 부담이 적다</p>
<h3 id="swaping-vs-demand-paging"><a href="#swaping-vs-demand-paging" class="headerlink" title="swaping vs  demand paging"></a>swaping vs  demand paging</h3><p><code>swaping</code> : 화장실 가면 프로세스를 백킹스토어로 몰아내는것. 이때 <u>왔다갔다하는 단위는 프로세스 단위</u>이다,<br><code>demand paging</code> : 백킹스토어를 <u>왔다갔다 하는 단위가 페이지 단위</u>이다,</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;일정크기로 자르는 페이징&lt;br&gt;논리적 크기로 자르는 세그멘테이션&lt;/p&gt;
&lt;p&gt;&lt;code&gt;보호와 공유적인 측면에서는 페이징보다 세그먼트가 낫다.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;세그먼트는 코드,데이터,스택이라고 잘랐을 때 각 크기는 다르다. 다른 데이터를
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>21.세그멘트 테이블, 주소변환</title>
    <link href="http://KKimSangHeon.github.io/2019/02/26/operating-system21/"/>
    <id>http://KKimSangHeon.github.io/2019/02/26/operating-system21/</id>
    <published>2019-02-26T11:40:29.000Z</published>
    <updated>2019-02-26T11:42:25.812Z</updated>
    
    <content type="html"><![CDATA[<h3 id="내부단편화-페이지-테이블"><a href="#내부단편화-페이지-테이블" class="headerlink" title="내부단편화, 페이지 테이블"></a>내부단편화, 페이지 테이블</h3><p>파워를 키면 OS가 메인 메모리로 올라간다. 프로세스들이 메모리에 연속으로 들어가게되면외부단편화 문제가 발생<br>그래서 메모리에 프로그램을 프레임 단위로 나눠 흩어져서 들어가게 했다.<br>하지만 CPU는 페이지 테이블로 인해 연속적으로 위치한다고 생각하게 된다.<br>페이지를 이용해서 내부단편화가 발생하지만 이는 미미한 정도이다!! 페이지 테이블은 고속의 SRAM으로 만드는데 이를 TLB (Translation Look-aside Buffer)라 한다.</p>
<p>페이지 테이블에서 물리주소를 찾을 수 있을 때 히트했다고 한다.</p>
<h3 id="보호"><a href="#보호" class="headerlink" title="보호"></a>보호</h3><p>모든 주소는 페이지 테이블을 경유한다. 그러므로 페이지테이블 엔트리(페이지 테이블의 끝쪽)마다 <u>R,W,X 비트를 두어 접근 제어를 한다.</u></p>
<h3 id="공유"><a href="#공유" class="headerlink" title="공유"></a>공유</h3><p>문서편집기를 세개 띄웠다고 가정하자. 각 프로그램마다 코드, 데이터, 스택이 따로 할당되면 메모리의 낭비이다. 코드는 공유가능하므로 하나만 만든다. 즉 페이지들이 코드영역은 셋다 똑같은 부분의 프레임을 가르키게 된다.<br>코드가 공유되려면 코드의 내용이 실행중에 변경되면 안된다, 이를  non-self- modifying code = reentrant code = pure code 라고 한다.<br><u>프로세스의 페이지 테이블 코드 영역이 같은 곳을 가리키게</u></p>
<h3 id="세그멘테이션-Segmentation"><a href="#세그멘테이션-Segmentation" class="headerlink" title="세그멘테이션 Segmentation"></a>세그멘테이션 Segmentation</h3><img src="/2019/02/26/operating-system21/image1.png" alt="세그먼트에서 주소변환" title="세그먼트에서 주소변환">
<p>페이지는 일정크기로 잘랐다.<br><u>세그멘테이션은 프로세스를 논리적 내용(=세그멘트)으로 잘라서 메모리에 배치!</u><br>코끼리를 자를때 페이지는 같은 크기로 자르지만 세그멘테이션은 논리적 크기(얼굴,몸통,꼬리)로 자른다.</p>
<p>프로세스는 세그멘테이션의 집합니다!. 프로세스는 코드 데이터 스택 세개의 뭉치가 존재한다. 하나의 프로세스는 세개의 프로세스의 집합이다! 일반적으로 세그먼트들의 크기는 다르다.</p>
<p>백킹스터어에 프로세스가 있을 때 메인메모리에 올리기 위해 세그먼트로 나누고 메모리로 올린다.(역시나 비연속적)<br>CPU를 속이기 위해 역시나 세그먼트 테이블을 만든다. 그리고 CPU가 낸 세그먼트 번호, 변위이고 세그먼트 테이블의 인덱스에 속한값+변위로 실제 주소를 알 수 있다. 또한 세그먼트 테이블에는 1차원 배열형태인 페이지 테이블과 다르게 base, limit로 즉 2차원배열형태로 구성된다. 만약 CPU가 낸 d의 값이 limit보다 클 경우 CPU로 인터럽트를 보내게 된다.</p>
<h4 id="논리주소-Logical-address"><a href="#논리주소-Logical-address" class="headerlink" title="논리주소 (Logical address)"></a>논리주소 (Logical address)</h4><p>CPU 가 내는 주소는 segment 번호(s) + 변위(d)</p>
<h4 id="주소변환-논리주소-→-물리주소-Physical-address"><a href="#주소변환-논리주소-→-물리주소-Physical-address" class="headerlink" title="주소변환: 논리주소 → 물리주소 (Physical address)"></a>주소변환: 논리주소 → 물리주소 (Physical address)</h4><p>세그멘트 테이블 내용: base 그리고 limit<br>세그멘트 번호(s)는 세그멘트 테이블 인덱스 값<br>s 에 해당되는 테이블 내용으로 시작 위치 및 한계값 파악<br>한계(limit)를 넘어서면 segment violation 예외 상황 처리</p>
<h2 id="물리주소-base-s-d"><a href="#물리주소-base-s-d" class="headerlink" title="물리주소 = base[s] + d"></a>물리주소 = base[s] + d</h2><h3 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h3><p>Limit / Base<br>1000 / 1400<br>400  / 6300<br>400  / 4300<br>1100 / 3200<br>1100 / 3200<br>1000 / 4700</p>
<ol>
<li><code>논리주소 (2,100) 는 물리주소 무엇인가?</code> 4400</li>
<li><code>논리주소 (1, 500) 은 물리주소?</code> 6800이라하면 틀렸다!!! 해당주소 없음!!(limit를 넘는다)</li>
</ol>
<h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h3><p>운영체제를 처음배울땐 프로세스들이 순차적으로 들어가는지 알았다. 그러다 보니 메모리 낭비가 심해서 자르기로 함.<br>그래서 일정크기로 자르는 페이징 기법이 나왔고 논리적 크기로 자르는 세그멘테이션이 나왔다.<br>페이징을 사용하는 방법이 더 일반적이다.</p>
<p>세그멘테이션은 보호와 공유측면에서 페이징보다 낫다.<br><code>왜 그럴까?</code> : 모든 주소는 세그멘트 테이블을 경유하므로, 세그멘트 테이블 엔트리마다 r, w, x 비트 두어 해당 세그멘트에 대한 접근 제어 가능<br><code>뭐야 페이지 뭐가다른데?</code> : 페이지 단위로 자르면 일정한 크기이기 때문에 코드,데이터가 섞이는 부분이 생길 수 있다. 즉 안심,등심이 섞인 부분이 생겨 r로만 줄지  rw로 줄지 논란이 생길 수 있다.</p>
<h3 id="그러나-대부분의-운영체제는-페이징을-쓴다"><a href="#그러나-대부분의-운영체제는-페이징을-쓴다" class="headerlink" title="그러나 대부분의 운영체제는 페이징을 쓴다"></a>그러나 대부분의 운영체제는 페이징을 쓴다</h3><p><code>왜?</code> 그건 다음포스팅에서..</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;내부단편화-페이지-테이블&quot;&gt;&lt;a href=&quot;#내부단편화-페이지-테이블&quot; class=&quot;headerlink&quot; title=&quot;내부단편화, 페이지 테이블&quot;&gt;&lt;/a&gt;내부단편화, 페이지 테이블&lt;/h3&gt;&lt;p&gt;파워를 키면 OS가 메인 메모리로 올라간다.
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>20.페이지 테이블, 주소변환/페이징에서의 주소변환</title>
    <link href="http://KKimSangHeon.github.io/2019/02/26/operating-system20/"/>
    <id>http://KKimSangHeon.github.io/2019/02/26/operating-system20/</id>
    <published>2019-02-25T23:57:15.000Z</published>
    <updated>2019-02-26T00:02:13.052Z</updated>
    
    <content type="html"><![CDATA[<p>페이지 테이블, 주소변환</p>
<h2 id="주소변환"><a href="#주소변환" class="headerlink" title="주소변환?"></a>주소변환?</h2><p>컴퓨터에는 CPU, 메모리, 보조기억장치가 존재.<br>파워를 켜면 메모리 안에 OS가 들어오고 요청하는 대로 프로그램들이 메모리로 들어온다.<br>프로그램들이 연속으로 들어갈 경우 외부단편화 문제가 발생한다. 그래서 메모리를 프레임 단위로 쪼개서 넣는다. 프로세스들은 흩어져서 프레임 단위로 저장된다. 이것이 가능한것은 CPU와 메모리 사이에 페이지테이블이 존재하기 때문에..<br>즉 CPU는 페이지 테이블로 인해 CPU는 프로세스가 연속한 상태로 착각한다.<br>메모리 빈곳(hole)을 다합치면 메모리가 큰데 프로세스를 넣을 수 없는것을 외부단편화라 함</p>
<h3 id="메모리-낭비를-위한기술"><a href="#메모리-낭비를-위한기술" class="headerlink" title="메모리 낭비를 위한기술"></a>메모리 낭비를 위한기술</h3><p>다이나믹 로딩<br>링킹<br>스와핑</p>
<h3 id="페이징-메모리-낭비를-줄이기-위한기술"><a href="#페이징-메모리-낭비를-줄이기-위한기술" class="headerlink" title="페이징(메모리 낭비를 줄이기 위한기술)"></a>페이징(메모리 낭비를 줄이기 위한기술)</h3><p>메모리를 꼭 연속된 공간에 넣을 필요는 없다. 프로그램을 프레임 단위로 잘라서 메모리에 흩어져서 넣는다.<br>프로세스는 페이지(page)의 집합<br>메모리는 프레임(frame)의 집합</p>
<p><code>페이지를 프레임에 할당</code><br>MMU 내의 재배치 레지스터 값을 바꿈으로서<br>CPU 는 프로세스가 연속된 메모리 공간에 위치한다고 착각<br>MMU 는 페이지 테이블 (page table) 이 된다.</p>
<p><code>예제</code><br>Page size = 4 bytes<br>Page Table: 5 6 1 2<br><u>논리주소 13 번지는 물리주소 몇 번지?</u></p>
<p>CPU가 내는 주소는 13이다. 이진수로 나타내면 1101(2) 인데 앞 두숫자 11이 p 이고 01이 d라고 볼 수 있다. (p는 페이지 사이즈 크기만큼 크기를 할당. 페이지 크기가 4이므로 두자리가 된다.) 페이지 테이블의 3번째 인덱스에 저장된 2가 f가 되고 d는 그대로 온다. 즉 10 01이 피지컬 어드레스가 된다. 즉 물리주소는 9번지가 된다. 9번지는 두번째 프레임에서 01만큼 떨어져있다고 할 수 있다.</p>
<p><code>예제</code><br>Page Size = 1KB<br>Page Table: 1 2 5 4 8 3 0 6<br><u>논리주소 3000번지는 물리주소 몇 번지?</u></p>
<p>1kb는 10bit. 3000은 101110111000(2) 이다. 페이지 사이즈는 2^10 이므로 10bit로 표현 가능하다. 즉 d는 뒤의 10자리(1110111000(2)) 이고 p는 앞에 두개(10(2))이다. 즉 2번째 인덱스인 101(2) 그리고 d를 붙인 1110111000 (2) 가 물리주소이다.</p>
<p><u>물리주소 0x1A53 번지는 논리주소 몇 번지?</u></p>
<p>1 1010 0101 0011 인데 뒤의 10개가 d 나머지 앞에 110이 프레임 넘버. 6은 페이지 테이블의 7번지에 저장되어 있으므로<br>111과  10 0101 0011 을 붙인것이 논리주소이다.</p>
<h3 id="내부단편화"><a href="#내부단편화" class="headerlink" title="내부단편화"></a>내부단편화</h3><p>페이지 사이즈가 4바이트일때 15바이트프로세스를 올리기 위해서는 페이지 4개가 필요하다.<br>4/4/4/3만큼 할당이 되는데 마지막 페이지의 1바이트가 비게된다. 이는 아무도 쓸수 없으므로 내부단편화 발생.</p>
<p>외부단편화를 페이지로 없앴는데 내부단편화가 발생한다. 내부단편화는 외부단편화에 비해 크기가 미미하므로 큰 문제가 되지 않는다.</p>
<p>페이지 테이블은 CPU안에 넣을 수 있다. 그러면 레지스터로 만들수도있다. 또는 메모리에 넣을 수도 있다.<br>‘CPU에 넣는경우’:페이지 테이블을 CPU레지스터로 만드면 주소변환이 정말 빠르다. 단점은 CPU에 넣어야 하므로 많은 데이터를 넣을 수없다.<br><code>메모리 안에 넣을 경우</code>: 페이지 테이블이 커도 문제가 되지 않는다. 그러나 변환속도가 느리다. 페이지테이블을 읽기위해 메모리를 한번읽고 또 한번 메모리를 읽어야 하므로 2배로 느려진다.</p>
<p><code>캐쉬메모리에 페이지 테이블을 넣는경우(실제로 사용됨)</code>: 페이지 테이블을 넣는 캐쉬메모리를 TLB (Translation Look-aside Buffer) 라 한다. 메모리에 넣는것보다 빠르고 CPU에 넣는것보다 많이 넣을 수 있다. 캐쉬메모리와 유사한 원리로 동작</p>
<p>CPU에서 낸 주소를 읽어오는덱 걸리는 시간을 유효메모리 접근시간이라 한다.<br>Tm(메모리 읽는속도) = 100ns, Tb(버퍼 읽는속도) = 20ns, hit ratio = 80%<br>CPU가 낸 주소가 페이지테이블 안에 존재할 경우 hit라고 한다,<br>유효 메모리 접근시간 : hit확률 <em>  (Tb+Tm) + hit되지 않을 확률 </em> (Tb+Tm)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;페이지 테이블, 주소변환&lt;/p&gt;
&lt;h2 id=&quot;주소변환&quot;&gt;&lt;a href=&quot;#주소변환&quot; class=&quot;headerlink&quot; title=&quot;주소변환?&quot;&gt;&lt;/a&gt;주소변환?&lt;/h2&gt;&lt;p&gt;컴퓨터에는 CPU, 메모리, 보조기억장치가 존재.&lt;br&gt;파워를 켜면 메
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>19.최초적합, 최적적합, 최악적합</title>
    <link href="http://KKimSangHeon.github.io/2019/02/25/operating-system19/"/>
    <id>http://KKimSangHeon.github.io/2019/02/25/operating-system19/</id>
    <published>2019-02-24T23:30:26.000Z</published>
    <updated>2019-02-25T13:54:57.309Z</updated>
    
    <content type="html"><![CDATA[<p>메모리 낭비를 줄이기 위한 기법<br>1.Dynamic Loading<br>2.Dynamic Linking<br>3.Swapping</p>
<h3 id="연속-메모리-할당"><a href="#연속-메모리-할당" class="headerlink" title="연속 메모리 할당"></a>연속 메모리 할당</h3><p>최초의 컴퓨터는 프로세스가 하나만 올라갔다. 그이 후 O/S가 올라가게 되었다.<br>하나의 운영체제에 여러개의 프로세스가 도는것이 다중프로그래밍. 즉 멀티프로그래밍이라 한다.<br>부팅을 하면 메모리가 비어있다가 OS가 자리잡게된다. OS이외에 부분은 비어있는데 이를 <u>big single hole 또는 hole</u>이라고 한다.</p>
<p><code>부팅 직후 메모리 상태</code>: O/S + big single hole<br><code>프로세스 생성 &amp; 종료 반복</code> : scattered holes(프로세스가 생성됐다가 없어지고 하다보면 곳곳에 hole 발생하게 된다.)</p>
<p>Hole 들이 불연속하게 흩어져 있기 때문에 프로세스 적재 불가한 경우가 생기는데 이를 <u>외부단편화(external fragmentation)</u>라 한다.</p>
<p><code>First-fit (최초 적합)</code>  : 메모리를 뒤져서 가장 처음에 들어갈 수 있는곳에 들어가는것.<br><code>Best-fit (최적 적합)</code> : 사이즈가 제일 비슷한놈에 들어가는것.<br><code>Worst-fit (최악 적합)</code> : 크기가 제일 안맞는놈한테 넣는것.(물론 큰것중에)</p>
<h4 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h4><p>Hole: 100 /500 / 600 / 300 / 200 KB<br>프로세스: 212 417 112 426 KB</p>
<p><code>First-fit (최초 적합)</code>의 경우 : 212는 500에 들어간다. 417은 600에 들어감. 112는 300에 들어감. 426은 못들어감.</p>
<p><code>Best-fit (최적 적합)</code> : 212는 300에 들어간다 . 417은 500 112는 200 .426은 500</p>
<p><code>Worst-fit (최악 적합)</code> : 212는 600에. 417은 500에. 112는 300에. 426은 못들어간다.</p>
<p>속도면에서는 First-fit가 빠르다.<br>나머지는 다 봐야하기 때문에 느리다.</p>
<p>이용률의 경우 first-fit, best-fit이 높은 이용율이 보임.<br>외부 단편화로 인한 메모리 낭비가 전체의 1/3 수준 (사용 불가)</p>
<p><code>이를 해결하기 위한 방법</code> : Compaction(hole들을 한곳으로 모으는것. 최적 알고리즘 없음, 고부담)<br>즉 OS가 지켜보다가 hole들을 한곳으로 모은다.(계산 부담)</p>
<p><code>다른방법은 없을까?</code> 페이징</p>
<h3 id="페이징"><a href="#페이징" class="headerlink" title="페이징"></a>페이징</h3><p>프로그램을 연속적으로 넣지 않고 일정한 단위로 잘라서 넣는다 이를 페이지라고 한다.(잘린것들을 말함).<br>메모리를 자른것을 프레임이라 함.</p>
<p>프로세스를 자른것을 페이지라 하고 메모리를 자른것을 프레임이라 한다.<br>페이지사이즈와 프레임사이즈 는 같으나 용어와 사용되는 위치가 다른것.</p>
<p>잘라서도 돌게하기 위해서는 CPU를 속여야한다. MMU 내의 Relocation Resgister을 여러개 둔다!<br>이러한 목적으로 사용되는 MMU를 페이지 테이블 (page table) 이라 한다.</p>
<p>이를 통해 외부단편화를 해결!</p>
<h3 id="페이징에서의-주소변환"><a href="#페이징에서의-주소변환" class="headerlink" title="페이징에서의 주소변환"></a>페이징에서의 주소변환</h3><img src="/2019/02/25/operating-system19/image1.png" alt="페이징에서의 주소변환" title="페이징에서의 주소변환">
<p>논리주소를 물리주소를 변환하는것을 주소변환이라한다.<br>CPU가 내는 주소가 m bit라 하자. 그럴 때 m-n은 페이지의 주소이고 n비트는 오프셋 또는 변위라고 한다.<br>즉 n은 페이지의 사이즈에 의존적이다. 페이지의 사이즈가 16일때 n은 4로 표현가능</p>
<p>메인메모리는 프레임 단위로 나뉘어져있다. 프레임의 크기는 페이지의 사이즈와 동일하다,<br>아까 말했듯 페이지 테이블(여러개의 mmu로 구성된것)은 프로세스가 페이지를 몇개쓰는가이 따라 달라진다.</p>
<p>p가 2라면 페이지 테이블의 두번째를 가르키는 것이고 d가 오프셋을 의미</p>
<p>만약 CPU가 50이라는 주소를 냈다하자. 그럼 110010(2) 이다. 이때 한 페이지가 16바이트라 가정했을 때 뒤의 네 수를 d로 보고 앞에 두개 11을 p로 본다. 즉 3번째 페이지에 저장되어있는 값(8이라 가정하자)에 맞는 프레임을 찾아가고 d를 활용하여 세부적인 값을 알아낸다. 이때는 10000010(2)가 된다,(앞에 네개는 8을 의미 뒤에 네개는 d를 그대로 가져다 쓴것)</p>
<p>정리하면 CPU가 내는 50번지는 10000010 즉 128번지 + d(2) 이므로 130번지를 찾아간다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;메모리 낭비를 줄이기 위한 기법&lt;br&gt;1.Dynamic Loading&lt;br&gt;2.Dynamic Linking&lt;br&gt;3.Swapping&lt;/p&gt;
&lt;h3 id=&quot;연속-메모리-할당&quot;&gt;&lt;a href=&quot;#연속-메모리-할당&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>18.동적적재, 동적연결, 스와핑</title>
    <link href="http://KKimSangHeon.github.io/2019/02/24/operating-system18/"/>
    <id>http://KKimSangHeon.github.io/2019/02/24/operating-system18/</id>
    <published>2019-02-24T02:25:43.000Z</published>
    <updated>2019-02-24T03:24:56.823Z</updated>
    
    <content type="html"><![CDATA[<p>컴퓨터에서 메모리는 CPU 만큼 중요하다.<br>하드디스크에 파일들이 들어있다. 파워를키면 OS가 메인메모리에 올라가고 특정 프로그램을 실행시키면 그 프로그램이 메인메모리로 올라간다. 이 메모리를 어떻게 잘 관리할것인가가 <code>메모리 매니지먼트</code></p>
<h3 id="실행파일을-메모리에-올리기"><a href="#실행파일을-메모리에-올리기" class="headerlink" title="실행파일을 메모리에 올리기"></a>실행파일을 메모리에 올리기</h3><p>src-obj-exe</p>
<p>메모리 몇 번지에?<br>다중 프로그래밍 환경에서는?</p>
<p>항상 똑같은 곳에 올리는것을 보장하지 못함. 그래서 MMU를 활용. CPU가 메모리에 몇번째 주소를 읽겠다 하면 메모리는 CPU로 데이터를 전송해준다. <u>MMU는 특정프로그램이 다른 프로그램으로 접근하지 못하게 해준다.</u> CPU가 메모리에 주소를 전달할 때 MMU를 거치는데 자기영역에 맞는 주소를요청하는지 파악한다.(base, limit 레지스터 활용)<br>MMU는 이뿐만 아니라 <u>Relocation register</u>을 둔다. 가령 A라는 프로그램이 있다고 하자. 개발자는 해당 프로그램이 0번지부터 시작한다고 생각하고 코딩을 했다. 하지만 이는 보장되지 않기 때문에 예측할 수 없다. 실제로는 프로그램이 1000번지에 로드되면 MMU 안에 Relocation register에 1000을 넣는다. 그러면 <u>CPU는 0번지를 요청하지만 MMU를 거치면서 1000이 더해져 실제로 저장되어 있는 1000번지로 접근하게 된다</u>. 즉 CPU를 속이게 된다.<br>그 다음날 A라는 프로그램이 실행되었을 때 5000번지에 실행될 경우 이때는 Relocation register에 5000이 들어가고 CPU는 5000번지에 접근하여 데이터를 읽어올 수 있다.</p>
<p>여기서 CPU가 보내는 주소를 <u>논리주소(logical address)</u> 라 하고 실제로 메인메모리로 들어가는 주소를 <u>물리주소 (physical address)</u>라 한다.</p>
<h3 id="메모리-낭비-방지"><a href="#메모리-낭비-방지" class="headerlink" title="메모리 낭비 방지"></a>메모리 낭비 방지</h3><p>운영체제는 컴퓨터 사용을 쉽게, 효율을 높게 하는것이 목표다.<br>이를 위해 어떤노력을 하는지 알아보자,<br>1.Dynamic Loading<br>2.Dynamic Linking<br>3.Swapping</p>
<p><code>Loading</code> : 프로그램(실행파일)을 메모리로 올리는것.<br><code>Booting</code> : OS를 메모리로 올리는것.</p>
<h4 id="메모리-낭비-방지-기법-Dynamic-Loading"><a href="#메모리-낭비-방지-기법-Dynamic-Loading" class="headerlink" title="메모리 낭비 방지 기법 : Dynamic Loading"></a>메모리 낭비 방지 기법 : Dynamic Loading</h4><p>프로그램을 메모리에 올릴때 오류처리 혹은 크게 생성한 배열 같은것들을 안올리고 오류가 일어나면 올린다.</p>
<p><code>나오게 된 배경</code>:<br>모든 루틴(routine)이 다 사용되는 것은 아니다 (예: 오류처리)<br>모든 데이터(data)가 다 사용되는 것은 아니다 (예: 배열)<br>자바: 모든 클래스가 다 사용되는 것은 아니다</p>
<p><u>즉 프로그램 실행에 반드시 필요한 루틴/데이터만 적재</u><br>현대의 운영체제는 이를 활용. 이전에는 모든것을 올리는 정적 적재(Static loading)를 활용했다.</p>
<h4 id="메모리-낭비-방지-기법-Dynamic-Linking"><a href="#메모리-낭비-방지-기법-Dynamic-Linking" class="headerlink" title="메모리 낭비 방지 기법 : Dynamic Linking"></a>메모리 낭비 방지 기법 : Dynamic Linking</h4><p><u>프로그램을 메인메모리에 올리는데 공통 라이브러리 루틴(library routine)를 메모리에 중복으로 올<br>리는 것은 낭비</u></p>
<p>이메일전송,  파일전송 둘다 네트워크를 사용한다. 즉 둘이 같은 라이브러리를 쓸것이다. 하나로 통 칠수있는경우이다. <u>이 기법은 오직 하나의 라이브러리 루틴만 메모리에 적재한다. 또한 exe파일을 만들때 link를 하지 않고 프로그램 실행 때 link하여 갖다 쓴게 한다. 그리고 다른 애플리케이션 실행 시 이 루틴과 연결(link)된다.</u><br>원래는 link를 exe파일이 만들어지기 전에 한다(정적 연결,Static Linking)</p>
<p>리눅스에서는 공유 라이브러리 (shared library)라 부른다 – Linux<br>윈도우에서는 동적 연결 라이브러리 (Dynamic Linking Library)라 부른다. - Windows</p>
<p>윈도우에서 .DLL파일을 본적이 있을것이다. 리눅스에는 .SO 파일.<br>C:\Windows\System32 에 많다.</p>
<h4 id="메모리-낭비-방지-기법-Swapping"><a href="#메모리-낭비-방지-기법-Swapping" class="headerlink" title="메모리 낭비 방지 기법 : Swapping"></a>메모리 낭비 방지 기법 : Swapping</h4><p><u>메모리에 적재되어 있으나 현재 사용되지 않고 있는 프로세스 이미지를 몰아낸다</u><br>프로그램을 사용하다 화장실에 갈경우 해당 프로그램은 아무것도 하지 않으면서 메모리를 잡아먹게 된다.<br>이 경우 해당 프로세스를 쫒아낸다. 즉 프로세스 이미지를 하드디스크 일부에 몰아낸다. 이는 메모리 활용도 높이기 위해 <u>Backing store (= swap device라고도 함)<u> 로 몰아낸다 한다.<br>Backing store (= swap device라고도 함)의 크기는 대략 메인메모리의 크기 정도면 충분하다.(메인메모리의 내용만 쫒아내는 구역이기 때문에.)</u></u></p>
<p>몰아내는것을 <u>Swap-out</u>라 하고 화장실에서 다시 돌아와 메모리로 다시 올리는것을 <u>Swap-in</u>이라고 한다. 서버는 Backing store 를위한 디스크를 따로 두기도 하며 슈퍼컴퓨터의 경우 Backing store를 하나의 메모리로 두기도 한다.(디스크 접근이 느리기 때문에)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;컴퓨터에서 메모리는 CPU 만큼 중요하다.&lt;br&gt;하드디스크에 파일들이 들어있다. 파워를키면 OS가 메인메모리에 올라가고 특정 프로그램을 실행시키면 그 프로그램이 메인메모리로 올라간다. 이 메모리를 어떻게 잘 관리할것인가가 &lt;code&gt;메모리 매니지
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>17.주기억장치 관리 개요</title>
    <link href="http://KKimSangHeon.github.io/2019/02/23/operating-system17/"/>
    <id>http://KKimSangHeon.github.io/2019/02/23/operating-system17/</id>
    <published>2019-02-23T00:48:52.000Z</published>
    <updated>2019-02-23T15:18:11.112Z</updated>
    
    <content type="html"><![CDATA[<p>CPU / 메모리 / 보조기억장치가 존재.<br>O/S는 프로세스 관리를한다. CPU 관리를 하는데 이를 프로세스 매니지먼트라함.<br>또한 O/S는 메모리 관리 즉 메모리 매니지먼트를 한다.</p>
<p>OS : 하드웨어를 어플리케이션이 활용할 수 있도록 함.<br><code>CPU 자원을 나눠주는 곳</code> : 프로세스 매니지먼트<br><code>메인메모리를 관리하는곳</code> : 메모리 매니지먼트.</p>
<h3 id="메모리-역사"><a href="#메모리-역사" class="headerlink" title="메모리 역사"></a>메모리 역사</h3><p><code>Core memory</code> : 반지모양의 철심에 자성물질을 바르고 전기를 흐르게 한 후 자석이 되게 한 후 메모리로 사용.<br><code>진공관 메모리</code> : 50~60년대 손가락 크기만함. 네다섯개가 한비트를 저장<br><code>트랜지스터 메모리</code> : 손톱만한 크기로 한비트를 저장하는데 네개의 트랜지스터 필. 반도체 소자안에 들어간다.<br><code>집적회로 메모리: SRAM, DRAM</code> : 보통 생각하는 메모리</p>
<h3 id="메모리-용량"><a href="#메모리-용량" class="headerlink" title="메모리 용량"></a>메모리 용량</h3><p>1970년대: 8-bit PC 64KB<br>1980년: 16-bit IBM-PC 640KB &gt; 1MB &gt; 4MB<br>1990년: 수MB &gt; 수십 MB<br>2000년~: 수백 MB &gt; 수 GB</p>
<h2 id="메모리가-지속적으로-커졌다"><a href="#메모리가-지속적으로-커졌다" class="headerlink" title="메모리가 지속적으로 커졌다!!"></a>메모리가 지속적으로 커졌다!!</h2><h3 id="메모리는-언제나-부족하다"><a href="#메모리는-언제나-부족하다" class="headerlink" title="메모리는 언제나 부족하다.."></a>메모리는 언제나 부족하다..</h3><h4 id="이유-프로그램의-변천"><a href="#이유-프로그램의-변천" class="headerlink" title="이유 : 프로그램의 변천"></a>이유 : 프로그램의 변천</h4><p>기계어/어셈블리어 작성<br>C언어<br>자바, 객체지향형 언어 작성<br>숫자 처리 &gt; 문자 처리 &gt; 멀티미디어 순으로 패러다임이 변화함.</p>
<h4 id="메모리-용량-증가-vs-프로그램-크기-증가"><a href="#메모리-용량-증가-vs-프로그램-크기-증가" class="headerlink" title="메모리 용량 증가 vs 프로그램 크기 증가"></a>메모리 용량 증가 vs 프로그램 크기 증가</h4><p>언제나 부족한 메모리 ㅠㅠ</p>
<h4 id="어떻게-메모리를-효과적으로-사용할-수-있을까"><a href="#어떻게-메모리를-효과적으로-사용할-수-있을까" class="headerlink" title="어떻게 메모리를 효과적으로 사용할 수 있을까?"></a>어떻게 메모리를 효과적으로 사용할 수 있을까?</h4><p>메모리 낭비를 없애고 가상메모리와 같은 기법을 활용!</p>
<h3 id="메모리-구조"><a href="#메모리-구조" class="headerlink" title="메모리 구조?"></a>메모리 구조?</h3><img src="/2019/02/23/operating-system17/image1.png" alt="CPU와 메모리" title="CPU와 메모리">
<p>CPU가 몇번지를 읽겠다고 주소를 메모리로 보낸다. 그러면 거기에 저장되어있는 정보를 메모리가 CPU에게 제공한다.<br>또한 데이터 저장을 위해서 CPU가 데이터를 전송하기도 한다<br>메모리는 주소(Address) + 데이터(Data)로 구성된다.</p>
<h3 id="프로그램은-어떻게-개발될까"><a href="#프로그램은-어떻게-개발될까" class="headerlink" title="프로그램은 어떻게 개발될까?"></a>프로그램은 어떻게 개발될까?</h3><p>컴파일러, 어셈블러, 링커, 로더에 대해 알아보자<br>프로그램이 실행되기까진 아래의 순서를 따른다.<br><u>main.c (고수준언어)-&gt;main.o(기계어) -&gt; link -&gt; 메인메모리로 올림</u><br>첫번째 화살표 컴파일러가 진행<br>두번째 화살표 링커가 진행<br>세번째 화살표 로더가 진행</p>
<p><code>원천파일 (Source file)</code>: 고수준언어 또는 어셈블리언어<br><code>목적파일 (Object file)</code>: 컴파일 또는 어셈블 결과<br><code>실행파일 (Executable file)</code>: 링크 결과<br>프로그램 실행을 위해 필요한것들: code + data + stack</p>
<p>실행파일을 메모리에 올리기 위해 메모리 몇번지에 올려야되지?(로더가 해결해준다)</p>
<h3 id="MMU의-사용"><a href="#MMU의-사용" class="headerlink" title="MMU의 사용"></a>MMU의 사용</h3><p>MMU 안에 base limit가 있다했는데 재배치 레지스터가 있다. 프로그램을 개발할 때 0번지에 들어간다고 생각했는데 실제로는 500번지에 들어간다면 Relocation register에 500을 넣어줘 CPU가 봤을땐 0번지 이지만 500을 더한 500번지에 저장되게 한다. 즉 CPU는 얘가 0번지에 있는줄 안다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CPU / 메모리 / 보조기억장치가 존재.&lt;br&gt;O/S는 프로세스 관리를한다. CPU 관리를 하는데 이를 프로세스 매니지먼트라함.&lt;br&gt;또한 O/S는 메모리 관리 즉 메모리 매니지먼트를 한다.&lt;/p&gt;
&lt;p&gt;OS : 하드웨어를 어플리케이션이 활용할
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>16.프로세스 동기화의 다른 도구인 모니터 사용</title>
    <link href="http://KKimSangHeon.github.io/2019/02/22/operating-system16/"/>
    <id>http://KKimSangHeon.github.io/2019/02/22/operating-system16/</id>
    <published>2019-02-22T13:51:04.000Z</published>
    <updated>2019-02-23T15:18:37.264Z</updated>
    
    <content type="html"><![CDATA[<h3 id="모니터"><a href="#모니터" class="headerlink" title="모니터"></a>모니터</h3><p>동기화 도구로 세마포어를 배웠다. 세마포어는 조금 오래된 동기화 도구인데 지금은 모니터를 많이쓴다. 주로 자바에서 많이쓴다.<br>즉 세마포 이후 프로세스 동기화 도구 이며 세마포 보다 고수준 개념</p>
<h3 id="세마포어의-구조"><a href="#세마포어의-구조" class="headerlink" title="세마포어의 구조"></a>세마포어의 구조</h3><p>정수변수, 큐, P(acquire)동작, V(release)동작</p>
<h3 id="모니터의-구조"><a href="#모니터의-구조" class="headerlink" title="모니터의 구조"></a>모니터의 구조</h3><p>공유자원 , 공유자원 접근함수 , 2개의 큐</p>
<p>2개의 큐?<br>하나는 배타동기. 즉 한쓰레드만 공유자원에 접근할 수 있도록 하는 큐<br>하나는 조건동기를 위한 큐</p>
<p>베타동기를 위한큐 | 다양한 함수 | 조건동기를 위한큐</p>
<img src="/2019/02/22/operating-system16/image1.png" alt="모니터의구조" title="모니터의구조">
<p>1.쓰레드 한개만 공유자원 접근 함수에 접근할 수 있다. 즉 들어오고 싶어하는 애들은 베타동기를 위한 큐에서 기다려야 한다.<br>2.진입 쓰레드가 조건을 만족하면(wait을 호출하여) 조건동기 큐로 들어가는데 이땐 블록된다. 그러면 새 쓰레드가 진입가능<br>3.새 쓰레드는 조건동기로 블록된 쓰레드를 notify를 호출하여 깨울 수 있다<br>4.깨워진 쓰레드는 현재 쓰레드가 나가면 재진입할 수 있다.<br>(하나의 쓰레드만 접근 가능하므로)</p>
<p>세마포어에 비해 복잡하나 사용하기 편리하다.</p>
<p><code>배타동기</code>: synchronized 키워드 사용하여 지정<br><code>조건동기</code>: wait(), notify(), notifyAll() 메소드 사용</p>
<p>베타동기: 하나만 특정함수에 들어갈 수 있다. 자바에서는 함수 정의 앞에 synchronized 키워드를 붙인다.<br>조건동기는 wait 함수를 호출하여 조건동기를 위한 큐에 갇히게 할 수 있고 notify(하나깨우기) 혹은 notify all(전체깨우기) 을 호출하여 깨울 수 도 있다.</p>
<h4 id="상호배제-용도로-사용"><a href="#상호배제-용도로-사용" class="headerlink" title="상호배제 용도로 사용"></a>상호배제 용도로 사용</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankAccount</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> balance;</div><div class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">int</span> amt)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> temp = balance + amt;</div><div class="line">		System.out.print(<span class="string">"+"</span>);</div><div class="line">		balance = temp;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> amt)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> temp = balance - amt;</div><div class="line">		System.out.print(<span class="string">"-"</span>);</div><div class="line">		balance = temp;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> balance;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>위처럼 하면 동기화가 가능하다. 세마포어 보다 쉽다!</p>
<h4 id="Ordering-용도로-사용"><a href="#Ordering-용도로-사용" class="headerlink" title="Ordering 용도로 사용"></a>Ordering 용도로 사용</h4><p>P1은 공백/ S1/notify();<br>P2는 wait/S2/공백</p>
<p>P1이 입금, P2가 출금 로직이라고 가정하고 생각해보자.</p>
<p>P1,P2 반복해서 출력되게 하려면 boolean 변수 하나를 둬서 처리<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">int</span> balacne = <span class="number">0</span>;</div><div class="line"><span class="keyword">boolean</span> p_turn;</div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">int</span> amt)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> temp = balance + amt;</div><div class="line">	balance = temp;</div><div class="line">	notify();</div><div class="line">	p_turn = <span class="keyword">false</span>;</div><div class="line">	wait();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> amt)</span> </span>&#123;</div><div class="line">	<span class="keyword">while</span>(p_turn)</div><div class="line">		wait();</div><div class="line"></div><div class="line">	<span class="keyword">int</span> temp = balance - amt;</div><div class="line">	balance = temp;</div><div class="line">	p_turn = <span class="keyword">true</span>;</div><div class="line">	notify();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">---</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span>[] buf;</div><div class="line">	<span class="keyword">int</span> size, count, in, out;</div><div class="line">	Buffer(<span class="keyword">int</span> size) &#123;</div><div class="line">		buf = <span class="keyword">new</span> <span class="keyword">int</span>[size];</div><div class="line">		<span class="keyword">this</span>.size = size;</div><div class="line">		count = in = out = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> item)</span> </span>&#123;</div><div class="line">	<span class="keyword">while</span> (count == size)</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		wait();</div><div class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</div><div class="line">	buf[in] = item;</div><div class="line">	in = (in+<span class="number">1</span>)%size;</div><div class="line">	notify();</div><div class="line">	count++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">while</span> (count == <span class="number">0</span>)</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		wait();</div><div class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</div><div class="line">	<span class="keyword">int</span> item = buf[out];</div><div class="line">	out = (out+<span class="number">1</span>)%size;</div><div class="line">	count--;</div><div class="line">	notify();</div><div class="line">	<span class="keyword">return</span> item;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">---</div><div class="line">교착상태에 대한 고려는 되지 않음.</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chopstick</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> inUse = <span class="keyword">false</span>;</div><div class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">		<span class="keyword">while</span> (inUse)</div><div class="line">		wait();</div><div class="line">		inUse = <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</div><div class="line">		inUse = <span class="keyword">false</span>;</div><div class="line">		notify();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;모니터&quot;&gt;&lt;a href=&quot;#모니터&quot; class=&quot;headerlink&quot; title=&quot;모니터&quot;&gt;&lt;/a&gt;모니터&lt;/h3&gt;&lt;p&gt;동기화 도구로 세마포어를 배웠다. 세마포어는 조금 오래된 동기화 도구인데 지금은 모니터를 많이쓴다. 주로 자바에서 많이
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>15.교착상태 필요조건, 교착상태의 해결법</title>
    <link href="http://KKimSangHeon.github.io/2019/02/22/operating-system15/"/>
    <id>http://KKimSangHeon.github.io/2019/02/22/operating-system15/</id>
    <published>2019-02-22T13:50:56.000Z</published>
    <updated>2019-02-22T13:56:55.165Z</updated>
    
    <content type="html"><![CDATA[<h3 id="교착상태"><a href="#교착상태" class="headerlink" title="교착상태"></a>교착상태</h3><p>발생이유 : 프로세스들이 자원을 많이 필요로 한다. 하지만 누가 사용하고 있으면 기다려야한다.<br>이러한 형태가 원을 이루면 교착상태가 발생한다.</p>
<h3 id="교창상태-필요조건"><a href="#교창상태-필요조건" class="headerlink" title="교창상태 필요조건."></a>교창상태 필요조건.</h3><p>Mutual exclusion (상호배타) : 자원을 서로 공유하지 못함<br>Hold and wait (보유 및 대기) : 하나를 잡고있으면서 다른것을 원함<br>No Preemption (비선점) : 다른것을 강제로 뺏어오지 못함.<br>Circular wait (환형대기) : 자원을 갖고있으면서 기다리는데 원형형태</p>
<p><u>네가지가 만족되면 일어날 수 있다. 반드시 일어나는것은 아님</u></p>
<h3 id="교착상태-처리"><a href="#교착상태-처리" class="headerlink" title="교착상태 처리"></a>교착상태 처리</h3><p>교착상태 처리는 크게 네가지가 있다.<br>1.교착상태 방지<br>Deadlock Prevention</p>
<p>2.교착상태 회피<br>Deadlock Avoidance</p>
<p>3.교착상태 검출 및 복구<br>Deadlock Detection &amp; Recovery</p>
<p>4.교착상태 무시<br>Don’t Care</p>
<h3 id="1-교착상태-방지"><a href="#1-교착상태-방지" class="headerlink" title="1.교착상태 방지"></a>1.교착상태 방지</h3><p><code>설명</code> : 필요조건 중 네가지 조건중에 하나라도 깨도록 하는것.<br><code>상호베타 조건을 깨기</code>: 이를 위해 공유가 가능하게 해야한다. 현실적으로 어렵다. 읽어내기만 하는 파일 같은 경우에는 가능하지만 일반적으로는 부적절</p>
<p><code>보유 및 대기 깨기</code>: 동시에 젓가락 갖게하기. 왼쪽 젓가락 잡고 오른쪽 젓가락 잡을라 했는데 누가 오른쪽을 갖고있으면 왼쪽도 놓기. 이는 굶어 죽을 확률이 생김. 자원의 활용도가 떨어진다. 상호베타 조건깨는것보다는 쉽다.<br>자원을 가지고 있으면서 다른 자원을 기다리지 않게 즉 자원이 없는 상태에서 모든 자원 대기; 일부 자원만 가용하면 보유 자원을 모두 놓아주기<br>단점: 자원 활용률 저하, 기아 (starvation)</p>
<p><code>비선점 깨기</code>: CPU의 경우에는 일부 가능하겠으나 일반적으로 불가능</p>
<p><code>환형대기 깨기</code> : 자원에다 번호 부여하고 자원의 오름차순으로 자원을 요청토록 함. 즉 R1,R2,R3 가 있을때 R1, R2 요청/ R2,R3 요청/ R1,R3요청처럼 구현. 자원의 활용도가 떨어진다.</p>
<p>보통 보유 및 대기 깨기 혹은 환형대기 깨기를 사용한다.</p>
<h3 id="2-교착상태-회피"><a href="#2-교착상태-회피" class="headerlink" title="2.교착상태 회피"></a>2.교착상태 회피</h3><p><code>설명</code> : 자원을 할당할 때 위험한 할당이 되지 않도록 하는것.<br>자원을 프로세스 한테 골고루 나눠주는것을 OS가 한다. 이를 리소스 매지저 / 올로케이터라 한다.<br>교착상태는 자원요청에 대한 잘못된 승인에 기인한다고 본다.</p>
<p>불안전한 할당 (Unsafe allocation)<br>운영체제는 자원을 할당할 때 불안전 할당 되지 않도록<br>불안전 할당 → 교착상태 유발<br>대출전문 은행과 유사: Banker’s Algorithm</p>
<h3 id="3-교착상태-검출-및-복구"><a href="#3-교착상태-검출-및-복구" class="headerlink" title="3.교착상태 검출 및 복구"></a>3.교착상태 검출 및 복구</h3><p><code>설명</code> : 프로세스가 필요한 대로 자원을 나눠주고 데드락이 발생하면 OS의 프로세스 복구.<br>교착상태가 일어나는 것을 허용 그리고 주기적 검사진행. 주기적 검사는 이를 하기 위한 오버헤드가 크다.<br>교착상태 발생 시 복구하기위해 주기적으로 이전의 상태를 기억하고 있어야 한다.<br>이를 위해 한 프로세스를 강제로 종료시키거나 혹은 자원을 선점하여 일부 프로세스에게 할당.</p>
<h3 id="4-교착상태-무시"><a href="#4-교착상태-무시" class="headerlink" title="4. 교착상태 무시"></a>4. 교착상태 무시</h3><p><code>설명</code> : 교착상태는 실제로 잘 일어나지 않으므로 그냥 무시해버린다.<br>교착상태 발생 시 재시동.</p>
<p>컴퓨터에서 가장 중요한것은 메모리 관리이다. 이를 프로세스 매니지먼트 부서가 하는데 이는 CPU 스케줄링 부서, 프로세스 싱크로나이즈 부서로 구성된다. 싱크로나이즈에서는 데드락관리또한 중요.</p>
<p>메인메모리 관리가 메모리 매니지 부서가 있다. 다음부터 공부한다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;교착상태&quot;&gt;&lt;a href=&quot;#교착상태&quot; class=&quot;headerlink&quot; title=&quot;교착상태&quot;&gt;&lt;/a&gt;교착상태&lt;/h3&gt;&lt;p&gt;발생이유 : 프로세스들이 자원을 많이 필요로 한다. 하지만 누가 사용하고 있으면 기다려야한다.&lt;br&gt;이러한 형태
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
</feed>
