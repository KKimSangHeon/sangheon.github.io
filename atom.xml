<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kim Sang Heon&#39;s Bolg</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://KKimSangHeon.github.io/"/>
  <updated>2019-03-06T13:45:55.148Z</updated>
  <id>http://KKimSangHeon.github.io/</id>
  
  <author>
    <name>Kim Sang Heon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>29. SCAN 알고리즘 및 변종</title>
    <link href="http://KKimSangHeon.github.io/2019/03/06/operating-system29/"/>
    <id>http://KKimSangHeon.github.io/2019/03/06/operating-system29/</id>
    <published>2019-03-06T13:40:17.000Z</published>
    <updated>2019-03-06T13:45:55.148Z</updated>
    
    <content type="html"><![CDATA[
<p>프로세스 관리(CPU 스케줄링,동기화), 메인메모리 관리(디멘딩 페이지), 파일관리(연속,연결,색인할당)</p>
<p>디스크의 헤더의 움직이는데 오래걸린다. 물론 ms는 느린게 아니지만 컴퓨터의 수준에서 느린것이다.<br>200개의 실린더가 있을 때 어떻게 조금만 움직일 수 있을까?<br>맨안에 원이 트랙1 그다음이 2…</p>
<p>다중프로그래밍 환경에서의 디스크 큐(disk queue)에는 많은 요청(request)들이 쌓여있다.<br>요청들을 어떻게 처리하면 탐색시간을 줄일 수 있을까?</p>
<h3 id="FCFS-First-Come-First-Served"><a href="#FCFS-First-Come-First-Served" class="headerlink" title="FCFS (First-Come First-Served)"></a>FCFS (First-Come First-Served)</h3><p> 온 순서대로 처리해준다.</p>
<h3 id="SSTF-Scheduling"><a href="#SSTF-Scheduling" class="headerlink" title="SSTF Scheduling"></a>SSTF Scheduling</h3><p>현재위치를 기준으로 헤더를 조금움직이기 위해 위한것.<br>이는 Starvation문제가 발생할 수 있다. 큐에 줄서있는 순서대로 제공하는것이 아니라 가까운놈 순으로 제공하기 때문에 멀리있는놈은 가까운놈들이 계속 들어올 때 기아상태가 된다..<br>SSTF가 가장 좋은것인가???? 아니다…</p>
<p>200 cylinder disk, 0 .. 199<br>Disk queue: 98 183 37 122 14 124 65 67<br>Head is currently at cylinder 53</p>
<p>SSTF의 경우 Total head movement = 236 cylinders<br>일 때<br>최적의 경우: 53 - 37 - … = 208 cyl으로 최적으로 돌릴 수 있다.</p>
<h3 id="SCAN-Scheduling"><a href="#SCAN-Scheduling" class="headerlink" title="SCAN Scheduling"></a>SCAN Scheduling</h3><p>디스크 헤더가 전체에걸쳐 들어갔다 나왔다 한다.</p>
<p>200 cylinder disk, 0 .. 199<br>Disk queue: 98 183 37 122 14 124 65 67<br>Head is currently at cylinder 53 (moving toward 0) - Total head movement = 53+183 cylinders (less time)</p>
<p>디스크 헤더를 끝까지 넣었다가 뺐다가 하는것.<br>53-37-14-0-65-67-….183<br>53부터~0 까지 + 0부터 ~183까지</p>
<p>스캔 알고리즘을 적용할 때 방향이 중요하다. 최적은 왼쪽으로 갔다 오른쪽으로 간다. 왼쪽으로 갔다 오른쪽으로 갔다면 걸린 시간이 다르다.</p>
<p>프로세스의 개수가 많으면 골고루 요청이 분포되어 있을것이다.</p>
<h3 id="SCAN의-변종-1-C-SCAN"><a href="#SCAN의-변종-1-C-SCAN" class="headerlink" title="SCAN의 변종 1.C-SCAN"></a>SCAN의 변종 1.C-SCAN</h3><p>53부터~0 까지 처리했으면 53부터 ~183까지 처리하는것이 더욱 효율적일것이다. 이를 Circular SCAN</p>
<h3 id="SCAN의-변종-2-LOOK"><a href="#SCAN의-변종-2-LOOK" class="headerlink" title="SCAN의 변종 2.LOOK"></a>SCAN의 변종 2.LOOK</h3><p>처음 53부터 0에서 제일 가까운 14까지만 가고 헤더를 옮겨 다시 53에서 183까지 가는것.<br>The head goes only as far as the final request in each direction<br>Look for a request before continuing to move in a given direction</p>
<h3 id="SCAN의-변종-3-C-LOOK"><a href="#SCAN의-변종-3-C-LOOK" class="headerlink" title="SCAN의 변종 3.C-LOOK"></a>SCAN의 변종 3.C-LOOK</h3><p>처음 53부터 0에서 제일 가까운 14까지만 가고 헤더를 옮겨 183부터 65까지 이동</p>
<h3 id="스캔알고리즘을-엘리베이터-알고리즘이라-한다"><a href="#스캔알고리즘을-엘리베이터-알고리즘이라-한다" class="headerlink" title="스캔알고리즘을 엘리베이터 알고리즘이라 한다."></a>스캔알고리즘을 엘리베이터 알고리즘이라 한다.</h3><p>올라가면서 서비스하고 내려오면서 쭉 서비스를 제공하기 때문에</p>
]]></content>
    
    <summary type="html">
    
      
&lt;p&gt;프로세스 관리(CPU 스케줄링,동기화), 메인메모리 관리(디멘딩 페이지), 파일관리(연속,연결,색인할당)&lt;/p&gt;
&lt;p&gt;디스크의 헤더의 움직이는데 오래걸린다. 물론 ms는 느린게 아니지만 컴퓨터의 수준에서 느린것이다.&lt;br&gt;200개의 실린더가 있
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>28.색인할당, 디스크 탐색시간, FCFS, SSTF</title>
    <link href="http://KKimSangHeon.github.io/2019/03/05/operating-system28/"/>
    <id>http://KKimSangHeon.github.io/2019/03/05/operating-system28/</id>
    <published>2019-03-05T13:03:20.000Z</published>
    <updated>2019-03-06T13:44:50.323Z</updated>
    
    <content type="html"><![CDATA[<p>보조기억장치중 하드디스크를 배운다<br>동심원이 있고 원판이 있다. 원판에 자성물질을 발라서 디스크 헤더에 전기를 흘려 기록을 하고 읽을 때는 고속으로 회전시켜 코일에 전류가 유도되는데 이를통해 읽는다.<br>이를 트랙이라 하고 보통 디스크는 앞 뒤로 쓰는데 트랙이라는 용어보다는 실린더라는 용어를 많이 쓰고 있다.<br>트랙을 쪼개서 섹터라 한다 섹터는 512b정도 된다. 이를 네개정도 모아서 블록이라고 한다.<br>하드디스크를 포멧하면 내용을 다지우고 나면 poll of block이라 한다.</p>
<h3 id="연속할당"><a href="#연속할당" class="headerlink" title="연속할당"></a>연속할당</h3><p>블록 하나가 1kb라고 가정하자 3.6kb파일을 하나 만들었을때 블록을 연속적으로 만들어주면 내부단편화가 발생한다.<br>하지만 헤더가 많이 안움직여도 되므로 빠르다.  디스크 헤더의 이동 최소화 = 빠른 i/o 성능<br>하지만 데이터를 지웠을 때 외부단편화가 발생한다.(곳곳에 흩어지는 holes로 인해)</p>
<h3 id="연결할당"><a href="#연결할당" class="headerlink" title="연결할당"></a>연결할당</h3><p>디렉토리라는것은 메인메모리에 저장되고 OS에서 관리된다. 파일 이름, 만들어진날짜 등등을 보관한다. 하지만 우리눈엔 안보이고 커널에만 보이는것이 있는데 파일의 위치가 그것이다. 파일의 시작위치를 지정해두고 파일이 연결리스트 형태로 이어진다. 포인터 저장을 위해 4바이트가 필요하다는점, 헤더가 많이 움직여야한다는점, 중간부터 읽을 수 없다는점이 단점이다.</p>
<h3 id="FAT"><a href="#FAT" class="headerlink" title="FAT"></a>FAT</h3><p>연결할당의 단점을 해결하기 위해 포인터만을 모은 테이블(FAT)을 만든것.</p>
<h3 id="색인할당-Indexed-Allocation"><a href="#색인할당-Indexed-Allocation" class="headerlink" title="색인할당 (Indexed Allocation)"></a>색인할당 (Indexed Allocation)</h3><p><u>3.6kb 파일을 만드려면 한 블록이 1kb일때 4개가 필요한데 인덱스 테이블을 특정한 블록에 저장하고 디렉토리에는 파일의 인덱스 블록의 주소를 갖고있다. 즉 인덱스 블록은 포인터의 모음이며 하나의 파일당 하나씩 갖고있다.</u></p>
<p>데이터가 들어있는것은 데이터블록 주소가 들어있는것은 인덱스 블록이며 파일 하나당 인덱스 블록이 필요하다.<br><u>Direct access 가능하고 외부 단편화 없다.</u></p>
<p>인덱스 블록을 위해 블록을 할당해야 하는것이 단점이다. 1바이트 짜리를 저장하는데도 블록의 크기만큼(예를들었을 경우 1kb)만큼 할당해줘야 한다.</p>
<p><code>파일의 최대크기</code>: 1블록의 크기가 512바이트라 가정해보자. 주소를 표현하는데는 4바이트 이므로 128개의 인덱스를 갖을 수 있다. 여기서 512바이트 * 128을 계산하면 64kb이다. 즉 파일의 최대 크기는 64kb이다.</p>
<p>예제: 1블록 = 1KB = 4바이트 x 256개 인덱스<br>즉 256 * 1KB = 256KB</p>
<img src="/2019/03/05/operating-system28/image1.png" alt="Linked" title="Linked">
<p><code>해결방법1:</code> Linked : 이를 개선하기 위해 인덱스를 갖는 블록이 다른 인덱스 블록을 가르키는것.</p>
<img src="/2019/03/05/operating-system28/image2.png" alt="Multilevel index" title="Multilevel index">
<p><code>해결방법2:</code> Multilevel index : 하나의 인덱스 블록이 여러개의 인덱스 블록을 가르키는것.</p>
<img src="/2019/03/05/operating-system28/image3.png" alt="Combined" title="Combined">
<p><code>해결방법3:</code> Combined : 처음 인덱스 블록에서 앞쪽은 실제로 데이터를 가르키고 나머지 블록은 인덱스 블록을 가르키고..이는 유닉스에서 쓰임..</p>
<h3 id="디스크-스케줄링"><a href="#디스크-스케줄링" class="headerlink" title="디스크 스케줄링."></a>디스크 스케줄링.</h3><p>대표적인 보조기억장치는 하드디스크이다. 디스크는 원판에 트랙이 있고 디스크를 움직여서 해당되는 트랙으로 이동한다. 제일 오래 걸리는 시간이 헤더를 움직이는 Seek time이 오래걸린다, 디스크가 도는 시간은  rotational delay(1분에 7200번돈다) 트랙이 헤더를 지나가면서 읽히는 시간이 transfer time이라 한다.</p>
<p>다중 프로그래밍 환경에서 여러개의 프로세스가 동시에 돌아간다. <u>여러프로세스가 디스크를 사용하려면 디스크 큐에 들어가야한다. 이때 어떻게 하면 탐색시간 즉 디스크 헤더를 가장 적게 움직일 수 있을까…</u></p>
<h3 id="디스크-스케줄링-1-FCFS"><a href="#디스크-스케줄링-1-FCFS" class="headerlink" title="디스크 스케줄링 1. FCFS"></a>디스크 스케줄링 1. FCFS</h3><p>먼저온놈한테 먼저 서비스를 제공.<br>200 cylinder disk, 0 .. 199<br>Disk queue: 98 183 37 122 14 124 65 67<br>Head is currently at cylinder 53<br>Total head movement = 640 cylinders</p>
<p>극혐이다,….</p>
<h3 id="디스크-스케줄링-2-SSTF"><a href="#디스크-스케줄링-2-SSTF" class="headerlink" title="디스크 스케줄링 2. SSTF"></a>디스크 스케줄링 2. SSTF</h3><p>Shortest-Seek-Time-First 의 약어로서 최소화 되는것을 먼저하는것.</p>
<p>즉 지금위치를 기준으로 했을 때 가장 짧은곳을 먼저 가는것.<br>200 cylinder disk, 0 .. 199<br>Disk queue: 98 183 37 122 14 124 65 67<br>Head is currently at cylinder 53<br>Total head movement = 236 cylinders</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;보조기억장치중 하드디스크를 배운다&lt;br&gt;동심원이 있고 원판이 있다. 원판에 자성물질을 발라서 디스크 헤더에 전기를 흘려 기록을 하고 읽을 때는 고속으로 회전시켜 코일에 전류가 유도되는데 이를통해 읽는다.&lt;br&gt;이를 트랙이라 하고 보통 디스크는 앞
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>27.연속할당, 연결할당의 장단점</title>
    <link href="http://KKimSangHeon.github.io/2019/03/05/operating-system27/"/>
    <id>http://KKimSangHeon.github.io/2019/03/05/operating-system27/</id>
    <published>2019-03-05T13:02:56.000Z</published>
    <updated>2019-03-06T13:49:55.622Z</updated>
    
    <content type="html"><![CDATA[<p>하드디스크는 poll of free blocks 즉 빈 블록들의 집합이다.</p>
<p>한블록이 1kb이고 파일A 5kb, 파일B 3kb, 파일C 4kb 일때 어느블록에 넣을까?<br>0~19까지의 블록이 있을때 어떤식으로 배치할 수 있을까??</p>
<h3 id="연속할당"><a href="#연속할당" class="headerlink" title="연속할당"></a>연속할당</h3><p><u>각 파일에 대해 디스크 상의 연속된 블록을 할당</u><br>즉 A는 0~4까지 할당, B는 5~7 , C는 8~11 까지 연속적으로 할당하는 방법<br>60~70년대에 사용되는 방법</p>
<p><code>장점</code> : 일고 쓸때 디스크 헤더의 움직임을 최소화 할 수 있다. 이는 빠른 i/o 성능과 직결<br>동영상, 음악, VOD 등에 적합<br>sequential access 순차접근이라고 한다.<br>특정 부분을 바로 읽을 수도 있다 (direct access 직접접근)</p>
<p><code>단점</code> : 파일을 지울 경우 문제가 된다. A,C를 지우고 6kb의 데이터를 넣으려고 하면 못넣는다. 외부단편화가 발생!<br><u>즉 외부 단편화로 인한 디스크 공간 낭비</u><br>이를 방지하기 위해 hole을 모으는 Compaction을 하면 되지만 시간이 오래걸린다.<br>또한 <u>파일을 생성할 때 파일의 크기를 예측 할 수 없기 때문에 어디에 할당해야 할지 알 수 없다. 또한 파일의 크기가 계속증가할 수 있기때문에 기존의 hole로는 배치가 불가능하게 될 수 있다.</u></p>
<h3 id="연결할당"><a href="#연결할당" class="headerlink" title="연결할당"></a>연결할당</h3><p>연속할당을 개선하기 위해 나온것이 연결할당</p>
<img src="/2019/03/05/operating-system27/image.png" alt="하드디스크 디렉토리의 관계" title="하드디스크 디렉토리의 관계">
<p>각 블록들에 포인터를 달아놓고 이어지는 블록을 가르킨다. 처음 블록 위치는 파일 디렉토리가 갖고 있다. 각 블록은 포인터 저장을 위한 4바이트 또는 이상 소모. 이는 외부단편화를 없앨 수 있다.<br>디렉토리라는것은 메인메모리에 저장되고 OS에서 관리된다. 파일 이름, 만들어진날짜 등등을 보관한다. 하지만 우리눈엔 안보이고 커널에만 보이는것이 있는데 파일의 위치가 그것이다</p>
<p><code>단점</code> : 연속할당의 경우 블록의 위치를 가늠할 수 있지만 연결할당의 경우 중간부터 읽기는 어려움이 있다. 즉 Direct access가 불가하고 동영상의 중간부터 보기가 불가능하다는것이다. 포인터 저장을 위해서 4바이트 이상이 손실한다, 또한 포인터가 끊어질 경우 접근이 불가능하므로 신뢰성이 낮다. 외부단편화는 없지만 데이터들이 흩어져있기 때문에 헤더가 계속 움직여야하기 때문에 io시간이 오래걸린다.</p>
<p>연속할당의 문제(단편화)를 해결했지만 이 또한 문제가 있다.</p>
<h3 id="연결할당을-개선한-FAT-파일-시스템"><a href="#연결할당을-개선한-FAT-파일-시스템" class="headerlink" title="연결할당을 개선한 FAT 파일 시스템"></a>연결할당을 개선한 FAT 파일 시스템</h3><p>USB메모리가 주로 FAT32를 쓰는데 뭔지 알아보자<br>연결할당의 변종으로서 File Allocation Table 파일 시스템이다. MS-DOS, OS/2, Windows 등에서 사용한다,</p>
<p>포인터들을 따로 모아서 포인터 테이블을 디스크 블록에 따로 저장한다. 포인터들만 모인 테이블을 FAT라고 한다. 이를 통해 블록을 읽지 않고 테이블만 읽음으로써 direct access 또한 가능하게 된다. 주기적으로 FAT에 변동사항을 넣어주고 하나의 블록이 깨지더라도 FAT 내용만 살아있다면 나머지를 읽을 수 있다. 즉 신뢰성 향상. FAT가 고장나면 큰일나기 때문에 보통 FAT 카피본을 저장하고 있다. FAT 는 일반적으로 메모리 캐싱</p>
<p>즉 direct access , 신뢰성(FAT 손실 시 복구 위해 이중 저장)을 높였다.<br>FAT를 얼마나 할당할까? 32비트를 할당하면 2^32 개의 주소를 저장할 수 있다. 이를 FAT32라고 한다.</p>
<h3 id="색인할당"><a href="#색인할당" class="headerlink" title="색인할당."></a>색인할당.</h3><p>다음 포스팅에..</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;하드디스크는 poll of free blocks 즉 빈 블록들의 집합이다.&lt;/p&gt;
&lt;p&gt;한블록이 1kb이고 파일A 5kb, 파일B 3kb, 파일C 4kb 일때 어느블록에 넣을까?&lt;br&gt;0~19까지의 블록이 있을때 어떤식으로 배치할 수 있을까??&lt;
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>26. 파일할당</title>
    <link href="http://KKimSangHeon.github.io/2019/03/05/operating-system26/"/>
    <id>http://KKimSangHeon.github.io/2019/03/05/operating-system26/</id>
    <published>2019-03-05T13:02:47.000Z</published>
    <updated>2019-03-06T13:44:45.174Z</updated>
    
    <content type="html"><![CDATA[<p>OS 프로세스관리 배웠고/ 메인메모리 관리 배웠고/ 파일시스템중 파일 할당에 대해 배운다</p>
<p>OS는 컴퓨터 자원을 관리한다.<br>CPU: 프로세스 관리 (CPU 스케쥴링, 프로세스 동기화)<br>주기억장치: 메인 메모리 관리 (페이징, 가상 메모리)<br>보조기억장치: 파일 시스템 관리</p>
<p>파일이 어떻게 할당되어지는가에 대해 알아보자.<br><code>하드디스크는 구조</code>: 원판에 자성물질을 바르고 모터를 달아서 돌린다.  데이터는 동심원 상에 저장된다. 또한 헤더가 존재하는데 헤더에는 코일이 감겨있고 여기에 전기를 흘리면 데이터가 기록된다. 데이터를 읽을 때는 판을 빨리 돌리면 판이 지나가면서 전기가 유도되는데 이 값을 통해 데이터를 읽어낸다.<br>하드디스크에는 트랙이 있고 이를 잘라 섹터라 한다. 실린더는 하나의 하드디스크 안에 여러 판을 넣을 수 있다. 즉 <u>실린더란 같은 거리에 있는 트랙들의 집합<u>을 의미한다. 즉 원통같은것을 의미.</u></u></p>
<p>보통 한섹터는 512 bytes이고 섹터를 모아놓은것을 block이라 한다. 하드디스크에 읽고 쓰는것은 블록 단위로 이뤄지는데 이때문에 하드디스크를 <u>block device</u>라고 한다. 이와 반대되는것을 <u>character device</u>라 하는데 대표적인것이 키보드가 있다.</p>
<p>메모장을 켜서 한글자를 입력하고 저장만 하고 속성을 들어가보자, 이때 크기는 1바이트인데 디스크 할당크기는 4바이트이다. 이를 통해 한 블록 크기가 4바이트인것을 알 수 있다.(억울하다,,,) 블록 크기는 운영체제 설계자가 정한다,</p>
<p>디스크는 pool of free blocks 즉 free 블록들의 모음이다. 각각의 파일에 대해 free block을 어떻게 할당해줄까???<br>연속적으로 할당할 수 도 있고 떨어져있는것들로 할수도있고.. 어떤것이 더 좋을까/???</p>
<p>이는 3가지로 나뉘는데 연속 할당 (Contiguous Allocation) /연결 할당 (Linked Allocation) / 색인 할당 (Indexed Allocation)<br>이 존재한다. 이에 대해서는 다음포스팅에서 알아보자.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OS 프로세스관리 배웠고/ 메인메모리 관리 배웠고/ 파일시스템중 파일 할당에 대해 배운다&lt;/p&gt;
&lt;p&gt;OS는 컴퓨터 자원을 관리한다.&lt;br&gt;CPU: 프로세스 관리 (CPU 스케쥴링, 프로세스 동기화)&lt;br&gt;주기억장치: 메인 메모리 관리 (페이징,
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>25.프레임 할당, 정적/동적 할당, 쓰레싱, 페이지 크기</title>
    <link href="http://KKimSangHeon.github.io/2019/03/04/operating-system25/"/>
    <id>http://KKimSangHeon.github.io/2019/03/04/operating-system25/</id>
    <published>2019-03-04T13:33:17.000Z</published>
    <updated>2019-03-06T13:47:13.899Z</updated>
    
    <content type="html"><![CDATA[<p>프로세스 매니지먼트에서는 CPU 스케줄링, 프로세스 동기화가 중요하다,<br>메인메모리 매니지먼트에서는 페이징, 가상주소(요구페이징, 요구 세그먼트 페이징이 있다)가 중요하다.</p>
<p>요구페이징을 하다보면 언젠가는 페이지가 가득차는데 어떤 페이지를 희생자로 택할것인가를 페이지 리플레이스먼트 알고리즘이다. 여기서 FIFO, Optimal 알고리즘이 있다. Optimal은 비현실적이여서 LRU가 많이 사용된다.</p>
<p>지금은 Allocation of Frames를 배운다. 어느프로세스에게 얼마만큼의 프레임을 줄것인가에 대한것.</p>
<p>페이징은 프로세스를 페이징 단위로 잘라서 메모리에 올린다. 이를 디맨딩 페이지라 한다.</p>
<p>다시말해 Allocation of Frames는 <u>3개의 프로세스가 있고 페이지가 100개가 있을 때 각각 얼마씩 나눠줄까에 대한것.</u></p>
<p>정적할당 동적할당이 있는데 동적할당은 프로그램이 더 크면 크게줄 경우 이를 비례할당이라 하고 그냥 33개씩 동등하게 나눠주는것을 균등할당이라 한다.<br>하지만 균등할당은 말이 안되고 비례할당 또한 말이 안된다. 프로그램이 크다고 해서 우리가 해당프로그램의 모든 기능을 다 쓰는것은 아니기 때문에… 즉 실행해봐야 얼마나 필요한지 알수있는데 이를 동적할당이라 한다.</p>
<h3 id="동적프레임-할당"><a href="#동적프레임-할당" class="headerlink" title="동적프레임 할당"></a>동적프레임 할당</h3><h4 id="동적프레임-할당-1-Working-set-model"><a href="#동적프레임-할당-1-Working-set-model" class="headerlink" title="동적프레임 할당 1.Working set model"></a>동적프레임 할당 1.Working set model</h4><p>시간대별로 이용하는 페이지들을 나열해 봤을 때 특정 시간에 이용하는 프레임들을 봤을 때 이용되는 프레임들의 셋을 Locality라고 한다. locality들을 기반으로 어떤 페이지들이 사용되었는지 예측하는것이 좋은데 과거의 것들을 working set이라고 한다. 또한 과거의 어느정도까지 볼것인가에 대한 것을 Working set window이라 하는데 이는 OS만드는 사람이 결정한다. 결국 Working set window가 3ms 라 했을때 현재시점부터 과거 3ms까지의 locality들의 집합이 working set이며 이를 기반으로 프레임을 할당한다.</p>
<h4 id="동적프레임-할당-2-Page-Fault-Frequency-PFF"><a href="#동적프레임-할당-2-Page-Fault-Frequency-PFF" class="headerlink" title="동적프레임 할당 2.Page-Fault Frequency (PFF)"></a>동적프레임 할당 2.Page-Fault Frequency (PFF)</h4><p>Working set model보다 간단한 방법으로 가로축이 할당된 프로세스의 갯수 세로축이 page fault rate라 했을 때 반비례 그래프가 나온다. OS는 Page fault 발생 비율의 상한/하한선을 기억해두고 페이지 폴트가 상한선 초과 프로세스인 경우에 더 많은 프레임 할당하고 하한선 이하인경우 프로세스의 프레임은 회수한다.</p>
<h3 id="페이지-크기"><a href="#페이지-크기" class="headerlink" title="페이지 크기"></a>페이지 크기</h3><p>디멘드 페이징이나 페이징할때 페이지는 어떤 크기로 자를까???<br>일반적 크기: 4KB ~ 4MB</p>
<p>페이지의 크기는 커지는중.. 프로세스의 크기도 커지고있으므로</p>
<p><code>페이지 사이즈는 큰게 좋을까 작은게 좋을까????</code><br>-내부단편화 측면에서는 페이지 사이즈는 작은게 좋다.<br>-페이지 폴트가 발생했을 때 페이지 인 아웃의 시간이 오래걸리는데 이때 페이지 크기는 큰것이 유리하다. 백킹스토어에서 헤더가 움직이고 데이터를 읽어오는것은 꽤 많은 시간이 들기 때문에…<br>-CPU가 내는 주소를 변환하기 위해 존재하는 페이지 테이블의 크기가 작으면 SRAM의 비용이 덜 들어가고 이를 위해서는페이지의 크기가 커야한다.<br>-Memory resolution입장에서는 우리가 필요한것만 위치하게 되는데 이를 위해 페이지 크기가 작은게 좋다. 페이지 크기가 필요없는것도 왕창 들어있을테니까.<br>-페이지 폴트가 적게 일어나기 위해서는 페이지의 크기가 클 수 록 좋다. CPU가 100번지를 읽으면 그다음에는 104번지,108번지 읽는데 넓게 갖고오면 당분간은 페이지 폴트가 발생하지 않는데 이를 위해 처음부터 크게 갖고오는것이 좋다.</p>
<p><u>즉 관점에 따라 메모리 크기는 큰게 좋을 수도 작은게 좋을 수도 있다.</u><br>일반적으로는 메모리, 프로그램의 크기는 점차 크지므로 점점 커지고 있다.</p>
<h3 id="페이지-테이블의-위치"><a href="#페이지-테이블의-위치" class="headerlink" title="페이지 테이블의 위치"></a>페이지 테이블의 위치</h3><p>페이지 테이블은 CPU도 아니고 메모리에도 넣지 않고 TLB캐시라는곳에 넣고 있다.<br>하지만 최근은 반도체가 좋아지다 보니까 별도의 칩으로 하지않고 TLB 그리고 여러 캐시 메모리가 CPU안에 들어가게 되었다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;프로세스 매니지먼트에서는 CPU 스케줄링, 프로세스 동기화가 중요하다,&lt;br&gt;메인메모리 매니지먼트에서는 페이징, 가상주소(요구페이징, 요구 세그먼트 페이징이 있다)가 중요하다.&lt;/p&gt;
&lt;p&gt;요구페이징을 하다보면 언젠가는 페이지가 가득차는데 어떤 
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>24.FIFO, OPT, LRU, 전역/지역교체</title>
    <link href="http://KKimSangHeon.github.io/2019/03/04/operating-system24/"/>
    <id>http://KKimSangHeon.github.io/2019/03/04/operating-system24/</id>
    <published>2019-03-03T23:22:17.000Z</published>
    <updated>2019-03-04T13:33:39.613Z</updated>
    
    <content type="html"><![CDATA[<p>메모리 용량이 작을수록 페이지 폴트가 자주일어난다</p>
<h3 id="Belady’s-Anomaly"><a href="#Belady’s-Anomaly" class="headerlink" title="Belady’s Anomaly"></a>Belady’s Anomaly</h3><p>메모리 용량이 늘어나느데도 페이지 폴트가 발생하는 이상한 현상이 발생한다.<br>언제? FIFO를 사용할때!</p>
<h3 id="Optimal-OPT"><a href="#Optimal-OPT" class="headerlink" title="Optimal (OPT)"></a>Optimal (OPT)</h3><p>2를 몰아냈는데 2가 필요한 경우가 생길 수 있다. 즉 억울한 경우<br>이런일이 안일어나게 하기위해 <u>앞으로 사용되지 않을것을 희생자로 선택한다.</u><br><u>이는 비현실적이다. 앞으로 뭐가 사용안될지 잘 모르는것이다,</u><br>SJF와 비슷하다. 이 또한 어떤놈이 제일 짧은지 알 수 없다.</p>
<h3 id="Least-Recently-Used-LRU"><a href="#Least-Recently-Used-LRU" class="headerlink" title="Least-Recently-Used (LRU)"></a>Least-Recently-Used (LRU)</h3><p><u>최근에 가장 적게 사용된놈을 희생양으로 삼는다. 대부분의 컴퓨터가 사용하는 방식.</u><br>가장 좋은것은 앞으로 사용안될것을 희생양으로 삼는게 좋겠지만 현실적으로 판단하기 어려움으로,</p>
<h3 id="Global-vs-Local-Replacement"><a href="#Global-vs-Local-Replacement" class="headerlink" title="Global vs Local Replacement"></a>Global vs Local Replacement</h3><p><code>Global replacement</code> - 희생자를 선택할 때 메모리 상의 모든 프로세스 페이지에 대해 교체<br><code>Local replacement</code>- 희생자를 선택할 때 메모리 상의 자기 프로세스 페이지에 대해 교체</p>
<p><code>성능 비교</code> - Global replacement 가 더 효율적일 수 있다.</p>
<hr>
<p>CPU utilization vs Degree of multiprogramming</p>
<p>CPU utilization - CPU 이용률<br>Degree of multiprogramming - 메인메모리에 올라와있는 프로세스의 갯수</p>
<p>메모리 안에프로세스를 많이 올리니까 일정범위를 넘어서면 CPU의 이용률이 감소했다.<br><code>왜그럴까?</code> : 너무 많은 프로세스로 인해 빈번한 page in/out가 발생한다. 즉 디스크 IO가 많아져서 CPU이용율이 떨어진다. 이를 <u>쓰레싱(Thrashing)</u>라고 한다.</p>
<p><code>쓰레싱???</code> : 일정범위를 넘어서면 CPU이용율이 떨어지는데 이범위를 쓰레싱이라 한다.</p>
<h3 id="쓰레싱을-극복하기-위한-방법"><a href="#쓰레싱을-극복하기-위한-방법" class="headerlink" title="쓰레싱을 극복하기 위한 방법."></a>쓰레싱을 극복하기 위한 방법.</h3><p>Global replacement 보다는 local replacement 활용<br>프로세스당 충분한/적절한 수의 메모리(프레임) 할당</p>
<h3 id="프레임-할당-Allocation-of-Frames"><a href="#프레임-할당-Allocation-of-Frames" class="headerlink" title="프레임 할당(Allocation of Frames)"></a>프레임 할당(Allocation of Frames)</h3><p><u>프레임 할당은 크게 <u>정적할당 동적할당</u>으로 나뉜다.</u></p>
<h4 id="정적-할당-static-allocation-또한-균등할당-비례할당으로-나뉜다"><a href="#정적-할당-static-allocation-또한-균등할당-비례할당으로-나뉜다" class="headerlink" title="정적 할당 (static allocation) 또한 균등할당, 비례할당으로 나뉜다."></a>정적 할당 (static allocation) 또한 균등할당, 비례할당으로 나뉜다.</h4><p><code>균등 할당 (Equal allocation)</code> : 메인메모리에 프레임 수가 100개고 프로세스 수가 3개면 각 프레세스에 프레임을 33개씩 할당해주는것. 조금 적절하지 않다. hwp와 메모장이 올라와 있을 때 동일하게 분배한다는것은 옳지않다!! hwp는 조금더 무겁잖아<br><code>비례 할당 (Proportional allocation)</code> : 사이즈가 큰놈한텐 많이 나눠주고 작은놈한텐 적게 나눠주는것.</p>
<p>사실 hwp에서 특별한 기능은 많이 쓰지 않으므로 정적할당은 올바르지 않다,</p>
<h4 id="동적-할당-dynamic-allocation-또한-Working-set-model-Page-fault-frequency-등으로-나뉜다"><a href="#동적-할당-dynamic-allocation-또한-Working-set-model-Page-fault-frequency-등으로-나뉜다" class="headerlink" title="동적 할당 (dynamic allocation) 또한 Working set model , Page fault frequency 등으로 나뉜다."></a>동적 할당 (dynamic allocation) 또한 Working set model , Page fault frequency 등으로 나뉜다.</h4><p><code>Working set model</code> :<br><code>Page fault frequency</code> :</p>
<p>다음 포스팅에서….</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;메모리 용량이 작을수록 페이지 폴트가 자주일어난다&lt;/p&gt;
&lt;h3 id=&quot;Belady’s-Anomaly&quot;&gt;&lt;a href=&quot;#Belady’s-Anomaly&quot; class=&quot;headerlink&quot; title=&quot;Belady’s Anomaly&quot;&gt;&lt;/a&gt;Bel
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>23.페이지 교체 필요성, 희생 페이지 설정 원칙</title>
    <link href="http://KKimSangHeon.github.io/2019/02/28/operating-system23/"/>
    <id>http://KKimSangHeon.github.io/2019/02/28/operating-system23/</id>
    <published>2019-02-28T05:39:51.000Z</published>
    <updated>2019-02-28T05:40:18.477Z</updated>
    
    <content type="html"><![CDATA[<h3 id="가상메모리"><a href="#가상메모리" class="headerlink" title="가상메모리"></a>가상메모리</h3><p>프로세스를 페이지 크기로 쪼개서 메인메모리로 올리는데 당장 필요한 것들만 올리고 보자</p>
<p>그러다 메모리가 꽉차게 되면 한놈을 쫒아내고 필요한놈을 불러온다,</p>
<h3 id="Demand-Paging"><a href="#Demand-Paging" class="headerlink" title="Demand Paging"></a>Demand Paging</h3><p>프로세스 이미지는 backing store 에 저장<br>프로세스는 페이지의 집합</p>
<h3 id="가상메모리를-위한-하드웨어-지원"><a href="#가상메모리를-위한-하드웨어-지원" class="headerlink" title="가상메모리를 위한 하드웨어 지원"></a>가상메모리를 위한 하드웨어 지원</h3><p>valid 비트 추가된 페이지 테이블<br>backing store (= swap device)</p>
<h3 id="Memory-full"><a href="#Memory-full" class="headerlink" title="Memory full!"></a>Memory full!</h3><p>메모리가 가득 차면 추가로 페이지를 가져오기 위해<br>어떤 페이지는 backing store 로 몰아내고 (page-out)<br>그 빈 공간으로 페이지를 가져온다 (page-in) -  용어: victim page</p>
<h3 id="어느-페이지를-몰아낼-것인가"><a href="#어느-페이지를-몰아낼-것인가" class="headerlink" title="어느 페이지를 몰아낼 것인가?"></a>어느 페이지를 몰아낼 것인가?</h3><p>i/o 시간 절약을 위해 기왕이면 modify 되지 않은 페이지를 victim 으로 선택<br>방법: modified bit (= dirty bit)</p>
<h3 id="Page-reference-string"><a href="#Page-reference-string" class="headerlink" title="Page reference string"></a>Page reference string</h3><p>CPU 가 내는 주소: 100 101 102 432 612 103 104 611 612<br>Page size = 100 바이트라면<br>페이지 번호 = 1 1 1 4 6 1 1 6 6<br>Page reference string = 1 4 6 1 6</p>
<p><code>설명</code>: fault가 발생하면 100바이트씩 (한페이지씩) 갖고오게 되기 떄문에 100번지를 못찾을경우 100~199까지 갖고오므로 그다음의 101은 fault가 발생하지 않는다. 즉 연속적일 때 앞에서 한번만 갖고오게 한다.</p>
<h3 id="Page-Replacement-Algorithms"><a href="#Page-Replacement-Algorithms" class="headerlink" title="Page Replacement Algorithms"></a>Page Replacement Algorithms</h3><p><code>FIFO (First-In First-Out)</code> : 메인메모리에 먼저 올라온놈을 내보낸다.<br><code>OPT (Optimal)</code> :<br><code>LRU (Least-Recently-Used)</code></p>
<h3 id="FIFO-기법"><a href="#FIFO-기법" class="headerlink" title="FIFO 기법"></a>FIFO 기법</h3><p><code>Idea</code>: 초기화 코드는 더 이상 사용되지 않을 것이라는 생각을 바탕으로 만들어짐! 가장 간단하다.</p>
<p><code>예제</code><br>페이지 참조열 = 7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1<br>of frames = 3<br>15 page faults</p>
<h3 id="Optimal-OPT"><a href="#Optimal-OPT" class="headerlink" title="Optimal(OPT)"></a>Optimal(OPT)</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;가상메모리&quot;&gt;&lt;a href=&quot;#가상메모리&quot; class=&quot;headerlink&quot; title=&quot;가상메모리&quot;&gt;&lt;/a&gt;가상메모리&lt;/h3&gt;&lt;p&gt;프로세스를 페이지 크기로 쪼개서 메인메모리로 올리는데 당장 필요한 것들만 올리고 보자&lt;/p&gt;
&lt;p&gt;그러다
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>22.가상메모리 개요와 원리</title>
    <link href="http://KKimSangHeon.github.io/2019/02/27/operating-system22/"/>
    <id>http://KKimSangHeon.github.io/2019/02/27/operating-system22/</id>
    <published>2019-02-26T22:48:09.000Z</published>
    <updated>2019-03-06T13:46:43.737Z</updated>
    
    <content type="html"><![CDATA[<p>일정크기로 자르는 페이징<br>논리적 크기로 자르는 세그멘테이션</p>
<p><code>보호와 공유적인 측면에서는 페이징보다 세그먼트가 낫다.</code></p>
<p>세그먼트는 코드,데이터,스택이라고 잘랐을 때 각 크기는 다르다. 다른 데이터를 남는부분에 넣을라 하면 들어갈 수가 없다. 즉 외부단편화가 발생한다. 치명적인 문제! 외부단편화는 너무 치명적이다.</p>
<p><code>그럼 세그멘테이션과 페이징을 합치면 좋지않을까?</code><br>1.처음에는 코드,데이터,스택으로 나누어 세그먼트로 자르고<br>2.각 세그먼트를 일정한크기(페이지로) 자른다.</p>
<p>이를 Paged segmentation이라 한다.</p>
<p>하지만 이 경우 CPU - 세그먼트 테이블 - 페이지 테이블 - 메모리 를 거치게 되는데 두가지의 테이블을 거치기 때문에 느려진다.</p>
<h3 id="가상메모리"><a href="#가상메모리" class="headerlink" title="가상메모리"></a>가상메모리</h3><p>물리적인 메모리 크기의 한계를 극복하기 나옴,.<br>내 컴퓨터의 메모리가 1gb이면 2gb의 프로세스를 올리지는 못한다.</p>
<p>요즘 나오는 컴퓨터는 모두 가상메모리 기법이 적용되어 있다.</p>
<p><code>어떤원리로?</code>: 오류처리, 배열 등 지금은 불필요한것들은 올리지 않고 나중에 필요할 때 올린다. 동적 적재 (dynamic loading)과 비슷한 개념. 즉 각 프로세스를 페이지단위로 자르고 지금필요한것만 올린다. 이를 <u>요구페이징(Demand Paging)</u>이라고 한다.</p>
<h3 id="Demand-Paging"><a href="#Demand-Paging" class="headerlink" title="Demand Paging"></a>Demand Paging</h3><p>프로세스 이미지는 backing store 에 저장<br>프로세스는 페이지의 집합<br><u>지금 필요한 페이지만 메모리에 올린다(load) - 요구되는 (demand) 페이지만 메모리에 올린다</u></p>
<p>CPU가 페이지 테이블에 접근했을 때 자기가 읽고자 하는것의 valid 비트가 invalid 일 경우 인터럽트가 걸리게되고 CPU는 하던일을 정지하고 오류처리(필요한것을 들고오는 루틴)를 실행한다.</p>
<p>가상메모리를 만드는 방법은 Demand paging , virtual memory가 있다.</p>
<h3 id="Page-Fault"><a href="#Page-Fault" class="headerlink" title="Page Fault"></a>Page Fault</h3><p>Demand Paging에서 페이지를 읽으려 했는데 페이지가 없다!<br>이에따른 Page Falult Routine가 필요하다.</p>
<h3 id="pure-demand-paging-vs-prepaging"><a href="#pure-demand-paging-vs-prepaging" class="headerlink" title="pure demand paging vs prepaging"></a>pure demand paging vs prepaging</h3><p><code>pure demand paging</code> : 프로그램 실행할 때 아무것도 들고오지 않음. 그러므로 처음시작부터 page fault가 발생하여 처음부터 필요한것을 갖고온다. 즉 이로 인해속도가 느려진다. 하지만 필요한것만 불러오므로 메모리가 절약된다.</p>
<p><code>prepaging</code>: 미리 필요한것을 예측하여 들고온다. 메모리는 낭비될 수 있으나 page fault가 적게일어나므로 속도적인 측면에서 부담이 적다</p>
<h3 id="swaping-vs-demand-paging"><a href="#swaping-vs-demand-paging" class="headerlink" title="swaping vs  demand paging"></a>swaping vs  demand paging</h3><p><code>swaping</code> : 화장실 가면 프로세스를 백킹스토어로 몰아내는것. 이때 <u>왔다갔다하는 단위는 프로세스 단위</u>이다,<br><code>demand paging</code> : 백킹스토어를 <u>왔다갔다 하는 단위가 페이지 단위</u>이다,</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;일정크기로 자르는 페이징&lt;br&gt;논리적 크기로 자르는 세그멘테이션&lt;/p&gt;
&lt;p&gt;&lt;code&gt;보호와 공유적인 측면에서는 페이징보다 세그먼트가 낫다.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;세그먼트는 코드,데이터,스택이라고 잘랐을 때 각 크기는 다르다. 다른 데이터를
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>21.세그멘트 테이블, 주소변환</title>
    <link href="http://KKimSangHeon.github.io/2019/02/26/operating-system21/"/>
    <id>http://KKimSangHeon.github.io/2019/02/26/operating-system21/</id>
    <published>2019-02-26T11:40:29.000Z</published>
    <updated>2019-02-26T11:42:25.812Z</updated>
    
    <content type="html"><![CDATA[<h3 id="내부단편화-페이지-테이블"><a href="#내부단편화-페이지-테이블" class="headerlink" title="내부단편화, 페이지 테이블"></a>내부단편화, 페이지 테이블</h3><p>파워를 키면 OS가 메인 메모리로 올라간다. 프로세스들이 메모리에 연속으로 들어가게되면외부단편화 문제가 발생<br>그래서 메모리에 프로그램을 프레임 단위로 나눠 흩어져서 들어가게 했다.<br>하지만 CPU는 페이지 테이블로 인해 연속적으로 위치한다고 생각하게 된다.<br>페이지를 이용해서 내부단편화가 발생하지만 이는 미미한 정도이다!! 페이지 테이블은 고속의 SRAM으로 만드는데 이를 TLB (Translation Look-aside Buffer)라 한다.</p>
<p>페이지 테이블에서 물리주소를 찾을 수 있을 때 히트했다고 한다.</p>
<h3 id="보호"><a href="#보호" class="headerlink" title="보호"></a>보호</h3><p>모든 주소는 페이지 테이블을 경유한다. 그러므로 페이지테이블 엔트리(페이지 테이블의 끝쪽)마다 <u>R,W,X 비트를 두어 접근 제어를 한다.</u></p>
<h3 id="공유"><a href="#공유" class="headerlink" title="공유"></a>공유</h3><p>문서편집기를 세개 띄웠다고 가정하자. 각 프로그램마다 코드, 데이터, 스택이 따로 할당되면 메모리의 낭비이다. 코드는 공유가능하므로 하나만 만든다. 즉 페이지들이 코드영역은 셋다 똑같은 부분의 프레임을 가르키게 된다.<br>코드가 공유되려면 코드의 내용이 실행중에 변경되면 안된다, 이를  non-self- modifying code = reentrant code = pure code 라고 한다.<br><u>프로세스의 페이지 테이블 코드 영역이 같은 곳을 가리키게</u></p>
<h3 id="세그멘테이션-Segmentation"><a href="#세그멘테이션-Segmentation" class="headerlink" title="세그멘테이션 Segmentation"></a>세그멘테이션 Segmentation</h3><img src="/2019/02/26/operating-system21/image1.png" alt="세그먼트에서 주소변환" title="세그먼트에서 주소변환">
<p>페이지는 일정크기로 잘랐다.<br><u>세그멘테이션은 프로세스를 논리적 내용(=세그멘트)으로 잘라서 메모리에 배치!</u><br>코끼리를 자를때 페이지는 같은 크기로 자르지만 세그멘테이션은 논리적 크기(얼굴,몸통,꼬리)로 자른다.</p>
<p>프로세스는 세그멘테이션의 집합니다!. 프로세스는 코드 데이터 스택 세개의 뭉치가 존재한다. 하나의 프로세스는 세개의 프로세스의 집합이다! 일반적으로 세그먼트들의 크기는 다르다.</p>
<p>백킹스터어에 프로세스가 있을 때 메인메모리에 올리기 위해 세그먼트로 나누고 메모리로 올린다.(역시나 비연속적)<br>CPU를 속이기 위해 역시나 세그먼트 테이블을 만든다. 그리고 CPU가 낸 세그먼트 번호, 변위이고 세그먼트 테이블의 인덱스에 속한값+변위로 실제 주소를 알 수 있다. 또한 세그먼트 테이블에는 1차원 배열형태인 페이지 테이블과 다르게 base, limit로 즉 2차원배열형태로 구성된다. 만약 CPU가 낸 d의 값이 limit보다 클 경우 CPU로 인터럽트를 보내게 된다.</p>
<h4 id="논리주소-Logical-address"><a href="#논리주소-Logical-address" class="headerlink" title="논리주소 (Logical address)"></a>논리주소 (Logical address)</h4><p>CPU 가 내는 주소는 segment 번호(s) + 변위(d)</p>
<h4 id="주소변환-논리주소-→-물리주소-Physical-address"><a href="#주소변환-논리주소-→-물리주소-Physical-address" class="headerlink" title="주소변환: 논리주소 → 물리주소 (Physical address)"></a>주소변환: 논리주소 → 물리주소 (Physical address)</h4><p>세그멘트 테이블 내용: base 그리고 limit<br>세그멘트 번호(s)는 세그멘트 테이블 인덱스 값<br>s 에 해당되는 테이블 내용으로 시작 위치 및 한계값 파악<br>한계(limit)를 넘어서면 segment violation 예외 상황 처리</p>
<h2 id="물리주소-base-s-d"><a href="#물리주소-base-s-d" class="headerlink" title="물리주소 = base[s] + d"></a>물리주소 = base[s] + d</h2><h3 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h3><p>Limit / Base<br>1000 / 1400<br>400  / 6300<br>400  / 4300<br>1100 / 3200<br>1100 / 3200<br>1000 / 4700</p>
<ol>
<li><code>논리주소 (2,100) 는 물리주소 무엇인가?</code> 4400</li>
<li><code>논리주소 (1, 500) 은 물리주소?</code> 6800이라하면 틀렸다!!! 해당주소 없음!!(limit를 넘는다)</li>
</ol>
<h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h3><p>운영체제를 처음배울땐 프로세스들이 순차적으로 들어가는지 알았다. 그러다 보니 메모리 낭비가 심해서 자르기로 함.<br>그래서 일정크기로 자르는 페이징 기법이 나왔고 논리적 크기로 자르는 세그멘테이션이 나왔다.<br>페이징을 사용하는 방법이 더 일반적이다.</p>
<p>세그멘테이션은 보호와 공유측면에서 페이징보다 낫다.<br><code>왜 그럴까?</code> : 모든 주소는 세그멘트 테이블을 경유하므로, 세그멘트 테이블 엔트리마다 r, w, x 비트 두어 해당 세그멘트에 대한 접근 제어 가능<br><code>뭐야 페이지 뭐가다른데?</code> : 페이지 단위로 자르면 일정한 크기이기 때문에 코드,데이터가 섞이는 부분이 생길 수 있다. 즉 안심,등심이 섞인 부분이 생겨 r로만 줄지  rw로 줄지 논란이 생길 수 있다.</p>
<h3 id="그러나-대부분의-운영체제는-페이징을-쓴다"><a href="#그러나-대부분의-운영체제는-페이징을-쓴다" class="headerlink" title="그러나 대부분의 운영체제는 페이징을 쓴다"></a>그러나 대부분의 운영체제는 페이징을 쓴다</h3><p><code>왜?</code> 그건 다음포스팅에서..</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;내부단편화-페이지-테이블&quot;&gt;&lt;a href=&quot;#내부단편화-페이지-테이블&quot; class=&quot;headerlink&quot; title=&quot;내부단편화, 페이지 테이블&quot;&gt;&lt;/a&gt;내부단편화, 페이지 테이블&lt;/h3&gt;&lt;p&gt;파워를 키면 OS가 메인 메모리로 올라간다.
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>20.페이지 테이블, 주소변환/페이징에서의 주소변환</title>
    <link href="http://KKimSangHeon.github.io/2019/02/26/operating-system20/"/>
    <id>http://KKimSangHeon.github.io/2019/02/26/operating-system20/</id>
    <published>2019-02-25T23:57:15.000Z</published>
    <updated>2019-02-26T00:02:13.052Z</updated>
    
    <content type="html"><![CDATA[<p>페이지 테이블, 주소변환</p>
<h2 id="주소변환"><a href="#주소변환" class="headerlink" title="주소변환?"></a>주소변환?</h2><p>컴퓨터에는 CPU, 메모리, 보조기억장치가 존재.<br>파워를 켜면 메모리 안에 OS가 들어오고 요청하는 대로 프로그램들이 메모리로 들어온다.<br>프로그램들이 연속으로 들어갈 경우 외부단편화 문제가 발생한다. 그래서 메모리를 프레임 단위로 쪼개서 넣는다. 프로세스들은 흩어져서 프레임 단위로 저장된다. 이것이 가능한것은 CPU와 메모리 사이에 페이지테이블이 존재하기 때문에..<br>즉 CPU는 페이지 테이블로 인해 CPU는 프로세스가 연속한 상태로 착각한다.<br>메모리 빈곳(hole)을 다합치면 메모리가 큰데 프로세스를 넣을 수 없는것을 외부단편화라 함</p>
<h3 id="메모리-낭비를-위한기술"><a href="#메모리-낭비를-위한기술" class="headerlink" title="메모리 낭비를 위한기술"></a>메모리 낭비를 위한기술</h3><p>다이나믹 로딩<br>링킹<br>스와핑</p>
<h3 id="페이징-메모리-낭비를-줄이기-위한기술"><a href="#페이징-메모리-낭비를-줄이기-위한기술" class="headerlink" title="페이징(메모리 낭비를 줄이기 위한기술)"></a>페이징(메모리 낭비를 줄이기 위한기술)</h3><p>메모리를 꼭 연속된 공간에 넣을 필요는 없다. 프로그램을 프레임 단위로 잘라서 메모리에 흩어져서 넣는다.<br>프로세스는 페이지(page)의 집합<br>메모리는 프레임(frame)의 집합</p>
<p><code>페이지를 프레임에 할당</code><br>MMU 내의 재배치 레지스터 값을 바꿈으로서<br>CPU 는 프로세스가 연속된 메모리 공간에 위치한다고 착각<br>MMU 는 페이지 테이블 (page table) 이 된다.</p>
<p><code>예제</code><br>Page size = 4 bytes<br>Page Table: 5 6 1 2<br><u>논리주소 13 번지는 물리주소 몇 번지?</u></p>
<p>CPU가 내는 주소는 13이다. 이진수로 나타내면 1101(2) 인데 앞 두숫자 11이 p 이고 01이 d라고 볼 수 있다. (p는 페이지 사이즈 크기만큼 크기를 할당. 페이지 크기가 4이므로 두자리가 된다.) 페이지 테이블의 3번째 인덱스에 저장된 2가 f가 되고 d는 그대로 온다. 즉 10 01이 피지컬 어드레스가 된다. 즉 물리주소는 9번지가 된다. 9번지는 두번째 프레임에서 01만큼 떨어져있다고 할 수 있다.</p>
<p><code>예제</code><br>Page Size = 1KB<br>Page Table: 1 2 5 4 8 3 0 6<br><u>논리주소 3000번지는 물리주소 몇 번지?</u></p>
<p>1kb는 10bit. 3000은 101110111000(2) 이다. 페이지 사이즈는 2^10 이므로 10bit로 표현 가능하다. 즉 d는 뒤의 10자리(1110111000(2)) 이고 p는 앞에 두개(10(2))이다. 즉 2번째 인덱스인 101(2) 그리고 d를 붙인 1110111000 (2) 가 물리주소이다.</p>
<p><u>물리주소 0x1A53 번지는 논리주소 몇 번지?</u></p>
<p>1 1010 0101 0011 인데 뒤의 10개가 d 나머지 앞에 110이 프레임 넘버. 6은 페이지 테이블의 7번지에 저장되어 있으므로<br>111과  10 0101 0011 을 붙인것이 논리주소이다.</p>
<h3 id="내부단편화"><a href="#내부단편화" class="headerlink" title="내부단편화"></a>내부단편화</h3><p>페이지 사이즈가 4바이트일때 15바이트프로세스를 올리기 위해서는 페이지 4개가 필요하다.<br>4/4/4/3만큼 할당이 되는데 마지막 페이지의 1바이트가 비게된다. 이는 아무도 쓸수 없으므로 내부단편화 발생.</p>
<p>외부단편화를 페이지로 없앴는데 내부단편화가 발생한다. 내부단편화는 외부단편화에 비해 크기가 미미하므로 큰 문제가 되지 않는다.</p>
<p>페이지 테이블은 CPU안에 넣을 수 있다. 그러면 레지스터로 만들수도있다. 또는 메모리에 넣을 수도 있다.<br>‘CPU에 넣는경우’:페이지 테이블을 CPU레지스터로 만드면 주소변환이 정말 빠르다. 단점은 CPU에 넣어야 하므로 많은 데이터를 넣을 수없다.<br><code>메모리 안에 넣을 경우</code>: 페이지 테이블이 커도 문제가 되지 않는다. 그러나 변환속도가 느리다. 페이지테이블을 읽기위해 메모리를 한번읽고 또 한번 메모리를 읽어야 하므로 2배로 느려진다.</p>
<p><code>캐쉬메모리에 페이지 테이블을 넣는경우(실제로 사용됨)</code>: 페이지 테이블을 넣는 캐쉬메모리를 TLB (Translation Look-aside Buffer) 라 한다. 메모리에 넣는것보다 빠르고 CPU에 넣는것보다 많이 넣을 수 있다. 캐쉬메모리와 유사한 원리로 동작</p>
<p>CPU에서 낸 주소를 읽어오는덱 걸리는 시간을 유효메모리 접근시간이라 한다.<br>Tm(메모리 읽는속도) = 100ns, Tb(버퍼 읽는속도) = 20ns, hit ratio = 80%<br>CPU가 낸 주소가 페이지테이블 안에 존재할 경우 hit라고 한다,<br>유효 메모리 접근시간 : hit확률 <em>  (Tb+Tm) + hit되지 않을 확률 </em> (Tb+Tm)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;페이지 테이블, 주소변환&lt;/p&gt;
&lt;h2 id=&quot;주소변환&quot;&gt;&lt;a href=&quot;#주소변환&quot; class=&quot;headerlink&quot; title=&quot;주소변환?&quot;&gt;&lt;/a&gt;주소변환?&lt;/h2&gt;&lt;p&gt;컴퓨터에는 CPU, 메모리, 보조기억장치가 존재.&lt;br&gt;파워를 켜면 메
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>19.최초적합, 최적적합, 최악적합</title>
    <link href="http://KKimSangHeon.github.io/2019/02/25/operating-system19/"/>
    <id>http://KKimSangHeon.github.io/2019/02/25/operating-system19/</id>
    <published>2019-02-24T23:30:26.000Z</published>
    <updated>2019-02-25T13:54:57.309Z</updated>
    
    <content type="html"><![CDATA[<p>메모리 낭비를 줄이기 위한 기법<br>1.Dynamic Loading<br>2.Dynamic Linking<br>3.Swapping</p>
<h3 id="연속-메모리-할당"><a href="#연속-메모리-할당" class="headerlink" title="연속 메모리 할당"></a>연속 메모리 할당</h3><p>최초의 컴퓨터는 프로세스가 하나만 올라갔다. 그이 후 O/S가 올라가게 되었다.<br>하나의 운영체제에 여러개의 프로세스가 도는것이 다중프로그래밍. 즉 멀티프로그래밍이라 한다.<br>부팅을 하면 메모리가 비어있다가 OS가 자리잡게된다. OS이외에 부분은 비어있는데 이를 <u>big single hole 또는 hole</u>이라고 한다.</p>
<p><code>부팅 직후 메모리 상태</code>: O/S + big single hole<br><code>프로세스 생성 &amp; 종료 반복</code> : scattered holes(프로세스가 생성됐다가 없어지고 하다보면 곳곳에 hole 발생하게 된다.)</p>
<p>Hole 들이 불연속하게 흩어져 있기 때문에 프로세스 적재 불가한 경우가 생기는데 이를 <u>외부단편화(external fragmentation)</u>라 한다.</p>
<p><code>First-fit (최초 적합)</code>  : 메모리를 뒤져서 가장 처음에 들어갈 수 있는곳에 들어가는것.<br><code>Best-fit (최적 적합)</code> : 사이즈가 제일 비슷한놈에 들어가는것.<br><code>Worst-fit (최악 적합)</code> : 크기가 제일 안맞는놈한테 넣는것.(물론 큰것중에)</p>
<h4 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h4><p>Hole: 100 /500 / 600 / 300 / 200 KB<br>프로세스: 212 417 112 426 KB</p>
<p><code>First-fit (최초 적합)</code>의 경우 : 212는 500에 들어간다. 417은 600에 들어감. 112는 300에 들어감. 426은 못들어감.</p>
<p><code>Best-fit (최적 적합)</code> : 212는 300에 들어간다 . 417은 500 112는 200 .426은 500</p>
<p><code>Worst-fit (최악 적합)</code> : 212는 600에. 417은 500에. 112는 300에. 426은 못들어간다.</p>
<p>속도면에서는 First-fit가 빠르다.<br>나머지는 다 봐야하기 때문에 느리다.</p>
<p>이용률의 경우 first-fit, best-fit이 높은 이용율이 보임.<br>외부 단편화로 인한 메모리 낭비가 전체의 1/3 수준 (사용 불가)</p>
<p><code>이를 해결하기 위한 방법</code> : Compaction(hole들을 한곳으로 모으는것. 최적 알고리즘 없음, 고부담)<br>즉 OS가 지켜보다가 hole들을 한곳으로 모은다.(계산 부담)</p>
<p><code>다른방법은 없을까?</code> 페이징</p>
<h3 id="페이징"><a href="#페이징" class="headerlink" title="페이징"></a>페이징</h3><p>프로그램을 연속적으로 넣지 않고 일정한 단위로 잘라서 넣는다 이를 페이지라고 한다.(잘린것들을 말함).<br>메모리를 자른것을 프레임이라 함.</p>
<p>프로세스를 자른것을 페이지라 하고 메모리를 자른것을 프레임이라 한다.<br>페이지사이즈와 프레임사이즈 는 같으나 용어와 사용되는 위치가 다른것.</p>
<p>잘라서도 돌게하기 위해서는 CPU를 속여야한다. MMU 내의 Relocation Resgister을 여러개 둔다!<br>이러한 목적으로 사용되는 MMU를 페이지 테이블 (page table) 이라 한다.</p>
<p>이를 통해 외부단편화를 해결!</p>
<h3 id="페이징에서의-주소변환"><a href="#페이징에서의-주소변환" class="headerlink" title="페이징에서의 주소변환"></a>페이징에서의 주소변환</h3><img src="/2019/02/25/operating-system19/image1.png" alt="페이징에서의 주소변환" title="페이징에서의 주소변환">
<p>논리주소를 물리주소를 변환하는것을 주소변환이라한다.<br>CPU가 내는 주소가 m bit라 하자. 그럴 때 m-n은 페이지의 주소이고 n비트는 오프셋 또는 변위라고 한다.<br>즉 n은 페이지의 사이즈에 의존적이다. 페이지의 사이즈가 16일때 n은 4로 표현가능</p>
<p>메인메모리는 프레임 단위로 나뉘어져있다. 프레임의 크기는 페이지의 사이즈와 동일하다,<br>아까 말했듯 페이지 테이블(여러개의 mmu로 구성된것)은 프로세스가 페이지를 몇개쓰는가이 따라 달라진다.</p>
<p>p가 2라면 페이지 테이블의 두번째를 가르키는 것이고 d가 오프셋을 의미</p>
<p>만약 CPU가 50이라는 주소를 냈다하자. 그럼 110010(2) 이다. 이때 한 페이지가 16바이트라 가정했을 때 뒤의 네 수를 d로 보고 앞에 두개 11을 p로 본다. 즉 3번째 페이지에 저장되어있는 값(8이라 가정하자)에 맞는 프레임을 찾아가고 d를 활용하여 세부적인 값을 알아낸다. 이때는 10000010(2)가 된다,(앞에 네개는 8을 의미 뒤에 네개는 d를 그대로 가져다 쓴것)</p>
<p>정리하면 CPU가 내는 50번지는 10000010 즉 128번지 + d(2) 이므로 130번지를 찾아간다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;메모리 낭비를 줄이기 위한 기법&lt;br&gt;1.Dynamic Loading&lt;br&gt;2.Dynamic Linking&lt;br&gt;3.Swapping&lt;/p&gt;
&lt;h3 id=&quot;연속-메모리-할당&quot;&gt;&lt;a href=&quot;#연속-메모리-할당&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>18.동적적재, 동적연결, 스와핑</title>
    <link href="http://KKimSangHeon.github.io/2019/02/24/operating-system18/"/>
    <id>http://KKimSangHeon.github.io/2019/02/24/operating-system18/</id>
    <published>2019-02-24T02:25:43.000Z</published>
    <updated>2019-02-24T03:24:56.823Z</updated>
    
    <content type="html"><![CDATA[<p>컴퓨터에서 메모리는 CPU 만큼 중요하다.<br>하드디스크에 파일들이 들어있다. 파워를키면 OS가 메인메모리에 올라가고 특정 프로그램을 실행시키면 그 프로그램이 메인메모리로 올라간다. 이 메모리를 어떻게 잘 관리할것인가가 <code>메모리 매니지먼트</code></p>
<h3 id="실행파일을-메모리에-올리기"><a href="#실행파일을-메모리에-올리기" class="headerlink" title="실행파일을 메모리에 올리기"></a>실행파일을 메모리에 올리기</h3><p>src-obj-exe</p>
<p>메모리 몇 번지에?<br>다중 프로그래밍 환경에서는?</p>
<p>항상 똑같은 곳에 올리는것을 보장하지 못함. 그래서 MMU를 활용. CPU가 메모리에 몇번째 주소를 읽겠다 하면 메모리는 CPU로 데이터를 전송해준다. <u>MMU는 특정프로그램이 다른 프로그램으로 접근하지 못하게 해준다.</u> CPU가 메모리에 주소를 전달할 때 MMU를 거치는데 자기영역에 맞는 주소를요청하는지 파악한다.(base, limit 레지스터 활용)<br>MMU는 이뿐만 아니라 <u>Relocation register</u>을 둔다. 가령 A라는 프로그램이 있다고 하자. 개발자는 해당 프로그램이 0번지부터 시작한다고 생각하고 코딩을 했다. 하지만 이는 보장되지 않기 때문에 예측할 수 없다. 실제로는 프로그램이 1000번지에 로드되면 MMU 안에 Relocation register에 1000을 넣는다. 그러면 <u>CPU는 0번지를 요청하지만 MMU를 거치면서 1000이 더해져 실제로 저장되어 있는 1000번지로 접근하게 된다</u>. 즉 CPU를 속이게 된다.<br>그 다음날 A라는 프로그램이 실행되었을 때 5000번지에 실행될 경우 이때는 Relocation register에 5000이 들어가고 CPU는 5000번지에 접근하여 데이터를 읽어올 수 있다.</p>
<p>여기서 CPU가 보내는 주소를 <u>논리주소(logical address)</u> 라 하고 실제로 메인메모리로 들어가는 주소를 <u>물리주소 (physical address)</u>라 한다.</p>
<h3 id="메모리-낭비-방지"><a href="#메모리-낭비-방지" class="headerlink" title="메모리 낭비 방지"></a>메모리 낭비 방지</h3><p>운영체제는 컴퓨터 사용을 쉽게, 효율을 높게 하는것이 목표다.<br>이를 위해 어떤노력을 하는지 알아보자,<br>1.Dynamic Loading<br>2.Dynamic Linking<br>3.Swapping</p>
<p><code>Loading</code> : 프로그램(실행파일)을 메모리로 올리는것.<br><code>Booting</code> : OS를 메모리로 올리는것.</p>
<h4 id="메모리-낭비-방지-기법-Dynamic-Loading"><a href="#메모리-낭비-방지-기법-Dynamic-Loading" class="headerlink" title="메모리 낭비 방지 기법 : Dynamic Loading"></a>메모리 낭비 방지 기법 : Dynamic Loading</h4><p>프로그램을 메모리에 올릴때 오류처리 혹은 크게 생성한 배열 같은것들을 안올리고 오류가 일어나면 올린다.</p>
<p><code>나오게 된 배경</code>:<br>모든 루틴(routine)이 다 사용되는 것은 아니다 (예: 오류처리)<br>모든 데이터(data)가 다 사용되는 것은 아니다 (예: 배열)<br>자바: 모든 클래스가 다 사용되는 것은 아니다</p>
<p><u>즉 프로그램 실행에 반드시 필요한 루틴/데이터만 적재</u><br>현대의 운영체제는 이를 활용. 이전에는 모든것을 올리는 정적 적재(Static loading)를 활용했다.</p>
<h4 id="메모리-낭비-방지-기법-Dynamic-Linking"><a href="#메모리-낭비-방지-기법-Dynamic-Linking" class="headerlink" title="메모리 낭비 방지 기법 : Dynamic Linking"></a>메모리 낭비 방지 기법 : Dynamic Linking</h4><p><u>프로그램을 메인메모리에 올리는데 공통 라이브러리 루틴(library routine)를 메모리에 중복으로 올<br>리는 것은 낭비</u></p>
<p>이메일전송,  파일전송 둘다 네트워크를 사용한다. 즉 둘이 같은 라이브러리를 쓸것이다. 하나로 통 칠수있는경우이다. <u>이 기법은 오직 하나의 라이브러리 루틴만 메모리에 적재한다. 또한 exe파일을 만들때 link를 하지 않고 프로그램 실행 때 link하여 갖다 쓴게 한다. 그리고 다른 애플리케이션 실행 시 이 루틴과 연결(link)된다.</u><br>원래는 link를 exe파일이 만들어지기 전에 한다(정적 연결,Static Linking)</p>
<p>리눅스에서는 공유 라이브러리 (shared library)라 부른다 – Linux<br>윈도우에서는 동적 연결 라이브러리 (Dynamic Linking Library)라 부른다. - Windows</p>
<p>윈도우에서 .DLL파일을 본적이 있을것이다. 리눅스에는 .SO 파일.<br>C:\Windows\System32 에 많다.</p>
<h4 id="메모리-낭비-방지-기법-Swapping"><a href="#메모리-낭비-방지-기법-Swapping" class="headerlink" title="메모리 낭비 방지 기법 : Swapping"></a>메모리 낭비 방지 기법 : Swapping</h4><p><u>메모리에 적재되어 있으나 현재 사용되지 않고 있는 프로세스 이미지를 몰아낸다</u><br>프로그램을 사용하다 화장실에 갈경우 해당 프로그램은 아무것도 하지 않으면서 메모리를 잡아먹게 된다.<br>이 경우 해당 프로세스를 쫒아낸다. 즉 프로세스 이미지를 하드디스크 일부에 몰아낸다. 이는 메모리 활용도 높이기 위해 <u>Backing store (= swap device라고도 함)<u> 로 몰아낸다 한다.<br>Backing store (= swap device라고도 함)의 크기는 대략 메인메모리의 크기 정도면 충분하다.(메인메모리의 내용만 쫒아내는 구역이기 때문에.)</u></u></p>
<p>몰아내는것을 <u>Swap-out</u>라 하고 화장실에서 다시 돌아와 메모리로 다시 올리는것을 <u>Swap-in</u>이라고 한다. 서버는 Backing store 를위한 디스크를 따로 두기도 하며 슈퍼컴퓨터의 경우 Backing store를 하나의 메모리로 두기도 한다.(디스크 접근이 느리기 때문에)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;컴퓨터에서 메모리는 CPU 만큼 중요하다.&lt;br&gt;하드디스크에 파일들이 들어있다. 파워를키면 OS가 메인메모리에 올라가고 특정 프로그램을 실행시키면 그 프로그램이 메인메모리로 올라간다. 이 메모리를 어떻게 잘 관리할것인가가 &lt;code&gt;메모리 매니지
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>17.주기억장치 관리 개요</title>
    <link href="http://KKimSangHeon.github.io/2019/02/23/operating-system17/"/>
    <id>http://KKimSangHeon.github.io/2019/02/23/operating-system17/</id>
    <published>2019-02-23T00:48:52.000Z</published>
    <updated>2019-02-23T15:18:11.112Z</updated>
    
    <content type="html"><![CDATA[<p>CPU / 메모리 / 보조기억장치가 존재.<br>O/S는 프로세스 관리를한다. CPU 관리를 하는데 이를 프로세스 매니지먼트라함.<br>또한 O/S는 메모리 관리 즉 메모리 매니지먼트를 한다.</p>
<p>OS : 하드웨어를 어플리케이션이 활용할 수 있도록 함.<br><code>CPU 자원을 나눠주는 곳</code> : 프로세스 매니지먼트<br><code>메인메모리를 관리하는곳</code> : 메모리 매니지먼트.</p>
<h3 id="메모리-역사"><a href="#메모리-역사" class="headerlink" title="메모리 역사"></a>메모리 역사</h3><p><code>Core memory</code> : 반지모양의 철심에 자성물질을 바르고 전기를 흐르게 한 후 자석이 되게 한 후 메모리로 사용.<br><code>진공관 메모리</code> : 50~60년대 손가락 크기만함. 네다섯개가 한비트를 저장<br><code>트랜지스터 메모리</code> : 손톱만한 크기로 한비트를 저장하는데 네개의 트랜지스터 필. 반도체 소자안에 들어간다.<br><code>집적회로 메모리: SRAM, DRAM</code> : 보통 생각하는 메모리</p>
<h3 id="메모리-용량"><a href="#메모리-용량" class="headerlink" title="메모리 용량"></a>메모리 용량</h3><p>1970년대: 8-bit PC 64KB<br>1980년: 16-bit IBM-PC 640KB &gt; 1MB &gt; 4MB<br>1990년: 수MB &gt; 수십 MB<br>2000년~: 수백 MB &gt; 수 GB</p>
<h2 id="메모리가-지속적으로-커졌다"><a href="#메모리가-지속적으로-커졌다" class="headerlink" title="메모리가 지속적으로 커졌다!!"></a>메모리가 지속적으로 커졌다!!</h2><h3 id="메모리는-언제나-부족하다"><a href="#메모리는-언제나-부족하다" class="headerlink" title="메모리는 언제나 부족하다.."></a>메모리는 언제나 부족하다..</h3><h4 id="이유-프로그램의-변천"><a href="#이유-프로그램의-변천" class="headerlink" title="이유 : 프로그램의 변천"></a>이유 : 프로그램의 변천</h4><p>기계어/어셈블리어 작성<br>C언어<br>자바, 객체지향형 언어 작성<br>숫자 처리 &gt; 문자 처리 &gt; 멀티미디어 순으로 패러다임이 변화함.</p>
<h4 id="메모리-용량-증가-vs-프로그램-크기-증가"><a href="#메모리-용량-증가-vs-프로그램-크기-증가" class="headerlink" title="메모리 용량 증가 vs 프로그램 크기 증가"></a>메모리 용량 증가 vs 프로그램 크기 증가</h4><p>언제나 부족한 메모리 ㅠㅠ</p>
<h4 id="어떻게-메모리를-효과적으로-사용할-수-있을까"><a href="#어떻게-메모리를-효과적으로-사용할-수-있을까" class="headerlink" title="어떻게 메모리를 효과적으로 사용할 수 있을까?"></a>어떻게 메모리를 효과적으로 사용할 수 있을까?</h4><p>메모리 낭비를 없애고 가상메모리와 같은 기법을 활용!</p>
<h3 id="메모리-구조"><a href="#메모리-구조" class="headerlink" title="메모리 구조?"></a>메모리 구조?</h3><img src="/2019/02/23/operating-system17/image1.png" alt="CPU와 메모리" title="CPU와 메모리">
<p>CPU가 몇번지를 읽겠다고 주소를 메모리로 보낸다. 그러면 거기에 저장되어있는 정보를 메모리가 CPU에게 제공한다.<br>또한 데이터 저장을 위해서 CPU가 데이터를 전송하기도 한다<br>메모리는 주소(Address) + 데이터(Data)로 구성된다.</p>
<h3 id="프로그램은-어떻게-개발될까"><a href="#프로그램은-어떻게-개발될까" class="headerlink" title="프로그램은 어떻게 개발될까?"></a>프로그램은 어떻게 개발될까?</h3><p>컴파일러, 어셈블러, 링커, 로더에 대해 알아보자<br>프로그램이 실행되기까진 아래의 순서를 따른다.<br><u>main.c (고수준언어)-&gt;main.o(기계어) -&gt; link -&gt; 메인메모리로 올림</u><br>첫번째 화살표 컴파일러가 진행<br>두번째 화살표 링커가 진행<br>세번째 화살표 로더가 진행</p>
<p><code>원천파일 (Source file)</code>: 고수준언어 또는 어셈블리언어<br><code>목적파일 (Object file)</code>: 컴파일 또는 어셈블 결과<br><code>실행파일 (Executable file)</code>: 링크 결과<br>프로그램 실행을 위해 필요한것들: code + data + stack</p>
<p>실행파일을 메모리에 올리기 위해 메모리 몇번지에 올려야되지?(로더가 해결해준다)</p>
<h3 id="MMU의-사용"><a href="#MMU의-사용" class="headerlink" title="MMU의 사용"></a>MMU의 사용</h3><p>MMU 안에 base limit가 있다했는데 재배치 레지스터가 있다. 프로그램을 개발할 때 0번지에 들어간다고 생각했는데 실제로는 500번지에 들어간다면 Relocation register에 500을 넣어줘 CPU가 봤을땐 0번지 이지만 500을 더한 500번지에 저장되게 한다. 즉 CPU는 얘가 0번지에 있는줄 안다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CPU / 메모리 / 보조기억장치가 존재.&lt;br&gt;O/S는 프로세스 관리를한다. CPU 관리를 하는데 이를 프로세스 매니지먼트라함.&lt;br&gt;또한 O/S는 메모리 관리 즉 메모리 매니지먼트를 한다.&lt;/p&gt;
&lt;p&gt;OS : 하드웨어를 어플리케이션이 활용할
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>16.프로세스 동기화의 다른 도구인 모니터 사용</title>
    <link href="http://KKimSangHeon.github.io/2019/02/22/operating-system16/"/>
    <id>http://KKimSangHeon.github.io/2019/02/22/operating-system16/</id>
    <published>2019-02-22T13:51:04.000Z</published>
    <updated>2019-02-23T15:18:37.264Z</updated>
    
    <content type="html"><![CDATA[<h3 id="모니터"><a href="#모니터" class="headerlink" title="모니터"></a>모니터</h3><p>동기화 도구로 세마포어를 배웠다. 세마포어는 조금 오래된 동기화 도구인데 지금은 모니터를 많이쓴다. 주로 자바에서 많이쓴다.<br>즉 세마포 이후 프로세스 동기화 도구 이며 세마포 보다 고수준 개념</p>
<h3 id="세마포어의-구조"><a href="#세마포어의-구조" class="headerlink" title="세마포어의 구조"></a>세마포어의 구조</h3><p>정수변수, 큐, P(acquire)동작, V(release)동작</p>
<h3 id="모니터의-구조"><a href="#모니터의-구조" class="headerlink" title="모니터의 구조"></a>모니터의 구조</h3><p>공유자원 , 공유자원 접근함수 , 2개의 큐</p>
<p>2개의 큐?<br>하나는 배타동기. 즉 한쓰레드만 공유자원에 접근할 수 있도록 하는 큐<br>하나는 조건동기를 위한 큐</p>
<p>베타동기를 위한큐 | 다양한 함수 | 조건동기를 위한큐</p>
<img src="/2019/02/22/operating-system16/image1.png" alt="모니터의구조" title="모니터의구조">
<p>1.쓰레드 한개만 공유자원 접근 함수에 접근할 수 있다. 즉 들어오고 싶어하는 애들은 베타동기를 위한 큐에서 기다려야 한다.<br>2.진입 쓰레드가 조건을 만족하면(wait을 호출하여) 조건동기 큐로 들어가는데 이땐 블록된다. 그러면 새 쓰레드가 진입가능<br>3.새 쓰레드는 조건동기로 블록된 쓰레드를 notify를 호출하여 깨울 수 있다<br>4.깨워진 쓰레드는 현재 쓰레드가 나가면 재진입할 수 있다.<br>(하나의 쓰레드만 접근 가능하므로)</p>
<p>세마포어에 비해 복잡하나 사용하기 편리하다.</p>
<p><code>배타동기</code>: synchronized 키워드 사용하여 지정<br><code>조건동기</code>: wait(), notify(), notifyAll() 메소드 사용</p>
<p>베타동기: 하나만 특정함수에 들어갈 수 있다. 자바에서는 함수 정의 앞에 synchronized 키워드를 붙인다.<br>조건동기는 wait 함수를 호출하여 조건동기를 위한 큐에 갇히게 할 수 있고 notify(하나깨우기) 혹은 notify all(전체깨우기) 을 호출하여 깨울 수 도 있다.</p>
<h4 id="상호배제-용도로-사용"><a href="#상호배제-용도로-사용" class="headerlink" title="상호배제 용도로 사용"></a>상호배제 용도로 사용</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankAccount</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> balance;</div><div class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">int</span> amt)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> temp = balance + amt;</div><div class="line">		System.out.print(<span class="string">"+"</span>);</div><div class="line">		balance = temp;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> amt)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> temp = balance - amt;</div><div class="line">		System.out.print(<span class="string">"-"</span>);</div><div class="line">		balance = temp;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> balance;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>위처럼 하면 동기화가 가능하다. 세마포어 보다 쉽다!</p>
<h4 id="Ordering-용도로-사용"><a href="#Ordering-용도로-사용" class="headerlink" title="Ordering 용도로 사용"></a>Ordering 용도로 사용</h4><p>P1은 공백/ S1/notify();<br>P2는 wait/S2/공백</p>
<p>P1이 입금, P2가 출금 로직이라고 가정하고 생각해보자.</p>
<p>P1,P2 반복해서 출력되게 하려면 boolean 변수 하나를 둬서 처리<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">int</span> balacne = <span class="number">0</span>;</div><div class="line"><span class="keyword">boolean</span> p_turn;</div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">int</span> amt)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> temp = balance + amt;</div><div class="line">	balance = temp;</div><div class="line">	notify();</div><div class="line">	p_turn = <span class="keyword">false</span>;</div><div class="line">	wait();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> amt)</span> </span>&#123;</div><div class="line">	<span class="keyword">while</span>(p_turn)</div><div class="line">		wait();</div><div class="line"></div><div class="line">	<span class="keyword">int</span> temp = balance - amt;</div><div class="line">	balance = temp;</div><div class="line">	p_turn = <span class="keyword">true</span>;</div><div class="line">	notify();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">---</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span>[] buf;</div><div class="line">	<span class="keyword">int</span> size, count, in, out;</div><div class="line">	Buffer(<span class="keyword">int</span> size) &#123;</div><div class="line">		buf = <span class="keyword">new</span> <span class="keyword">int</span>[size];</div><div class="line">		<span class="keyword">this</span>.size = size;</div><div class="line">		count = in = out = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> item)</span> </span>&#123;</div><div class="line">	<span class="keyword">while</span> (count == size)</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		wait();</div><div class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</div><div class="line">	buf[in] = item;</div><div class="line">	in = (in+<span class="number">1</span>)%size;</div><div class="line">	notify();</div><div class="line">	count++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">while</span> (count == <span class="number">0</span>)</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		wait();</div><div class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</div><div class="line">	<span class="keyword">int</span> item = buf[out];</div><div class="line">	out = (out+<span class="number">1</span>)%size;</div><div class="line">	count--;</div><div class="line">	notify();</div><div class="line">	<span class="keyword">return</span> item;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">---</div><div class="line">교착상태에 대한 고려는 되지 않음.</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chopstick</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> inUse = <span class="keyword">false</span>;</div><div class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">		<span class="keyword">while</span> (inUse)</div><div class="line">		wait();</div><div class="line">		inUse = <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</div><div class="line">		inUse = <span class="keyword">false</span>;</div><div class="line">		notify();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;모니터&quot;&gt;&lt;a href=&quot;#모니터&quot; class=&quot;headerlink&quot; title=&quot;모니터&quot;&gt;&lt;/a&gt;모니터&lt;/h3&gt;&lt;p&gt;동기화 도구로 세마포어를 배웠다. 세마포어는 조금 오래된 동기화 도구인데 지금은 모니터를 많이쓴다. 주로 자바에서 많이
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>15.교착상태 필요조건, 교착상태의 해결법</title>
    <link href="http://KKimSangHeon.github.io/2019/02/22/operating-system15/"/>
    <id>http://KKimSangHeon.github.io/2019/02/22/operating-system15/</id>
    <published>2019-02-22T13:50:56.000Z</published>
    <updated>2019-02-22T13:56:55.165Z</updated>
    
    <content type="html"><![CDATA[<h3 id="교착상태"><a href="#교착상태" class="headerlink" title="교착상태"></a>교착상태</h3><p>발생이유 : 프로세스들이 자원을 많이 필요로 한다. 하지만 누가 사용하고 있으면 기다려야한다.<br>이러한 형태가 원을 이루면 교착상태가 발생한다.</p>
<h3 id="교창상태-필요조건"><a href="#교창상태-필요조건" class="headerlink" title="교창상태 필요조건."></a>교창상태 필요조건.</h3><p>Mutual exclusion (상호배타) : 자원을 서로 공유하지 못함<br>Hold and wait (보유 및 대기) : 하나를 잡고있으면서 다른것을 원함<br>No Preemption (비선점) : 다른것을 강제로 뺏어오지 못함.<br>Circular wait (환형대기) : 자원을 갖고있으면서 기다리는데 원형형태</p>
<p><u>네가지가 만족되면 일어날 수 있다. 반드시 일어나는것은 아님</u></p>
<h3 id="교착상태-처리"><a href="#교착상태-처리" class="headerlink" title="교착상태 처리"></a>교착상태 처리</h3><p>교착상태 처리는 크게 네가지가 있다.<br>1.교착상태 방지<br>Deadlock Prevention</p>
<p>2.교착상태 회피<br>Deadlock Avoidance</p>
<p>3.교착상태 검출 및 복구<br>Deadlock Detection &amp; Recovery</p>
<p>4.교착상태 무시<br>Don’t Care</p>
<h3 id="1-교착상태-방지"><a href="#1-교착상태-방지" class="headerlink" title="1.교착상태 방지"></a>1.교착상태 방지</h3><p><code>설명</code> : 필요조건 중 네가지 조건중에 하나라도 깨도록 하는것.<br><code>상호베타 조건을 깨기</code>: 이를 위해 공유가 가능하게 해야한다. 현실적으로 어렵다. 읽어내기만 하는 파일 같은 경우에는 가능하지만 일반적으로는 부적절</p>
<p><code>보유 및 대기 깨기</code>: 동시에 젓가락 갖게하기. 왼쪽 젓가락 잡고 오른쪽 젓가락 잡을라 했는데 누가 오른쪽을 갖고있으면 왼쪽도 놓기. 이는 굶어 죽을 확률이 생김. 자원의 활용도가 떨어진다. 상호베타 조건깨는것보다는 쉽다.<br>자원을 가지고 있으면서 다른 자원을 기다리지 않게 즉 자원이 없는 상태에서 모든 자원 대기; 일부 자원만 가용하면 보유 자원을 모두 놓아주기<br>단점: 자원 활용률 저하, 기아 (starvation)</p>
<p><code>비선점 깨기</code>: CPU의 경우에는 일부 가능하겠으나 일반적으로 불가능</p>
<p><code>환형대기 깨기</code> : 자원에다 번호 부여하고 자원의 오름차순으로 자원을 요청토록 함. 즉 R1,R2,R3 가 있을때 R1, R2 요청/ R2,R3 요청/ R1,R3요청처럼 구현. 자원의 활용도가 떨어진다.</p>
<p>보통 보유 및 대기 깨기 혹은 환형대기 깨기를 사용한다.</p>
<h3 id="2-교착상태-회피"><a href="#2-교착상태-회피" class="headerlink" title="2.교착상태 회피"></a>2.교착상태 회피</h3><p><code>설명</code> : 자원을 할당할 때 위험한 할당이 되지 않도록 하는것.<br>자원을 프로세스 한테 골고루 나눠주는것을 OS가 한다. 이를 리소스 매지저 / 올로케이터라 한다.<br>교착상태는 자원요청에 대한 잘못된 승인에 기인한다고 본다.</p>
<p>불안전한 할당 (Unsafe allocation)<br>운영체제는 자원을 할당할 때 불안전 할당 되지 않도록<br>불안전 할당 → 교착상태 유발<br>대출전문 은행과 유사: Banker’s Algorithm</p>
<h3 id="3-교착상태-검출-및-복구"><a href="#3-교착상태-검출-및-복구" class="headerlink" title="3.교착상태 검출 및 복구"></a>3.교착상태 검출 및 복구</h3><p><code>설명</code> : 프로세스가 필요한 대로 자원을 나눠주고 데드락이 발생하면 OS의 프로세스 복구.<br>교착상태가 일어나는 것을 허용 그리고 주기적 검사진행. 주기적 검사는 이를 하기 위한 오버헤드가 크다.<br>교착상태 발생 시 복구하기위해 주기적으로 이전의 상태를 기억하고 있어야 한다.<br>이를 위해 한 프로세스를 강제로 종료시키거나 혹은 자원을 선점하여 일부 프로세스에게 할당.</p>
<h3 id="4-교착상태-무시"><a href="#4-교착상태-무시" class="headerlink" title="4. 교착상태 무시"></a>4. 교착상태 무시</h3><p><code>설명</code> : 교착상태는 실제로 잘 일어나지 않으므로 그냥 무시해버린다.<br>교착상태 발생 시 재시동.</p>
<p>컴퓨터에서 가장 중요한것은 메모리 관리이다. 이를 프로세스 매니지먼트 부서가 하는데 이는 CPU 스케줄링 부서, 프로세스 싱크로나이즈 부서로 구성된다. 싱크로나이즈에서는 데드락관리또한 중요.</p>
<p>메인메모리 관리가 메모리 매니지 부서가 있다. 다음부터 공부한다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;교착상태&quot;&gt;&lt;a href=&quot;#교착상태&quot; class=&quot;headerlink&quot; title=&quot;교착상태&quot;&gt;&lt;/a&gt;교착상태&lt;/h3&gt;&lt;p&gt;발생이유 : 프로세스들이 자원을 많이 필요로 한다. 하지만 누가 사용하고 있으면 기다려야한다.&lt;br&gt;이러한 형태
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>14.읽기-쓰기 문제, 식사하는 철학자 문제</title>
    <link href="http://KKimSangHeon.github.io/2019/02/22/operating-system14/"/>
    <id>http://KKimSangHeon.github.io/2019/02/22/operating-system14/</id>
    <published>2019-02-22T13:50:49.000Z</published>
    <updated>2019-02-22T13:53:18.540Z</updated>
    
    <content type="html"><![CDATA[<p>읽기-쓰기 문제, 식사하는 철학자 문제</p>
<h3 id="Reader-amp-Writer"><a href="#Reader-amp-Writer" class="headerlink" title="Reader &amp; Writer"></a>Reader &amp; Writer</h3><p>DB 읽기만 하는 프로세스 DB를 바꾸는 프로세스</p>
<p>A가 DB를 읽고 있을 때 B가 읽을 수 있다.<br>즉 한 프로세스가 DB를 읽을 때 다른 프로세스도 읽을 수 있게 허용해줘야 한다.</p>
<p>The first R/W problem (readers-preference)<br>리더가 있으면 라이터가 미뤄지는것</p>
<p>The second R/W problem (writers-preference)<br>라이터가 먼저 우선순위가 주어지는것</p>
<p>The Third R/W problem<br>아무한테도 주지 않는것</p>
<p><code>정리</code> : 즉 리더가 들어왔는데 라이터가 들어오려면 블록되어야 하고<br>라이터가 들어왔는데 리더가 들어오려면 블록되어야 하고<br>리더가 들어와있는데 리더가 들어오면 허용해야한다</p>
<h3 id="Dining-Philosopher-Problem"><a href="#Dining-Philosopher-Problem" class="headerlink" title="Dining Philosopher Problem"></a>Dining Philosopher Problem</h3><p><code>다음 프로그램 설명</code><br>철학자 5명이 둥근탁상에 앉아있다. 젓가락은 5개뿐. 즉 자신의 왼쪽 오른쪽에 젓가락이 위치.<br>젓가락을 세마포어로 만들고 초기화를 1로한다.<br>무한루프를 돌면서 왼쪽젓가락, 오른쪽 젓가락을 acquire 하고. 먹고 다시 왼쪽 오른쪽 젓가락을 release한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> id; <span class="comment">// philosopher id</span></div><div class="line">	Semaphore lstick, rstick; <span class="comment">// left, right chopsticks</span></div><div class="line">	Philosopher(<span class="keyword">int</span> id, Semaphore lstick, Semaphore rstick) &#123;</div><div class="line">		<span class="keyword">this</span>.id = id;</div><div class="line">		<span class="keyword">this</span>.lstick = lstick;</div><div class="line">		<span class="keyword">this</span>.rstick = rstick;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">				lstick.acquire();</div><div class="line">				rstick.acquire();</div><div class="line">				eating();</div><div class="line">				lstick.release();</div><div class="line">				rstick.release();</div><div class="line">				thinking();</div><div class="line">			&#125;</div><div class="line">		&#125;<span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">eating</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"["</span> + id + <span class="string">"] eating"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"["</span> + id + <span class="string">"] thinking"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">5</span>; <span class="comment">// number of philosphers &amp; chopsticks</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> i;</div><div class="line">		<span class="comment">/* chopsticks */</span></div><div class="line">		Semaphore[] stick = <span class="keyword">new</span> Semaphore[num];</div><div class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;num; i++)</div><div class="line">			stick[i] = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</div><div class="line"></div><div class="line">		<span class="comment">/* philosophers */</span></div><div class="line">		Philosopher[] phil = <span class="keyword">new</span> Philosopher[num];</div><div class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;num; i++)</div><div class="line">			phil[i] = <span class="keyword">new</span> Philosopher(i, stick[i], stick[(i+<span class="number">1</span>)%num]);</div><div class="line"></div><div class="line">		<span class="comment">/* let philosophers eat and think */</span></div><div class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;num; i++)</div><div class="line">			phil[i].start();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>위의 프로그램은 쭉 가다가 정지된다. 그 이유는 <u>기아상태</u> 유발<br>모든사람이 각자의 왼쪽 젓가락을 들었을 때 해당상황이 발생<br>이를 <u>교착상태</u>라 한다.</p>
<p>운영체제에서 중요한것은 프로세스 관리. 이중 중요한것이 CPU 스케줄링, 동기화 문제이다.<br>동기화에서 중요한건 크리티컬 섹션문제, 효율성 증대 즉 ordering 인데 ordering를 잘못하면 <u>교착상태(Deadlock)</u>에 빠지게 된다.</p>
<h3 id="교착상태-Deadlocks"><a href="#교착상태-Deadlocks" class="headerlink" title="교착상태(Deadlocks)"></a>교착상태(Deadlocks)</h3><p>프로세스가 실행되기 위해서는 하드웨어 자원이 필요하다. 이를 리소스 즉 자원이라 한다. 자원을 사용하는 애플리케이션 즉 프로세스가 있고 중간에 OS가 있다. OS는 애플리케이션한테 자원을 잘 나눠줘야 한다. 자원은 한정되어 있는데 이를 사용하고자 하는 프로세스는 많다. 여기서 잘 나눠주지 못하면 교착상태가 발생한다.</p>
<p>어떤 자원은 갖고 있으나 다른 자원은 갖지 못할 때 (e.g., 다른 프로세스가 사용 중) 대기해야 한다.<br>다른 프로세스 역시 다른 자원을 가지려고 대기할 때 교착상태 가능성 발생</p>
<p>교착상태는 어떤자원을 갖고있을 때 다른 자원을 갖고자 할 때 발생</p>
<h3 id="교착상태-필요-조건-Necessary-Conditions"><a href="#교착상태-필요-조건-Necessary-Conditions" class="headerlink" title="교착상태 필요 조건 (Necessary Conditions)"></a>교착상태 필요 조건 (Necessary Conditions)</h3><p>Mutual exclusion (상호배타) : 리소스가 상호 배타적이다. 즉 한프로세스가 A를 쓰고 있다면 다른 프로세스는 A를 쓰지 못한다.<br>Hold and wait (보유 및 대기) : 왼쪽 젓가락 잡고있으면서 오른쪽 젓가락을 기다리는것.<br>No Preemption (비선점) : 다른사람의 젓가락 하나를 강제로 뺏을 수 없다.<br>Circular wait (환형대기) : 대기하는 형태가 원을 이룸.</p>
<h3 id="교착상태"><a href="#교착상태" class="headerlink" title="교착상태"></a>교착상태</h3><p>OS에서는 데드락이 일어나지 않도록 미리 조취를 해야한다.</p>
<h4 id="자원의-사용"><a href="#자원의-사용" class="headerlink" title="자원의 사용"></a>자원의 사용</h4><p><u>요청 (request) → 사용 (use) → 반납 </u><br>프로세스가 자원을 쓰려면 OS에게 요청을 한다. 그 요청이 올바르면 OS는 그것을 허용하고 프로세스가 자원을 다 쓰면 OS에게 반납한다.</p>
<h4 id="동일-자원"><a href="#동일-자원" class="headerlink" title="동일 자원"></a>동일 자원</h4><p>동일 형식 (type) 자원이 여러 개 있을 수 있다 (instance) - 예: 동일 CPU 2개, 동일 프린터 3개 등</p>
<h3 id="자원-할당도-Resource-Allocation-Graph"><a href="#자원-할당도-Resource-Allocation-Graph" class="headerlink" title="자원 할당도 (Resource Allocation Graph)"></a>자원 할당도 (Resource Allocation Graph)</h3><p><u>시스템 내에 어느 자원이 있고 어떤 프로세스에게 할당되었는가에 대한 그래프</u><br>어떤 자원이 어떤 프로세스에게 할당되었는가?<br>어떤 프로세스가 어떤 자원을 할당 받으려고 기다리고 있는가?<br><u>자원: 사각형, 프로세스: 원, 할당: 화살표</u></p>
<p>그래프 강의는 37분부터 보자</p>
<h4 id="교착상태-필요조건"><a href="#교착상태-필요조건" class="headerlink" title="교착상태 필요조건"></a>교착상태 필요조건</h4><p>자원 할당도 상에 원이 만들어져야 (환형대기) - 충분조건은 아님!<br>자원에서 프로세스를 가르키면 프로세스가 자원을 할당받은 상태<br>프로세스에서 자원을 가르키면 자원을 요청한 상태</p>
<p>짝수번 철학자는 왼쪽들고 오른쪽 들고<br>홀수번 철학자는 오른쪽들고 왼쪽거 들기. 그러면 원형이 깨지게 되어 교착상태가 발생하지 않게된다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;읽기-쓰기 문제, 식사하는 철학자 문제&lt;/p&gt;
&lt;h3 id=&quot;Reader-amp-Writer&quot;&gt;&lt;a href=&quot;#Reader-amp-Writer&quot; class=&quot;headerlink&quot; title=&quot;Reader &amp;amp; Writer&quot;&gt;&lt;/a&gt;Read
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>13.전통적 동기화 문제, 생산자-소비자 문제</title>
    <link href="http://KKimSangHeon.github.io/2019/02/21/operating-system13/"/>
    <id>http://KKimSangHeon.github.io/2019/02/21/operating-system13/</id>
    <published>2019-02-21T13:10:14.000Z</published>
    <updated>2019-02-22T13:52:46.125Z</updated>
    
    <content type="html"><![CDATA[<p>OS에서 가장중요한게 프로세스 관리<br>이중 CPU 스케줄링, 프로세스 동기화가 중요하다.<br>이때 임계구역 처리를 잘해야한다.</p>
<h3 id="전통적-동기화-예제"><a href="#전통적-동기화-예제" class="headerlink" title="전통적 동기화 예제"></a>전통적 동기화 예제</h3><p>1.Producer and Consumer Problem(생산자-소비자 문제, 유한버퍼 문제 (Bounded Buffer Problem))<br>2.Readers-Writers Problem(공유 데이터베이스 접근)<br>3.Dining Philosopher Problem(식사하는 철학자 문제)</p>
<hr>
<h3 id="Producer-Consumer-Problem"><a href="#Producer-Consumer-Problem" class="headerlink" title="Producer-Consumer Problem"></a>Producer-Consumer Problem</h3><h4 id="생산자-소비자-문제"><a href="#생산자-소비자-문제" class="headerlink" title="생산자-소비자 문제"></a>생산자-소비자 문제</h4><p>생산자가 데이터를 생산하면 소비자는 그것을 소비<br>예: 컴파일러 &gt; 어셈블러, 파일 서버 &gt; 클라이언트, 웹 서버 &gt; 웹 클라이언트</p>
<h4 id="Bounded-Buffer"><a href="#Bounded-Buffer" class="headerlink" title="Bounded Buffer"></a>Bounded Buffer</h4><p>보통 생산소비와 소비속도는 다르다.<br>그래서 보통 창고(버퍼)에 저장하고 컨슈머가 조금씩 빼먹는다.</p>
<p>생산된 데이터는 버퍼에 일단 저장 (속도 차이 등)<br>현실 시스템에서 버퍼 크기는 유한<br>생산자는 버퍼가 가득 차면 더 넣을 수 없다.<br>소비자는 버퍼가 비면 뺄 수 없다</p>
<p>버퍼가 가득차면 생산자는 버퍼가 비워질때까지 기다려야한다.<br>버퍼가 비면 소비자는 빼갈것이 없다.</p>
<p>생산자가 10000번 넣고 소비자가 10000번 넣으면 0이되지 않을 수 있다.<br><code>이유</code> : 공통변수 count, buf[] 에 대한 동시 업데이트<br>공통변수 업데이트 구간(= 임계구역)에 대한 동시 진입</p>
<p><code>해결법</code> : 임계구역에 대한 동시 접근 방지 (상호배타)<br>세마포를 사용한 상호배타 (mutual exclusion, mutex)</p>
<h3 id="Busy-wait"><a href="#Busy-wait" class="headerlink" title="Busy-wait"></a>Busy-wait</h3><p>바쁘게 기다린다.<br>생산자: 버퍼가 가득 차면 기다려야 == 빈(empty) 공간이 있어야 한다<br>소비자: 버퍼가 비면 기다려야 == 찬(full) 공간이 있어야 한다</p>
<p>이때 무한루프를 돌면서 기다리면 CPU는 다른일을 못하고 잡히게 된다. -&gt; 비효율적<br><code>해결법</code> : 두개의 세마포어를 사용. empty의 초깃값은 BUF_SIZE 만큼 full의 초깃값은 0으로 하여 사용<br>생산자 :<br>empty.acquire();<br>PRODUCE;<br>full.release();</p>
<p>소비자 :<br>full.acquire();<br>CONSUME;</p>
<h2 id="empty-release"><a href="#empty-release" class="headerlink" title="empty.release();"></a>empty.release();</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OS에서 가장중요한게 프로세스 관리&lt;br&gt;이중 CPU 스케줄링, 프로세스 동기화가 중요하다.&lt;br&gt;이때 임계구역 처리를 잘해야한다.&lt;/p&gt;
&lt;h3 id=&quot;전통적-동기화-예제&quot;&gt;&lt;a href=&quot;#전통적-동기화-예제&quot; class=&quot;headerlink
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>12.세마포를 사용한 프로세스 동기화</title>
    <link href="http://KKimSangHeon.github.io/2019/02/20/operating-system12/"/>
    <id>http://KKimSangHeon.github.io/2019/02/20/operating-system12/</id>
    <published>2019-02-20T14:16:51.000Z</published>
    <updated>2019-02-20T14:17:22.281Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h3 id="프로세스-관리에서-중요한것들"><a href="#프로세스-관리에서-중요한것들" class="headerlink" title="프로세스 관리에서 중요한것들"></a>프로세스 관리에서 중요한것들</h3><p>CPU 스케줄링 : 이전포스팅 참고</p>
<p>프로세스(쓰레드) 동기화<br><code>필요이유</code> : 보통컴퓨터 안에있는 프로세스들은 독립적이지 않고 협조적이므로 즉 공통된 자원에 접근함<br><code>동기화가 되지 않으면?</code> : 누군가는 계속 입금하고 누군가는 출금하는 로직이 있을 때 다 더한값이 0이 아닐 수 있다.<br><code>임계구역</code> : 공통적으로 사용되는 부분</p>
<p><code>임계구역 문제 해결</code> : 상호베타, 진행, 유한대기 ( 모르겠으면 이전포스팅 보자)<br>우리가 원하는대로 프로세스 순서를 맞추는것.</p>
<h3 id="동기화-툴"><a href="#동기화-툴" class="headerlink" title="동기화 툴"></a>동기화 툴</h3><p><code>세마포어</code> : acquire P동작 release V동작이 있음<br>누가 CPU 서비스를 받다가 acquire를 호출했는데 if문이 만족하면 세마포어 큐안에 잡혀들어간다. 이 후 누가 wake를 시켜주면 다시 레디큐로 들어가게 된다.<br>세마포어는 Mutual exclusion을 위해 사용한다. 즉 크리티컬 섹션에는 한명만 들어갈 수 있다.</p>
<p>세마포어의 일반적 사용은 <u>Mutual exclusion</u> 그리고 <u>Ordering</u>으로 나뉜다.<br>그 중 Ordering를 구현하기 위해서는 다음과 같이 하면 된다.</p>
<p>P1    P2<br>S1    S2</p>
<p><code>P1, P2가 있을 때 P1을 먼저 실행하고자 할 때(Ordering)</code> : 세마포어의 value를 0으로 셋팅한다. 그 후 P2 앞에 sem.acquire를 호출한다.<br>이러면 P1이 먼저 호출되면 우리가 원하던 대로 되는것이고 그렇지 않고 P2가 먼저 실행될 경우 세마포어 큐에 들어가서 block이 된다. 아무튼 P1이 먼저 실행되게 되고 실행을 완료하면 release를 호출하여 P2가 실행 될 수 있도록 한다.<br>즉 다음과 같은 형태</p>
<p>P1        P2<br>        acquire<br>S1        S2<br>release</p>
<h3 id="세마포어-정리"><a href="#세마포어-정리" class="headerlink" title="세마포어 정리"></a>세마포어 정리</h3><p>세마포어는 임계구역 문제 해결, 프로세스 실행 순서 제어를 한다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h3 id=&quot;프로세스-관리에서-중요한것들&quot;&gt;&lt;a href=&quot;#프로세스-관리에서-중요한것들&quot; class=&quot;headerlink&quot; title=&quot;프로세스 관리에서 중요한것들&quot;&gt;&lt;/a&gt;프로세스 관리에서 중요한것들&lt;/h3&gt;&lt;p&gt;CPU 스케줄링 : 이전
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>11.임계구역 문제, 동기화 도구</title>
    <link href="http://KKimSangHeon.github.io/2019/02/19/operating-system11/"/>
    <id>http://KKimSangHeon.github.io/2019/02/19/operating-system11/</id>
    <published>2019-02-19T11:04:12.000Z</published>
    <updated>2019-02-20T14:16:20.363Z</updated>
    
    <content type="html"><![CDATA[<h3 id="임계구역-문제-critical-section-problem"><a href="#임계구역-문제-critical-section-problem" class="headerlink" title="임계구역 문제(critical-section problem)"></a>임계구역 문제(critical-section problem)</h3><p>여러개의 쓰레드로 이뤄진 시스템에서 각각의 쓰레드는 코드영역을 갖고있는데 이를 크리티컬 섹션이라한다. 또한 쓰레드로 부터 공통으로 사용되고 변경될 수 있는 부분을 의미한다.</p>
<p><u>어떤 복수개의 쓰레드들이 공통적으로 사용하는 부분.</u></p>
<h3 id="임계영역-해결"><a href="#임계영역-해결" class="headerlink" title="임계영역 해결"></a>임계영역 해결</h3><p>이를 해결하기 위해 다음 세가지가 만족되어야 한다.</p>
<p><code>Mutual exclusion (상호배타)</code>: 오직 한 쓰레드만 진입<br><code>Progress (진행)</code>: 진입 결정은 유한 시간 내. 즉 누가 먼저 들어가야되는지 유한시간내에 결정해야 한다.<br><code>Bounded waiting (유한대기)</code>: 어느 쓰레드라도 유한 시간 내 크리티컬 섹션안에 들어갈 수 있어야한다. 기다리는 시간이 한계가 정해져 있다.</p>
<h3 id="동기화의-목적"><a href="#동기화의-목적" class="headerlink" title="동기화의 목적"></a>동기화의 목적</h3><p><u>우리가 원하는대로 프로세스 혹은 쓰레드의 실행 순서를 결정 지을 수 있는것.</u></p>
<p>O/S 가 가진 여러 매니지먼트(프로세스 매니지먼트,메모리 매니지먼트,파일 시스템 매니지먼트, I/O 매니지먼트) 중 가장 중요한것은 프로세스 매니지먼트. 프로세스 매니지먼트는 두 가지로 나뉘는데 하나는 <u>CPU Scheduling, Synchronization</u></p>
<h3 id="Synchronization를-위한도구"><a href="#Synchronization를-위한도구" class="headerlink" title="Synchronization를 위한도구"></a>Synchronization를 위한도구</h3><p>세마포어 모니터가 있다.</p>
<p><code>Semaphores</code> : 기차역에서 출발신호를 의미하는 깃발이다. 네덜란드사람 딕스트라가 만듦.<br>내부구조는 정수 하나와 동작 두개로 구성된다. <u>하나는 P 동작 하나는 V 동작</u><br>P: Proberen (test) 즉 acquire()  검사<br>V: Verhogen (increment) 즉 release() 증가.</p>
<p>스택에는 푸쉬, 팝이라는 동작이 있다. 마찬가지로 세마포어도 내부에 정수가 있고 P,V가 존재한다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> </span>&#123;</div><div class="line">  value--;</div><div class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>) &#123;</div><div class="line">        add <span class="keyword">this</span> process/thread to list;  <span class="comment">// 누가 호출하면 큐안에 넣는다.</span></div><div class="line">        block;</div><div class="line">      &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</div><div class="line">  value++;</div><div class="line">    <span class="keyword">if</span> (value &lt;= <span class="number">0</span>) &#123;</div><div class="line">        remove a process P from list; <span class="comment">//누군가 갇혀있으면 깨워준다.</span></div><div class="line">        wakeup P;</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>저번에 배웠듯이 레디큐에서 CPU의 서비스를 받기 위해 기다리던 프로세스들이 CPU 서비스를 받다 IO를 만나면 IO서비스를 받으려 하는데 누가 IO서비스를 받고있다면 IO Queue(Device Queue)에서 대기하다 IO서비스를 받고 끝나면 다시 레디큐로 돌아온다.</p>
<p>타임쉐어링 시스템의 경우엔 IO를 만나지 않더라도 시간이 지나면 다시 레디큐로 돌아간다.</p>
<p>이는 프로세스의 큐잉 모델 즉 줄서서 기다리는 모델이다.</p>
<p>세마포어는 정수값도 있고 세마포어 큐도 있다. 어떤 프로세스가 레디큐에 있다 CPU를 쓰다가 acquire를 호출했는데 if문이 맞으면 갇혀버린다.(like 감옥) 이후에 누가 release를 해주면 감옥에서 탈출하여 다른 레디큐로 갈 수 있다.</p>
<p>위에서 value는 권한의 갯수로 생각하면 된다.</p>
<h3 id="세마포어는-Mutual-exclusion-상호베타를-위해-동작한다"><a href="#세마포어는-Mutual-exclusion-상호베타를-위해-동작한다" class="headerlink" title="세마포어는 Mutual exclusion 상호베타를 위해 동작한다."></a>세마포어는 Mutual exclusion 상호베타를 위해 동작한다.</h3><p>세마포어의 초깃값이 1이라 하자. 이때 레디큐에 A, B가 있다고 하자.<br>먼저 A가 acquire(); 을 호출하면 0이 되고 크리티컬 섹션 안으로 들어간다.(블록 걸리지 않음)<br>이때 컨텍스트 스위칭이 되고 B가 acquire를 호출하면 이때는 value가 -1이므로 세마포어 큐에 갇히게 된다.  (크리티컬 섹션 안으로 못들어간다). 그 후 A가 작업을 마치고 release를 호출하게 되면 value를 늘리고 세마포어 큐에 갇혀있는 B를 깨워 다시 레디큐로 들어가게 한다.</p>
<p> 이를 상호베타라 한다.</p>
<p><code>Monitors</code> :</p>
<p>메모리 매니지먼트라<br>파일 시스템 매니지먼트<br>I/O 매니지먼트</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;임계구역-문제-critical-section-problem&quot;&gt;&lt;a href=&quot;#임계구역-문제-critical-section-problem&quot; class=&quot;headerlink&quot; title=&quot;임계구역 문제(critical-section pro
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>10.프로세스 동기화의 중요성, 은행계좌 문제</title>
    <link href="http://KKimSangHeon.github.io/2019/02/18/operating-system10/"/>
    <id>http://KKimSangHeon.github.io/2019/02/18/operating-system10/</id>
    <published>2019-02-18T13:31:45.000Z</published>
    <updated>2019-02-18T13:34:32.742Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-쓰레드란"><a href="#1-쓰레드란" class="headerlink" title="1. 쓰레드란?"></a>1. 쓰레드란?</h3><p>프로그램 내부의 흐름, 맥</p>
<p>맥이 하나만 있는 프로그램 : 싱글쓰레드<br>여러개있는것: 멀티(다중)쓰레드</p>
<p>쓰레드가 여러개가 빠르게 동시에(왔다갔다하면서) 실행됨. 우리는 CPU하나임을 가정하고 공부하기 때문에</p>
<h3 id="1-1-쓰레드-구조"><a href="#1-1-쓰레드-구조" class="headerlink" title="1.1 쓰레드 구조"></a>1.1 쓰레드 구조</h3><p>프로세스의 메모리 공간 공유 : (code, data)<br>프로세스의 자원 공유 : (file, i/o, …)<br>비공유: 개별적인 PC, SP, registers, stack</p>
<p>운영체제의 프로세스 관리부서에서 중요한것은 프로세스 동기화 또는 쓰레드 동기화이다.</p>
<h3 id="프로세스는-크게-두가지로-나뉜다"><a href="#프로세스는-크게-두가지로-나뉜다" class="headerlink" title="프로세스는 크게 두가지로 나뉜다."></a>프로세스는 크게 두가지로 나뉜다.</h3><p>Independent process : p1, p2가 영향이 없다<br>Cooperating process : p1, p2가 영향을 주던지 받던지 한다. 이런경우가 훨씬 많다.<br>프로세스간 통신: 전자우편, 파일 전송<br>프로세스간 자원 공유: 메모리 상의 자료들, 데이터베이스 등<br>명절 기차표 예약, 대학 온라인 수강신청, 실시간 주식거래</p>
<h3 id="2-프로세스-쓰레드-동기화"><a href="#2-프로세스-쓰레드-동기화" class="headerlink" title="2. 프로세스(쓰레드) 동기화"></a>2. 프로세스(쓰레드) 동기화</h3><p><code>공통데이터에 접근하는것은 문제가 발생할 수 있다. (공유되는 프로세스가 동시에 접근할 때.)</code><br>동기화가 제대로 이뤄지지 않으면 똑같은 자리에 두명이상이 배정된다던가 하는 문제가 생긴다.</p>
<p><u>프로세스간에 순서를 잘 지정해서 이상한 상태에 빠지지 않도록 하여 데이터의 일관성을 유지</u></p>
<h3 id="2-1-BankAccount-Problem-은행계좌문제"><a href="#2-1-BankAccount-Problem-은행계좌문제" class="headerlink" title="2.1 BankAccount Problem (은행계좌문제)"></a>2.1 BankAccount Problem (은행계좌문제)</h3><p>부모님은 은행계좌에 입금; 자녀는 출금<br>입금(deposit)과 출금(withdraw) 은 독립적으로 일어난다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-쓰레드란&quot;&gt;&lt;a href=&quot;#1-쓰레드란&quot; class=&quot;headerlink&quot; title=&quot;1. 쓰레드란?&quot;&gt;&lt;/a&gt;1. 쓰레드란?&lt;/h3&gt;&lt;p&gt;프로그램 내부의 흐름, 맥&lt;/p&gt;
&lt;p&gt;맥이 하나만 있는 프로그램 : 싱글쓰레드&lt;br&gt;여러
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
</feed>
