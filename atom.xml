<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kim Sang Heon&#39;s Bolg</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://KKimSangHeon.github.io/"/>
  <updated>2019-02-24T03:00:09.984Z</updated>
  <id>http://KKimSangHeon.github.io/</id>
  
  <author>
    <name>Kim Sang Heon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>18.동적적재, 동적연결, 스와핑</title>
    <link href="http://KKimSangHeon.github.io/2019/02/24/operating-system18/"/>
    <id>http://KKimSangHeon.github.io/2019/02/24/operating-system18/</id>
    <published>2019-02-24T02:25:43.000Z</published>
    <updated>2019-02-24T03:00:09.984Z</updated>
    
    <content type="html"><![CDATA[<p>컴퓨터에서 메모리는 CPU 만큼 중요하다.<br>하드디스크에 파일들이 들어있다. 파워를키면 OS가 메인메모리에 올라가고 특정 프로그램을 실행시키면 그 프로그램이 메인메모리로 올라간다. 이 메모리를 어떻게 잘 관리할것인가가 <code>메모리 매니지먼트</code></p>
<h3 id="실행파일을-메모리에-올리기"><a href="#실행파일을-메모리에-올리기" class="headerlink" title="실행파일을 메모리에 올리기"></a>실행파일을 메모리에 올리기</h3><p>src-obj-exe</p>
<p>메모리 몇 번지에?<br>다중 프로그래밍 환경에서는?</p>
<p>항상 똑같은 곳에 올리는것을 보장하지 못함. 그래서 MMU를 활용. CPU가 메모리에 몇번째 주소를 읽겠다 하면 메모리는 CPU로 데이터를 전송해준다. <u>MMU는 특정프로그램이 다른 프로그램으로 접근하지 못하게 해준다.</u> CPU가 메모리에 주소를 전달할 때 MMU를 거치는데 자기영역에 맞는 주소를요청하는지 파악한다.(base, limit 레지스터 활용)<br>MMU는 이뿐만 아니라 <u>Relocation register</u>을 둔다. 가령 A라는 프로그램이 있다고 하자. 개발자는 해당 프로그램이 0번지부터 시작한다고 생각하고 코딩을 했다. 하지만 이는 보장되지 않기 때문에 예측할 수 없다. 실제로는 프로그램이 1000번지에 로드되면 MMU 안에 Relocation register에 1000을 넣는다. 그러면 <u>CPU는 0번지를 요청하지만 MMU를 거치면서 1000이 더해져 실제로 저장되어 있는 1000번지로 접근하게 된다</u>. 즉 CPU를 속이게 된다.<br>그 다음날 A라는 프로그램이 실행되었을 때 5000번지에 실행될 경우 이때는 Relocation register에 5000이 들어가고 CPU는 5000번지에 접근하여 데이터를 읽어올 수 있다.</p>
<p>여기서 CPU가 보내는 주소를 <u>논리주소(logical address)</u> 라 하고 실제로 메인메모리로 들어가는 주소를 <u>물리주소 (physical address)</u>라 한다.</p>
<p>link</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;컴퓨터에서 메모리는 CPU 만큼 중요하다.&lt;br&gt;하드디스크에 파일들이 들어있다. 파워를키면 OS가 메인메모리에 올라가고 특정 프로그램을 실행시키면 그 프로그램이 메인메모리로 올라간다. 이 메모리를 어떻게 잘 관리할것인가가 &lt;code&gt;메모리 매니지
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>17.주기억장치 관리 개요</title>
    <link href="http://KKimSangHeon.github.io/2019/02/23/operating-system17/"/>
    <id>http://KKimSangHeon.github.io/2019/02/23/operating-system17/</id>
    <published>2019-02-23T00:48:52.000Z</published>
    <updated>2019-02-23T15:18:11.112Z</updated>
    
    <content type="html"><![CDATA[<p>CPU / 메모리 / 보조기억장치가 존재.<br>O/S는 프로세스 관리를한다. CPU 관리를 하는데 이를 프로세스 매니지먼트라함.<br>또한 O/S는 메모리 관리 즉 메모리 매니지먼트를 한다.</p>
<p>OS : 하드웨어를 어플리케이션이 활용할 수 있도록 함.<br><code>CPU 자원을 나눠주는 곳</code> : 프로세스 매니지먼트<br><code>메인메모리를 관리하는곳</code> : 메모리 매니지먼트.</p>
<h3 id="메모리-역사"><a href="#메모리-역사" class="headerlink" title="메모리 역사"></a>메모리 역사</h3><p><code>Core memory</code> : 반지모양의 철심에 자성물질을 바르고 전기를 흐르게 한 후 자석이 되게 한 후 메모리로 사용.<br><code>진공관 메모리</code> : 50~60년대 손가락 크기만함. 네다섯개가 한비트를 저장<br><code>트랜지스터 메모리</code> : 손톱만한 크기로 한비트를 저장하는데 네개의 트랜지스터 필. 반도체 소자안에 들어간다.<br><code>집적회로 메모리: SRAM, DRAM</code> : 보통 생각하는 메모리</p>
<h3 id="메모리-용량"><a href="#메모리-용량" class="headerlink" title="메모리 용량"></a>메모리 용량</h3><p>1970년대: 8-bit PC 64KB<br>1980년: 16-bit IBM-PC 640KB &gt; 1MB &gt; 4MB<br>1990년: 수MB &gt; 수십 MB<br>2000년~: 수백 MB &gt; 수 GB</p>
<h2 id="메모리가-지속적으로-커졌다"><a href="#메모리가-지속적으로-커졌다" class="headerlink" title="메모리가 지속적으로 커졌다!!"></a>메모리가 지속적으로 커졌다!!</h2><h3 id="메모리는-언제나-부족하다"><a href="#메모리는-언제나-부족하다" class="headerlink" title="메모리는 언제나 부족하다.."></a>메모리는 언제나 부족하다..</h3><h4 id="이유-프로그램의-변천"><a href="#이유-프로그램의-변천" class="headerlink" title="이유 : 프로그램의 변천"></a>이유 : 프로그램의 변천</h4><p>기계어/어셈블리어 작성<br>C언어<br>자바, 객체지향형 언어 작성<br>숫자 처리 &gt; 문자 처리 &gt; 멀티미디어 순으로 패러다임이 변화함.</p>
<h4 id="메모리-용량-증가-vs-프로그램-크기-증가"><a href="#메모리-용량-증가-vs-프로그램-크기-증가" class="headerlink" title="메모리 용량 증가 vs 프로그램 크기 증가"></a>메모리 용량 증가 vs 프로그램 크기 증가</h4><p>언제나 부족한 메모리 ㅠㅠ</p>
<h4 id="어떻게-메모리를-효과적으로-사용할-수-있을까"><a href="#어떻게-메모리를-효과적으로-사용할-수-있을까" class="headerlink" title="어떻게 메모리를 효과적으로 사용할 수 있을까?"></a>어떻게 메모리를 효과적으로 사용할 수 있을까?</h4><p>메모리 낭비를 없애고 가상메모리와 같은 기법을 활용!</p>
<h3 id="메모리-구조"><a href="#메모리-구조" class="headerlink" title="메모리 구조?"></a>메모리 구조?</h3><img src="/2019/02/23/operating-system17/image1.png" alt="CPU와 메모리" title="CPU와 메모리">
<p>CPU가 몇번지를 읽겠다고 주소를 메모리로 보낸다. 그러면 거기에 저장되어있는 정보를 메모리가 CPU에게 제공한다.<br>또한 데이터 저장을 위해서 CPU가 데이터를 전송하기도 한다<br>메모리는 주소(Address) + 데이터(Data)로 구성된다.</p>
<h3 id="프로그램은-어떻게-개발될까"><a href="#프로그램은-어떻게-개발될까" class="headerlink" title="프로그램은 어떻게 개발될까?"></a>프로그램은 어떻게 개발될까?</h3><p>컴파일러, 어셈블러, 링커, 로더에 대해 알아보자<br>프로그램이 실행되기까진 아래의 순서를 따른다.<br><u>main.c (고수준언어)-&gt;main.o(기계어) -&gt; link -&gt; 메인메모리로 올림</u><br>첫번째 화살표 컴파일러가 진행<br>두번째 화살표 링커가 진행<br>세번째 화살표 로더가 진행</p>
<p><code>원천파일 (Source file)</code>: 고수준언어 또는 어셈블리언어<br><code>목적파일 (Object file)</code>: 컴파일 또는 어셈블 결과<br><code>실행파일 (Executable file)</code>: 링크 결과<br>프로그램 실행을 위해 필요한것들: code + data + stack</p>
<p>실행파일을 메모리에 올리기 위해 메모리 몇번지에 올려야되지?(로더가 해결해준다)</p>
<h3 id="MMU의-사용"><a href="#MMU의-사용" class="headerlink" title="MMU의 사용"></a>MMU의 사용</h3><p>MMU 안에 base limit가 있다했는데 재배치 레지스터가 있다. 프로그램을 개발할 때 0번지에 들어간다고 생각했는데 실제로는 500번지에 들어간다면 Relocation register에 500을 넣어줘 CPU가 봤을땐 0번지 이지만 500을 더한 500번지에 저장되게 한다. 즉 CPU는 얘가 0번지에 있는줄 안다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CPU / 메모리 / 보조기억장치가 존재.&lt;br&gt;O/S는 프로세스 관리를한다. CPU 관리를 하는데 이를 프로세스 매니지먼트라함.&lt;br&gt;또한 O/S는 메모리 관리 즉 메모리 매니지먼트를 한다.&lt;/p&gt;
&lt;p&gt;OS : 하드웨어를 어플리케이션이 활용할
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>16.프로세스 동기화의 다른 도구인 모니터 사용</title>
    <link href="http://KKimSangHeon.github.io/2019/02/22/operating-system16/"/>
    <id>http://KKimSangHeon.github.io/2019/02/22/operating-system16/</id>
    <published>2019-02-22T13:51:04.000Z</published>
    <updated>2019-02-23T15:18:37.264Z</updated>
    
    <content type="html"><![CDATA[<h3 id="모니터"><a href="#모니터" class="headerlink" title="모니터"></a>모니터</h3><p>동기화 도구로 세마포어를 배웠다. 세마포어는 조금 오래된 동기화 도구인데 지금은 모니터를 많이쓴다. 주로 자바에서 많이쓴다.<br>즉 세마포 이후 프로세스 동기화 도구 이며 세마포 보다 고수준 개념</p>
<h3 id="세마포어의-구조"><a href="#세마포어의-구조" class="headerlink" title="세마포어의 구조"></a>세마포어의 구조</h3><p>정수변수, 큐, P(acquire)동작, V(release)동작</p>
<h3 id="모니터의-구조"><a href="#모니터의-구조" class="headerlink" title="모니터의 구조"></a>모니터의 구조</h3><p>공유자원 , 공유자원 접근함수 , 2개의 큐</p>
<p>2개의 큐?<br>하나는 배타동기. 즉 한쓰레드만 공유자원에 접근할 수 있도록 하는 큐<br>하나는 조건동기를 위한 큐</p>
<p>베타동기를 위한큐 | 다양한 함수 | 조건동기를 위한큐</p>
<img src="/2019/02/22/operating-system16/image1.png" alt="모니터의구조" title="모니터의구조">
<p>1.쓰레드 한개만 공유자원 접근 함수에 접근할 수 있다. 즉 들어오고 싶어하는 애들은 베타동기를 위한 큐에서 기다려야 한다.<br>2.진입 쓰레드가 조건을 만족하면(wait을 호출하여) 조건동기 큐로 들어가는데 이땐 블록된다. 그러면 새 쓰레드가 진입가능<br>3.새 쓰레드는 조건동기로 블록된 쓰레드를 notify를 호출하여 깨울 수 있다<br>4.깨워진 쓰레드는 현재 쓰레드가 나가면 재진입할 수 있다.<br>(하나의 쓰레드만 접근 가능하므로)</p>
<p>세마포어에 비해 복잡하나 사용하기 편리하다.</p>
<p><code>배타동기</code>: synchronized 키워드 사용하여 지정<br><code>조건동기</code>: wait(), notify(), notifyAll() 메소드 사용</p>
<p>베타동기: 하나만 특정함수에 들어갈 수 있다. 자바에서는 함수 정의 앞에 synchronized 키워드를 붙인다.<br>조건동기는 wait 함수를 호출하여 조건동기를 위한 큐에 갇히게 할 수 있고 notify(하나깨우기) 혹은 notify all(전체깨우기) 을 호출하여 깨울 수 도 있다.</p>
<h4 id="상호배제-용도로-사용"><a href="#상호배제-용도로-사용" class="headerlink" title="상호배제 용도로 사용"></a>상호배제 용도로 사용</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankAccount</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> balance;</div><div class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">int</span> amt)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> temp = balance + amt;</div><div class="line">		System.out.print(<span class="string">"+"</span>);</div><div class="line">		balance = temp;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> amt)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> temp = balance - amt;</div><div class="line">		System.out.print(<span class="string">"-"</span>);</div><div class="line">		balance = temp;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> balance;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>위처럼 하면 동기화가 가능하다. 세마포어 보다 쉽다!</p>
<h4 id="Ordering-용도로-사용"><a href="#Ordering-용도로-사용" class="headerlink" title="Ordering 용도로 사용"></a>Ordering 용도로 사용</h4><p>P1은 공백/ S1/notify();<br>P2는 wait/S2/공백</p>
<p>P1이 입금, P2가 출금 로직이라고 가정하고 생각해보자.</p>
<p>P1,P2 반복해서 출력되게 하려면 boolean 변수 하나를 둬서 처리<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">int</span> balacne = <span class="number">0</span>;</div><div class="line"><span class="keyword">boolean</span> p_turn;</div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">int</span> amt)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> temp = balance + amt;</div><div class="line">	balance = temp;</div><div class="line">	notify();</div><div class="line">	p_turn = <span class="keyword">false</span>;</div><div class="line">	wait();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> amt)</span> </span>&#123;</div><div class="line">	<span class="keyword">while</span>(p_turn)</div><div class="line">		wait();</div><div class="line"></div><div class="line">	<span class="keyword">int</span> temp = balance - amt;</div><div class="line">	balance = temp;</div><div class="line">	p_turn = <span class="keyword">true</span>;</div><div class="line">	notify();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">---</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span>[] buf;</div><div class="line">	<span class="keyword">int</span> size, count, in, out;</div><div class="line">	Buffer(<span class="keyword">int</span> size) &#123;</div><div class="line">		buf = <span class="keyword">new</span> <span class="keyword">int</span>[size];</div><div class="line">		<span class="keyword">this</span>.size = size;</div><div class="line">		count = in = out = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> item)</span> </span>&#123;</div><div class="line">	<span class="keyword">while</span> (count == size)</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		wait();</div><div class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</div><div class="line">	buf[in] = item;</div><div class="line">	in = (in+<span class="number">1</span>)%size;</div><div class="line">	notify();</div><div class="line">	count++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">while</span> (count == <span class="number">0</span>)</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		wait();</div><div class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</div><div class="line">	<span class="keyword">int</span> item = buf[out];</div><div class="line">	out = (out+<span class="number">1</span>)%size;</div><div class="line">	count--;</div><div class="line">	notify();</div><div class="line">	<span class="keyword">return</span> item;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">---</div><div class="line">교착상태에 대한 고려는 되지 않음.</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chopstick</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> inUse = <span class="keyword">false</span>;</div><div class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">		<span class="keyword">while</span> (inUse)</div><div class="line">		wait();</div><div class="line">		inUse = <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</div><div class="line">		inUse = <span class="keyword">false</span>;</div><div class="line">		notify();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;모니터&quot;&gt;&lt;a href=&quot;#모니터&quot; class=&quot;headerlink&quot; title=&quot;모니터&quot;&gt;&lt;/a&gt;모니터&lt;/h3&gt;&lt;p&gt;동기화 도구로 세마포어를 배웠다. 세마포어는 조금 오래된 동기화 도구인데 지금은 모니터를 많이쓴다. 주로 자바에서 많이
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>15.교착상태 필요조건, 교착상태의 해결법</title>
    <link href="http://KKimSangHeon.github.io/2019/02/22/operating-system15/"/>
    <id>http://KKimSangHeon.github.io/2019/02/22/operating-system15/</id>
    <published>2019-02-22T13:50:56.000Z</published>
    <updated>2019-02-22T13:56:55.165Z</updated>
    
    <content type="html"><![CDATA[<h3 id="교착상태"><a href="#교착상태" class="headerlink" title="교착상태"></a>교착상태</h3><p>발생이유 : 프로세스들이 자원을 많이 필요로 한다. 하지만 누가 사용하고 있으면 기다려야한다.<br>이러한 형태가 원을 이루면 교착상태가 발생한다.</p>
<h3 id="교창상태-필요조건"><a href="#교창상태-필요조건" class="headerlink" title="교창상태 필요조건."></a>교창상태 필요조건.</h3><p>Mutual exclusion (상호배타) : 자원을 서로 공유하지 못함<br>Hold and wait (보유 및 대기) : 하나를 잡고있으면서 다른것을 원함<br>No Preemption (비선점) : 다른것을 강제로 뺏어오지 못함.<br>Circular wait (환형대기) : 자원을 갖고있으면서 기다리는데 원형형태</p>
<p><u>네가지가 만족되면 일어날 수 있다. 반드시 일어나는것은 아님</u></p>
<h3 id="교착상태-처리"><a href="#교착상태-처리" class="headerlink" title="교착상태 처리"></a>교착상태 처리</h3><p>교착상태 처리는 크게 네가지가 있다.<br>1.교착상태 방지<br>Deadlock Prevention</p>
<p>2.교착상태 회피<br>Deadlock Avoidance</p>
<p>3.교착상태 검출 및 복구<br>Deadlock Detection &amp; Recovery</p>
<p>4.교착상태 무시<br>Don’t Care</p>
<h3 id="1-교착상태-방지"><a href="#1-교착상태-방지" class="headerlink" title="1.교착상태 방지"></a>1.교착상태 방지</h3><p><code>설명</code> : 필요조건 중 네가지 조건중에 하나라도 깨도록 하는것.<br><code>상호베타 조건을 깨기</code>: 이를 위해 공유가 가능하게 해야한다. 현실적으로 어렵다. 읽어내기만 하는 파일 같은 경우에는 가능하지만 일반적으로는 부적절</p>
<p><code>보유 및 대기 깨기</code>: 동시에 젓가락 갖게하기. 왼쪽 젓가락 잡고 오른쪽 젓가락 잡을라 했는데 누가 오른쪽을 갖고있으면 왼쪽도 놓기. 이는 굶어 죽을 확률이 생김. 자원의 활용도가 떨어진다. 상호베타 조건깨는것보다는 쉽다.<br>자원을 가지고 있으면서 다른 자원을 기다리지 않게 즉 자원이 없는 상태에서 모든 자원 대기; 일부 자원만 가용하면 보유 자원을 모두 놓아주기<br>단점: 자원 활용률 저하, 기아 (starvation)</p>
<p><code>비선점 깨기</code>: CPU의 경우에는 일부 가능하겠으나 일반적으로 불가능</p>
<p><code>환형대기 깨기</code> : 자원에다 번호 부여하고 자원의 오름차순으로 자원을 요청토록 함. 즉 R1,R2,R3 가 있을때 R1, R2 요청/ R2,R3 요청/ R1,R3요청처럼 구현. 자원의 활용도가 떨어진다.</p>
<p>보통 보유 및 대기 깨기 혹은 환형대기 깨기를 사용한다.</p>
<h3 id="2-교착상태-회피"><a href="#2-교착상태-회피" class="headerlink" title="2.교착상태 회피"></a>2.교착상태 회피</h3><p><code>설명</code> : 자원을 할당할 때 위험한 할당이 되지 않도록 하는것.<br>자원을 프로세스 한테 골고루 나눠주는것을 OS가 한다. 이를 리소스 매지저 / 올로케이터라 한다.<br>교착상태는 자원요청에 대한 잘못된 승인에 기인한다고 본다.</p>
<p>불안전한 할당 (Unsafe allocation)<br>운영체제는 자원을 할당할 때 불안전 할당 되지 않도록<br>불안전 할당 → 교착상태 유발<br>대출전문 은행과 유사: Banker’s Algorithm</p>
<h3 id="3-교착상태-검출-및-복구"><a href="#3-교착상태-검출-및-복구" class="headerlink" title="3.교착상태 검출 및 복구"></a>3.교착상태 검출 및 복구</h3><p><code>설명</code> : 프로세스가 필요한 대로 자원을 나눠주고 데드락이 발생하면 OS의 프로세스 복구.<br>교착상태가 일어나는 것을 허용 그리고 주기적 검사진행. 주기적 검사는 이를 하기 위한 오버헤드가 크다.<br>교착상태 발생 시 복구하기위해 주기적으로 이전의 상태를 기억하고 있어야 한다.<br>이를 위해 한 프로세스를 강제로 종료시키거나 혹은 자원을 선점하여 일부 프로세스에게 할당.</p>
<h3 id="4-교착상태-무시"><a href="#4-교착상태-무시" class="headerlink" title="4. 교착상태 무시"></a>4. 교착상태 무시</h3><p><code>설명</code> : 교착상태는 실제로 잘 일어나지 않으므로 그냥 무시해버린다.<br>교착상태 발생 시 재시동.</p>
<p>컴퓨터에서 가장 중요한것은 메모리 관리이다. 이를 프로세스 매니지먼트 부서가 하는데 이는 CPU 스케줄링 부서, 프로세스 싱크로나이즈 부서로 구성된다. 싱크로나이즈에서는 데드락관리또한 중요.</p>
<p>메인메모리 관리가 메모리 매니지 부서가 있다. 다음부터 공부한다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;교착상태&quot;&gt;&lt;a href=&quot;#교착상태&quot; class=&quot;headerlink&quot; title=&quot;교착상태&quot;&gt;&lt;/a&gt;교착상태&lt;/h3&gt;&lt;p&gt;발생이유 : 프로세스들이 자원을 많이 필요로 한다. 하지만 누가 사용하고 있으면 기다려야한다.&lt;br&gt;이러한 형태
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>14.읽기-쓰기 문제, 식사하는 철학자 문제</title>
    <link href="http://KKimSangHeon.github.io/2019/02/22/operating-system14/"/>
    <id>http://KKimSangHeon.github.io/2019/02/22/operating-system14/</id>
    <published>2019-02-22T13:50:49.000Z</published>
    <updated>2019-02-22T13:53:18.540Z</updated>
    
    <content type="html"><![CDATA[<p>읽기-쓰기 문제, 식사하는 철학자 문제</p>
<h3 id="Reader-amp-Writer"><a href="#Reader-amp-Writer" class="headerlink" title="Reader &amp; Writer"></a>Reader &amp; Writer</h3><p>DB 읽기만 하는 프로세스 DB를 바꾸는 프로세스</p>
<p>A가 DB를 읽고 있을 때 B가 읽을 수 있다.<br>즉 한 프로세스가 DB를 읽을 때 다른 프로세스도 읽을 수 있게 허용해줘야 한다.</p>
<p>The first R/W problem (readers-preference)<br>리더가 있으면 라이터가 미뤄지는것</p>
<p>The second R/W problem (writers-preference)<br>라이터가 먼저 우선순위가 주어지는것</p>
<p>The Third R/W problem<br>아무한테도 주지 않는것</p>
<p><code>정리</code> : 즉 리더가 들어왔는데 라이터가 들어오려면 블록되어야 하고<br>라이터가 들어왔는데 리더가 들어오려면 블록되어야 하고<br>리더가 들어와있는데 리더가 들어오면 허용해야한다</p>
<h3 id="Dining-Philosopher-Problem"><a href="#Dining-Philosopher-Problem" class="headerlink" title="Dining Philosopher Problem"></a>Dining Philosopher Problem</h3><p><code>다음 프로그램 설명</code><br>철학자 5명이 둥근탁상에 앉아있다. 젓가락은 5개뿐. 즉 자신의 왼쪽 오른쪽에 젓가락이 위치.<br>젓가락을 세마포어로 만들고 초기화를 1로한다.<br>무한루프를 돌면서 왼쪽젓가락, 오른쪽 젓가락을 acquire 하고. 먹고 다시 왼쪽 오른쪽 젓가락을 release한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> id; <span class="comment">// philosopher id</span></div><div class="line">	Semaphore lstick, rstick; <span class="comment">// left, right chopsticks</span></div><div class="line">	Philosopher(<span class="keyword">int</span> id, Semaphore lstick, Semaphore rstick) &#123;</div><div class="line">		<span class="keyword">this</span>.id = id;</div><div class="line">		<span class="keyword">this</span>.lstick = lstick;</div><div class="line">		<span class="keyword">this</span>.rstick = rstick;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">				lstick.acquire();</div><div class="line">				rstick.acquire();</div><div class="line">				eating();</div><div class="line">				lstick.release();</div><div class="line">				rstick.release();</div><div class="line">				thinking();</div><div class="line">			&#125;</div><div class="line">		&#125;<span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">eating</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"["</span> + id + <span class="string">"] eating"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"["</span> + id + <span class="string">"] thinking"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">5</span>; <span class="comment">// number of philosphers &amp; chopsticks</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> i;</div><div class="line">		<span class="comment">/* chopsticks */</span></div><div class="line">		Semaphore[] stick = <span class="keyword">new</span> Semaphore[num];</div><div class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;num; i++)</div><div class="line">			stick[i] = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</div><div class="line"></div><div class="line">		<span class="comment">/* philosophers */</span></div><div class="line">		Philosopher[] phil = <span class="keyword">new</span> Philosopher[num];</div><div class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;num; i++)</div><div class="line">			phil[i] = <span class="keyword">new</span> Philosopher(i, stick[i], stick[(i+<span class="number">1</span>)%num]);</div><div class="line"></div><div class="line">		<span class="comment">/* let philosophers eat and think */</span></div><div class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;num; i++)</div><div class="line">			phil[i].start();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>위의 프로그램은 쭉 가다가 정지된다. 그 이유는 <u>기아상태</u> 유발<br>모든사람이 각자의 왼쪽 젓가락을 들었을 때 해당상황이 발생<br>이를 <u>교착상태</u>라 한다.</p>
<p>운영체제에서 중요한것은 프로세스 관리. 이중 중요한것이 CPU 스케줄링, 동기화 문제이다.<br>동기화에서 중요한건 크리티컬 섹션문제, 효율성 증대 즉 ordering 인데 ordering를 잘못하면 <u>교착상태(Deadlock)</u>에 빠지게 된다.</p>
<h3 id="교착상태-Deadlocks"><a href="#교착상태-Deadlocks" class="headerlink" title="교착상태(Deadlocks)"></a>교착상태(Deadlocks)</h3><p>프로세스가 실행되기 위해서는 하드웨어 자원이 필요하다. 이를 리소스 즉 자원이라 한다. 자원을 사용하는 애플리케이션 즉 프로세스가 있고 중간에 OS가 있다. OS는 애플리케이션한테 자원을 잘 나눠줘야 한다. 자원은 한정되어 있는데 이를 사용하고자 하는 프로세스는 많다. 여기서 잘 나눠주지 못하면 교착상태가 발생한다.</p>
<p>어떤 자원은 갖고 있으나 다른 자원은 갖지 못할 때 (e.g., 다른 프로세스가 사용 중) 대기해야 한다.<br>다른 프로세스 역시 다른 자원을 가지려고 대기할 때 교착상태 가능성 발생</p>
<p>교착상태는 어떤자원을 갖고있을 때 다른 자원을 갖고자 할 때 발생</p>
<h3 id="교착상태-필요-조건-Necessary-Conditions"><a href="#교착상태-필요-조건-Necessary-Conditions" class="headerlink" title="교착상태 필요 조건 (Necessary Conditions)"></a>교착상태 필요 조건 (Necessary Conditions)</h3><p>Mutual exclusion (상호배타) : 리소스가 상호 배타적이다. 즉 한프로세스가 A를 쓰고 있다면 다른 프로세스는 A를 쓰지 못한다.<br>Hold and wait (보유 및 대기) : 왼쪽 젓가락 잡고있으면서 오른쪽 젓가락을 기다리는것.<br>No Preemption (비선점) : 다른사람의 젓가락 하나를 강제로 뺏을 수 없다.<br>Circular wait (환형대기) : 대기하는 형태가 원을 이룸.</p>
<h3 id="교착상태"><a href="#교착상태" class="headerlink" title="교착상태"></a>교착상태</h3><p>OS에서는 데드락이 일어나지 않도록 미리 조취를 해야한다.</p>
<h4 id="자원의-사용"><a href="#자원의-사용" class="headerlink" title="자원의 사용"></a>자원의 사용</h4><p><u>요청 (request) → 사용 (use) → 반납 </u><br>프로세스가 자원을 쓰려면 OS에게 요청을 한다. 그 요청이 올바르면 OS는 그것을 허용하고 프로세스가 자원을 다 쓰면 OS에게 반납한다.</p>
<h4 id="동일-자원"><a href="#동일-자원" class="headerlink" title="동일 자원"></a>동일 자원</h4><p>동일 형식 (type) 자원이 여러 개 있을 수 있다 (instance) - 예: 동일 CPU 2개, 동일 프린터 3개 등</p>
<h3 id="자원-할당도-Resource-Allocation-Graph"><a href="#자원-할당도-Resource-Allocation-Graph" class="headerlink" title="자원 할당도 (Resource Allocation Graph)"></a>자원 할당도 (Resource Allocation Graph)</h3><p><u>시스템 내에 어느 자원이 있고 어떤 프로세스에게 할당되었는가에 대한 그래프</u><br>어떤 자원이 어떤 프로세스에게 할당되었는가?<br>어떤 프로세스가 어떤 자원을 할당 받으려고 기다리고 있는가?<br><u>자원: 사각형, 프로세스: 원, 할당: 화살표</u></p>
<p>그래프 강의는 37분부터 보자</p>
<h4 id="교착상태-필요조건"><a href="#교착상태-필요조건" class="headerlink" title="교착상태 필요조건"></a>교착상태 필요조건</h4><p>자원 할당도 상에 원이 만들어져야 (환형대기) - 충분조건은 아님!<br>자원에서 프로세스를 가르키면 프로세스가 자원을 할당받은 상태<br>프로세스에서 자원을 가르키면 자원을 요청한 상태</p>
<p>짝수번 철학자는 왼쪽들고 오른쪽 들고<br>홀수번 철학자는 오른쪽들고 왼쪽거 들기. 그러면 원형이 깨지게 되어 교착상태가 발생하지 않게된다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;읽기-쓰기 문제, 식사하는 철학자 문제&lt;/p&gt;
&lt;h3 id=&quot;Reader-amp-Writer&quot;&gt;&lt;a href=&quot;#Reader-amp-Writer&quot; class=&quot;headerlink&quot; title=&quot;Reader &amp;amp; Writer&quot;&gt;&lt;/a&gt;Read
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>13.전통적 동기화 문제, 생산자-소비자 문제</title>
    <link href="http://KKimSangHeon.github.io/2019/02/21/operating-system13/"/>
    <id>http://KKimSangHeon.github.io/2019/02/21/operating-system13/</id>
    <published>2019-02-21T13:10:14.000Z</published>
    <updated>2019-02-22T13:52:46.125Z</updated>
    
    <content type="html"><![CDATA[<p>OS에서 가장중요한게 프로세스 관리<br>이중 CPU 스케줄링, 프로세스 동기화가 중요하다.<br>이때 임계구역 처리를 잘해야한다.</p>
<h3 id="전통적-동기화-예제"><a href="#전통적-동기화-예제" class="headerlink" title="전통적 동기화 예제"></a>전통적 동기화 예제</h3><p>1.Producer and Consumer Problem(생산자-소비자 문제, 유한버퍼 문제 (Bounded Buffer Problem))<br>2.Readers-Writers Problem(공유 데이터베이스 접근)<br>3.Dining Philosopher Problem(식사하는 철학자 문제)</p>
<hr>
<h3 id="Producer-Consumer-Problem"><a href="#Producer-Consumer-Problem" class="headerlink" title="Producer-Consumer Problem"></a>Producer-Consumer Problem</h3><h4 id="생산자-소비자-문제"><a href="#생산자-소비자-문제" class="headerlink" title="생산자-소비자 문제"></a>생산자-소비자 문제</h4><p>생산자가 데이터를 생산하면 소비자는 그것을 소비<br>예: 컴파일러 &gt; 어셈블러, 파일 서버 &gt; 클라이언트, 웹 서버 &gt; 웹 클라이언트</p>
<h4 id="Bounded-Buffer"><a href="#Bounded-Buffer" class="headerlink" title="Bounded Buffer"></a>Bounded Buffer</h4><p>보통 생산소비와 소비속도는 다르다.<br>그래서 보통 창고(버퍼)에 저장하고 컨슈머가 조금씩 빼먹는다.</p>
<p>생산된 데이터는 버퍼에 일단 저장 (속도 차이 등)<br>현실 시스템에서 버퍼 크기는 유한<br>생산자는 버퍼가 가득 차면 더 넣을 수 없다.<br>소비자는 버퍼가 비면 뺄 수 없다</p>
<p>버퍼가 가득차면 생산자는 버퍼가 비워질때까지 기다려야한다.<br>버퍼가 비면 소비자는 빼갈것이 없다.</p>
<p>생산자가 10000번 넣고 소비자가 10000번 넣으면 0이되지 않을 수 있다.<br><code>이유</code> : 공통변수 count, buf[] 에 대한 동시 업데이트<br>공통변수 업데이트 구간(= 임계구역)에 대한 동시 진입</p>
<p><code>해결법</code> : 임계구역에 대한 동시 접근 방지 (상호배타)<br>세마포를 사용한 상호배타 (mutual exclusion, mutex)</p>
<h3 id="Busy-wait"><a href="#Busy-wait" class="headerlink" title="Busy-wait"></a>Busy-wait</h3><p>바쁘게 기다린다.<br>생산자: 버퍼가 가득 차면 기다려야 == 빈(empty) 공간이 있어야 한다<br>소비자: 버퍼가 비면 기다려야 == 찬(full) 공간이 있어야 한다</p>
<p>이때 무한루프를 돌면서 기다리면 CPU는 다른일을 못하고 잡히게 된다. -&gt; 비효율적<br><code>해결법</code> : 두개의 세마포어를 사용. empty의 초깃값은 BUF_SIZE 만큼 full의 초깃값은 0으로 하여 사용<br>생산자 :<br>empty.acquire();<br>PRODUCE;<br>full.release();</p>
<p>소비자 :<br>full.acquire();<br>CONSUME;</p>
<h2 id="empty-release"><a href="#empty-release" class="headerlink" title="empty.release();"></a>empty.release();</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OS에서 가장중요한게 프로세스 관리&lt;br&gt;이중 CPU 스케줄링, 프로세스 동기화가 중요하다.&lt;br&gt;이때 임계구역 처리를 잘해야한다.&lt;/p&gt;
&lt;h3 id=&quot;전통적-동기화-예제&quot;&gt;&lt;a href=&quot;#전통적-동기화-예제&quot; class=&quot;headerlink
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>12.세마포를 사용한 프로세스 동기화</title>
    <link href="http://KKimSangHeon.github.io/2019/02/20/operating-system12/"/>
    <id>http://KKimSangHeon.github.io/2019/02/20/operating-system12/</id>
    <published>2019-02-20T14:16:51.000Z</published>
    <updated>2019-02-20T14:17:22.281Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h3 id="프로세스-관리에서-중요한것들"><a href="#프로세스-관리에서-중요한것들" class="headerlink" title="프로세스 관리에서 중요한것들"></a>프로세스 관리에서 중요한것들</h3><p>CPU 스케줄링 : 이전포스팅 참고</p>
<p>프로세스(쓰레드) 동기화<br><code>필요이유</code> : 보통컴퓨터 안에있는 프로세스들은 독립적이지 않고 협조적이므로 즉 공통된 자원에 접근함<br><code>동기화가 되지 않으면?</code> : 누군가는 계속 입금하고 누군가는 출금하는 로직이 있을 때 다 더한값이 0이 아닐 수 있다.<br><code>임계구역</code> : 공통적으로 사용되는 부분</p>
<p><code>임계구역 문제 해결</code> : 상호베타, 진행, 유한대기 ( 모르겠으면 이전포스팅 보자)<br>우리가 원하는대로 프로세스 순서를 맞추는것.</p>
<h3 id="동기화-툴"><a href="#동기화-툴" class="headerlink" title="동기화 툴"></a>동기화 툴</h3><p><code>세마포어</code> : acquire P동작 release V동작이 있음<br>누가 CPU 서비스를 받다가 acquire를 호출했는데 if문이 만족하면 세마포어 큐안에 잡혀들어간다. 이 후 누가 wake를 시켜주면 다시 레디큐로 들어가게 된다.<br>세마포어는 Mutual exclusion을 위해 사용한다. 즉 크리티컬 섹션에는 한명만 들어갈 수 있다.</p>
<p>세마포어의 일반적 사용은 <u>Mutual exclusion</u> 그리고 <u>Ordering</u>으로 나뉜다.<br>그 중 Ordering를 구현하기 위해서는 다음과 같이 하면 된다.</p>
<p>P1    P2<br>S1    S2</p>
<p><code>P1, P2가 있을 때 P1을 먼저 실행하고자 할 때(Ordering)</code> : 세마포어의 value를 0으로 셋팅한다. 그 후 P2 앞에 sem.acquire를 호출한다.<br>이러면 P1이 먼저 호출되면 우리가 원하던 대로 되는것이고 그렇지 않고 P2가 먼저 실행될 경우 세마포어 큐에 들어가서 block이 된다. 아무튼 P1이 먼저 실행되게 되고 실행을 완료하면 release를 호출하여 P2가 실행 될 수 있도록 한다.<br>즉 다음과 같은 형태</p>
<p>P1        P2<br>        acquire<br>S1        S2<br>release</p>
<h3 id="세마포어-정리"><a href="#세마포어-정리" class="headerlink" title="세마포어 정리"></a>세마포어 정리</h3><p>세마포어는 임계구역 문제 해결, 프로세스 실행 순서 제어를 한다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h3 id=&quot;프로세스-관리에서-중요한것들&quot;&gt;&lt;a href=&quot;#프로세스-관리에서-중요한것들&quot; class=&quot;headerlink&quot; title=&quot;프로세스 관리에서 중요한것들&quot;&gt;&lt;/a&gt;프로세스 관리에서 중요한것들&lt;/h3&gt;&lt;p&gt;CPU 스케줄링 : 이전
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>11.임계구역 문제, 동기화 도구</title>
    <link href="http://KKimSangHeon.github.io/2019/02/19/operating-system11/"/>
    <id>http://KKimSangHeon.github.io/2019/02/19/operating-system11/</id>
    <published>2019-02-19T11:04:12.000Z</published>
    <updated>2019-02-20T14:16:20.363Z</updated>
    
    <content type="html"><![CDATA[<h3 id="임계구역-문제-critical-section-problem"><a href="#임계구역-문제-critical-section-problem" class="headerlink" title="임계구역 문제(critical-section problem)"></a>임계구역 문제(critical-section problem)</h3><p>여러개의 쓰레드로 이뤄진 시스템에서 각각의 쓰레드는 코드영역을 갖고있는데 이를 크리티컬 섹션이라한다. 또한 쓰레드로 부터 공통으로 사용되고 변경될 수 있는 부분을 의미한다.</p>
<p><u>어떤 복수개의 쓰레드들이 공통적으로 사용하는 부분.</u></p>
<h3 id="임계영역-해결"><a href="#임계영역-해결" class="headerlink" title="임계영역 해결"></a>임계영역 해결</h3><p>이를 해결하기 위해 다음 세가지가 만족되어야 한다.</p>
<p><code>Mutual exclusion (상호배타)</code>: 오직 한 쓰레드만 진입<br><code>Progress (진행)</code>: 진입 결정은 유한 시간 내. 즉 누가 먼저 들어가야되는지 유한시간내에 결정해야 한다.<br><code>Bounded waiting (유한대기)</code>: 어느 쓰레드라도 유한 시간 내 크리티컬 섹션안에 들어갈 수 있어야한다. 기다리는 시간이 한계가 정해져 있다.</p>
<h3 id="동기화의-목적"><a href="#동기화의-목적" class="headerlink" title="동기화의 목적"></a>동기화의 목적</h3><p><u>우리가 원하는대로 프로세스 혹은 쓰레드의 실행 순서를 결정 지을 수 있는것.</u></p>
<p>O/S 가 가진 여러 매니지먼트(프로세스 매니지먼트,메모리 매니지먼트,파일 시스템 매니지먼트, I/O 매니지먼트) 중 가장 중요한것은 프로세스 매니지먼트. 프로세스 매니지먼트는 두 가지로 나뉘는데 하나는 <u>CPU Scheduling, Synchronization</u></p>
<h3 id="Synchronization를-위한도구"><a href="#Synchronization를-위한도구" class="headerlink" title="Synchronization를 위한도구"></a>Synchronization를 위한도구</h3><p>세마포어 모니터가 있다.</p>
<p><code>Semaphores</code> : 기차역에서 출발신호를 의미하는 깃발이다. 네덜란드사람 딕스트라가 만듦.<br>내부구조는 정수 하나와 동작 두개로 구성된다. <u>하나는 P 동작 하나는 V 동작</u><br>P: Proberen (test) 즉 acquire()  검사<br>V: Verhogen (increment) 즉 release() 증가.</p>
<p>스택에는 푸쉬, 팝이라는 동작이 있다. 마찬가지로 세마포어도 내부에 정수가 있고 P,V가 존재한다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> </span>&#123;</div><div class="line">  value--;</div><div class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>) &#123;</div><div class="line">        add <span class="keyword">this</span> process/thread to list;  <span class="comment">// 누가 호출하면 큐안에 넣는다.</span></div><div class="line">        block;</div><div class="line">      &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</div><div class="line">  value++;</div><div class="line">    <span class="keyword">if</span> (value &lt;= <span class="number">0</span>) &#123;</div><div class="line">        remove a process P from list; <span class="comment">//누군가 갇혀있으면 깨워준다.</span></div><div class="line">        wakeup P;</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>저번에 배웠듯이 레디큐에서 CPU의 서비스를 받기 위해 기다리던 프로세스들이 CPU 서비스를 받다 IO를 만나면 IO서비스를 받으려 하는데 누가 IO서비스를 받고있다면 IO Queue(Device Queue)에서 대기하다 IO서비스를 받고 끝나면 다시 레디큐로 돌아온다.</p>
<p>타임쉐어링 시스템의 경우엔 IO를 만나지 않더라도 시간이 지나면 다시 레디큐로 돌아간다.</p>
<p>이는 프로세스의 큐잉 모델 즉 줄서서 기다리는 모델이다.</p>
<p>세마포어는 정수값도 있고 세마포어 큐도 있다. 어떤 프로세스가 레디큐에 있다 CPU를 쓰다가 acquire를 호출했는데 if문이 맞으면 갇혀버린다.(like 감옥) 이후에 누가 release를 해주면 감옥에서 탈출하여 다른 레디큐로 갈 수 있다.</p>
<p>위에서 value는 권한의 갯수로 생각하면 된다.</p>
<h3 id="세마포어는-Mutual-exclusion-상호베타를-위해-동작한다"><a href="#세마포어는-Mutual-exclusion-상호베타를-위해-동작한다" class="headerlink" title="세마포어는 Mutual exclusion 상호베타를 위해 동작한다."></a>세마포어는 Mutual exclusion 상호베타를 위해 동작한다.</h3><p>세마포어의 초깃값이 1이라 하자. 이때 레디큐에 A, B가 있다고 하자.<br>먼저 A가 acquire(); 을 호출하면 0이 되고 크리티컬 섹션 안으로 들어간다.(블록 걸리지 않음)<br>이때 컨텍스트 스위칭이 되고 B가 acquire를 호출하면 이때는 value가 -1이므로 세마포어 큐에 갇히게 된다.  (크리티컬 섹션 안으로 못들어간다). 그 후 A가 작업을 마치고 release를 호출하게 되면 value를 늘리고 세마포어 큐에 갇혀있는 B를 깨워 다시 레디큐로 들어가게 한다.</p>
<p> 이를 상호베타라 한다.</p>
<p><code>Monitors</code> :</p>
<p>메모리 매니지먼트라<br>파일 시스템 매니지먼트<br>I/O 매니지먼트</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;임계구역-문제-critical-section-problem&quot;&gt;&lt;a href=&quot;#임계구역-문제-critical-section-problem&quot; class=&quot;headerlink&quot; title=&quot;임계구역 문제(critical-section pro
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>10.프로세스 동기화의 중요성, 은행계좌 문제</title>
    <link href="http://KKimSangHeon.github.io/2019/02/18/operating-system10/"/>
    <id>http://KKimSangHeon.github.io/2019/02/18/operating-system10/</id>
    <published>2019-02-18T13:31:45.000Z</published>
    <updated>2019-02-18T13:34:32.742Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-쓰레드란"><a href="#1-쓰레드란" class="headerlink" title="1. 쓰레드란?"></a>1. 쓰레드란?</h3><p>프로그램 내부의 흐름, 맥</p>
<p>맥이 하나만 있는 프로그램 : 싱글쓰레드<br>여러개있는것: 멀티(다중)쓰레드</p>
<p>쓰레드가 여러개가 빠르게 동시에(왔다갔다하면서) 실행됨. 우리는 CPU하나임을 가정하고 공부하기 때문에</p>
<h3 id="1-1-쓰레드-구조"><a href="#1-1-쓰레드-구조" class="headerlink" title="1.1 쓰레드 구조"></a>1.1 쓰레드 구조</h3><p>프로세스의 메모리 공간 공유 : (code, data)<br>프로세스의 자원 공유 : (file, i/o, …)<br>비공유: 개별적인 PC, SP, registers, stack</p>
<p>운영체제의 프로세스 관리부서에서 중요한것은 프로세스 동기화 또는 쓰레드 동기화이다.</p>
<h3 id="프로세스는-크게-두가지로-나뉜다"><a href="#프로세스는-크게-두가지로-나뉜다" class="headerlink" title="프로세스는 크게 두가지로 나뉜다."></a>프로세스는 크게 두가지로 나뉜다.</h3><p>Independent process : p1, p2가 영향이 없다<br>Cooperating process : p1, p2가 영향을 주던지 받던지 한다. 이런경우가 훨씬 많다.<br>프로세스간 통신: 전자우편, 파일 전송<br>프로세스간 자원 공유: 메모리 상의 자료들, 데이터베이스 등<br>명절 기차표 예약, 대학 온라인 수강신청, 실시간 주식거래</p>
<h3 id="2-프로세스-쓰레드-동기화"><a href="#2-프로세스-쓰레드-동기화" class="headerlink" title="2. 프로세스(쓰레드) 동기화"></a>2. 프로세스(쓰레드) 동기화</h3><p><code>공통데이터에 접근하는것은 문제가 발생할 수 있다. (공유되는 프로세스가 동시에 접근할 때.)</code><br>동기화가 제대로 이뤄지지 않으면 똑같은 자리에 두명이상이 배정된다던가 하는 문제가 생긴다.</p>
<p><u>프로세스간에 순서를 잘 지정해서 이상한 상태에 빠지지 않도록 하여 데이터의 일관성을 유지</u></p>
<h3 id="2-1-BankAccount-Problem-은행계좌문제"><a href="#2-1-BankAccount-Problem-은행계좌문제" class="headerlink" title="2.1 BankAccount Problem (은행계좌문제)"></a>2.1 BankAccount Problem (은행계좌문제)</h3><p>부모님은 은행계좌에 입금; 자녀는 출금<br>입금(deposit)과 출금(withdraw) 은 독립적으로 일어난다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-쓰레드란&quot;&gt;&lt;a href=&quot;#1-쓰레드란&quot; class=&quot;headerlink&quot; title=&quot;1. 쓰레드란?&quot;&gt;&lt;/a&gt;1. 쓰레드란?&lt;/h3&gt;&lt;p&gt;프로그램 내부의 흐름, 맥&lt;/p&gt;
&lt;p&gt;맥이 하나만 있는 프로그램 : 싱글쓰레드&lt;br&gt;여러
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>9.다중 큐 스케쥴링, 프로세스 생성과 소멸, 쓰레드</title>
    <link href="http://KKimSangHeon.github.io/2019/02/18/operating-system9/"/>
    <id>http://KKimSangHeon.github.io/2019/02/18/operating-system9/</id>
    <published>2019-02-18T13:29:58.000Z</published>
    <updated>2019-02-18T13:31:23.624Z</updated>
    
    <content type="html"><![CDATA[<h3 id="다중-큐-스케쥴링-프로세스-생성과-소멸-쓰레드"><a href="#다중-큐-스케쥴링-프로세스-생성과-소멸-쓰레드" class="headerlink" title="다중 큐 스케쥴링, 프로세스 생성과 소멸, 쓰레드"></a>다중 큐 스케쥴링, 프로세스 생성과 소멸, 쓰레드</h3><h3 id="다양한-CPU-스케줄링-알고리즘"><a href="#다양한-CPU-스케줄링-알고리즘" class="headerlink" title="다양한 CPU 스케줄링 알고리즘"></a>다양한 CPU 스케줄링 알고리즘</h3><p>First-Come, First-Served (FCFS)<br>Shortest-Job-First (SJF)<br>Priority<br>Round-Robin (RR)<br>Multilevel Queue<br>Multilevel Feedback Queue</p>
<h3 id="1-Multilevel-Queue-Scheduling"><a href="#1-Multilevel-Queue-Scheduling" class="headerlink" title="1. Multilevel Queue Scheduling"></a>1. Multilevel Queue Scheduling</h3><h3 id="1-1-Process-groups-프로세스는-그룹별로-묶일-수-있다"><a href="#1-1-Process-groups-프로세스는-그룹별로-묶일-수-있다" class="headerlink" title="1.1 Process groups : 프로세스는 그룹별로 묶일 수 있다."></a>1.1 Process groups : 프로세스는 그룹별로 묶일 수 있다.</h3><p>System processes : 가장 긴급하고 먼저 처리되어야 하는것.<br>Interactive processes : 대화형 프로세스<br>Interactive editing processes : ex 워드프로세스<br>Batch processes : 인터액션이 따로 없다.<br>Student processes</p>
<p>성격이 다양한것을 동일한 큐에 세우는것이 맞지 않다라고 판단.<br>입출금은 빠르게 끝나는데 대출은 오래 끝나니까!<br>이를 위해 <u>큐를 여러개를 두자 이를 멀티레벨 큐</u>.</p>
<h3 id="1-2-Single-ready-queue-→-Several-separate-queues"><a href="#1-2-Single-ready-queue-→-Several-separate-queues" class="headerlink" title="1.2 Single ready queue → Several separate queues"></a>1.2 Single ready queue → Several separate queues</h3><p>각각의 Queue 에 절대적 우선순위 존재<br>또는 CPU time 을 각 Queue 에 차등배분<br>각 Queue 는 독립된 scheduling 정책</p>
<p>큐가 여러개이므로 우선순위를 둬서 차등반영한다.<br>또한 각 큐별로 다른 스케줄링 기법을 사용한다.</p>
<h3 id="2-Multilevel-Feedback-Queue-Scheduling"><a href="#2-Multilevel-Feedback-Queue-Scheduling" class="headerlink" title="2. Multilevel Feedback Queue Scheduling"></a>2. Multilevel Feedback Queue Scheduling</h3><p>큐를 여러개 둔다는점은 Multilevel Queue Scheduling와 같은데 <code>하나의 입구로 진입해서 거의 실행되지 않는다면 다른큐로 이동한다.</code></p>
<h3 id="2-1-다른-Queue-로의-점진적-이동"><a href="#2-1-다른-Queue-로의-점진적-이동" class="headerlink" title="2.1 다른 Queue 로의 점진적 이동"></a>2.1 다른 Queue 로의 점진적 이동</h3><p>모든 프로세스는 하나의 입구로 진입<br>너무 많은 CPU time 사용 시 다른 Queue 로<br>기아 상태 우려 시 우선순위 높은 Queue 로</p>
<p>상용운영체제는 여러 큐를 갖고있어 다양한 스케줄링 정책을 두어 적절히 활용한다.</p>
<h3 id="3-Process-Creation"><a href="#3-Process-Creation" class="headerlink" title="3. Process Creation"></a>3. Process Creation</h3><p>프로세스는 사람과 비슷하다. <u>프로세스는 프로세스에 의해 만들어진다.</u></p>
<p><code>그렇다면 제일 첫번째 프로세스는 어떻게 만들어졌을까??</code><br>O/S가 메모리로 올라가고 초기화 작업을 하면 제일 처음 프로세스를 만든다. 제일 첫번째 프로세스 이름을 유닉스의 경우 init프로세스(OS마다 다름)라 한다. 이 프로세스가 다른 프로세스를 만든다.</p>
<h3 id="3-1-Process-Identifier-PID"><a href="#3-1-Process-Identifier-PID" class="headerlink" title="3.1 Process Identifier (PID)"></a>3.1 Process Identifier (PID)</h3><p>사람의 주민등록번호와 같은것.<br>처음 만들어지는 프로그램은 0이다.<br>PPID? 부모 PID</p>
<h3 id="3-2-프로세스-생성"><a href="#3-2-프로세스-생성" class="headerlink" title="3.2 프로세스 생성"></a>3.2 프로세스 생성</h3><p>fork() system call - 새로운 프로세스 만드는것.<br>exec() - 만들어진 프로세스의 실행파일을 메모리로 갖고오는것.</p>
<h3 id="3-3-프로세스-종료"><a href="#3-3-프로세스-종료" class="headerlink" title="3.3 프로세스 종료"></a>3.3 프로세스 종료</h3><p>exit() system call - 해당 프로세스가 가졌던 모든 자원은 OS에게 반환 (메모리, 파일, 입출력장치 등)</p>
<h3 id="4-쓰레드"><a href="#4-쓰레드" class="headerlink" title="4. 쓰레드"></a>4. 쓰레드</h3><p><u>프로그램 내부의 흐름, 맥이라고 한다.</u></p>
<h3 id="4-1-다중-쓰레드-Multithreads"><a href="#4-1-다중-쓰레드-Multithreads" class="headerlink" title="4.1 다중 쓰레드(Multithreads)"></a>4.1 다중 쓰레드(Multithreads)</h3><p><u>하나의 프로그램에 맥이 2개이상 있는것.</u><br>맥이 빠른 시간 간격으로 스위칭 된다 →  여러 맥이 동시에 실행되는 것처럼 보인다<br>Web browser : 화면 출력하는 쓰레드 + 데이터 읽어오는 쓰레드<br>Word processor : 화면 출력하는 쓰레드 + 키보드 입력 받는 쓰레드 + 철자/문법오류 확인 쓰레드</p>
<p>이전강의까지는 P1이 끝나면 P2로 넘어간다 했는데 그건 예전의 OS이다.<br>즉 <u>현재의 컴퓨터는 컨텍스트 스위칭 단위가 프로세스가 아니라 쓰레드 단위이다</u>.</p>
<p>각 쓰레드는 코드와 데이터 공유하고 스택은 공유하지 않는다.</p>
<p>한 프로세스에는 기본 1개의 쓰레드 : <code>단일 쓰레드 (single thread) 프로그램</code><br>한 프로세스에 여러 개의 쓰레드 : <code>다중 쓰레드 (multi-thread) 프로그램</code></p>
<h3 id="4-2-쓰레드-구조"><a href="#4-2-쓰레드-구조" class="headerlink" title="4.2 쓰레드 구조"></a>4.2 쓰레드 구조</h3><p>프로세스의 메모리 공간 공유 : (code, data)<br>프로세스의 자원 공유 : (file, i/o, …)<br>비공유: 개별적인 PC, SP, registers, stack</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;다중-큐-스케쥴링-프로세스-생성과-소멸-쓰레드&quot;&gt;&lt;a href=&quot;#다중-큐-스케쥴링-프로세스-생성과-소멸-쓰레드&quot; class=&quot;headerlink&quot; title=&quot;다중 큐 스케쥴링, 프로세스 생성과 소멸, 쓰레드&quot;&gt;&lt;/a&gt;다중 큐 스케쥴링
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>8.SJF, Priority, RR 스케쥴링</title>
    <link href="http://KKimSangHeon.github.io/2019/02/16/operating-system8/"/>
    <id>http://KKimSangHeon.github.io/2019/02/16/operating-system8/</id>
    <published>2019-02-16T04:17:07.000Z</published>
    <updated>2019-02-17T11:46:28.048Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CPU-스케줄링-알고리즘"><a href="#CPU-스케줄링-알고리즘" class="headerlink" title="CPU 스케줄링 알고리즘"></a>CPU 스케줄링 알고리즘</h3><p><u>CPU 스케줄링은 레디큐에서 프로세스들이 CPU의 작업을 기다리고있을 때 누가 먼저 들어갈것인가에 대한것.</u></p>
<p>FCFS는 이전포스트 참고</p>
<p><code>AWT</code>를 평균대기시간이라 함.<br><code>ATT</code>를 Average turnaround time 반환시간이라함.</p>
<h3 id="SJF"><a href="#SJF" class="headerlink" title="SJF"></a>SJF</h3><p><u>가장 짧은것을 먼저하는것.</u><br>P1 6<br>P2 8<br>P3 7<br>P4 3<br>의 프로세스가있을 때 대기시간.</p>
<p>p4, p1,p3,p2의 순서로 진행된다.<br>평균 대기시간은 (3+16+9+0)/4 = 7 이다.<br>FCFS로 하면<br>(0+6+14+21) /4 = 10.25 이다.</p>
<p>실제로 프로세스가 얼마나 사용할지는 모른다. 해봐야 한다.<br>대기시간을 줄이기 위해 적절한 방법이긴 한데 CPU 사용시간을 예측을 해야한다.(이를 정확하게 예측하기 위해서는 과거를 기억해야 하는등 계산하는데 오버헤드가 발생한다.)</p>
<p>실제로 적용하기엔 어렵다!</p>
<p>Preemptive or Nonpreemtive 둘다 적용가능하다.</p>
<h3 id="Priority-Scheduling"><a href="#Priority-Scheduling" class="headerlink" title="Priority Scheduling"></a>Priority Scheduling</h3><p><u>우선순위가 높은것을 먼저 처리</u></p>
<p>우선순위는 내부적요소, 외부적 요소로 결정된다.<br>내부요소: 타임 리밋이 짧은것을 높게주기, 메모리 적게잡는놈 높게주기, IO가 길고 CPU burst가 짧은거 높게주기 등등<br>외부요소: 돈 많이 낸사람, 정치적요소</p>
<p>일반적으로 많이 사용된다.</p>
<p>이 또한 Preemptive or Nonpreemtive 둘다 적용가능하다.</p>
<p>문제점: 기아상태<br>우선순위가 낮은 프로세스가 기다리는데 우선순위 높은것들이 자꾸 들어온다면 아무리 기다려도 자기 차례가 오지 않는다.<br>해결방법 : againg 어떤 프로세스가 오래머물러 있다면 점진적으로 우선순위를 높여준다</p>
<h3 id="Round-Robin"><a href="#Round-Robin" class="headerlink" title="Round Robin"></a>Round Robin</h3><p><u>시간을 쪼개서 진행</u><br>Time quantum 시간양자 = time slice (보통 10 ~ 100msec으로 잡는)<br>Preemptive scheduling</p>
<p>타임퀀텀을 얼마로 잡느냐에 따라 AWT가 달라진다.<br>즉 Time quantum에 의존적이다<br>Time quantum을 무한대로 주면 FCFS와 동일하다</p>
<p>반대로 Time quantum을 0으로 주면 동시에 도는것과 같이느낄 수있다,<br>context switching overhead 가 발생함.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CPU-스케줄링-알고리즘&quot;&gt;&lt;a href=&quot;#CPU-스케줄링-알고리즘&quot; class=&quot;headerlink&quot; title=&quot;CPU 스케줄링 알고리즘&quot;&gt;&lt;/a&gt;CPU 스케줄링 알고리즘&lt;/h3&gt;&lt;p&gt;&lt;u&gt;CPU 스케줄링은 레디큐에서 프로세스들이 
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>7.스케쥴링 척도, FCFS</title>
    <link href="http://KKimSangHeon.github.io/2019/02/15/os7/"/>
    <id>http://KKimSangHeon.github.io/2019/02/15/os7/</id>
    <published>2019-02-15T12:27:56.000Z</published>
    <updated>2019-02-17T11:45:42.025Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CPU-스케쥴링"><a href="#CPU-스케쥴링" class="headerlink" title="CPU 스케쥴링"></a>CPU 스케쥴링</h3><p>프로그램은 하드디스크안에 들어있고 아무런 동작도 하지안흔다. 메인메모리에 올라가서 실행이 되면 활동한다.</p>
<p>활동중에 있는 프로그램을 프로세스라함.</p>
<p>프로세스에 대한 것들을 PCB안에 넣어놓는다.</p>
<p>컴퓨터 안에는 여러가지 큐가 있는데 <code>job queue, ready queue, device queue</code>가 있다.</p>
<p>메인메모리에 여러 프로그램이 올라와있는게 멀티 프로그래밍<br>프로그램이 몇개인가에 대한것이 Degree of multiprogramming</p>
<p><u>잡스케줄러가 하는일은 i/o-bound 를 CPU-bound process 적절히 분배하는것.</u></p>
<p><code>short-term scheduler</code> : <u>메모리에 올라온 프로세스들은 CPU를 받기위해 줄서있는데 어느놈을 선택해서 서비스해줄지에 대한것</u><br><code>Long-term scheduler</code> : 하드디스크에서 메인메모리에 올라가기 위해 <u>job queue에 대기하는 프로그램중 어느놈을 먼저 올려야하는지에 대한것</u></p>
<p>메인메모리에 올라온 프로세스중에 일정시간동안 사용되지 않는것을 물리적인 하드디스크에 Swap out 한다.<br><code>Medium-term scheduler</code> : Swap out 리스트중 어느것을 Swap in 할지에 대한것을 의미함.</p>
<p>하드디스크는 파일시스템목적, Backing store(물리적인 하드디스크에 Swap out할 때 목적지) 용도로 사용된다.</p>
<h3 id="Context-switching"><a href="#Context-switching" class="headerlink" title="Context switching"></a>Context switching</h3><p>CPU가 p1을 실행하다 p2로 넘어가는데 이를 문맥교환이라 한다.</p>
<h3 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h3><p>레디큐에 있는 놈 중 어느놈을 CPU로 보내줄까에 대한것.<br>지금있는 프로세스가 끝나면 어느놈을 선택할것인가에 대한것.<br>O/S안에 들어있는 컴퓨터 프로그램이다.</p>
<h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><p><u>스케줄러가 선택한 프로세스를 실행하도록 여러가지 상태를 변경해주는것.<br>p2가 선택되었다면 p2를 돌리기 위해 p1의 현재상태 프로그램카운터,스택포인터,레지스터,베이스레지스터 등을 P1의 PCB 에 저장해 놓아야한다.</u><br>즉 p1의 현재상태를 pcb1에 저장해놓는다. p2의 PCB에저장된 값을 복원(restore)<br>이런일을 하는것이 디스패처라 한다.<br>이런일을 하는것은 오버헤드(부담)이 발생하게 된다. 이를 Context Switching Overhead라고 한다.</p>
<p>즉 컨텍스트 스위칭을 자주하는것은 손해이다.<br>Dispatcher는 주로 어셈블리어와같은 low 레벨로 짜서 효율을 높인다.</p>
<h3 id="CPU스케줄링"><a href="#CPU스케줄링" class="headerlink" title="CPU스케줄링"></a>CPU스케줄링</h3><p>현재 실행중인 프로세스가 끝나면 어느것을 실행해줄까</p>
<h3 id="Preemptive-vs-Non-preemptive"><a href="#Preemptive-vs-Non-preemptive" class="headerlink" title="Preemptive vs Non-preemptive"></a>Preemptive vs Non-preemptive</h3><p><code>Preemptive</code> : CPU가 어떤일을 하고 있는데 IO를 만나거나 끝나지도 않았는데 강제로 끝내고 들어갈 수 있는것<br><code>Non-preemptive</code> : 이미 어떤프로세스가 실행중이면 끝나거나 IO를 만나지 않으면 변경되지 않는것</p>
<h3 id="Scheduling-criteria-척도"><a href="#Scheduling-criteria-척도" class="headerlink" title="Scheduling criteria(척도)"></a>Scheduling criteria(척도)</h3><p>특정 Scheduling 기법을 판단하는 기준</p>
<ul>
<li><p>CPU Utilization (CPU 이용률) : CPU가 놀지않고 얼마나 열심히 일하는가. a방법은 100%로 돌고 b방법은 80%로 들 때 a방법을 채택</p>
</li>
<li><p>Throughput (처리율) : 시간당 몇개의 작업을 처리하는가.</p>
</li>
<li><p>Turnaround time (반환시간) : 작업이 ready queue로 들어가 작업을 끝내고 나오는 시간.</p>
</li>
<li><p>Waiting time (대기시간) : CPU를 받기위해 ready queue에서 얼마나 기다려야 하는가. 당연히 짧을수록 좋다.</p>
</li>
<li><p>Response time (응답시간) : interactive 환경에서 중요하다. 처음 응답이 나올때 까지 걸리는 시간. 주로 대화형 컴퓨터에서 척도로 삼음</p>
</li>
</ul>
<p>기타 요소 존재….</p>
<hr>
<h3 id="First-Come-First-Served-FCFS"><a href="#First-Come-First-Served-FCFS" class="headerlink" title="First-Come, First-Served (FCFS)"></a>First-Come, First-Served (FCFS)</h3><p><u>먼저온놈을 먼저 처리해준다.</u>  - Non-preemptive schedulling<br>레디큐에 프로세스가 대기중이다.</p>
<p>p1은 burst time 24<br>p2는 3<br>p3는 3 일때</p>
<p>평균적으로 기다린 시간은 (0 +24 + 27)/3 = 17 이다.</p>
<p>P3,P2,P1 순으로 들어왔다고 할 경우 (0+3+6)/3 = 3 이라고 할 수 있다.<br>당연히 아래방식이 더 좋다.</p>
<p>간트차트 추가</p>
<p>즉 이런방식으로 해주면 평균 대기시간을 고려할 때 그리 좋은방법이 아니다.</p>
<p>Convoy Effect (호위효과) : CPU를 많이 잡아먹는놈이 앞에있으면 뒤에놈들이 오래 기다려야 한다.</p>
<h3 id="Shortest-Job-First-SJF"><a href="#Shortest-Job-First-SJF" class="headerlink" title="Shortest-Job-First (SJF)"></a>Shortest-Job-First (SJF)</h3><p><u>짧은 작업을 먼저 처리해준다.</u></p>
<h3 id="Shortest-Remaining-Time-First"><a href="#Shortest-Remaining-Time-First" class="headerlink" title="Shortest-Remaining-Time-First"></a>Shortest-Remaining-Time-First</h3><h3 id="Priority"><a href="#Priority" class="headerlink" title="Priority"></a>Priority</h3><h3 id="Round-Robin-RR"><a href="#Round-Robin-RR" class="headerlink" title="Round-Robin (RR)"></a>Round-Robin (RR)</h3><h3 id="Multilevel-Queue"><a href="#Multilevel-Queue" class="headerlink" title="Multilevel Queue"></a>Multilevel Queue</h3><h3 id="Multilevel-Feedback-Queue"><a href="#Multilevel-Feedback-Queue" class="headerlink" title="Multilevel Feedback Queue"></a>Multilevel Feedback Queue</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CPU-스케쥴링&quot;&gt;&lt;a href=&quot;#CPU-스케쥴링&quot; class=&quot;headerlink&quot; title=&quot;CPU 스케쥴링&quot;&gt;&lt;/a&gt;CPU 스케쥴링&lt;/h3&gt;&lt;p&gt;프로그램은 하드디스크안에 들어있고 아무런 동작도 하지안흔다. 메인메모리에 올라가서 
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>6.프로세스의 정의, CPU 스케쥴러, 멀티프로그래밍</title>
    <link href="http://KKimSangHeon.github.io/2019/02/15/os6/"/>
    <id>http://KKimSangHeon.github.io/2019/02/15/os6/</id>
    <published>2019-02-15T12:24:01.000Z</published>
    <updated>2019-02-22T14:32:45.181Z</updated>
    
    <content type="html"><![CDATA[<h3 id="프로세스-관리"><a href="#프로세스-관리" class="headerlink" title="프로세스 관리"></a>프로세스 관리</h3><p>CPU를 프로세스한테 어떻게 잘 나눠주는가에 대한것.</p>
<p>Process<br>실행중인 프로그램.</p>
<p>프로그램은 무덤속에 있는것. 프로세스는 살아있는것.<br>program in execution: text + data + stack, pc, sp, registers, …</p>
<h3 id="프로세스의-상태"><a href="#프로세스의-상태" class="headerlink" title="프로세스의 상태"></a>프로세스의 상태</h3><p>new - 메인 메모리로 올라온 상태.<br>ready - 실행할 준비가 모두 다 된상태 ( waiting이 끝나도 ready로 돌아옴)<br>running - CPU가 실행중인 상태 (CPU를 잡게된 상태)<br>waiting - 기다리는 상태. ( hwp 프로그램이 프린터를 요청하고 기다림. 즉 IO를 만나는 경우에도 wating상태가 된다,)<br>terminated - 끝난상태.</p>
<p>ready, running, wating의 반복으로 프로세스가 동작</p>
<p>타임쉐어링 시스템은 일정시간이 지나면 바로 ready 상태로 간다</p>
<h3 id="PCB-Process-Control-Block"><a href="#PCB-Process-Control-Block" class="headerlink" title="PCB(Process Control Block )"></a>PCB(Process Control Block )</h3><p>Task == Process<br>프로세스 제어 블록이며 Task Control Block (TCB) 이라고도 함.</p>
<p>PCB는 프로세스에 대한 모든 정보를 담고있다.<br><u>하나의 프로세스에 대해 PCB를 갖고있다. 다른 프로세스로 처리가 넘어가다러도 다시 돌아올 수 있도록 관리.</u><br>상태정보, PC(지금은 몇번지인지. 번지정보), registers, MMU info (base, limit), CPU time(CPU 이용시간), process id, list of open files(얘가 지금 어떤파일을 사용하고 있는지)…</p>
<p>PCB는 OS의 프로세스 관리 부서(프로세스 매니지먼트,모르겠으면 이전포스팅 참고) 안에 들어있다.</p>
<p>모든프로그램은 원래 하드디스크 안에 들어있다.  </p>
<h3 id="여러가지-Queue"><a href="#여러가지-Queue" class="headerlink" title="여러가지 Queue"></a>여러가지 Queue</h3><p>하드디스크에서 메모리로 올라가기 위해서는 줄서서 기다려야한다. 그런것을 <code>Job queue</code>라고 한다.</p>
<p>메인메모리에 올라와서 CPU를 받으려면 줄서야 하는데 이를 <code>Ready queue</code>라고 한다.</p>
<p>I/O를 사용하려 해도 줄서서 기다려야 한다. 이를 <code>Device queue</code> 라고 한다.</p>
<p>I/O를 끝내면 ready상태로 가는데 여기서도 줄서서 기다려야 한다.</p>
<hr>
<img src="/2019/02/15/os6/image1.png" alt="여러가지의 Queue" title="여러가지의 Queue">
<h3 id="Job-scheduling-Long-term-scheduler"><a href="#Job-scheduling-Long-term-scheduler" class="headerlink" title="Job scheduling(Long-term scheduler)"></a>Job scheduling(Long-term scheduler)</h3><p>하드디스크에서 메인메모리에 올라가기 위해 <u>job queue에 대기하는 프로그램중 어느놈을 먼저 올려야하는지에 대한것</u>을 <code>Job scheduling(Long-term scheduler)</code>라 한다. 잡 스케줄링은 역시 O/S 안에 프로세스 관리안에 존재한다.<br>일반적으로 프로세스가 끝나고 메모리가 비워져야 일어나기 때문에 Long-term scheduler 라고도 한다. 즉 스케줄러가 일어나는 시간이 몇분이 걸린다.</p>
<h3 id="CPU-Scheduler-Short-term-scheduler"><a href="#CPU-Scheduler-Short-term-scheduler" class="headerlink" title="CPU Scheduler( Short-term scheduler )"></a>CPU Scheduler( Short-term scheduler )</h3><p><u>메모리에 올라온 프로세스들은 CPU를 받기위해 줄서있는데 어느놈을 선택해서 서비스해줄지에 대한것</u>을 <code>CPU Scheduler( Short-term scheduler )</code>이라 한다.<br>메인 메모리에 여러 프로그램이 있는데 스위칭이 빠르게 일어난다. 1초에 수십번,수백번도 발생한다.  그래서 Short-term scheduler 라고도 부른다. <u>다른 스케줄링 보다도 가장 중요한 스케줄링이다.</u></p>
<h3 id="Device-Scheduler"><a href="#Device-Scheduler" class="headerlink" title="Device Scheduler"></a>Device Scheduler</h3><p>디바이스 서비스를 받기위해 기다리는것을 <code>Device Scheduler</code>이라 한다.</p>
<h3 id="멀티프로그래밍"><a href="#멀티프로그래밍" class="headerlink" title="멀티프로그래밍"></a>멀티프로그래밍</h3><p><u>메인메모리에 하나의 프로그램, 프로세스를 올리는것이 아니라 여러개를 올리는것.</u></p>
<p><code>Degree of multiprogramming</code> - 멀티프로그래밍의 정도 ( 메인메모리에 몇개의 프로세스가 올라와있는가)</p>
<h3 id="프로세스의-구분"><a href="#프로세스의-구분" class="headerlink" title="프로세스의 구분"></a>프로세스의 구분</h3><p>프로세스는 크게 두가지로 나눌 수 있다,<br>i/o-bound : 프로세스가 하는게 주로 I/O를 사용하는것(ex. 워드프로세서)<br>CPU-bound process  : 프로세스가 주로 cpu를 사용함.(ex. 일기예보와 같은 계산)</p>
<p>O/S는 작업을 적당히 섞어서 잡 스케줄링결과로 CPU 혹은 IO에만 작업이 치중해 한쪽이 놀지 않도록 한다.</p>
<h3 id="Medium-term-scheduler"><a href="#Medium-term-scheduler" class="headerlink" title="Medium-term scheduler"></a>Medium-term scheduler</h3><p>서버컴퓨터에 여러명이 사용중이라 가정하자. B라는 사람이 심심해서 커피를 마시러 갔다하자. 그동안 B를 위한 메모리는 올라와있지만 CPU는 아무역할도 하지 않는다. 즉 낭비다. B를 위한 자원을 쫒아내는것이 이득인데 이를 위해 디스크로 쫒아내고 비어있는 메모리공간을 확보한다. 여기서 쫒아내는 것을 <code>Swap out</code>라고 한다. 이처럼 디스크를 프로세스 이미지를 쫒아내는 목적으로 사용하는것을 <code>swap device</code> 라고 한다. 다시 B가 커피를 마시고 돌아와 마우스를 움직이면 Swap device로 갔던 프로세스를 불러들이는데 이를 <code>Swap in</code>이라 한다. swap device로 swap in되고 swap out 되는것을 Swapping 이라 한다.</p>
<p>이때 쫒겨났을때 쫒겨난 자리로 그대로 들어가는것을 보장하지는 않는다.</p>
<p>즉 Medium-term scheduler 는 현재 사용되고 있지 않은 어떤놈을 쫒아낼지 결정하는것이다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;프로세스-관리&quot;&gt;&lt;a href=&quot;#프로세스-관리&quot; class=&quot;headerlink&quot; title=&quot;프로세스 관리&quot;&gt;&lt;/a&gt;프로세스 관리&lt;/h3&gt;&lt;p&gt;CPU를 프로세스한테 어떻게 잘 나눠주는가에 대한것.&lt;/p&gt;
&lt;p&gt;Process&lt;br&gt;실행
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>5.운영체제의 주요 서비스 프로세스, 메모리, 파일관리, 시스템 호출</title>
    <link href="http://KKimSangHeon.github.io/2019/02/14/operating-system/"/>
    <id>http://KKimSangHeon.github.io/2019/02/14/operating-system/</id>
    <published>2019-02-14T13:01:23.000Z</published>
    <updated>2019-02-17T11:02:54.527Z</updated>
    
    <content type="html"><![CDATA[<h3 id="운영체제-서비스"><a href="#운영체제-서비스" class="headerlink" title="운영체제 서비스"></a>운영체제 서비스</h3><p>지금은 서버컴퓨터 하나에 여러명이 동시에 사용하는 구조.<br>이러한 구조에선 한사람이 잘못된 것을 할 경우 해악이 될 수있다.</p>
<p>다중유저시스템, 다중프로그래밍시스템에서 필요한 보호들</p>
<p>1.입출력장치 보호<br>A,B가 바로 하드웨어에 접근하지 못하도록 함<br>어떻게? In(입력),Out(출력) 명령을 특권명령으로 만들어 A,B는 이를 실행하지 못하고 O/S에게 부탁하여 실행토록 함.<br>그러면 O/S가 프린터를 구동시켜줌</p>
<p>2.메모리 보호<br>자기에게 넘어간 메모리 접근을 못하도록 하는것.<br>유저1이 OS영역이나 다른사람 영역을 못들어가도록 함.<br><code>어떻게?</code> MMU를 활용하여 base, limit 값을 넘지 못하도록한다. 넘을경우 인터럽트를 발생시켜 프로그램 강제종료</p>
<p>3.CPU 보호<br>while(a=1)…<br>위의 경우 CPU가 한 사용자에 독점되게 된다.<br><code>어떻게?</code> 타이머를 걸어서 일정시간이 지나면 인터럽트를 걸도록 한다.<br>인터럽트 서비스 루틴에는 CPU가 골고루 돌아가고 있는지. 한 프로그램에만 돌아가고 있지 않은지 파악하도록 짠다.<br>인터럽트 &gt; 운영체제 &gt; 다른 프로그램으로 강제 전환</p>
<h3 id="운영체제가-하는일"><a href="#운영체제가-하는일" class="headerlink" title="운영체제가 하는일"></a>운영체제가 하는일</h3><p>정부가 하는일과 비슷하다.<br>자원을 효율적으로 나눠주는 시스템을 OS라 한다.<br>모든애플리케이션은 하드웨어를사는데 이 하드웨어를 적절하게 분배하는것을 OS라 한다.</p>
<h4 id="프로세스-매니지먼트"><a href="#프로세스-매니지먼트" class="headerlink" title="프로세스 매니지먼트"></a>프로세스 매니지먼트</h4><p>이 중 CPU를 나눠주는 부분이 프로세스 매니지먼트</p>
<p>프로세스는 ? <u>메인 메모리에서 실행중인 프로그램. 실행상태에 있는 프로그램</u><br>하드디스크에는 많은 프로그램이 있지만 메인메모리로 올라와 있는 것을 프로세스라 함.<br>그래서 프로그램 매니지먼트라 하지않고 프로세스 매니지먼트라 함.</p>
<p>프로세스들이 많아지만 교착상태가 발생할 수 있는데 이를 프로세스 관리부분이 처리해준다.</p>
<h4 id="메인메모리-매니지먼트"><a href="#메인메모리-매니지먼트" class="headerlink" title="메인메모리 매니지먼트"></a>메인메모리 매니지먼트</h4><p>주기억장치를 나눠주는 부분이 메인메모리 매니지먼트</p>
<p>프로세스한테 메인메모리를 할당한다.<br>메모리의 어느 부분이 어느 프로세스에게 할당되었는가 추적 및 감시<br>프로세스 종료 시 메모리 회수 (deallocation)<br>메모리의 효과적 사용<br>가상 메모리: 물리적 실제 메모리보다 큰 용량 갖도록</p>
<h4 id="파일-매니지먼트"><a href="#파일-매니지먼트" class="headerlink" title="파일 매니지먼트"></a>파일 매니지먼트</h4><p>하드디스크 안에 파일을 관리하는것이 파일 매니지먼트</p>
<p>판 위에 트랙을 만들고 이를 잘라서 섹터라 한다. 즉 트랙, 섹터의 집합</p>
<p>파일을 만들기도 하고 없애기도 하고 디렉토리 생성 삭제에 관여<br><u>파일에 대한 기본동작(open, close, read, write, create, delete) 지원</u><br>백업(backup)</p>
<h4 id="보조기억장치관리-Secondary-storage-management"><a href="#보조기억장치관리-Secondary-storage-management" class="headerlink" title="보조기억장치관리(Secondary storage management)"></a>보조기억장치관리(Secondary storage management)</h4><p>보조기억장치는 트랙, 섹터의 집합인데 이를 어떻게 관리할것인가</p>
<p>하드 디스크, 플래시 메모리 등</p>
<p>섹터들을 모아서 block이라 하는데 block들에 데이터를 저장하게 되는데 빈 공간 관리, 저장공간 할당, 디스크 스케쥴링을 제공한다.</p>
<h4 id="입출력-장치-관리"><a href="#입출력-장치-관리" class="headerlink" title="입출력 장치 관리"></a>입출력 장치 관리</h4><p>장치드라이브 관리(웹켐, 사운드카드 등)<br>입출력 장치의 성능향상을 위해 버퍼링, 캐싱, 스풀링을 활용한다</p>
<p>스풀링 메모리 대신 하드디스크를 중간 매체로 사용한다.<br>스풀링 : 프린터는 일반적으로 느리기때문에 씨피유에 저장하기 보다는 씨피유보다 느리고 프린터 보다 빠른 하드디스크에 저장하는것.<br>빈 공간 관리 (free space management)<br>저장공간 할당 (storage allocation)<br>디스크 스케쥴링 (disk scheduling)</p>
<h4 id="네트워킹"><a href="#네트워킹" class="headerlink" title="네트워킹"></a>네트워킹</h4><h4 id="보호"><a href="#보호" class="headerlink" title="보호"></a>보호</h4><h4 id="기타-등등…"><a href="#기타-등등…" class="headerlink" title="기타 등등…"></a>기타 등등…</h4><h3 id="시스템-콜"><a href="#시스템-콜" class="headerlink" title="시스템 콜"></a>시스템 콜</h3><p><u>O/S가 제공하는 여러가지 기능을 받기 위해 호출하는것.</u></p>
<p>OS에는 여러가지 관리 부서가 있다.<br>또한 여러가지 프로그램이 메모리로 올라가 여러 프로세스가 존재한다,<br>각 프로세스는 OS가 제공하는 관리 기능들이 필요한데 이때 이를 사용하기 위한것이 시스템 콜이라 한다.</p>
<h3 id="주요-시스템-콜"><a href="#주요-시스템-콜" class="headerlink" title="주요 시스템 콜"></a>주요 시스템 콜</h3><p>– Process: end, abort, load, execute, create, terminate, get/set<br>attributes, wait event, signal event<br>– Memory: allocate, free<br>– File: create, delete, open, close, read, write, get/set attributes<br>– Device: request, release, read, write, get/set attributes, attach/detache devices<br>– Information: get/set time, get/set system data<br>– Communication: socket, send, receive</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;운영체제-서비스&quot;&gt;&lt;a href=&quot;#운영체제-서비스&quot; class=&quot;headerlink&quot; title=&quot;운영체제 서비스&quot;&gt;&lt;/a&gt;운영체제 서비스&lt;/h3&gt;&lt;p&gt;지금은 서버컴퓨터 하나에 여러명이 동시에 사용하는 구조.&lt;br&gt;이러한 구조에선 한사
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>4.사용자모드와 관리자모드, 하드웨어 보호</title>
    <link href="http://KKimSangHeon.github.io/2019/02/11/os4/"/>
    <id>http://KKimSangHeon.github.io/2019/02/11/os4/</id>
    <published>2019-02-11T12:29:11.000Z</published>
    <updated>2019-02-15T12:27:37.482Z</updated>
    
    <content type="html"><![CDATA[<h3 id="이중모드-하드웨어-보호"><a href="#이중모드-하드웨어-보호" class="headerlink" title="이중모드, 하드웨어 보호"></a>이중모드, 하드웨어 보호</h3><p>한 컴퓨터를 여러 사람이 동시에 사용하는 환경이다.<br>한사람의 실수가 전체에 영향을 끼칠 수  있으므로 일반유저는 STOP, HALT, RESET 등과같은 명령어는 일반 유저가 이용할 수 없도록 하는것. 이를 <code>이중모드</code>라 한다.</p>
<p>이를 <u>사용자(user)모드, 관리자(supervisor) 모드</u> 라고 한다.<br>관리자 모드 = 시스템 모드 = 모니터 모드 = 특권 모드<br>특권 명령(ex. STOP, HALT, RESET, SET_TIMER, SET_HW 등은 관리자 모드에서만 사용 가능)</p>
<h3 id="이중모드-동작방식"><a href="#이중모드-동작방식" class="headerlink" title="이중모드 동작방식"></a>이중모드 동작방식</h3><p>CPU안에 레지스터 ALU, 제어유닛이 있다,</p>
<p>레지스터는 비트들의 모음(32bit의 경우 32개가 있다.)<br>레지스터 비트는 carry,zero, negative, overflow 와 같은 플래그도 갖고있다,<br><u>또한 이중모드를 나타내기 위한 플래그(모니터 비트라 함) 또한 레즈스터에 존재한다.</u></p>
<p>모니터 비트가 1이면 시스템모드 0이면 유저모드이다.</p>
<h3 id="가령-게임을-실행하고-저장한다고-가정해보자"><a href="#가령-게임을-실행하고-저장한다고-가정해보자" class="headerlink" title="가령 게임을 실행하고 저장한다고 가정해보자."></a>가령 게임을 실행하고 저장한다고 가정해보자.</h3><p>1.처음 파워를 키면 부팅이 일어난다 이때는 모니터 비트가 1이다.(시스템 모드)<br>2.OS의 부트가 끝나고 특정 게임을 실행한다고 하자, 그럼 디스크에서 게임을 메모리로 갖고올 것이다.<br>3.그리고 실행이 게임으로 넘어갈 때 모니터 비트는 0 (유저모드)로 변경된다.<br>4.다시 게임내용을 하드디스크에 저장할 때는 OS에게 부탁(SWI,소프트웨어 인터럽트)하여 OS가 저장하게 한다(다른파일을 덮어쓰는지와 같은 부정한 행위를 하는지에 대한 판단을 하고 저장하게 해줌). 이때는 모니터 비트가 다시 1이된다. //물론 게임 자체적으로 디스크에 저장할 수 있지만 보안상의 이슈 존재!<br>5.저장을 완료하면 다시 게임 프로그램으로 돌아오고 모니터 비트가 0이된다.</p>
<p>운영체제 서비스 실행될 때는 관리자 모드<br>사용자 프로그램 실행될 때는 사용자 모드<br>하드웨어/소프트웨어 인터럽트 발생하면 관리자 모드<br>운영체제 서비스가 끝나면 다시 사용자 모드</p>
<h3 id="하드웨어-보호"><a href="#하드웨어-보호" class="headerlink" title="하드웨어 보호"></a>하드웨어 보호</h3><p>1.입출력장치에 대한 보호</p>
<p>하드웨어에 대한 적절한 보호가 없을 때의 경우<br>내가 프린트하는데 누가 방해할라고 그놈도 계속 프린트 명령을 보내는상황이 발생했을 때.<br>내가원하는 출력물, 상대가 원하는 출력물이 섞여서 나오는 경우가 생길 수 있다.</p>
<p>어떻게?<br><code>아무유저나 In,Out 명령을 내리지 못하도록 특권명령으로 한다.</code></p>
<h3 id="사용자가-입출력-명령을-직접-내린-경우"><a href="#사용자가-입출력-명령을-직접-내린-경우" class="headerlink" title="사용자가 입출력 명령을 직접 내린 경우?"></a>사용자가 입출력 명령을 직접 내린 경우?</h3><p>Privileged instruction violation 이라 하며 해당 프로그램을 강제로 중지시킨다.</p>
<h3 id="메모리-보호"><a href="#메모리-보호" class="headerlink" title="메모리 보호"></a>메모리 보호</h3><p>멀티프로그래밍, 타임쉐어링 프로그래밍에서는 동시에 여러프로그램이 돌고있다.<br>특정 프로그램이 돌면서 다른 프로그램 혹은 OS의 영역에 기웃거리지 못하게 한다.</p>
<p>어떻게?<br>메모리에 접근하려면 어드레스 버스를 통해야하는데 어드레스 버스에 문지기를 두어 자기것에만 접근하는지 확인한다.<br>확인할 때는 base, limit 를 참고한다. 잘못된 범위를 읽을 땐 인터럽트를 O/S로 보낸다. 잘못된 번지를 읽을 때 보내는 신호를 보통 <u>Segment violation</u> 라고 부른다.</p>
<p>여기서 문지기를 <code>MMU(Memory Management Unit)라고 한다. base 와 limit 사이에 들어오는지 확인하며 base와 limit는 OS가 관리한다. 또한 base와 limit는 아무나 설정하면 안되므로 특권명령으로 관리된다.</code></p>
<p>3.CPU 보호</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;이중모드-하드웨어-보호&quot;&gt;&lt;a href=&quot;#이중모드-하드웨어-보호&quot; class=&quot;headerlink&quot; title=&quot;이중모드, 하드웨어 보호&quot;&gt;&lt;/a&gt;이중모드, 하드웨어 보호&lt;/h3&gt;&lt;p&gt;한 컴퓨터를 여러 사람이 동시에 사용하는 환경이다.
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>3.최근의 고급운영체제, 인터럽트에 기반한 현대 운영체제</title>
    <link href="http://KKimSangHeon.github.io/2019/02/11/os3/"/>
    <id>http://KKimSangHeon.github.io/2019/02/11/os3/</id>
    <published>2019-02-11T10:49:46.000Z</published>
    <updated>2019-02-15T12:27:37.793Z</updated>
    
    <content type="html"><![CDATA[<h3 id="다중-프로세서-시스템"><a href="#다중-프로세서-시스템" class="headerlink" title="다중 프로세서 시스템"></a>다중 프로세서 시스템</h3><p>메모리는 하난데 CPU가 여러개이다. 이를 병렬 시스템이라고도 한다.<br>장점 :</p>
<ul>
<li>병렬 시스템을 통한 성능향상을 목표</li>
<li>비용 : 하나의 강한 CPU 보다 여러개의 저렴한 CPU로 구성하는것이 일반적으로 저렴하다.</li>
<li>신뢰성 제공 : 하나가 고장나도 다른 CPU로 돌릴 수 있다.</li>
</ul>
<p>CPU가 여러개일 때 운영체제를 다중 프로세서 운영체제라 한다. 또한 강결합이라 한다.</p>
<h3 id="분산-시스템"><a href="#분산-시스템" class="headerlink" title="분산 시스템"></a>분산 시스템</h3><p>멀티컴퓨터 시스템이라고도 하며 네트워크(LAN) 등으로 연결되어 있다.<br>이는 메인메모리가 따로있고 랜으로 연결되어있으므로 소결합이라 한다.<br>OS도 서로 다 따로따로 있다. 이를 분산 운영체제라 한다.</p>
<h3 id="다중프로세서-시스템-분산시스템의-공통점"><a href="#다중프로세서-시스템-분산시스템의-공통점" class="headerlink" title="다중프로세서 시스템, 분산시스템의 공통점"></a>다중프로세서 시스템, 분산시스템의 공통점</h3><p>신뢰성, 성능, 비용절감을 목표로 한다.</p>
<h3 id="실시간-시스템"><a href="#실시간-시스템" class="headerlink" title="실시간 시스템"></a>실시간 시스템</h3><p>특정 시간내에 반드시 연산이 끝나야 하는것.<br>시간제약 즉 Deadline를 정해둔다. 실시간 시스템은 네비게이션에서도 쓰인다. 실시간 경로안내할때 그 지점에 도착하기 전에 계산이 끝나야하기 때문에<br>주로 공장자동화, 군사, 항공, 우주 분야에서도 쓰인다.<br>실시간 시스템을 위한 운영체제는 실시간 운영체제(Real-time OS = RTOS)라 한다.</p>
<h3 id="인터럽트"><a href="#인터럽트" class="headerlink" title="인터럽트"></a>인터럽트</h3><p>현대 운영체제는 인터럽트 기반 시스템이다.</p>
<p>컴퓨터를 키면 ROM에 있는 부트로더가 디스크에서 O/S를 메모리로 갖고온다. 이를 부팅이라 한다.<br>이 후 운영체제는 메모리에 상주하게 된다.<br>이 다음에는 아이콘이 나타나고 깜빡거린다.<br>이러다 <u>우리가 마우스를 움직이면 전기신호가 발생하고 CPU에 인터럽트 선을 통해 전기신호를 올려준다</u>.<br>그럼 CPU는 지금하던일을 중지하고 OS안에 마우스가 어떤 전기신호를 보냈을 때 어떤 행동을 하라고 정의되어있는지(<u>mouse interrupt service routine</u>)에 따라 처리한다.</p>
<h3 id="하드웨어-인터럽트"><a href="#하드웨어-인터럽트" class="headerlink" title="하드웨어 인터럽트"></a>하드웨어 인터럽트</h3><p>인터럽트 결과 운영체제 내의 특정코드를 실행한다.(ISR)<br>interrupt Service Routine 종료 후 다시 대기</p>
<h3 id="소프트웨어-인터럽트"><a href="#소프트웨어-인터럽트" class="headerlink" title="소프트웨어 인터럽트"></a>소프트웨어 인터럽트</h3><p>SWI 명령어는 인터럽트가 걸리는것이다. 보통 인터럽트는 하드웨어가 걸리는데</p>
<p>SWI(Software interrupt) - ARM에서의 소프트웨어 인터럽트 명령<br>INT - 팬티엄에서의 인터럽트 명령</p>
<p>hwp 프로그램이 실행되다가 하드디스크에 있는 내용을 읽어온다고 가정하자.<br>하드디스크를 읽어오는 루틴은 O/S안에 존재한다. 이것또한 ISR이다. 아무튼 <u>하드디스크 내용을 읽기위해 소프트웨어 인터럽트가 걸리게 되고 O/S안에 있는 하드디스크를 읽어오는 루틴을 실행하고 원래 실행중인 곳으로 돌아온다.</u></p>
<h3 id="운영체제는-평소에는-대기상태이다"><a href="#운영체제는-평소에는-대기상태이다" class="headerlink" title="운영체제는 평소에는 대기상태이다"></a>운영체제는 평소에는 대기상태이다</h3><p><u>운영체제는 평소에는 대기상태이다. 그러나 하드웨어 인터럽트, 소프트웨어 인터럽트, 내부인터럽트에 의해 운영체제 코드를 실행한다.</u></p>
<p>내부 인터럽트는 5를 0으로 나누는것과 같은 논리적인 오류가 있을 때 발생하는 인터럽트이다. 이 땐 divide by zero를 처리하는 ISR이 호출된다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;다중-프로세서-시스템&quot;&gt;&lt;a href=&quot;#다중-프로세서-시스템&quot; class=&quot;headerlink&quot; title=&quot;다중 프로세서 시스템&quot;&gt;&lt;/a&gt;다중 프로세서 시스템&lt;/h3&gt;&lt;p&gt;메모리는 하난데 CPU가 여러개이다. 이를 병렬 시스템이라고도
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>2.일괄처리부터 시분할시스템까지 운영체제 변천 역사</title>
    <link href="http://KKimSangHeon.github.io/2019/02/10/os2/"/>
    <id>http://KKimSangHeon.github.io/2019/02/10/os2/</id>
    <published>2019-02-10T13:33:13.000Z</published>
    <updated>2019-02-15T12:27:36.853Z</updated>
    
    <content type="html"><![CDATA[<h3 id="컴퓨터의-역사"><a href="#컴퓨터의-역사" class="headerlink" title="컴퓨터의 역사"></a>컴퓨터의 역사</h3><p>2차세계 대전 중 1940년대 말 만들어졌다.</p>
<p><code>1.초기에는 운영체제가 존재하지 않았다.</code></p>
<p><code>2.이후엔 Batch processing system(일괄처리)이 나왔다</code><br>이는 최초의 O/S로 볼 수 있다.</p>
<p><code>3.Multiprogramming system</code><br>가령 수를 더해서 출력하고 다시 이를 특정 수를 반복해서 더하는 프로그램이 있다고 해보자.<br>수를 더하는것은 CPU가 할 것이고 출력은 입출력 장치가 하게될것이다.<br>이 때 CPU가 작업을 마치고 출력을 위해 입출력 장치가 출력을 실행하게 되면 느린 i/o의 성능으로 인해 CPU가 idle(노는시간) 즉 기다리는 시간이 생기게 된다. 이를 개선하기 위해 메모리에 여러 프로그램을 올리고 실행중인 프로그램이 <u>i/o</u>를 만나면 다른 프로그램을 실행토록 한다.</p>
<p><u>이를 통해 CPU가 노는 시간이 없도록한다.</u><br>이와 관련하여 <u>CPU scheduling</u>가 나오게된다. 어떤 순으로 실행하여 성능을 좋게할까에 대한 알고리즘이다.<br><u>메모리 관리</u>또한 나오게된다. 이는 적절하게 프로그램을 메모리에 배치하기 위한 기법이다.<br><u>보호</u>개념또한 등장하게 되는데 메모리에서 다른 프로그램의 영역에 침범하면 안되므로!</p>
<p><code>4.Time-sharing system</code><br>여러사람이 한 컴퓨터로 들어와 자신의 프로그램을 사용한다고 가정하자. 이 때 여러사람들은 Multiprogramming system에서는 동시에 사용하기란 불가능하다.(이는 I/O를 만나야 다른 프로그램을 동작시키는 로직이므로..)<br>그래서 <u>아주 짧은시간으로 나눠 여러 유저의 작업을 번갈아가며 CPU가 처리해주도록</u> 한다.</p>
<p>이러한 시스템이 등장하며 특정유저가 다른 유저에게 데이터를 주고받는것이 즉 <u>프로세스간 통신</u>이 가능해졌다.<br>또한 누가 먼저 앞서고 뒤서는지에 대한 <u>동기</u>라는 개념이 등장한다.<br>또한 하드디스크의 일부를 메인메모리인냥 사용하는 기술인 <u>가상 메모리</u> 또한 등장하게된다.</p>
<h3 id="OS-기술-천이"><a href="#OS-기술-천이" class="headerlink" title="OS 기술 천이"></a>OS 기술 천이</h3><p>컴퓨터의 규모별 분류는 다음과 같다.<br><code>과거의 분류 :</code><br>  Supercomputer &gt; Mainframe &gt; Mini &gt; Micro<br><code>현재의 분류 :</code><br>  Supercomputer &gt; Server &gt; Workstation &gt; PC &gt; Handheld &gt; Embedded<br>워크스테이션 : PC에서 처리못하는 조금 큰 작업 처리</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;컴퓨터의-역사&quot;&gt;&lt;a href=&quot;#컴퓨터의-역사&quot; class=&quot;headerlink&quot; title=&quot;컴퓨터의 역사&quot;&gt;&lt;/a&gt;컴퓨터의 역사&lt;/h3&gt;&lt;p&gt;2차세계 대전 중 1940년대 말 만들어졌다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1.초기에는 운영체제
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>1.	운영체제의 정의와 역할</title>
    <link href="http://KKimSangHeon.github.io/2019/02/10/os/"/>
    <id>http://KKimSangHeon.github.io/2019/02/10/os/</id>
    <published>2019-02-10T12:03:53.000Z</published>
    <updated>2019-02-22T14:15:21.308Z</updated>
    
    <content type="html"><![CDATA[<p>운영체제 포스팅은 <a href="http://www.kocw.net/home/search/kemView.do?kemId=978503" target="_blank" rel="external">http://www.kocw.net/home/search/kemView.do?kemId=978503</a> (KOCW) 를 참고하여 작성됩니다.</p>
<h3 id="운영체제가-없는-PC는-어떨까"><a href="#운영체제가-없는-PC는-어떨까" class="headerlink" title="운영체제가 없는 PC는 어떨까?"></a>운영체제가 없는 PC는 어떨까?</h3><p>야생마와 같다. 프로그램 실행과 같은 동작을 할 수 없게된다.<br>하드디스크에 있는 파일을 메모리에 올릴수 없다.<br>즉 하드디스크에 있는 파일을 운영체제가 올려주는것!</p>
<h3 id="운영체제란"><a href="#운영체제란" class="headerlink" title="운영체제란?"></a>운영체제란?</h3><p>하드웨어를 잘 관리하는것.(하드웨어: 프로세서, 메모리, 디스크…)<br>이를 통해 <code>성능을</code> 올리고 사용자에게 <code>편의성</code>을 제공</p>
<h3 id="부팅"><a href="#부팅" class="headerlink" title="부팅"></a>부팅</h3><p>메모리는 램, 롬으로 나뉜다. 대부분은 램으로 구성된다. 롬은 많아야 수백키로바이트밖에 되지 않는다,<br><code>그렇다면 ROM이 필요한 이유는?</code> 전원을 껐다 켜면 램의 데이터는 다 날라가는데 ROM은 그렇지 않다.</p>
<p>컴퓨터를 부팅하면 프로세서는 ROM에 있는 코드를 읽어온다.<br>그렇다면 <code>ROM에는 어떤 프로그램이 있으며 부팅과정은?</code><br>1.POST(Power On Self Test) 프로그램을 ROM에서 가져와 실행<br>  <code>POST?</code>  모니터는 끼워져있는가, 키보드는 꽂아져 있나, 메모리는 얼마인가 등을 확인하는 프로그램<br>2.부트로더(Boot loader)를 ROM에서 가져와 실행.<br>  <code>부트로더는?</code> 하드디스크를 뒤져서 os를 메인메모리(RAM)로 갖고온다. 이를 부팅이라 한다.</p>
<p>메모리에 올라온 OS는 컴퓨터가 종료될때 까지 지워지지 않는다. 하지만 다른 응용프로그램들은 프로그램 종료에 따라 지워지게된다. 그래서 OS를 <code>메모리 Resident</code>라고 한다.</p>
<img src="/2019/02/10/os/image1.png" alt="커널과 쉘" title="커널과 쉘">
<h3 id="커널과-쉘"><a href="#커널과-쉘" class="headerlink" title="커널과 쉘"></a>커널과 쉘</h3><p>OS는 하드웨어를 감싸고 있는데 하드웨어를 제외한 부분을 <code>kernel</code>이라고 한다. 또한 OS의 바깥부분을 <code>(shell,command interpreter)</code>이라 한다.</p>
<p>어떤 명령을 내릴 수 있도록 만드는것을 (<code>shell,command interpreter</code>)이라고 한다.<br>다시말해 <u>OS바깥부분에 위치해서 사용자의 명령을 받아들이는 곳. 그 명령을 인터프리터(해석해서) 명령을 실행해주는 것!</u></p>
<p><code>커널</code>은 실제로 <u>Cpu,메모리, 디스크를 관리하는것.</u></p>
<h3 id="응용프로그램-동작"><a href="#응용프로그램-동작" class="headerlink" title="응용프로그램 동작?"></a>응용프로그램 동작?</h3><p>응용프로그램은 O/S위에서 동작한다.<br>즉 맥킨토시 app을 윈도우에서 실행하면 동작하지 않는다.</p>
<h3 id="OS-는-정부와-비슷하다"><a href="#OS-는-정부와-비슷하다" class="headerlink" title="OS 는 정부와 비슷하다."></a>OS 는 정부와 비슷하다.</h3><p>주어진 자원을 어떻게 활용할까에 대한 고민을 하는것이 유사!</p>
<p>정부에도 여러가지 부서가 있듯이 OS안에도 많은 부서가 존재!</p>
<p>프로세스 매니지먼트 - 프로세스 관리부서<br>메모리 매니지먼트 - 메모리 관리<br>IO 매니지먼트 - 프린트, 키보드 관리<br>파일 매니지먼트 - 파일관리<br>네트워크 매니지먼트 - 네트워크 관리<br>시큐어티 매니지먼트 - 보안관리<br>…..<br>이런부분을 모두 운영체제의 커널로 불린다.</p>
<p>가장중요한것은 프로세스 매니지먼트! CPU가 가장비싸니까 가장 중요하고 프로그램 동작에 핵심이다.<br>그다음으로 중요한것이 메모리 매니지먼트</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;운영체제 포스팅은 &lt;a href=&quot;http://www.kocw.net/home/search/kemView.do?kemId=978503&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.kocw.net/home/searc
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>oneM2M, OMA-DM 생각정리..</title>
    <link href="http://KKimSangHeon.github.io/2019/02/08/mine/"/>
    <id>http://KKimSangHeon.github.io/2019/02/08/mine/</id>
    <published>2019-02-08T10:53:12.000Z</published>
    <updated>2019-02-10T08:02:03.813Z</updated>
    
    <content type="html"><![CDATA[<h3 id="oneM2M"><a href="#oneM2M" class="headerlink" title="oneM2M"></a>oneM2M</h3><p>iot 솔루션을 제공함에 있어 여러 벤더를 맞추기란 힘들다… oneM2M이라는 표준을 만들고 이를 여러 벤더가 맞춤으로써 응용개발사 또한 iot시스템을 개발함에 있어 개발공수를 낮출 수 있게된다.<br>oneM2M에는 CSE라는게 있는데 공통서비스를 제공하는것이다. 가령 데이터 저장, 요금청구 등등 다양하게 있다..</p>
<p>CSE는 REST 형태로 제공되어 편리하다는 장점이 있으며 최근에는 일반 응용개발에 oneM2M을 적용하여 CSE를 적절히 활용하는 경우도 있다. 이를 Distributed Platform 형태 라고 한다<br>통신사업자는 oneM2M 표준을 기반으로 CSE를 사용하는 플랫폼을 만들고 일반에 공개하게 되면 일반 개발자들은 통신사업자가 만든 플랫폼을 사용할 수 있게된다.(?? 맞는지 모르겠다.)</p>
<h3 id="OMA-DM"><a href="#OMA-DM" class="headerlink" title="OMA-DM"></a>OMA-DM</h3><p>이는 이동통신장치 관리표주으로서 내부 데이터에 접근하고 제어하는 표준이라 이해했다. xml기반 마크업 언어 SyncML 기반으로 명령과 결과를 주고받으며 심지어 운영체제 설치 그리고 응용프로그램의 파라미터 까지 변경이 가능하다고 한다. 여기서 관리할수 있는 자원을 <code>관리객체(MO, Management Object)</code>라고 한다.</p>
<h3 id="TR-069"><a href="#TR-069" class="headerlink" title="TR-069"></a>TR-069</h3><p>CPE WAN Management Protocol (CWMP) 이라 불리며 CPE 즉 사용자 단말을 관리하는 프로토콜인것같다.</p>
<h3 id="oneM2M과-OMA-DM의-상관관계"><a href="#oneM2M과-OMA-DM의-상관관계" class="headerlink" title="oneM2M과 OMA-DM의 상관관계???"></a>oneM2M과 OMA-DM의 상관관계???</h3><p>아래부터 개인적인생각입니다. 참고하지도 마세요!<br>oneM2M은 장치에서 받은 데이터를 활용하고 정제 저장하는 표준이라고 생각한다. 즉 디바이스의 정보를 뭐 제어하거나 어떻게 가져오는건 아니라 생각한다.<br>하지만 OMA-DM는 내부데이터 관리와 같은 디바이스 내부로 들어가는 표준인것같다.</p>
<p>아래 그림처럼 구분되나보다<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;oneM2M&quot;&gt;&lt;a href=&quot;#oneM2M&quot; class=&quot;headerlink&quot; title=&quot;oneM2M&quot;&gt;&lt;/a&gt;oneM2M&lt;/h3&gt;&lt;p&gt;iot 솔루션을 제공함에 있어 여러 벤더를 맞추기란 힘들다… oneM2M이라는 표준을 만들고 이를
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="IOT" scheme="http://KKimSangHeon.github.io/categories/CS/IOT/"/>
    
    
  </entry>
  
  <entry>
    <title>onem2m</title>
    <link href="http://KKimSangHeon.github.io/2019/02/08/onem2m/"/>
    <id>http://KKimSangHeon.github.io/2019/02/08/onem2m/</id>
    <published>2019-02-08T09:44:50.000Z</published>
    <updated>2019-02-08T10:39:25.022Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.youtube.com/watch?v=tBQ085PvR9E" target="_blank" rel="external">https://www.youtube.com/watch?v=tBQ085PvR9E</a> 요약</p>
<h3 id="IOT의-4계층"><a href="#IOT의-4계층" class="headerlink" title="IOT의 4계층"></a>IOT의 4계층</h3><p>Application layer - 스마트홈, 스마트카, 헬스케어<br>Service layer - IoT 서비스 개발이 용이하도록 공통으로 요구되는 기능 제공 <code>oneM2M, AllJoyn, OIC</code><br>Network layer - 장치 간 또는 서비스간 연결, 정보전달 <code>HTTP, CoAP, MQTT, Wi-Fi ...</code><br>Device layer - 센서 또는 다른 하드웨어</p>
<h3 id="oneM2M"><a href="#oneM2M" class="headerlink" title="oneM2M ?"></a>oneM2M ?</h3><p>IoT 응용 개발이 용이하도록 공통 기능을 제공하는 국제표준 플랫폼 기술</p>
<p>데이터관리, 연결 제어, 구독/통지, 보안, 그룹관리 ….</p>
<p>등을 제공하는데 응용 개발자는 이를 적절히 활용하여 개발공수를 줄일 수 있다.</p>
<h3 id="oneM2M발생이유"><a href="#oneM2M발생이유" class="headerlink" title="oneM2M발생이유"></a>oneM2M발생이유</h3><p>기존엔 응용이 특정한 디바이스를 타겟으로 개발되었다. 이를 개선할 수 있는것이 oneM2M</p>
<h3 id="oneM2M-1"><a href="#oneM2M-1" class="headerlink" title="oneM2M"></a>oneM2M</h3><p>먼저 Use Case를 기반으로 요구사항을 도출해봤더니 다음과 같았다.<br><code>일반요구사항:</code> 성능, 네트워크 연결지원에 따른 다양한 IoT장치 지원, QoS 기반 메시지 전달, 과금관리…<br><code>장치관리요구사항:</code> <u>OMA DM</u>/ BBF TR-069, 펌웨어, 소프트웨어 제어, 고장제어<br><code>보안 요구사항:</code>요청자에 대한 인증/권한 부여, 기반 네트워크 보안기능 활용</p>
<p>이를 기반으로 공통기능 CSE를 도출해냄<br>데이터관리 : 장치가 데이터를 저장할 수 없을때 플랫폼이 저장해준다<br>연결제어 : 레이턴시는 10ms 이하여야 한다.(예시)<br>구독. 통지 : 온도가 40도 이상이면 문자보내줘<br>과금 : 통신플랫폼의 사업자 이므로 이 또한 가능<br>이종 플랫폼 연동<br>사업자간 로밍 : 나의 커넥티드 카가 해외로 넘어가게 되면 로밍을 제공<br>기타 많은 공통기능 제공</p>
<p>oneM2M 안드로이드 플랫폼이랑 유사하다. CSE는 공통기능이 포함된 엔티티다.</p>
<p>AE를 카카오톡이라고 보면 좋다. 카톡은 안드로이드에 존재하는 간단한 API를 호출해 메세지를 보낸다.<br>즉 AE개발자는 CSE를 적절히 활용하면 된다.</p>
<p>여러플랫폼이 서로 연결되어 큰 iot를 만들어 낼 수 있게된다.</p>
<h3 id="Distributed-Platform-형태인-oneM2M"><a href="#Distributed-Platform-형태인-oneM2M" class="headerlink" title="Distributed Platform 형태인 oneM2M"></a>Distributed Platform 형태인 oneM2M</h3><p>IOT의 호출순서는 다음과 같다고 가정 하자.<br><code>디바이스 - 게이트웨이 - 클라우드 - 게이트웨이 - 디바이스</code><br>과거에는 클라우드에만 CSE를 탑재하여 호출하였지만 최근에는 게이트웨이, 디바이스에도 이를 탑재하여 분산처리를 한다.<br>물론 하드웨어의 용량이 부족할 경우 플랫폼 기능을 배제하기도 한다. 이 경우 <u>Constrained Device Support</u> 라고 한다.</p>
<h3 id="그렇다면-CSE를-어떻게-호출할까"><a href="#그렇다면-CSE를-어떻게-호출할까" class="headerlink" title="그렇다면 CSE를 어떻게 호출할까?"></a>그렇다면 CSE를 어떻게 호출할까?</h3><p>과거에는 RPC(Remote Procedure Call)을 활용하였지만 REST 기반 API구조를 사용한다.<br>CSE의 기능들을 REST 형태로 개방한다. 즉 URI만 갖고있으면 웹브라우저에서 기능을 호출할 수 있다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=tBQ085PvR9E&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.youtube.com/watch?v=tBQ085PvR9E&lt;/a&gt; 요약&lt;/
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="IOT" scheme="http://KKimSangHeon.github.io/categories/CS/IOT/"/>
    
    
  </entry>
  
</feed>
