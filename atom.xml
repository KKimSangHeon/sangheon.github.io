<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kim Sang Heon&#39;s Bolg</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://KKimSangHeon.github.io/"/>
  <updated>2019-02-21T13:12:27.326Z</updated>
  <id>http://KKimSangHeon.github.io/</id>
  
  <author>
    <name>Kim Sang Heon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>13.전통적 동기화 문제, 생산자-소비자 문제</title>
    <link href="http://KKimSangHeon.github.io/2019/02/21/operating-system13/"/>
    <id>http://KKimSangHeon.github.io/2019/02/21/operating-system13/</id>
    <published>2019-02-21T13:10:14.000Z</published>
    <updated>2019-02-21T13:12:27.326Z</updated>
    
    <content type="html"><![CDATA[<p>전통적 동기화 문제, 생산자-소비자 문제</p>
<p>OS에서 가장중요한게 프로세스 관리<br>이중 CPU 스케줄링, 프로세스 동기화가 중요하다.<br>이때 임계구역 처리를 잘해야한다.</p>
<h3 id="전통적-동기화-예제"><a href="#전통적-동기화-예제" class="headerlink" title="전통적 동기화 예제"></a>전통적 동기화 예제</h3><p>1.Producer and Consumer Problem(생산자-소비자 문제, 유한버퍼 문제 (Bounded Buffer Problem))<br>2.Readers-Writers Problem(공유 데이터베이스 접근)<br>3.Dining Philosopher Problem(식사하는 철학자 문제)</p>
<hr>
<h3 id="Producer-Consumer-Problem"><a href="#Producer-Consumer-Problem" class="headerlink" title="Producer-Consumer Problem"></a>Producer-Consumer Problem</h3><h4 id="생산자-소비자-문제"><a href="#생산자-소비자-문제" class="headerlink" title="생산자-소비자 문제"></a>생산자-소비자 문제</h4><p>생산자가 데이터를 생산하면 소비자는 그것을 소비<br>예: 컴파일러 &gt; 어셈블러, 파일 서버 &gt; 클라이언트, 웹 서버 &gt; 웹 클라이언트</p>
<h4 id="Bounded-Buffer"><a href="#Bounded-Buffer" class="headerlink" title="Bounded Buffer"></a>Bounded Buffer</h4><p>보통 생산소비와 소비속도는 다르다.<br>그래서 보통 창고(버퍼)에 저장하고 컨슈머가 조금씩 빼먹는다.</p>
<p>생산된 데이터는 버퍼에 일단 저장 (속도 차이 등)<br>현실 시스템에서 버퍼 크기는 유한<br>생산자는 버퍼가 가득 차면 더 넣을 수 없다.<br>소비자는 버퍼가 비면 뺄 수 없다</p>
<p>버퍼가 가득차면 생산자는 버퍼가 비워질때까지 기다려야한다.<br>버퍼가 비면 소비자는 빼갈것이 없다.</p>
<p>생산자가 10000번 넣고 소비자가 10000번 넣으면 0이되지 않을 수 있다.<br><code>이유</code> : 공통변수 count, buf[] 에 대한 동시 업데이트<br>공통변수 업데이트 구간(= 임계구역)에 대한 동시 진입</p>
<p><code>해결법</code> : 임계구역에 대한 동시 접근 방지 (상호배타)<br>세마포를 사용한 상호배타 (mutual exclusion, mutex)</p>
<h3 id="Busy-wait"><a href="#Busy-wait" class="headerlink" title="Busy-wait"></a>Busy-wait</h3><p>바쁘게 기다린다.<br>생산자: 버퍼가 가득 차면 기다려야 == 빈(empty) 공간이 있어야 한다<br>소비자: 버퍼가 비면 기다려야 == 찬(full) 공간이 있어야 한다</p>
<p>이때 무한루프를 돌면서 기다리면 CPU는 다른일을 못하고 잡히게 된다. -&gt; 비효율적<br><code>해결법</code> : 두개의 세마포어를 사용. empty의 초깃값은 BUF_SIZE 만큼 full의 초깃값은 0으로 하여 사용<br>생산자 :<br>empty.acquire();<br>PRODUCE;<br>full.release();</p>
<p>소비자 :<br>full.acquire();<br>CONSUME;</p>
<h2 id="empty-release"><a href="#empty-release" class="headerlink" title="empty.release();"></a>empty.release();</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;전통적 동기화 문제, 생산자-소비자 문제&lt;/p&gt;
&lt;p&gt;OS에서 가장중요한게 프로세스 관리&lt;br&gt;이중 CPU 스케줄링, 프로세스 동기화가 중요하다.&lt;br&gt;이때 임계구역 처리를 잘해야한다.&lt;/p&gt;
&lt;h3 id=&quot;전통적-동기화-예제&quot;&gt;&lt;a href=&quot;
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>12.세마포를 사용한 프로세스 동기화</title>
    <link href="http://KKimSangHeon.github.io/2019/02/20/operating-system12/"/>
    <id>http://KKimSangHeon.github.io/2019/02/20/operating-system12/</id>
    <published>2019-02-20T14:16:51.000Z</published>
    <updated>2019-02-20T14:17:22.281Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h3 id="프로세스-관리에서-중요한것들"><a href="#프로세스-관리에서-중요한것들" class="headerlink" title="프로세스 관리에서 중요한것들"></a>프로세스 관리에서 중요한것들</h3><p>CPU 스케줄링 : 이전포스팅 참고</p>
<p>프로세스(쓰레드) 동기화<br><code>필요이유</code> : 보통컴퓨터 안에있는 프로세스들은 독립적이지 않고 협조적이므로 즉 공통된 자원에 접근함<br><code>동기화가 되지 않으면?</code> : 누군가는 계속 입금하고 누군가는 출금하는 로직이 있을 때 다 더한값이 0이 아닐 수 있다.<br><code>임계구역</code> : 공통적으로 사용되는 부분</p>
<p><code>임계구역 문제 해결</code> : 상호베타, 진행, 유한대기 ( 모르겠으면 이전포스팅 보자)<br>우리가 원하는대로 프로세스 순서를 맞추는것.</p>
<h3 id="동기화-툴"><a href="#동기화-툴" class="headerlink" title="동기화 툴"></a>동기화 툴</h3><p><code>세마포어</code> : acquire P동작 release V동작이 있음<br>누가 CPU 서비스를 받다가 acquire를 호출했는데 if문이 만족하면 세마포어 큐안에 잡혀들어간다. 이 후 누가 wake를 시켜주면 다시 레디큐로 들어가게 된다.<br>세마포어는 Mutual exclusion을 위해 사용한다. 즉 크리티컬 섹션에는 한명만 들어갈 수 있다.</p>
<p>세마포어의 일반적 사용은 <u>Mutual exclusion</u> 그리고 <u>Ordering</u>으로 나뉜다.<br>그 중 Ordering를 구현하기 위해서는 다음과 같이 하면 된다.</p>
<p>P1    P2<br>S1    S2</p>
<p><code>P1, P2가 있을 때 P1을 먼저 실행하고자 할 때(Ordering)</code> : 세마포어의 value를 0으로 셋팅한다. 그 후 P2 앞에 sem.acquire를 호출한다.<br>이러면 P1이 먼저 호출되면 우리가 원하던 대로 되는것이고 그렇지 않고 P2가 먼저 실행될 경우 세마포어 큐에 들어가서 block이 된다. 아무튼 P1이 먼저 실행되게 되고 실행을 완료하면 release를 호출하여 P2가 실행 될 수 있도록 한다.<br>즉 다음과 같은 형태</p>
<p>P1        P2<br>        acquire<br>S1        S2<br>release</p>
<h3 id="세마포어-정리"><a href="#세마포어-정리" class="headerlink" title="세마포어 정리"></a>세마포어 정리</h3><p>세마포어는 임계구역 문제 해결, 프로세스 실행 순서 제어를 한다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h3 id=&quot;프로세스-관리에서-중요한것들&quot;&gt;&lt;a href=&quot;#프로세스-관리에서-중요한것들&quot; class=&quot;headerlink&quot; title=&quot;프로세스 관리에서 중요한것들&quot;&gt;&lt;/a&gt;프로세스 관리에서 중요한것들&lt;/h3&gt;&lt;p&gt;CPU 스케줄링 : 이전
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>11.임계구역 문제, 동기화 도구</title>
    <link href="http://KKimSangHeon.github.io/2019/02/19/operating-system11/"/>
    <id>http://KKimSangHeon.github.io/2019/02/19/operating-system11/</id>
    <published>2019-02-19T11:04:12.000Z</published>
    <updated>2019-02-20T14:16:20.363Z</updated>
    
    <content type="html"><![CDATA[<h3 id="임계구역-문제-critical-section-problem"><a href="#임계구역-문제-critical-section-problem" class="headerlink" title="임계구역 문제(critical-section problem)"></a>임계구역 문제(critical-section problem)</h3><p>여러개의 쓰레드로 이뤄진 시스템에서 각각의 쓰레드는 코드영역을 갖고있는데 이를 크리티컬 섹션이라한다. 또한 쓰레드로 부터 공통으로 사용되고 변경될 수 있는 부분을 의미한다.</p>
<p><u>어떤 복수개의 쓰레드들이 공통적으로 사용하는 부분.</u></p>
<h3 id="임계영역-해결"><a href="#임계영역-해결" class="headerlink" title="임계영역 해결"></a>임계영역 해결</h3><p>이를 해결하기 위해 다음 세가지가 만족되어야 한다.</p>
<p><code>Mutual exclusion (상호배타)</code>: 오직 한 쓰레드만 진입<br><code>Progress (진행)</code>: 진입 결정은 유한 시간 내. 즉 누가 먼저 들어가야되는지 유한시간내에 결정해야 한다.<br><code>Bounded waiting (유한대기)</code>: 어느 쓰레드라도 유한 시간 내 크리티컬 섹션안에 들어갈 수 있어야한다. 기다리는 시간이 한계가 정해져 있다.</p>
<h3 id="동기화의-목적"><a href="#동기화의-목적" class="headerlink" title="동기화의 목적"></a>동기화의 목적</h3><p><u>우리가 원하는대로 프로세스 혹은 쓰레드의 실행 순서를 결정 지을 수 있는것.</u></p>
<p>O/S 가 가진 여러 매니지먼트(프로세스 매니지먼트,메모리 매니지먼트,파일 시스템 매니지먼트, I/O 매니지먼트) 중 가장 중요한것은 프로세스 매니지먼트. 프로세스 매니지먼트는 두 가지로 나뉘는데 하나는 <u>CPU Scheduling, Synchronization</u></p>
<h3 id="Synchronization를-위한도구"><a href="#Synchronization를-위한도구" class="headerlink" title="Synchronization를 위한도구"></a>Synchronization를 위한도구</h3><p>세마포어 모니터가 있다.</p>
<p><code>Semaphores</code> : 기차역에서 출발신호를 의미하는 깃발이다. 네덜란드사람 딕스트라가 만듦.<br>내부구조는 정수 하나와 동작 두개로 구성된다. <u>하나는 P 동작 하나는 V 동작</u><br>P: Proberen (test) 즉 acquire()  검사<br>V: Verhogen (increment) 즉 release() 증가.</p>
<p>스택에는 푸쉬, 팝이라는 동작이 있다. 마찬가지로 세마포어도 내부에 정수가 있고 P,V가 존재한다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> </span>&#123;</div><div class="line">  value--;</div><div class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>) &#123;</div><div class="line">        add <span class="keyword">this</span> process/thread to list;  <span class="comment">// 누가 호출하면 큐안에 넣는다.</span></div><div class="line">        block;</div><div class="line">      &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</div><div class="line">  value++;</div><div class="line">    <span class="keyword">if</span> (value &lt;= <span class="number">0</span>) &#123;</div><div class="line">        remove a process P from list; <span class="comment">//누군가 갇혀있으면 깨워준다.</span></div><div class="line">        wakeup P;</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>저번에 배웠듯이 레디큐에서 CPU의 서비스를 받기 위해 기다리던 프로세스들이 CPU 서비스를 받다 IO를 만나면 IO서비스를 받으려 하는데 누가 IO서비스를 받고있다면 IO Queue(Device Queue)에서 대기하다 IO서비스를 받고 끝나면 다시 레디큐로 돌아온다.</p>
<p>타임쉐어링 시스템의 경우엔 IO를 만나지 않더라도 시간이 지나면 다시 레디큐로 돌아간다.</p>
<p>이는 프로세스의 큐잉 모델 즉 줄서서 기다리는 모델이다.</p>
<p>세마포어는 정수값도 있고 세마포어 큐도 있다. 어떤 프로세스가 레디큐에 있다 CPU를 쓰다가 acquire를 호출했는데 if문이 맞으면 갇혀버린다.(like 감옥) 이후에 누가 release를 해주면 감옥에서 탈출하여 다른 레디큐로 갈 수 있다.</p>
<p>위에서 value는 권한의 갯수로 생각하면 된다.</p>
<h3 id="세마포어는-Mutual-exclusion-상호베타를-위해-동작한다"><a href="#세마포어는-Mutual-exclusion-상호베타를-위해-동작한다" class="headerlink" title="세마포어는 Mutual exclusion 상호베타를 위해 동작한다."></a>세마포어는 Mutual exclusion 상호베타를 위해 동작한다.</h3><p>세마포어의 초깃값이 1이라 하자. 이때 레디큐에 A, B가 있다고 하자.<br>먼저 A가 acquire(); 을 호출하면 0이 되고 크리티컬 섹션 안으로 들어간다.(블록 걸리지 않음)<br>이때 컨텍스트 스위칭이 되고 B가 acquire를 호출하면 이때는 value가 -1이므로 세마포어 큐에 갇히게 된다.  (크리티컬 섹션 안으로 못들어간다). 그 후 A가 작업을 마치고 release를 호출하게 되면 value를 늘리고 세마포어 큐에 갇혀있는 B를 깨워 다시 레디큐로 들어가게 한다.</p>
<p> 이를 상호베타라 한다.</p>
<p><code>Monitors</code> :</p>
<p>메모리 매니지먼트라<br>파일 시스템 매니지먼트<br>I/O 매니지먼트</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;임계구역-문제-critical-section-problem&quot;&gt;&lt;a href=&quot;#임계구역-문제-critical-section-problem&quot; class=&quot;headerlink&quot; title=&quot;임계구역 문제(critical-section pro
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>10.프로세스 동기화의 중요성, 은행계좌 문제</title>
    <link href="http://KKimSangHeon.github.io/2019/02/18/operating-system10/"/>
    <id>http://KKimSangHeon.github.io/2019/02/18/operating-system10/</id>
    <published>2019-02-18T13:31:45.000Z</published>
    <updated>2019-02-18T13:34:32.742Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-쓰레드란"><a href="#1-쓰레드란" class="headerlink" title="1. 쓰레드란?"></a>1. 쓰레드란?</h3><p>프로그램 내부의 흐름, 맥</p>
<p>맥이 하나만 있는 프로그램 : 싱글쓰레드<br>여러개있는것: 멀티(다중)쓰레드</p>
<p>쓰레드가 여러개가 빠르게 동시에(왔다갔다하면서) 실행됨. 우리는 CPU하나임을 가정하고 공부하기 때문에</p>
<h3 id="1-1-쓰레드-구조"><a href="#1-1-쓰레드-구조" class="headerlink" title="1.1 쓰레드 구조"></a>1.1 쓰레드 구조</h3><p>프로세스의 메모리 공간 공유 : (code, data)<br>프로세스의 자원 공유 : (file, i/o, …)<br>비공유: 개별적인 PC, SP, registers, stack</p>
<p>운영체제의 프로세스 관리부서에서 중요한것은 프로세스 동기화 또는 쓰레드 동기화이다.</p>
<h3 id="프로세스는-크게-두가지로-나뉜다"><a href="#프로세스는-크게-두가지로-나뉜다" class="headerlink" title="프로세스는 크게 두가지로 나뉜다."></a>프로세스는 크게 두가지로 나뉜다.</h3><p>Independent process : p1, p2가 영향이 없다<br>Cooperating process : p1, p2가 영향을 주던지 받던지 한다. 이런경우가 훨씬 많다.<br>프로세스간 통신: 전자우편, 파일 전송<br>프로세스간 자원 공유: 메모리 상의 자료들, 데이터베이스 등<br>명절 기차표 예약, 대학 온라인 수강신청, 실시간 주식거래</p>
<h3 id="2-프로세스-쓰레드-동기화"><a href="#2-프로세스-쓰레드-동기화" class="headerlink" title="2. 프로세스(쓰레드) 동기화"></a>2. 프로세스(쓰레드) 동기화</h3><p><code>공통데이터에 접근하는것은 문제가 발생할 수 있다. (공유되는 프로세스가 동시에 접근할 때.)</code><br>동기화가 제대로 이뤄지지 않으면 똑같은 자리에 두명이상이 배정된다던가 하는 문제가 생긴다.</p>
<p><u>프로세스간에 순서를 잘 지정해서 이상한 상태에 빠지지 않도록 하여 데이터의 일관성을 유지</u></p>
<h3 id="2-1-BankAccount-Problem-은행계좌문제"><a href="#2-1-BankAccount-Problem-은행계좌문제" class="headerlink" title="2.1 BankAccount Problem (은행계좌문제)"></a>2.1 BankAccount Problem (은행계좌문제)</h3><p>부모님은 은행계좌에 입금; 자녀는 출금<br>입금(deposit)과 출금(withdraw) 은 독립적으로 일어난다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-쓰레드란&quot;&gt;&lt;a href=&quot;#1-쓰레드란&quot; class=&quot;headerlink&quot; title=&quot;1. 쓰레드란?&quot;&gt;&lt;/a&gt;1. 쓰레드란?&lt;/h3&gt;&lt;p&gt;프로그램 내부의 흐름, 맥&lt;/p&gt;
&lt;p&gt;맥이 하나만 있는 프로그램 : 싱글쓰레드&lt;br&gt;여러
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>9.다중 큐 스케쥴링, 프로세스 생성과 소멸, 쓰레드</title>
    <link href="http://KKimSangHeon.github.io/2019/02/18/operating-system9/"/>
    <id>http://KKimSangHeon.github.io/2019/02/18/operating-system9/</id>
    <published>2019-02-18T13:29:58.000Z</published>
    <updated>2019-02-18T13:31:23.624Z</updated>
    
    <content type="html"><![CDATA[<h3 id="다중-큐-스케쥴링-프로세스-생성과-소멸-쓰레드"><a href="#다중-큐-스케쥴링-프로세스-생성과-소멸-쓰레드" class="headerlink" title="다중 큐 스케쥴링, 프로세스 생성과 소멸, 쓰레드"></a>다중 큐 스케쥴링, 프로세스 생성과 소멸, 쓰레드</h3><h3 id="다양한-CPU-스케줄링-알고리즘"><a href="#다양한-CPU-스케줄링-알고리즘" class="headerlink" title="다양한 CPU 스케줄링 알고리즘"></a>다양한 CPU 스케줄링 알고리즘</h3><p>First-Come, First-Served (FCFS)<br>Shortest-Job-First (SJF)<br>Priority<br>Round-Robin (RR)<br>Multilevel Queue<br>Multilevel Feedback Queue</p>
<h3 id="1-Multilevel-Queue-Scheduling"><a href="#1-Multilevel-Queue-Scheduling" class="headerlink" title="1. Multilevel Queue Scheduling"></a>1. Multilevel Queue Scheduling</h3><h3 id="1-1-Process-groups-프로세스는-그룹별로-묶일-수-있다"><a href="#1-1-Process-groups-프로세스는-그룹별로-묶일-수-있다" class="headerlink" title="1.1 Process groups : 프로세스는 그룹별로 묶일 수 있다."></a>1.1 Process groups : 프로세스는 그룹별로 묶일 수 있다.</h3><p>System processes : 가장 긴급하고 먼저 처리되어야 하는것.<br>Interactive processes : 대화형 프로세스<br>Interactive editing processes : ex 워드프로세스<br>Batch processes : 인터액션이 따로 없다.<br>Student processes</p>
<p>성격이 다양한것을 동일한 큐에 세우는것이 맞지 않다라고 판단.<br>입출금은 빠르게 끝나는데 대출은 오래 끝나니까!<br>이를 위해 <u>큐를 여러개를 두자 이를 멀티레벨 큐</u>.</p>
<h3 id="1-2-Single-ready-queue-→-Several-separate-queues"><a href="#1-2-Single-ready-queue-→-Several-separate-queues" class="headerlink" title="1.2 Single ready queue → Several separate queues"></a>1.2 Single ready queue → Several separate queues</h3><p>각각의 Queue 에 절대적 우선순위 존재<br>또는 CPU time 을 각 Queue 에 차등배분<br>각 Queue 는 독립된 scheduling 정책</p>
<p>큐가 여러개이므로 우선순위를 둬서 차등반영한다.<br>또한 각 큐별로 다른 스케줄링 기법을 사용한다.</p>
<h3 id="2-Multilevel-Feedback-Queue-Scheduling"><a href="#2-Multilevel-Feedback-Queue-Scheduling" class="headerlink" title="2. Multilevel Feedback Queue Scheduling"></a>2. Multilevel Feedback Queue Scheduling</h3><p>큐를 여러개 둔다는점은 Multilevel Queue Scheduling와 같은데 <code>하나의 입구로 진입해서 거의 실행되지 않는다면 다른큐로 이동한다.</code></p>
<h3 id="2-1-다른-Queue-로의-점진적-이동"><a href="#2-1-다른-Queue-로의-점진적-이동" class="headerlink" title="2.1 다른 Queue 로의 점진적 이동"></a>2.1 다른 Queue 로의 점진적 이동</h3><p>모든 프로세스는 하나의 입구로 진입<br>너무 많은 CPU time 사용 시 다른 Queue 로<br>기아 상태 우려 시 우선순위 높은 Queue 로</p>
<p>상용운영체제는 여러 큐를 갖고있어 다양한 스케줄링 정책을 두어 적절히 활용한다.</p>
<h3 id="3-Process-Creation"><a href="#3-Process-Creation" class="headerlink" title="3. Process Creation"></a>3. Process Creation</h3><p>프로세스는 사람과 비슷하다. <u>프로세스는 프로세스에 의해 만들어진다.</u></p>
<p><code>그렇다면 제일 첫번째 프로세스는 어떻게 만들어졌을까??</code><br>O/S가 메모리로 올라가고 초기화 작업을 하면 제일 처음 프로세스를 만든다. 제일 첫번째 프로세스 이름을 유닉스의 경우 init프로세스(OS마다 다름)라 한다. 이 프로세스가 다른 프로세스를 만든다.</p>
<h3 id="3-1-Process-Identifier-PID"><a href="#3-1-Process-Identifier-PID" class="headerlink" title="3.1 Process Identifier (PID)"></a>3.1 Process Identifier (PID)</h3><p>사람의 주민등록번호와 같은것.<br>처음 만들어지는 프로그램은 0이다.<br>PPID? 부모 PID</p>
<h3 id="3-2-프로세스-생성"><a href="#3-2-프로세스-생성" class="headerlink" title="3.2 프로세스 생성"></a>3.2 프로세스 생성</h3><p>fork() system call - 새로운 프로세스 만드는것.<br>exec() - 만들어진 프로세스의 실행파일을 메모리로 갖고오는것.</p>
<h3 id="3-3-프로세스-종료"><a href="#3-3-프로세스-종료" class="headerlink" title="3.3 프로세스 종료"></a>3.3 프로세스 종료</h3><p>exit() system call - 해당 프로세스가 가졌던 모든 자원은 OS에게 반환 (메모리, 파일, 입출력장치 등)</p>
<h3 id="4-쓰레드"><a href="#4-쓰레드" class="headerlink" title="4. 쓰레드"></a>4. 쓰레드</h3><p><u>프로그램 내부의 흐름, 맥이라고 한다.</u></p>
<h3 id="4-1-다중-쓰레드-Multithreads"><a href="#4-1-다중-쓰레드-Multithreads" class="headerlink" title="4.1 다중 쓰레드(Multithreads)"></a>4.1 다중 쓰레드(Multithreads)</h3><p><u>하나의 프로그램에 맥이 2개이상 있는것.</u><br>맥이 빠른 시간 간격으로 스위칭 된다 →  여러 맥이 동시에 실행되는 것처럼 보인다<br>Web browser : 화면 출력하는 쓰레드 + 데이터 읽어오는 쓰레드<br>Word processor : 화면 출력하는 쓰레드 + 키보드 입력 받는 쓰레드 + 철자/문법오류 확인 쓰레드</p>
<p>이전강의까지는 P1이 끝나면 P2로 넘어간다 했는데 그건 예전의 OS이다.<br>즉 <u>현재의 컴퓨터는 컨텍스트 스위칭 단위가 프로세스가 아니라 쓰레드 단위이다</u>.</p>
<p>각 쓰레드는 코드와 데이터 공유하고 스택은 공유하지 않는다.</p>
<p>한 프로세스에는 기본 1개의 쓰레드 : <code>단일 쓰레드 (single thread) 프로그램</code><br>한 프로세스에 여러 개의 쓰레드 : <code>다중 쓰레드 (multi-thread) 프로그램</code></p>
<h3 id="4-2-쓰레드-구조"><a href="#4-2-쓰레드-구조" class="headerlink" title="4.2 쓰레드 구조"></a>4.2 쓰레드 구조</h3><p>프로세스의 메모리 공간 공유 : (code, data)<br>프로세스의 자원 공유 : (file, i/o, …)<br>비공유: 개별적인 PC, SP, registers, stack</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;다중-큐-스케쥴링-프로세스-생성과-소멸-쓰레드&quot;&gt;&lt;a href=&quot;#다중-큐-스케쥴링-프로세스-생성과-소멸-쓰레드&quot; class=&quot;headerlink&quot; title=&quot;다중 큐 스케쥴링, 프로세스 생성과 소멸, 쓰레드&quot;&gt;&lt;/a&gt;다중 큐 스케쥴링
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>8.SJF, Priority, RR 스케쥴링</title>
    <link href="http://KKimSangHeon.github.io/2019/02/16/operating-system8/"/>
    <id>http://KKimSangHeon.github.io/2019/02/16/operating-system8/</id>
    <published>2019-02-16T04:17:07.000Z</published>
    <updated>2019-02-17T11:46:28.048Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CPU-스케줄링-알고리즘"><a href="#CPU-스케줄링-알고리즘" class="headerlink" title="CPU 스케줄링 알고리즘"></a>CPU 스케줄링 알고리즘</h3><p><u>CPU 스케줄링은 레디큐에서 프로세스들이 CPU의 작업을 기다리고있을 때 누가 먼저 들어갈것인가에 대한것.</u></p>
<p>FCFS는 이전포스트 참고</p>
<p><code>AWT</code>를 평균대기시간이라 함.<br><code>ATT</code>를 Average turnaround time 반환시간이라함.</p>
<h3 id="SJF"><a href="#SJF" class="headerlink" title="SJF"></a>SJF</h3><p><u>가장 짧은것을 먼저하는것.</u><br>P1 6<br>P2 8<br>P3 7<br>P4 3<br>의 프로세스가있을 때 대기시간.</p>
<p>p4, p1,p3,p2의 순서로 진행된다.<br>평균 대기시간은 (3+16+9+0)/4 = 7 이다.<br>FCFS로 하면<br>(0+6+14+21) /4 = 10.25 이다.</p>
<p>실제로 프로세스가 얼마나 사용할지는 모른다. 해봐야 한다.<br>대기시간을 줄이기 위해 적절한 방법이긴 한데 CPU 사용시간을 예측을 해야한다.(이를 정확하게 예측하기 위해서는 과거를 기억해야 하는등 계산하는데 오버헤드가 발생한다.)</p>
<p>실제로 적용하기엔 어렵다!</p>
<p>Preemptive or Nonpreemtive 둘다 적용가능하다.</p>
<h3 id="Priority-Scheduling"><a href="#Priority-Scheduling" class="headerlink" title="Priority Scheduling"></a>Priority Scheduling</h3><p><u>우선순위가 높은것을 먼저 처리</u></p>
<p>우선순위는 내부적요소, 외부적 요소로 결정된다.<br>내부요소: 타임 리밋이 짧은것을 높게주기, 메모리 적게잡는놈 높게주기, IO가 길고 CPU burst가 짧은거 높게주기 등등<br>외부요소: 돈 많이 낸사람, 정치적요소</p>
<p>일반적으로 많이 사용된다.</p>
<p>이 또한 Preemptive or Nonpreemtive 둘다 적용가능하다.</p>
<p>문제점: 기아상태<br>우선순위가 낮은 프로세스가 기다리는데 우선순위 높은것들이 자꾸 들어온다면 아무리 기다려도 자기 차례가 오지 않는다.<br>해결방법 : againg 어떤 프로세스가 오래머물러 있다면 점진적으로 우선순위를 높여준다</p>
<h3 id="Round-Robin"><a href="#Round-Robin" class="headerlink" title="Round Robin"></a>Round Robin</h3><p><u>시간을 쪼개서 진행</u><br>Time quantum 시간양자 = time slice (보통 10 ~ 100msec으로 잡는)<br>Preemptive scheduling</p>
<p>타임퀀텀을 얼마로 잡느냐에 따라 AWT가 달라진다.<br>즉 Time quantum에 의존적이다<br>Time quantum을 무한대로 주면 FCFS와 동일하다</p>
<p>반대로 Time quantum을 0으로 주면 동시에 도는것과 같이느낄 수있다,<br>context switching overhead 가 발생함.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CPU-스케줄링-알고리즘&quot;&gt;&lt;a href=&quot;#CPU-스케줄링-알고리즘&quot; class=&quot;headerlink&quot; title=&quot;CPU 스케줄링 알고리즘&quot;&gt;&lt;/a&gt;CPU 스케줄링 알고리즘&lt;/h3&gt;&lt;p&gt;&lt;u&gt;CPU 스케줄링은 레디큐에서 프로세스들이 
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>7.스케쥴링 척도, FCFS</title>
    <link href="http://KKimSangHeon.github.io/2019/02/15/os7/"/>
    <id>http://KKimSangHeon.github.io/2019/02/15/os7/</id>
    <published>2019-02-15T12:27:56.000Z</published>
    <updated>2019-02-17T11:45:42.025Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CPU-스케쥴링"><a href="#CPU-스케쥴링" class="headerlink" title="CPU 스케쥴링"></a>CPU 스케쥴링</h3><p>프로그램은 하드디스크안에 들어있고 아무런 동작도 하지안흔다. 메인메모리에 올라가서 실행이 되면 활동한다.</p>
<p>활동중에 있는 프로그램을 프로세스라함.</p>
<p>프로세스에 대한 것들을 PCB안에 넣어놓는다.</p>
<p>컴퓨터 안에는 여러가지 큐가 있는데 <code>job queue, ready queue, device queue</code>가 있다.</p>
<p>메인메모리에 여러 프로그램이 올라와있는게 멀티 프로그래밍<br>프로그램이 몇개인가에 대한것이 Degree of multiprogramming</p>
<p><u>잡스케줄러가 하는일은 i/o-bound 를 CPU-bound process 적절히 분배하는것.</u></p>
<p><code>short-term scheduler</code> : <u>메모리에 올라온 프로세스들은 CPU를 받기위해 줄서있는데 어느놈을 선택해서 서비스해줄지에 대한것</u><br><code>Long-term scheduler</code> : 하드디스크에서 메인메모리에 올라가기 위해 <u>job queue에 대기하는 프로그램중 어느놈을 먼저 올려야하는지에 대한것</u></p>
<p>메인메모리에 올라온 프로세스중에 일정시간동안 사용되지 않는것을 물리적인 하드디스크에 Swap out 한다.<br><code>Medium-term scheduler</code> : Swap out 리스트중 어느것을 Swap in 할지에 대한것을 의미함.</p>
<p>하드디스크는 파일시스템목적, Backing store(물리적인 하드디스크에 Swap out할 때 목적지) 용도로 사용된다.</p>
<h3 id="Context-switching"><a href="#Context-switching" class="headerlink" title="Context switching"></a>Context switching</h3><p>CPU가 p1을 실행하다 p2로 넘어가는데 이를 문맥교환이라 한다.</p>
<h3 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h3><p>레디큐에 있는 놈 중 어느놈을 CPU로 보내줄까에 대한것.<br>지금있는 프로세스가 끝나면 어느놈을 선택할것인가에 대한것.<br>O/S안에 들어있는 컴퓨터 프로그램이다.</p>
<h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><p><u>스케줄러가 선택한 프로세스를 실행하도록 여러가지 상태를 변경해주는것.<br>p2가 선택되었다면 p2를 돌리기 위해 p1의 현재상태 프로그램카운터,스택포인터,레지스터,베이스레지스터 등을 P1의 PCB 에 저장해 놓아야한다.</u><br>즉 p1의 현재상태를 pcb1에 저장해놓는다. p2의 PCB에저장된 값을 복원(restore)<br>이런일을 하는것이 디스패처라 한다.<br>이런일을 하는것은 오버헤드(부담)이 발생하게 된다. 이를 Context Switching Overhead라고 한다.</p>
<p>즉 컨텍스트 스위칭을 자주하는것은 손해이다.<br>Dispatcher는 주로 어셈블리어와같은 low 레벨로 짜서 효율을 높인다.</p>
<h3 id="CPU스케줄링"><a href="#CPU스케줄링" class="headerlink" title="CPU스케줄링"></a>CPU스케줄링</h3><p>현재 실행중인 프로세스가 끝나면 어느것을 실행해줄까</p>
<h3 id="Preemptive-vs-Non-preemptive"><a href="#Preemptive-vs-Non-preemptive" class="headerlink" title="Preemptive vs Non-preemptive"></a>Preemptive vs Non-preemptive</h3><p><code>Preemptive</code> : CPU가 어떤일을 하고 있는데 IO를 만나거나 끝나지도 않았는데 강제로 끝내고 들어갈 수 있는것<br><code>Non-preemptive</code> : 이미 어떤프로세스가 실행중이면 끝나거나 IO를 만나지 않으면 변경되지 않는것</p>
<h3 id="Scheduling-criteria-척도"><a href="#Scheduling-criteria-척도" class="headerlink" title="Scheduling criteria(척도)"></a>Scheduling criteria(척도)</h3><p>특정 Scheduling 기법을 판단하는 기준</p>
<ul>
<li><p>CPU Utilization (CPU 이용률) : CPU가 놀지않고 얼마나 열심히 일하는가. a방법은 100%로 돌고 b방법은 80%로 들 때 a방법을 채택</p>
</li>
<li><p>Throughput (처리율) : 시간당 몇개의 작업을 처리하는가.</p>
</li>
<li><p>Turnaround time (반환시간) : 작업이 ready queue로 들어가 작업을 끝내고 나오는 시간.</p>
</li>
<li><p>Waiting time (대기시간) : CPU를 받기위해 ready queue에서 얼마나 기다려야 하는가. 당연히 짧을수록 좋다.</p>
</li>
<li><p>Response time (응답시간) : interactive 환경에서 중요하다. 처음 응답이 나올때 까지 걸리는 시간. 주로 대화형 컴퓨터에서 척도로 삼음</p>
</li>
</ul>
<p>기타 요소 존재….</p>
<hr>
<h3 id="First-Come-First-Served-FCFS"><a href="#First-Come-First-Served-FCFS" class="headerlink" title="First-Come, First-Served (FCFS)"></a>First-Come, First-Served (FCFS)</h3><p><u>먼저온놈을 먼저 처리해준다.</u>  - Non-preemptive schedulling<br>레디큐에 프로세스가 대기중이다.</p>
<p>p1은 burst time 24<br>p2는 3<br>p3는 3 일때</p>
<p>평균적으로 기다린 시간은 (0 +24 + 27)/3 = 17 이다.</p>
<p>P3,P2,P1 순으로 들어왔다고 할 경우 (0+3+6)/3 = 3 이라고 할 수 있다.<br>당연히 아래방식이 더 좋다.</p>
<p>간트차트 추가</p>
<p>즉 이런방식으로 해주면 평균 대기시간을 고려할 때 그리 좋은방법이 아니다.</p>
<p>Convoy Effect (호위효과) : CPU를 많이 잡아먹는놈이 앞에있으면 뒤에놈들이 오래 기다려야 한다.</p>
<h3 id="Shortest-Job-First-SJF"><a href="#Shortest-Job-First-SJF" class="headerlink" title="Shortest-Job-First (SJF)"></a>Shortest-Job-First (SJF)</h3><p><u>짧은 작업을 먼저 처리해준다.</u></p>
<h3 id="Shortest-Remaining-Time-First"><a href="#Shortest-Remaining-Time-First" class="headerlink" title="Shortest-Remaining-Time-First"></a>Shortest-Remaining-Time-First</h3><h3 id="Priority"><a href="#Priority" class="headerlink" title="Priority"></a>Priority</h3><h3 id="Round-Robin-RR"><a href="#Round-Robin-RR" class="headerlink" title="Round-Robin (RR)"></a>Round-Robin (RR)</h3><h3 id="Multilevel-Queue"><a href="#Multilevel-Queue" class="headerlink" title="Multilevel Queue"></a>Multilevel Queue</h3><h3 id="Multilevel-Feedback-Queue"><a href="#Multilevel-Feedback-Queue" class="headerlink" title="Multilevel Feedback Queue"></a>Multilevel Feedback Queue</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CPU-스케쥴링&quot;&gt;&lt;a href=&quot;#CPU-스케쥴링&quot; class=&quot;headerlink&quot; title=&quot;CPU 스케쥴링&quot;&gt;&lt;/a&gt;CPU 스케쥴링&lt;/h3&gt;&lt;p&gt;프로그램은 하드디스크안에 들어있고 아무런 동작도 하지안흔다. 메인메모리에 올라가서 
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>6.프로세스의 정의, CPU 스케쥴러, 멀티프로그래밍</title>
    <link href="http://KKimSangHeon.github.io/2019/02/15/os6/"/>
    <id>http://KKimSangHeon.github.io/2019/02/15/os6/</id>
    <published>2019-02-15T12:24:01.000Z</published>
    <updated>2019-02-17T11:13:03.347Z</updated>
    
    <content type="html"><![CDATA[<h3 id="프로세스-관리"><a href="#프로세스-관리" class="headerlink" title="프로세스 관리"></a>프로세스 관리</h3><p>CPU를 프로세스한테 어떻게 잘 나눠주는가에 대한것.</p>
<p>Process<br>실행중인 프로그램.</p>
<p>프로그램은 무덤속에 있는것. 프로세스는 살아있는것.<br>program in execution: text + data + stack, pc, sp, registers, …</p>
<h3 id="프로세스의-상태"><a href="#프로세스의-상태" class="headerlink" title="프로세스의 상태"></a>프로세스의 상태</h3><p>new - 메인 메모리로 올라온 상태.<br>ready - 실행할 준비가 모두 다 된상태 ( waiting이 끝나도 ready로 돌아옴)<br>running - CPU가 실행중인 상태 (CPU를 잡게된 상태)<br>waiting - 기다리는 상태. ( hwp 프로그램이 프린터를 요청하고 기다림. 즉 IO를 만나는 경우에도 wating상태가 된다,)<br>terminated - 끝난상태.</p>
<p>ready, running, wating의 반복으로 프로세스가 동작</p>
<p>타임쉐어링 시스템은 일정시간이 지나면 바로 ready 상태로 간다</p>
<h3 id="PCB-Process-Control-Block"><a href="#PCB-Process-Control-Block" class="headerlink" title="PCB(Process Control Block )"></a>PCB(Process Control Block )</h3><p>Task == Process<br>프로세스 제어 블록이며 Task Control Block (TCB) 이라고도 함.</p>
<p>PCB는 프로세스에 대한 모든 정보를 담고있다.<br><u>하나의 프로세스에 대해 PCB를 갖고있다. 다른 프로세스로 처리가 넘어가다러도 다시 돌아올 수 있도록 관리.</u><br>상태정보, PC(지금은 몇번지인지. 번지정보), registers, MMU info (base, limit), CPU time(CPU 이용시간), process id, list of open files(얘가 지금 어떤파일을 사용하고 있는지)…</p>
<p>PCB는 OS의 프로세스 관리 부서(프로세스 매니지먼트,모르겠으면 이전포스팅 참고) 안에 들어있다.</p>
<p>모든프로그램은 원래 하드디스크 안에 들어있다.  </p>
<h3 id="여러가지-Queue"><a href="#여러가지-Queue" class="headerlink" title="여러가지 Queue"></a>여러가지 Queue</h3><p>하드디스크에서 메모리로 올라가기 위해서는 줄서서 기다려야한다. 그런것을 <code>Job queue</code>라고 한다.</p>
<p>메인메모리에 올라와서 CPU를 받으려면 줄서야 하는데 이를 <code>Ready queue</code>라고 한다.</p>
<p>I/O를 사용하려 해도 줄서서 기다려야 한다. 이를 <code>Device queue</code> 라고 한다.</p>
<p>I/O를 끝내면 ready상태로 가는데 여기서도 줄서서 기다려야 한다.</p>
<hr>
<h3 id="Job-scheduling-Long-term-scheduler"><a href="#Job-scheduling-Long-term-scheduler" class="headerlink" title="Job scheduling(Long-term scheduler)"></a>Job scheduling(Long-term scheduler)</h3><p>하드디스크에서 메인메모리에 올라가기 위해 <u>job queue에 대기하는 프로그램중 어느놈을 먼저 올려야하는지에 대한것</u>을 <code>Job scheduling(Long-term scheduler)</code>라 한다. 잡 스케줄링은 역시 O/S 안에 프로세스 관리안에 존재한다.<br>일반적으로 프로세스가 끝나고 메모리가 비워져야 일어나기 때문에 Long-term scheduler 라고도 한다. 즉 스케줄러가 일어나는 시간이 몇분이 걸린다.</p>
<h3 id="CPU-Scheduler-Short-term-scheduler"><a href="#CPU-Scheduler-Short-term-scheduler" class="headerlink" title="CPU Scheduler( Short-term scheduler )"></a>CPU Scheduler( Short-term scheduler )</h3><p><u>메모리에 올라온 프로세스들은 CPU를 받기위해 줄서있는데 어느놈을 선택해서 서비스해줄지에 대한것</u>을 <code>CPU Scheduler( Short-term scheduler )</code>이라 한다.<br>메인 메모리에 여러 프로그램이 있는데 스위칭이 빠르게 일어난다. 1초에 수십번,수백번도 발생한다.  그래서 Short-term scheduler 라고도 부른다. <u>다른 스케줄링 보다도 가장 중요한 스케줄링이다.</u></p>
<h3 id="Device-Scheduler"><a href="#Device-Scheduler" class="headerlink" title="Device Scheduler"></a>Device Scheduler</h3><p>디바이스 서비스를 받기위해 기다리는것을 <code>Device Scheduler</code>이라 한다.</p>
<h3 id="멀티프로그래밍"><a href="#멀티프로그래밍" class="headerlink" title="멀티프로그래밍"></a>멀티프로그래밍</h3><p><u>메인메모리에 하나의 프로그램, 프로세스를 올리는것이 아니라 여러개를 올리는것.</u></p>
<p><code>Degree of multiprogramming</code> - 멀티프로그래밍의 정도 ( 메인메모리에 몇개의 프로세스가 올라와있는가)</p>
<h3 id="프로세스의-구분"><a href="#프로세스의-구분" class="headerlink" title="프로세스의 구분"></a>프로세스의 구분</h3><p>프로세스는 크게 두가지로 나눌 수 있다,<br>i/o-bound : 프로세스가 하는게 주로 I/O를 사용하는것(ex. 워드프로세서)<br>CPU-bound process  : 프로세스가 주로 cpu를 사용함.(ex. 일기예보와 같은 계산)</p>
<p>O/S는 작업을 적당히 섞어서 잡 스케줄링결과로 CPU 혹은 IO에만 작업이 치중해 한쪽이 놀지 않도록 한다.</p>
<h3 id="Medium-term-scheduler"><a href="#Medium-term-scheduler" class="headerlink" title="Medium-term scheduler"></a>Medium-term scheduler</h3><p>서버컴퓨터에 여러명이 사용중이라 가정하자. B라는 사람이 심심해서 커피를 마시러 갔다하자. 그동안 B를 위한 메모리는 올라와있지만 CPU는 아무역할도 하지 않는다. 즉 낭비다. B를 위한 자원을 쫒아내는것이 이득인데 이를 위해 디스크로 쫒아내고 비어있는 메모리공간을 확보한다. 여기서 쫒아내는 것을 <code>Swap out</code>라고 한다. 이처럼 디스크를 프로세스 이미지를 쫒아내는 목적으로 사용하는것을 <code>swap device</code> 라고 한다. 다시 B가 커피를 마시고 돌아와 마우스를 움직이면 Swap device로 갔던 프로세스를 불러들이는데 이를 <code>Swap in</code>이라 한다. swap device로 swap in되고 swap out 되는것을 Swapping 이라 한다.</p>
<p>이때 쫒겨났을때 쫒겨난 자리로 그대로 들어가는것을 보장하지는 않는다.</p>
<p>즉 Medium-term scheduler 는 현재 사용되고 있지 않은 어떤놈을 쫒아낼지 결정하는것이다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;프로세스-관리&quot;&gt;&lt;a href=&quot;#프로세스-관리&quot; class=&quot;headerlink&quot; title=&quot;프로세스 관리&quot;&gt;&lt;/a&gt;프로세스 관리&lt;/h3&gt;&lt;p&gt;CPU를 프로세스한테 어떻게 잘 나눠주는가에 대한것.&lt;/p&gt;
&lt;p&gt;Process&lt;br&gt;실행
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>5.운영체제의 주요 서비스 프로세스, 메모리, 파일관리, 시스템 호출</title>
    <link href="http://KKimSangHeon.github.io/2019/02/14/operating-system/"/>
    <id>http://KKimSangHeon.github.io/2019/02/14/operating-system/</id>
    <published>2019-02-14T13:01:23.000Z</published>
    <updated>2019-02-17T11:02:54.527Z</updated>
    
    <content type="html"><![CDATA[<h3 id="운영체제-서비스"><a href="#운영체제-서비스" class="headerlink" title="운영체제 서비스"></a>운영체제 서비스</h3><p>지금은 서버컴퓨터 하나에 여러명이 동시에 사용하는 구조.<br>이러한 구조에선 한사람이 잘못된 것을 할 경우 해악이 될 수있다.</p>
<p>다중유저시스템, 다중프로그래밍시스템에서 필요한 보호들</p>
<p>1.입출력장치 보호<br>A,B가 바로 하드웨어에 접근하지 못하도록 함<br>어떻게? In(입력),Out(출력) 명령을 특권명령으로 만들어 A,B는 이를 실행하지 못하고 O/S에게 부탁하여 실행토록 함.<br>그러면 O/S가 프린터를 구동시켜줌</p>
<p>2.메모리 보호<br>자기에게 넘어간 메모리 접근을 못하도록 하는것.<br>유저1이 OS영역이나 다른사람 영역을 못들어가도록 함.<br><code>어떻게?</code> MMU를 활용하여 base, limit 값을 넘지 못하도록한다. 넘을경우 인터럽트를 발생시켜 프로그램 강제종료</p>
<p>3.CPU 보호<br>while(a=1)…<br>위의 경우 CPU가 한 사용자에 독점되게 된다.<br><code>어떻게?</code> 타이머를 걸어서 일정시간이 지나면 인터럽트를 걸도록 한다.<br>인터럽트 서비스 루틴에는 CPU가 골고루 돌아가고 있는지. 한 프로그램에만 돌아가고 있지 않은지 파악하도록 짠다.<br>인터럽트 &gt; 운영체제 &gt; 다른 프로그램으로 강제 전환</p>
<h3 id="운영체제가-하는일"><a href="#운영체제가-하는일" class="headerlink" title="운영체제가 하는일"></a>운영체제가 하는일</h3><p>정부가 하는일과 비슷하다.<br>자원을 효율적으로 나눠주는 시스템을 OS라 한다.<br>모든애플리케이션은 하드웨어를사는데 이 하드웨어를 적절하게 분배하는것을 OS라 한다.</p>
<h4 id="프로세스-매니지먼트"><a href="#프로세스-매니지먼트" class="headerlink" title="프로세스 매니지먼트"></a>프로세스 매니지먼트</h4><p>이 중 CPU를 나눠주는 부분이 프로세스 매니지먼트</p>
<p>프로세스는 ? <u>메인 메모리에서 실행중인 프로그램. 실행상태에 있는 프로그램</u><br>하드디스크에는 많은 프로그램이 있지만 메인메모리로 올라와 있는 것을 프로세스라 함.<br>그래서 프로그램 매니지먼트라 하지않고 프로세스 매니지먼트라 함.</p>
<p>프로세스들이 많아지만 교착상태가 발생할 수 있는데 이를 프로세스 관리부분이 처리해준다.</p>
<h4 id="메인메모리-매니지먼트"><a href="#메인메모리-매니지먼트" class="headerlink" title="메인메모리 매니지먼트"></a>메인메모리 매니지먼트</h4><p>주기억장치를 나눠주는 부분이 메인메모리 매니지먼트</p>
<p>프로세스한테 메인메모리를 할당한다.<br>메모리의 어느 부분이 어느 프로세스에게 할당되었는가 추적 및 감시<br>프로세스 종료 시 메모리 회수 (deallocation)<br>메모리의 효과적 사용<br>가상 메모리: 물리적 실제 메모리보다 큰 용량 갖도록</p>
<h4 id="파일-매니지먼트"><a href="#파일-매니지먼트" class="headerlink" title="파일 매니지먼트"></a>파일 매니지먼트</h4><p>하드디스크 안에 파일을 관리하는것이 파일 매니지먼트</p>
<p>판 위에 트랙을 만들고 이를 잘라서 섹터라 한다. 즉 트랙, 섹터의 집합</p>
<p>파일을 만들기도 하고 없애기도 하고 디렉토리 생성 삭제에 관여<br><u>파일에 대한 기본동작(open, close, read, write, create, delete) 지원</u><br>백업(backup)</p>
<h4 id="보조기억장치관리-Secondary-storage-management"><a href="#보조기억장치관리-Secondary-storage-management" class="headerlink" title="보조기억장치관리(Secondary storage management)"></a>보조기억장치관리(Secondary storage management)</h4><p>보조기억장치는 트랙, 섹터의 집합인데 이를 어떻게 관리할것인가</p>
<p>하드 디스크, 플래시 메모리 등</p>
<p>섹터들을 모아서 block이라 하는데 block들에 데이터를 저장하게 되는데 빈 공간 관리, 저장공간 할당, 디스크 스케쥴링을 제공한다.</p>
<h4 id="입출력-장치-관리"><a href="#입출력-장치-관리" class="headerlink" title="입출력 장치 관리"></a>입출력 장치 관리</h4><p>장치드라이브 관리(웹켐, 사운드카드 등)<br>입출력 장치의 성능향상을 위해 버퍼링, 캐싱, 스풀링을 활용한다</p>
<p>스풀링 메모리 대신 하드디스크를 중간 매체로 사용한다.<br>스풀링 : 프린터는 일반적으로 느리기때문에 씨피유에 저장하기 보다는 씨피유보다 느리고 프린터 보다 빠른 하드디스크에 저장하는것.<br>빈 공간 관리 (free space management)<br>저장공간 할당 (storage allocation)<br>디스크 스케쥴링 (disk scheduling)</p>
<h4 id="네트워킹"><a href="#네트워킹" class="headerlink" title="네트워킹"></a>네트워킹</h4><h4 id="보호"><a href="#보호" class="headerlink" title="보호"></a>보호</h4><h4 id="기타-등등…"><a href="#기타-등등…" class="headerlink" title="기타 등등…"></a>기타 등등…</h4><h3 id="시스템-콜"><a href="#시스템-콜" class="headerlink" title="시스템 콜"></a>시스템 콜</h3><p><u>O/S가 제공하는 여러가지 기능을 받기 위해 호출하는것.</u></p>
<p>OS에는 여러가지 관리 부서가 있다.<br>또한 여러가지 프로그램이 메모리로 올라가 여러 프로세스가 존재한다,<br>각 프로세스는 OS가 제공하는 관리 기능들이 필요한데 이때 이를 사용하기 위한것이 시스템 콜이라 한다.</p>
<h3 id="주요-시스템-콜"><a href="#주요-시스템-콜" class="headerlink" title="주요 시스템 콜"></a>주요 시스템 콜</h3><p>– Process: end, abort, load, execute, create, terminate, get/set<br>attributes, wait event, signal event<br>– Memory: allocate, free<br>– File: create, delete, open, close, read, write, get/set attributes<br>– Device: request, release, read, write, get/set attributes, attach/detache devices<br>– Information: get/set time, get/set system data<br>– Communication: socket, send, receive</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;운영체제-서비스&quot;&gt;&lt;a href=&quot;#운영체제-서비스&quot; class=&quot;headerlink&quot; title=&quot;운영체제 서비스&quot;&gt;&lt;/a&gt;운영체제 서비스&lt;/h3&gt;&lt;p&gt;지금은 서버컴퓨터 하나에 여러명이 동시에 사용하는 구조.&lt;br&gt;이러한 구조에선 한사
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>4.사용자모드와 관리자모드, 하드웨어 보호</title>
    <link href="http://KKimSangHeon.github.io/2019/02/11/os4/"/>
    <id>http://KKimSangHeon.github.io/2019/02/11/os4/</id>
    <published>2019-02-11T12:29:11.000Z</published>
    <updated>2019-02-15T12:27:37.482Z</updated>
    
    <content type="html"><![CDATA[<h3 id="이중모드-하드웨어-보호"><a href="#이중모드-하드웨어-보호" class="headerlink" title="이중모드, 하드웨어 보호"></a>이중모드, 하드웨어 보호</h3><p>한 컴퓨터를 여러 사람이 동시에 사용하는 환경이다.<br>한사람의 실수가 전체에 영향을 끼칠 수  있으므로 일반유저는 STOP, HALT, RESET 등과같은 명령어는 일반 유저가 이용할 수 없도록 하는것. 이를 <code>이중모드</code>라 한다.</p>
<p>이를 <u>사용자(user)모드, 관리자(supervisor) 모드</u> 라고 한다.<br>관리자 모드 = 시스템 모드 = 모니터 모드 = 특권 모드<br>특권 명령(ex. STOP, HALT, RESET, SET_TIMER, SET_HW 등은 관리자 모드에서만 사용 가능)</p>
<h3 id="이중모드-동작방식"><a href="#이중모드-동작방식" class="headerlink" title="이중모드 동작방식"></a>이중모드 동작방식</h3><p>CPU안에 레지스터 ALU, 제어유닛이 있다,</p>
<p>레지스터는 비트들의 모음(32bit의 경우 32개가 있다.)<br>레지스터 비트는 carry,zero, negative, overflow 와 같은 플래그도 갖고있다,<br><u>또한 이중모드를 나타내기 위한 플래그(모니터 비트라 함) 또한 레즈스터에 존재한다.</u></p>
<p>모니터 비트가 1이면 시스템모드 0이면 유저모드이다.</p>
<h3 id="가령-게임을-실행하고-저장한다고-가정해보자"><a href="#가령-게임을-실행하고-저장한다고-가정해보자" class="headerlink" title="가령 게임을 실행하고 저장한다고 가정해보자."></a>가령 게임을 실행하고 저장한다고 가정해보자.</h3><p>1.처음 파워를 키면 부팅이 일어난다 이때는 모니터 비트가 1이다.(시스템 모드)<br>2.OS의 부트가 끝나고 특정 게임을 실행한다고 하자, 그럼 디스크에서 게임을 메모리로 갖고올 것이다.<br>3.그리고 실행이 게임으로 넘어갈 때 모니터 비트는 0 (유저모드)로 변경된다.<br>4.다시 게임내용을 하드디스크에 저장할 때는 OS에게 부탁(SWI,소프트웨어 인터럽트)하여 OS가 저장하게 한다(다른파일을 덮어쓰는지와 같은 부정한 행위를 하는지에 대한 판단을 하고 저장하게 해줌). 이때는 모니터 비트가 다시 1이된다. //물론 게임 자체적으로 디스크에 저장할 수 있지만 보안상의 이슈 존재!<br>5.저장을 완료하면 다시 게임 프로그램으로 돌아오고 모니터 비트가 0이된다.</p>
<p>운영체제 서비스 실행될 때는 관리자 모드<br>사용자 프로그램 실행될 때는 사용자 모드<br>하드웨어/소프트웨어 인터럽트 발생하면 관리자 모드<br>운영체제 서비스가 끝나면 다시 사용자 모드</p>
<h3 id="하드웨어-보호"><a href="#하드웨어-보호" class="headerlink" title="하드웨어 보호"></a>하드웨어 보호</h3><p>1.입출력장치에 대한 보호</p>
<p>하드웨어에 대한 적절한 보호가 없을 때의 경우<br>내가 프린트하는데 누가 방해할라고 그놈도 계속 프린트 명령을 보내는상황이 발생했을 때.<br>내가원하는 출력물, 상대가 원하는 출력물이 섞여서 나오는 경우가 생길 수 있다.</p>
<p>어떻게?<br><code>아무유저나 In,Out 명령을 내리지 못하도록 특권명령으로 한다.</code></p>
<h3 id="사용자가-입출력-명령을-직접-내린-경우"><a href="#사용자가-입출력-명령을-직접-내린-경우" class="headerlink" title="사용자가 입출력 명령을 직접 내린 경우?"></a>사용자가 입출력 명령을 직접 내린 경우?</h3><p>Privileged instruction violation 이라 하며 해당 프로그램을 강제로 중지시킨다.</p>
<h3 id="메모리-보호"><a href="#메모리-보호" class="headerlink" title="메모리 보호"></a>메모리 보호</h3><p>멀티프로그래밍, 타임쉐어링 프로그래밍에서는 동시에 여러프로그램이 돌고있다.<br>특정 프로그램이 돌면서 다른 프로그램 혹은 OS의 영역에 기웃거리지 못하게 한다.</p>
<p>어떻게?<br>메모리에 접근하려면 어드레스 버스를 통해야하는데 어드레스 버스에 문지기를 두어 자기것에만 접근하는지 확인한다.<br>확인할 때는 base, limit 를 참고한다. 잘못된 범위를 읽을 땐 인터럽트를 O/S로 보낸다. 잘못된 번지를 읽을 때 보내는 신호를 보통 <u>Segment violation</u> 라고 부른다.</p>
<p>여기서 문지기를 <code>MMU(Memory Management Unit)라고 한다. base 와 limit 사이에 들어오는지 확인하며 base와 limit는 OS가 관리한다. 또한 base와 limit는 아무나 설정하면 안되므로 특권명령으로 관리된다.</code></p>
<p>3.CPU 보호</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;이중모드-하드웨어-보호&quot;&gt;&lt;a href=&quot;#이중모드-하드웨어-보호&quot; class=&quot;headerlink&quot; title=&quot;이중모드, 하드웨어 보호&quot;&gt;&lt;/a&gt;이중모드, 하드웨어 보호&lt;/h3&gt;&lt;p&gt;한 컴퓨터를 여러 사람이 동시에 사용하는 환경이다.
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>3.최근의 고급운영체제, 인터럽트에 기반한 현대 운영체제</title>
    <link href="http://KKimSangHeon.github.io/2019/02/11/os3/"/>
    <id>http://KKimSangHeon.github.io/2019/02/11/os3/</id>
    <published>2019-02-11T10:49:46.000Z</published>
    <updated>2019-02-15T12:27:37.793Z</updated>
    
    <content type="html"><![CDATA[<h3 id="다중-프로세서-시스템"><a href="#다중-프로세서-시스템" class="headerlink" title="다중 프로세서 시스템"></a>다중 프로세서 시스템</h3><p>메모리는 하난데 CPU가 여러개이다. 이를 병렬 시스템이라고도 한다.<br>장점 :</p>
<ul>
<li>병렬 시스템을 통한 성능향상을 목표</li>
<li>비용 : 하나의 강한 CPU 보다 여러개의 저렴한 CPU로 구성하는것이 일반적으로 저렴하다.</li>
<li>신뢰성 제공 : 하나가 고장나도 다른 CPU로 돌릴 수 있다.</li>
</ul>
<p>CPU가 여러개일 때 운영체제를 다중 프로세서 운영체제라 한다. 또한 강결합이라 한다.</p>
<h3 id="분산-시스템"><a href="#분산-시스템" class="headerlink" title="분산 시스템"></a>분산 시스템</h3><p>멀티컴퓨터 시스템이라고도 하며 네트워크(LAN) 등으로 연결되어 있다.<br>이는 메인메모리가 따로있고 랜으로 연결되어있으므로 소결합이라 한다.<br>OS도 서로 다 따로따로 있다. 이를 분산 운영체제라 한다.</p>
<h3 id="다중프로세서-시스템-분산시스템의-공통점"><a href="#다중프로세서-시스템-분산시스템의-공통점" class="headerlink" title="다중프로세서 시스템, 분산시스템의 공통점"></a>다중프로세서 시스템, 분산시스템의 공통점</h3><p>신뢰성, 성능, 비용절감을 목표로 한다.</p>
<h3 id="실시간-시스템"><a href="#실시간-시스템" class="headerlink" title="실시간 시스템"></a>실시간 시스템</h3><p>특정 시간내에 반드시 연산이 끝나야 하는것.<br>시간제약 즉 Deadline를 정해둔다. 실시간 시스템은 네비게이션에서도 쓰인다. 실시간 경로안내할때 그 지점에 도착하기 전에 계산이 끝나야하기 때문에<br>주로 공장자동화, 군사, 항공, 우주 분야에서도 쓰인다.<br>실시간 시스템을 위한 운영체제는 실시간 운영체제(Real-time OS = RTOS)라 한다.</p>
<h3 id="인터럽트"><a href="#인터럽트" class="headerlink" title="인터럽트"></a>인터럽트</h3><p>현대 운영체제는 인터럽트 기반 시스템이다.</p>
<p>컴퓨터를 키면 ROM에 있는 부트로더가 디스크에서 O/S를 메모리로 갖고온다. 이를 부팅이라 한다.<br>이 후 운영체제는 메모리에 상주하게 된다.<br>이 다음에는 아이콘이 나타나고 깜빡거린다.<br>이러다 <u>우리가 마우스를 움직이면 전기신호가 발생하고 CPU에 인터럽트 선을 통해 전기신호를 올려준다</u>.<br>그럼 CPU는 지금하던일을 중지하고 OS안에 마우스가 어떤 전기신호를 보냈을 때 어떤 행동을 하라고 정의되어있는지(<u>mouse interrupt service routine</u>)에 따라 처리한다.</p>
<h3 id="하드웨어-인터럽트"><a href="#하드웨어-인터럽트" class="headerlink" title="하드웨어 인터럽트"></a>하드웨어 인터럽트</h3><p>인터럽트 결과 운영체제 내의 특정코드를 실행한다.(ISR)<br>interrupt Service Routine 종료 후 다시 대기</p>
<h3 id="소프트웨어-인터럽트"><a href="#소프트웨어-인터럽트" class="headerlink" title="소프트웨어 인터럽트"></a>소프트웨어 인터럽트</h3><p>SWI 명령어는 인터럽트가 걸리는것이다. 보통 인터럽트는 하드웨어가 걸리는데</p>
<p>SWI(Software interrupt) - ARM에서의 소프트웨어 인터럽트 명령<br>INT - 팬티엄에서의 인터럽트 명령</p>
<p>hwp 프로그램이 실행되다가 하드디스크에 있는 내용을 읽어온다고 가정하자.<br>하드디스크를 읽어오는 루틴은 O/S안에 존재한다. 이것또한 ISR이다. 아무튼 <u>하드디스크 내용을 읽기위해 소프트웨어 인터럽트가 걸리게 되고 O/S안에 있는 하드디스크를 읽어오는 루틴을 실행하고 원래 실행중인 곳으로 돌아온다.</u></p>
<h3 id="운영체제는-평소에는-대기상태이다"><a href="#운영체제는-평소에는-대기상태이다" class="headerlink" title="운영체제는 평소에는 대기상태이다"></a>운영체제는 평소에는 대기상태이다</h3><p><u>운영체제는 평소에는 대기상태이다. 그러나 하드웨어 인터럽트, 소프트웨어 인터럽트, 내부인터럽트에 의해 운영체제 코드를 실행한다.</u></p>
<p>내부 인터럽트는 5를 0으로 나누는것과 같은 논리적인 오류가 있을 때 발생하는 인터럽트이다. 이 땐 divide by zero를 처리하는 ISR이 호출된다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;다중-프로세서-시스템&quot;&gt;&lt;a href=&quot;#다중-프로세서-시스템&quot; class=&quot;headerlink&quot; title=&quot;다중 프로세서 시스템&quot;&gt;&lt;/a&gt;다중 프로세서 시스템&lt;/h3&gt;&lt;p&gt;메모리는 하난데 CPU가 여러개이다. 이를 병렬 시스템이라고도
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>2.일괄처리부터 시분할시스템까지 운영체제 변천 역사</title>
    <link href="http://KKimSangHeon.github.io/2019/02/10/os2/"/>
    <id>http://KKimSangHeon.github.io/2019/02/10/os2/</id>
    <published>2019-02-10T13:33:13.000Z</published>
    <updated>2019-02-15T12:27:36.853Z</updated>
    
    <content type="html"><![CDATA[<h3 id="컴퓨터의-역사"><a href="#컴퓨터의-역사" class="headerlink" title="컴퓨터의 역사"></a>컴퓨터의 역사</h3><p>2차세계 대전 중 1940년대 말 만들어졌다.</p>
<p><code>1.초기에는 운영체제가 존재하지 않았다.</code></p>
<p><code>2.이후엔 Batch processing system(일괄처리)이 나왔다</code><br>이는 최초의 O/S로 볼 수 있다.</p>
<p><code>3.Multiprogramming system</code><br>가령 수를 더해서 출력하고 다시 이를 특정 수를 반복해서 더하는 프로그램이 있다고 해보자.<br>수를 더하는것은 CPU가 할 것이고 출력은 입출력 장치가 하게될것이다.<br>이 때 CPU가 작업을 마치고 출력을 위해 입출력 장치가 출력을 실행하게 되면 느린 i/o의 성능으로 인해 CPU가 idle(노는시간) 즉 기다리는 시간이 생기게 된다. 이를 개선하기 위해 메모리에 여러 프로그램을 올리고 실행중인 프로그램이 <u>i/o</u>를 만나면 다른 프로그램을 실행토록 한다.</p>
<p><u>이를 통해 CPU가 노는 시간이 없도록한다.</u><br>이와 관련하여 <u>CPU scheduling</u>가 나오게된다. 어떤 순으로 실행하여 성능을 좋게할까에 대한 알고리즘이다.<br><u>메모리 관리</u>또한 나오게된다. 이는 적절하게 프로그램을 메모리에 배치하기 위한 기법이다.<br><u>보호</u>개념또한 등장하게 되는데 메모리에서 다른 프로그램의 영역에 침범하면 안되므로!</p>
<p><code>4.Time-sharing system</code><br>여러사람이 한 컴퓨터로 들어와 자신의 프로그램을 사용한다고 가정하자. 이 때 여러사람들은 Multiprogramming system에서는 동시에 사용하기란 불가능하다.(이는 I/O를 만나야 다른 프로그램을 동작시키는 로직이므로..)<br>그래서 <u>아주 짧은시간으로 나눠 여러 유저의 작업을 번갈아가며 CPU가 처리해주도록</u> 한다.</p>
<p>이러한 시스템이 등장하며 특정유저가 다른 유저에게 데이터를 주고받는것이 즉 <u>프로세스간 통신</u>이 가능해졌다.<br>또한 누가 먼저 앞서고 뒤서는지에 대한 <u>동기</u>라는 개념이 등장한다.<br>또한 하드디스크의 일부를 메인메모리인냥 사용하는 기술인 <u>가상 메모리</u> 또한 등장하게된다.</p>
<h3 id="OS-기술-천이"><a href="#OS-기술-천이" class="headerlink" title="OS 기술 천이"></a>OS 기술 천이</h3><p>컴퓨터의 규모별 분류는 다음과 같다.<br><code>과거의 분류 :</code><br>  Supercomputer &gt; Mainframe &gt; Mini &gt; Micro<br><code>현재의 분류 :</code><br>  Supercomputer &gt; Server &gt; Workstation &gt; PC &gt; Handheld &gt; Embedded<br>워크스테이션 : PC에서 처리못하는 조금 큰 작업 처리</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;컴퓨터의-역사&quot;&gt;&lt;a href=&quot;#컴퓨터의-역사&quot; class=&quot;headerlink&quot; title=&quot;컴퓨터의 역사&quot;&gt;&lt;/a&gt;컴퓨터의 역사&lt;/h3&gt;&lt;p&gt;2차세계 대전 중 1940년대 말 만들어졌다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1.초기에는 운영체제
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>1.	운영체제의 정의와 역할</title>
    <link href="http://KKimSangHeon.github.io/2019/02/10/os/"/>
    <id>http://KKimSangHeon.github.io/2019/02/10/os/</id>
    <published>2019-02-10T12:03:53.000Z</published>
    <updated>2019-02-15T12:27:28.905Z</updated>
    
    <content type="html"><![CDATA[<p>운영체제 포스팅은 <a href="http://www.kocw.net/home/search/kemView.do?kemId=978503" target="_blank" rel="external">http://www.kocw.net/home/search/kemView.do?kemId=978503</a> (KOCW) 를 참고하여 작성됩니다.</p>
<h3 id="운영체제가-없는-PC는-어떨까"><a href="#운영체제가-없는-PC는-어떨까" class="headerlink" title="운영체제가 없는 PC는 어떨까?"></a>운영체제가 없는 PC는 어떨까?</h3><p>야생마와 같다. 프로그램 실행과 같은 동작을 할 수 없게된다.<br>하드디스크에 있는 파일을 메모리에 올릴수 없다.<br>즉 하드디스크에 있는 파일을 운영체제가 올려주는것!</p>
<h3 id="운영체제란"><a href="#운영체제란" class="headerlink" title="운영체제란?"></a>운영체제란?</h3><p>하드웨어를 잘 관리하는것.(하드웨어: 프로세서, 메모리, 디스크…)<br>이를 통해 <code>성능을</code> 올리고 사용자에게 <code>편의성</code>을 제공</p>
<h3 id="부팅"><a href="#부팅" class="headerlink" title="부팅"></a>부팅</h3><p>메모리는 램, 롬으로 나뉜다. 대부분은 램으로 구성된다. 롬은 많아야 수백키로바이트밖에 되지 않는다,<br><code>그렇다면 ROM이 필요한 이유는?</code> 전원을 껐다 켜면 램의 데이터는 다 날라가는데 ROM은 그렇지 않다.</p>
<p>컴퓨터를 부팅하면 프로세서는 ROM에 있는 코드를 읽어온다.<br>그렇다면 <code>ROM에는 어떤 프로그램이 있으며 부팅과정은?</code><br>1.POST(Power On Self Test) 프로그램을 ROM에서 가져와 실행<br>  <code>POST?</code>  모니터는 끼워져있는가, 키보드는 꽂아져 있나, 메모리는 얼마인가 등을 확인하는 프로그램<br>2.부트로더(Boot loader)를 ROM에서 가져와 실행.<br>  <code>부트로더는?</code> 하드디스크를 뒤져서 os를 메인메모리(RAM)로 갖고온다. 이를 부팅이라 한다.</p>
<p>메모리에 올라온 OS는 컴퓨터가 종료될때 까지 지워지지 않는다. 하지만 다른 응용프로그램들은 프로그램 종료에 따라 지워지게된다. 그래서 OS를 <code>메모리 Resident</code>라고 한다.</p>
<h3 id="커널과-쉘"><a href="#커널과-쉘" class="headerlink" title="커널과 쉘"></a>커널과 쉘</h3><p>OS는 하드웨어를 감싸고 있는데 하드웨어를 제외한 부분을 <code>kernel</code>이라고 한다. 또한 OS의 바깥부분을 <code>(shell,command interpreter)</code>이라 한다.</p>
<p>어떤 명령을 내릴 수 있도록 만드는것을 (<code>shell,command interpreter</code>)이라고 한다.<br>다시말해 <u>OS바깥부분에 위치해서 사용자의 명령을 받아들이는 곳. 그 명령을 인터프리터(해석해서) 명령을 실행해주는 것!</u></p>
<p><code>커널</code>은 실제로 <u>Cpu,메모리, 디스크를 관리하는것.</u></p>
<h3 id="응용프로그램-동작"><a href="#응용프로그램-동작" class="headerlink" title="응용프로그램 동작?"></a>응용프로그램 동작?</h3><p>응용프로그램은 O/S위에서 동작한다.<br>즉 맥킨토시 app을 윈도우에서 실행하면 동작하지 않는다.</p>
<h3 id="OS-는-정부와-비슷하다"><a href="#OS-는-정부와-비슷하다" class="headerlink" title="OS 는 정부와 비슷하다."></a>OS 는 정부와 비슷하다.</h3><p>주어진 자원을 어떻게 활용할까에 대한 고민을 하는것이 유사!</p>
<p>정부에도 여러가지 부서가 있듯이 OS안에도 많은 부서가 존재!</p>
<p>프로세스 매니지먼트 - 프로세스 관리부서<br>메모리 매니지먼트 - 메모리 관리<br>IO 매니지먼트 - 프린트, 키보드 관리<br>파일 매니지먼트 - 파일관리<br>네트워크 매니지먼트 - 네트워크 관리<br>시큐어티 매니지먼트 - 보안관리<br>…..<br>이런부분을 모두 운영체제의 커널로 불린다.</p>
<p>가장중요한것은 프로세스 매니지먼트! CPU가 가장비싸니까 가장 중요하고 프로그램 동작에 핵심이다.<br>그다음으로 중요한것이 메모리 매니지먼트</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;운영체제 포스팅은 &lt;a href=&quot;http://www.kocw.net/home/search/kemView.do?kemId=978503&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.kocw.net/home/searc
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>oneM2M, OMA-DM 생각정리..</title>
    <link href="http://KKimSangHeon.github.io/2019/02/08/mine/"/>
    <id>http://KKimSangHeon.github.io/2019/02/08/mine/</id>
    <published>2019-02-08T10:53:12.000Z</published>
    <updated>2019-02-10T08:02:03.813Z</updated>
    
    <content type="html"><![CDATA[<h3 id="oneM2M"><a href="#oneM2M" class="headerlink" title="oneM2M"></a>oneM2M</h3><p>iot 솔루션을 제공함에 있어 여러 벤더를 맞추기란 힘들다… oneM2M이라는 표준을 만들고 이를 여러 벤더가 맞춤으로써 응용개발사 또한 iot시스템을 개발함에 있어 개발공수를 낮출 수 있게된다.<br>oneM2M에는 CSE라는게 있는데 공통서비스를 제공하는것이다. 가령 데이터 저장, 요금청구 등등 다양하게 있다..</p>
<p>CSE는 REST 형태로 제공되어 편리하다는 장점이 있으며 최근에는 일반 응용개발에 oneM2M을 적용하여 CSE를 적절히 활용하는 경우도 있다. 이를 Distributed Platform 형태 라고 한다<br>통신사업자는 oneM2M 표준을 기반으로 CSE를 사용하는 플랫폼을 만들고 일반에 공개하게 되면 일반 개발자들은 통신사업자가 만든 플랫폼을 사용할 수 있게된다.(?? 맞는지 모르겠다.)</p>
<h3 id="OMA-DM"><a href="#OMA-DM" class="headerlink" title="OMA-DM"></a>OMA-DM</h3><p>이는 이동통신장치 관리표주으로서 내부 데이터에 접근하고 제어하는 표준이라 이해했다. xml기반 마크업 언어 SyncML 기반으로 명령과 결과를 주고받으며 심지어 운영체제 설치 그리고 응용프로그램의 파라미터 까지 변경이 가능하다고 한다. 여기서 관리할수 있는 자원을 <code>관리객체(MO, Management Object)</code>라고 한다.</p>
<h3 id="TR-069"><a href="#TR-069" class="headerlink" title="TR-069"></a>TR-069</h3><p>CPE WAN Management Protocol (CWMP) 이라 불리며 CPE 즉 사용자 단말을 관리하는 프로토콜인것같다.</p>
<h3 id="oneM2M과-OMA-DM의-상관관계"><a href="#oneM2M과-OMA-DM의-상관관계" class="headerlink" title="oneM2M과 OMA-DM의 상관관계???"></a>oneM2M과 OMA-DM의 상관관계???</h3><p>아래부터 개인적인생각입니다. 참고하지도 마세요!<br>oneM2M은 장치에서 받은 데이터를 활용하고 정제 저장하는 표준이라고 생각한다. 즉 디바이스의 정보를 뭐 제어하거나 어떻게 가져오는건 아니라 생각한다.<br>하지만 OMA-DM는 내부데이터 관리와 같은 디바이스 내부로 들어가는 표준인것같다.</p>
<p>아래 그림처럼 구분되나보다<br></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;oneM2M&quot;&gt;&lt;a href=&quot;#oneM2M&quot; class=&quot;headerlink&quot; title=&quot;oneM2M&quot;&gt;&lt;/a&gt;oneM2M&lt;/h3&gt;&lt;p&gt;iot 솔루션을 제공함에 있어 여러 벤더를 맞추기란 힘들다… oneM2M이라는 표준을 만들고 이를
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="IOT" scheme="http://KKimSangHeon.github.io/categories/CS/IOT/"/>
    
    
  </entry>
  
  <entry>
    <title>onem2m</title>
    <link href="http://KKimSangHeon.github.io/2019/02/08/onem2m/"/>
    <id>http://KKimSangHeon.github.io/2019/02/08/onem2m/</id>
    <published>2019-02-08T09:44:50.000Z</published>
    <updated>2019-02-08T10:39:25.022Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.youtube.com/watch?v=tBQ085PvR9E" target="_blank" rel="external">https://www.youtube.com/watch?v=tBQ085PvR9E</a> 요약</p>
<h3 id="IOT의-4계층"><a href="#IOT의-4계층" class="headerlink" title="IOT의 4계층"></a>IOT의 4계층</h3><p>Application layer - 스마트홈, 스마트카, 헬스케어<br>Service layer - IoT 서비스 개발이 용이하도록 공통으로 요구되는 기능 제공 <code>oneM2M, AllJoyn, OIC</code><br>Network layer - 장치 간 또는 서비스간 연결, 정보전달 <code>HTTP, CoAP, MQTT, Wi-Fi ...</code><br>Device layer - 센서 또는 다른 하드웨어</p>
<h3 id="oneM2M"><a href="#oneM2M" class="headerlink" title="oneM2M ?"></a>oneM2M ?</h3><p>IoT 응용 개발이 용이하도록 공통 기능을 제공하는 국제표준 플랫폼 기술</p>
<p>데이터관리, 연결 제어, 구독/통지, 보안, 그룹관리 ….</p>
<p>등을 제공하는데 응용 개발자는 이를 적절히 활용하여 개발공수를 줄일 수 있다.</p>
<h3 id="oneM2M발생이유"><a href="#oneM2M발생이유" class="headerlink" title="oneM2M발생이유"></a>oneM2M발생이유</h3><p>기존엔 응용이 특정한 디바이스를 타겟으로 개발되었다. 이를 개선할 수 있는것이 oneM2M</p>
<h3 id="oneM2M-1"><a href="#oneM2M-1" class="headerlink" title="oneM2M"></a>oneM2M</h3><p>먼저 Use Case를 기반으로 요구사항을 도출해봤더니 다음과 같았다.<br><code>일반요구사항:</code> 성능, 네트워크 연결지원에 따른 다양한 IoT장치 지원, QoS 기반 메시지 전달, 과금관리…<br><code>장치관리요구사항:</code> <u>OMA DM</u>/ BBF TR-069, 펌웨어, 소프트웨어 제어, 고장제어<br><code>보안 요구사항:</code>요청자에 대한 인증/권한 부여, 기반 네트워크 보안기능 활용</p>
<p>이를 기반으로 공통기능 CSE를 도출해냄<br>데이터관리 : 장치가 데이터를 저장할 수 없을때 플랫폼이 저장해준다<br>연결제어 : 레이턴시는 10ms 이하여야 한다.(예시)<br>구독. 통지 : 온도가 40도 이상이면 문자보내줘<br>과금 : 통신플랫폼의 사업자 이므로 이 또한 가능<br>이종 플랫폼 연동<br>사업자간 로밍 : 나의 커넥티드 카가 해외로 넘어가게 되면 로밍을 제공<br>기타 많은 공통기능 제공</p>
<p>oneM2M 안드로이드 플랫폼이랑 유사하다. CSE는 공통기능이 포함된 엔티티다.</p>
<p>AE를 카카오톡이라고 보면 좋다. 카톡은 안드로이드에 존재하는 간단한 API를 호출해 메세지를 보낸다.<br>즉 AE개발자는 CSE를 적절히 활용하면 된다.</p>
<p>여러플랫폼이 서로 연결되어 큰 iot를 만들어 낼 수 있게된다.</p>
<h3 id="Distributed-Platform-형태인-oneM2M"><a href="#Distributed-Platform-형태인-oneM2M" class="headerlink" title="Distributed Platform 형태인 oneM2M"></a>Distributed Platform 형태인 oneM2M</h3><p>IOT의 호출순서는 다음과 같다고 가정 하자.<br><code>디바이스 - 게이트웨이 - 클라우드 - 게이트웨이 - 디바이스</code><br>과거에는 클라우드에만 CSE를 탑재하여 호출하였지만 최근에는 게이트웨이, 디바이스에도 이를 탑재하여 분산처리를 한다.<br>물론 하드웨어의 용량이 부족할 경우 플랫폼 기능을 배제하기도 한다. 이 경우 <u>Constrained Device Support</u> 라고 한다.</p>
<h3 id="그렇다면-CSE를-어떻게-호출할까"><a href="#그렇다면-CSE를-어떻게-호출할까" class="headerlink" title="그렇다면 CSE를 어떻게 호출할까?"></a>그렇다면 CSE를 어떻게 호출할까?</h3><p>과거에는 RPC(Remote Procedure Call)을 활용하였지만 REST 기반 API구조를 사용한다.<br>CSE의 기능들을 REST 형태로 개방한다. 즉 URI만 갖고있으면 웹브라우저에서 기능을 호출할 수 있다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=tBQ085PvR9E&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.youtube.com/watch?v=tBQ085PvR9E&lt;/a&gt; 요약&lt;/
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="IOT" scheme="http://KKimSangHeon.github.io/categories/CS/IOT/"/>
    
    
  </entry>
  
  <entry>
    <title>TR-069</title>
    <link href="http://KKimSangHeon.github.io/2019/02/08/TR-069/"/>
    <id>http://KKimSangHeon.github.io/2019/02/08/TR-069/</id>
    <published>2019-02-08T05:52:45.000Z</published>
    <updated>2019-02-10T08:35:10.602Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TR-069"><a href="#TR-069" class="headerlink" title="TR-069"></a>TR-069</h3><p>customer-premises equipment (CPE, 말단 사용자 장치)<br>Auto Configuration Servers (ACS, 자동 설정 서버)</p>
<p>TR-069 (Technical Report 069)는 DSL 포럼 (이후 Broadband 포럼으로 변경)의 기술 명세서이다. 이 문서의 정식 명칭은 CPE WAN Management Protocol (CWMP)이다. 이 문서는 말단 사용자 장치를 관리하기 위한 사용자 계층 프로토콜을 정의하고 있다.</p>
<p><code>TR-069 프로토콜은 양방향 SOAP/HTTP 을 기반으로 customer-premises equipment (CPE, 말단 사용자 장치) 와 Auto Configuration Servers (ACS,자동 설정 서버) 간 통신을 가능하게 한다.</code> 또한 안전한 자동 설정 기능을 제공하며 통합 환경 내에서 다른 CPE 관리 함수를 제어하고 동작시킬 수 있도록 해준다.</p>
<h3 id="등장배경"><a href="#등장배경" class="headerlink" title="등장배경"></a>등장배경</h3><p> 브로드밴드 시장이 활성화 되면서 여러개의 다른 종류의 인터넷 접속 또한 많이 생겨났다. ( 모뎀, 라우터, 게이트웨이, 세트톱박스, VoIP-phone 등). <code>또한 동시에 이러한 장비들을 설정하는 것은 더욱 복잡해졌다. 말단 사용자에게는 이러한 설정이 더욱 어려운데 이러한 이유로 TR-069 표준이 개발되었다. TR-069 표준은 여러가지 접속 방법에 대한 자동 설정을 제공한다.</code> 이에대한 구체적인 기술적인 사항은 Broadband 포럼에서 관리하고 발행하고 있다.<code>TR-069을 이용해서 말단 장비들은 자동 설정 서버 (Auto Configuration Servers) (ACS)에 접속하고 필요한 설정을 자동으로 받아오게 된다. 이렇게 함으로써 사용자가 따로 설정하지 않아도 필요한 서비스를 사용하는 것이 가능해진다.</code> TR-069는 DSL broadband 시장에서 터미널을 활성화하기 위해 현재 사용중인 표준이다.</p>
<h3 id="CPE-WAN-Management-Protocol-CWMP"><a href="#CPE-WAN-Management-Protocol-CWMP" class="headerlink" title="CPE WAN Management Protocol (CWMP)??"></a>CPE WAN Management Protocol (CWMP)??</h3><p>서비스 프로바이더가 ACS를 통해 CPE를 원격으로 데이터 모델을 관리할 수 있게 해준다. 제공기능은 다음과 같다.</p>
<p>자동 구성 및 동적 서비스 프로비저닝<br>소프트웨어 / 펌웨어 이미지 관리<br>소프트웨어 모듈 관리 상태 및 성능 모니터링 진단</p>
<h3 id="TR-069-아키텍처"><a href="#TR-069-아키텍처" class="headerlink" title="TR-069 아키텍처"></a>TR-069 아키텍처</h3><img src="/2019/02/08/TR-069/image1.png" alt="TR-069 아키텍처" title="TR-069 아키텍처">
<p><u>All CWMP sessions begin with the CPE making the Inform RPC on the ACS.</u> This is also referred to as “sending an Inform” or “an Inform message”. An Inform RPC, and consequently, a CWMP session, is always made for a specific reason, called an Event. These Events drive CWMP operation.</p>
<h4 id="TR-069-초기-세션"><a href="#TR-069-초기-세션" class="headerlink" title="TR-069 초기 세션"></a>TR-069 초기 세션</h4><p>ACS와 연결하기 위해서는 다음의 데이터가 필요하다.</p>
<ul>
<li>ACS URL : ACS에 접속하기 위한 URL</li>
<li>주기적인 알림 : ACS와 주기적인 소통이 정의되어야 한다.</li>
<li>Username and password - 옵션데이터이나 보안을 위해 하는것이 좋다.</li>
</ul>
<img src="/2019/02/08/TR-069/image2.png" alt="TR-069의 초기 세션" title="TR-069의 초기 세션">
<p>1.First, the CPE initiates a TCP session with ACS and negotiates a secure connection.<br>2.The CPE begins every session by sending an Inform RPC to the ACS, with arguments that include the Event that caused the session. This is done over an HTTP Post.<br>3.In the HTTP Response, the the ACS sends an InformResponse. Once processed by the CPE, this means that the Inform RPC is complete.<br>4.There’s probably no other RPCs that CPE wishes to make on the ACS, so it sends an empty HTTP Post to indicate that it is finished. This may happen at any time during the session.<br>5.The ACS begins to send remote procedure calls to the CPE, such as the GetParamterValues RPC.<br>6.The CPE sends its GetParameterResponse in an HTTP Post, with the information the ACS was looking for. This ends the GetParameterValues RPC.<br>7.The ACS makes any other RPCs it needs to during this session, such as SetParameterValues to change the state of the CPE, or SetParameterAttributes to set up a notification.<br>8.When the ACS has no more RPCs to make, it sends an empty HTTP Response, just like the CPE did earlier. When both the CPE and the ACS have done this, the session is over and it’s time to tear down the connection.</p>
<h3 id="전송방식"><a href="#전송방식" class="headerlink" title="전송방식"></a>전송방식</h3><p>CWMP는 텍스트 기반 프로토콜입니다. 장치 (CPE)와 자동 구성 서버 (ACS)간에 전송 된 주문은 HTTP 혹은 HTTPS 를 통해 전송됩니다. 이 수준 (HTTP)에서 CPE는 클라이언트 역할을하며 ACS는 HTTP 서버 역할을합니다.</p>
<hr>
<h2 id="별첨"><a href="#별첨" class="headerlink" title="별첨"></a>별첨</h2><h4 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h4><p>SOAP(Simple Object Access Protocol)은 일반적으로 널리 알려진 HTTP, HTTPS, SMTP 등을 통해 XML 기반의 메시지를 컴퓨터 네트워크 상에서 교환하는 프로토콜이다. SOAP은 웹 서비스에서 기본적인 메시지를 전달하는 기반이 된다.</p>
<hr>
<h3 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h3><p><a href="https://www.qacafe.com/tr-069-training/" target="_blank" rel="external">https://www.qacafe.com/tr-069-training/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;TR-069&quot;&gt;&lt;a href=&quot;#TR-069&quot; class=&quot;headerlink&quot; title=&quot;TR-069&quot;&gt;&lt;/a&gt;TR-069&lt;/h3&gt;&lt;p&gt;customer-premises equipment (CPE, 말단 사용자 장치)&lt;br&gt;Auto C
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="IOT" scheme="http://KKimSangHeon.github.io/categories/CS/IOT/"/>
    
    
  </entry>
  
  <entry>
    <title>OMA-DM</title>
    <link href="http://KKimSangHeon.github.io/2019/02/08/oma-dm/"/>
    <id>http://KKimSangHeon.github.io/2019/02/08/oma-dm/</id>
    <published>2019-02-08T01:29:08.000Z</published>
    <updated>2019-02-10T08:41:54.697Z</updated>
    
    <content type="html"><![CDATA[<h4 id="OMA-Open-Mobile-Alliance"><a href="#OMA-Open-Mobile-Alliance" class="headerlink" title="OMA(Open Mobile Alliance)"></a>OMA(Open Mobile Alliance)</h4><p>이동통신 서비스 애플리케이션 표준화 기구이며 일부 애플리케이션 프로토콜을 다루고 있는 산업 포럼의 증진에 응하기 위해 2002년 6월 설립되었다.</p>
<h4 id="Device-Management-DM"><a href="#Device-Management-DM" class="headerlink" title="Device Management(DM) ?"></a>Device Management(DM) ?</h4><p><code>장치 관리 기술이란 직접 수익을 창출하는 기술은 아니지만, 사업자가 응용 서비스를 시작하고 개선하고 관리하는 과정에서 겪는 문제점들을 해결해 줄 수 있는 효과적인 기술로서 이들 서비스를 통한 수익 창출에 효과적인 솔루션이다.</code><br>WAP, 3G Partnership Project(3GPP), Open Service Gateway Initiative(OSGi), Telemanagement Forum(TMF)등은 그들이 개발한 응용 서비스를 관리해 줄 수 있는 기술, 그들이 개발한 서비스 관리 기법을 가능하게 해줄 기술을 필요로 하게 되었다.</p>
<h4 id="OMA-DM"><a href="#OMA-DM" class="headerlink" title="OMA-DM"></a>OMA-DM</h4><p><code>장치(단말기) 안에 존재하는 데이터를 서버가 원격으로 접근할 수 있도록 하는 Technology와 규격을 OMA가 제정함</code></p>
<p>OMA 장치 관리 기술은 범세계적인 이동 통신 시장의 특별한 Use Case와 요구 사항을 고려하여 개발되고 있으며, 특히 이동 단말기의 종류, 운영체제, 지역, 네트워크 기술에 제한되지 않은 열린 기술이기 때문에 결국 기존의 일부 특정 네트워크와 단말기에 국한된 장치 관리 기술들을 통합하거나 대체할 수 있는 기술이다.</p>
<p>OMA-DM 은 초기 설정, 소프트웨어 및 펌웨어 관리, 원 격 제어, 진단 및 모니터링 등의 기능을 가지고 있으며, 스마트폰 등의 모바일 단말을 대 상으로 관리 서비스를 제공한다.</p>
<h4 id="OMA-DM-프로토콜"><a href="#OMA-DM-프로토콜" class="headerlink" title="OMA-DM 프로토콜"></a>OMA-DM 프로토콜</h4><p>두 통신 상대가 장치 관리 서비스를 제공하는 서버와 장치 관리 서비스를 받아 처리하는 클라이언트의 관계를 갖는다는 관점에서 비대칭 구조를 갖는 프로토콜이다.<br>장치 관리 서버의 역할은 클라이언트에게 장치 관리 명령을 내리는 것이고 클라이언트의 역할은 주어진 명령을 수행하는 것이다. 장치 관리 서버는 장치 관리 명령을 통해 장치에 설치된 응용 서비스의 파라미터를 변경할 수 있으며, 새로운 파라미터를 생성하도록 할 수 있으며, 장치 내부의 정보를 읽어낼 수 있으며, 응용 소프트웨어를 장치에 설치하고, 그것들의 실행을 원격으로 제어할 수 있을 뿐 아니라 운용체제(OS)를 다시 설치할 수도 있다. <u>결국, OMA Device Management 프로토콜이란 장치의 자원을 장치 관리 서버가 원격으로 접근할 수 있게하는 프로토콜이며, 장치 관리 프로토콜을 통해 관리할 수 있는 이러한 자원을 관리 객체(Management Object) 라고 부른다</u></p>
<p>서버와 클라이언트간의 장치 관리 <u>명령과 결과는 원격으로 XML에 기반한 마크업(Markup) 언어인 SyncML 메시지를 HTTP, WSP, OBEX 등의 유선, 무선, 또는 적외선 전송 프로토콜을 통해 서로 전송된다</u>. 뿐만 아니라, Device Management(DM) Tree라는 장치 관리 프로토콜만의 파일 시스템을 정의하고 각 노드를 URI를 통해 접근할 수 있도록 하였다. 그리고, 장치 고유의 데이터 베이스 또는 파일 시스템은 DM Tree와 메핑을 통해 장치 관리 서버에게 투사된다. 그러므로 어떤 장치는 결국 장치 관리 서버에게 있어서 하나의 DM Tree로 나타나게 되는 셈이다. 또한 동일한 장치라도 주어진 접근 권한에 따라 서로 다른 서버에게 다른 형태로 나타나게 된다.</p>
<h4 id="OMA-Device-Management-기술-규격의-구성"><a href="#OMA-Device-Management-기술-규격의-구성" class="headerlink" title="OMA Device Management 기술 규격의 구성"></a>OMA Device Management 기술 규격의 구성</h4><p>아래 그림의 규격 구성에 깔린 의도는 첫째로, <u>기본 규격(Base Protocol)을 다른“Silo”규격들과 분리함으로써 기본 규격이 오랜 기간동안 변하지 않고 꾸준한 안정화 과정을 지날 수 있도록 한다는 것이다.</u> 안정적인 기본 프로토콜의 바탕 위에 변화하는 이동 통신 시장의 요구를 충족시키기 위한 독립적인“Silo”프로토콜들을 정의하도록 함으로써 최소한의 노력으로 안정된 토대 위에서 시장이 필요로 하는 규격을 공급할 수 있는 방안을 마련하였다. 이것은, 각“Silo”규격들이 오직 기본 프로토콜에만 의존적이면서 서로 간에 독립적인 구조를 갖는 프로토콜이기 때문이기도 하다. 둘째로, <u>자료 동기 프로토콜과 SyncML 파서와 SyncML Toolkit을 공유함으로써 기존 SyncML Toolkit에 기반한 네트워크 인프라를 보호하고 재활용할 수 있도록 하기 위함이다.</u></p>
<img src="/2019/02/08/oma-dm/image1.PNG" alt="OMA Device Management 규격의 구성" title="OMA Device Management 규격의 구성">
<h4 id="Management-Object-MO"><a href="#Management-Object-MO" class="headerlink" title="Management Object (MO)"></a>Management Object (MO)</h4><p>OMA-DA의 관리 서버는 기기 내의 관리 객체(Management Object: MO)를 액세스함으로써 장치를 관리하도록 되어 있다. MO 에는 다음과 같은 것들이 있다.</p>
<p><code>FUMO(Firmware Update Management Object):</code> 펌웨어 업데이트 관리<br><code>SCOMO(Software Management):</code> 소프트웨어 컴포넌트 설치, 삭제, 관리<br><code>DiagMon MO(Diagnostics and Monitoring):</code> 배터리, 메모리, 라디오, QoS 파라메터 상태를 수집, 진단<br><code>ConnMo(Connectivity):</code> 베어러나 프록시 등 설정<br><code>DCMO(Device Capabilities):</code> 카메라, 블루투스, USB 등 주변기기를 원격으로 활성 화/비활성화하는 권한<br><code>LAWMO(Lock and Wipe):</code> 분실, 도난시 기기를 잠그거나 완전 삭제<br><code>BMO(Browser):</code> 브라우저 설정 관리: VirMO(Virtualization): 원격에 있는 가상 머신을 관리<br><code>Management Policy MO:</code> 어떤 이벤트가 발생하면 어떤 동작을 수행할 수 있도록 하는 정책을 배포 및 관리: OMA-DM 은 HTTP RESTful 메소드를 이용하며, XML 및 JSON 기반의 메시지를 이 용하고, SSL/TLS 보안 기술을 이용.</p>
<h4 id="OMA-DM의-가상시나리오"><a href="#OMA-DM의-가상시나리오" class="headerlink" title="OMA-DM의 가상시나리오"></a>OMA-DM의 가상시나리오</h4><p>어느 한 통신 사업자의 네트워크 관리자가 신규 가입자가 가입할 때 신청한 서비스 내역을 검토한 후 알맞은 응용 프로그램을 가입자 단말기에게 설치하도록 장치 관리 서버에게 요청한다.<br>장치 관리 서버는 Connectionless WAP Push방식으로 DM Notification메시지를 가입자 장치로 전송한다.<br>DM Notification 메시지는 장치 관리 서버의 전자 서명이 포함된 메시지이며 보통 장치 관리 클라이언트에 의해 처리되고 장치 관리 클라이언트가 서버에게 장치 관리 세션을 요청하도록 한다. 장치 관리 세션이 만들어 지면 장치 관리 서버는 응용 프로그램을 장치 관리 명령을 통해 주어진 응용 프로그램을 장치로 다운로드 한 뒤 그 응용 프로그램이 정상적으로 동작할 수 있도록 사용자 계정, 비밀 번호 등 서비스에 필요한 설정값을 구성하여 사용자가 요구한 대로 동작할 수 있도록 한다.<br>마지막으로, 장치 관리 서버는 역시 장치 관리 명령을 통해 장치의 화면에 앞서 일어난 과정에 대해 설명하는 문구를 나타내어 사용자에게 알려 준다. 사용자는 설치된 응용 프로그램을 이용하여 서비스를 이용한다.</p>
<h4 id="OMA-DM의-ACL"><a href="#OMA-DM의-ACL" class="headerlink" title="OMA-DM의 ACL"></a>OMA-DM의 ACL</h4><p>OMA Device Management 프로토콜은 하나의 장치에 대해 여러 장치 관리 서버가 접근할 수 있도록 설계되었다. 예를 들어, 회사 업무용 소프트웨어를 설치한 단말기의 경우 그 회사의 장치 관리 서버를 구축하여 그 소프트웨어에 대한 사용자명, 비밀 번호, 게이트웨이 등 을 설정하여 회사 내 기밀 자원에 접근할 수 있도록 설정할 수 있으며, 다른 일반 서비스 즉, MMS 서비스 등의 관리를 위해선 외부 통신 사업자의 장치 관리 서버를 통해 장치에 접근하도록 하는 경우를 생각할 수 있다. 이를 위해 OMA Device management 프로토콜은 장치 내부에 존재하는 객체에 대한 관리 권한을 Access Control List(ACL)를 통해 제한하고 있다. ACL를 통해 클라이언트는 어떤 장치 관리 서버가 요청한 장치 관리 명령에 대한 수행 여부를 판단할 수 있다. 이러한 판단 기준은 특정 서버의 특정 장치 관리 명령에 대해 명시할 수가 있다.</p>
<h4 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h4><p>OMA 표준화 동향 - OMA Device Management [LG전자 이동통신기술연구소 김 태 현]<br>TTA저널 제 96호</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;OMA-Open-Mobile-Alliance&quot;&gt;&lt;a href=&quot;#OMA-Open-Mobile-Alliance&quot; class=&quot;headerlink&quot; title=&quot;OMA(Open Mobile Alliance)&quot;&gt;&lt;/a&gt;OMA(Open Mobi
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="IOT" scheme="http://KKimSangHeon.github.io/categories/CS/IOT/"/>
    
    
  </entry>
  
  <entry>
    <title>oneM2M</title>
    <link href="http://KKimSangHeon.github.io/2019/02/07/onem2m/"/>
    <id>http://KKimSangHeon.github.io/2019/02/07/onem2m/</id>
    <published>2019-02-07T11:46:50.000Z</published>
    <updated>2019-02-09T06:51:54.249Z</updated>
    
    <content type="html"><![CDATA[<h3 id="M2M-Machine-to-Machine"><a href="#M2M-Machine-to-Machine" class="headerlink" title="M2M(Machine to Machine)"></a>M2M(Machine to Machine)</h3><ul>
<li>사물 또는 지능화된 기기들이 사람을 대신해 통신의 양쪽 모두를 맡고 있는 기술을 의미</li>
<li>센서 등을 통해 전달, 수집, 가공된 위치, 시각, 날씨 등의 데이터를 다른 장비나 기기 등에 전달하기 위한 통신을 의미</li>
<li>M2M은 개별 장치들에 대한 연결성을 제공하는 것이 기본 목적</li>
</ul>
<hr>
<h3 id="oneM2M"><a href="#oneM2M" class="headerlink" title="oneM2M"></a>oneM2M</h3><h4 id="기구-설명"><a href="#기구-설명" class="headerlink" title="기구 설명"></a>기구 설명</h4><p>1.에너지, 교통, 국방, 공공서비스 등 산업별로 종속적이고 폐쇄적으로 운영되는, 파편화된 서비스 플랫폼 개발 구조를 벗어나 응용서비스 인프라(플랫폼) 환경을 통합하고 공유하기위한 사물인터넷 공동서비스 플랫폼 개발을 위해 발족된 사실상 표준화 단체임</p>
<p>2.oneM2M의 기술 워킹그룹(6개)은 요구사항을 다루는 Requirement(WG1), 시스템 구조를 다루는 Architecture(WG2), 프로토콜과 관련한 Protocols(WG3), 보안관련 Security(WG4), 장치관리 및 추상화, 시멘틱과 관련된 Management, Abstraction and Semantics(WG5), 테스킹 규격을 위한 Test(WG6)로 구성되어 있음</p>
<img src="/2019/02/07/onem2m/image1.PNG" alt="oneM2M표준 적용 후" title="oneM2M표준 적용 후">
<hr>
<h3 id="oneM2M-Release-1"><a href="#oneM2M-Release-1" class="headerlink" title="oneM2M Release 1"></a>oneM2M Release 1</h3><p><code>15.01월 Minimum Deployeable Solution을 모토로 Release 1 규격을 공개하여 다양한 IoT 서비스에서 필요한 공통 기능을 oneM2M 플랫폼의 RESTful API로 지원</code></p>
<ul>
<li>oneM2M 플랫폼이 제공하는 기능을 공통 서비스 기능(CSF, Common Services Function) 으로 정의함</li>
<li>공통 기능은 사물인터넷 서비스 애플리케이션에서 자주 사용되는 기능을 정의한 것으로 데이터 저장/공유, 장치 관리, 그룹 관리, 구독/통지(Subscription/Notification), 위치 정보, 과금 등의 기능을 포함하며, 보안 기능은 기본적인 인증, 접근 제어 등의 기능을 제공</li>
<li>또한, oneM2M 코어 프로토콜 메시지(Primitive)는 CoAP, HTTP 및 MQTT 프로토콜 메시지를 통해 전송됨. oneM2M의 코어 프로토콜은 향후 추가 프로토콜 바인딩(Binding)을 지원할 수 있도록 특정 메시지 프로토콜에 종속성을 가지지 않도록 개발되었음</li>
</ul>
<hr>
<h3 id="oneM2M-Release-2"><a href="#oneM2M-Release-2" class="headerlink" title="oneM2M Release 2"></a>oneM2M Release 2</h3><p><code>16.07월 다양한 IoT 기술과의 연동성을 강조하여 Release 2 규격을 공개하여 OCF, AllJoyn, LwM2M, 3GPP Rel-13 등의 기술과의 연동성을 제공하고 가전 기기에 대한 정보 모델 표준을 제공 및 다양한 추가 기능을 제공</code></p>
<ul>
<li>다양한 인더스트리 사물인터넷 플랫폼 및 네트워크 연동이 주 목적</li>
<li>사물인터넷 연동으로는 AllJoyn, OCF(Open Connectivity Foundation) 및 Lightweight M2M 기술과의 연동 규격을 제공함</li>
<li>네트워크 연동으로는 3GPP Rel-13 네트워크와 연동을 위한 트래픽 패턴 설정(Traffic Pattern Configuration) 기능을 정의하고 있으며 릴리즈 3에 모니터링 등의 연동 기능을 추가하기 위한 기술 보고서를 작업을 지속하고 있음</li>
<li>높은 디바이스 및 애플리케이션의 호환성을 보장하기 위해 우선적으로 가전 디바이스에 대한 데이터 모델을 정의함<ul>
<li>릴리즈 1에서는 가전 제어 및 센싱 정보를 교환하기 위해 사전에 애플리케이션 간 정의한 데이터 모델을 container 및 contentInstance 자원 타입을 이용했다. 이에 비해 릴리즈 2에서는 oneM2M 플랫폼을 이용하는 모든 애플리케이션이 표준에 정의된 가전 디바이스 데이터 모델을 사용함으로써 가전 제조사 및 애플리케이션 개발자 간에 별도의 데이터 모델을 정의하는 번거로움을 없애고 제품과 애플리케이션 간의 호환성을 보장한다.</li>
</ul>
</li>
<li>프로토콜 바인딩은 동시 송수신(Full-duplex)을 지원하는 WebSocket이 추가됨</li>
</ul>
<hr>
<h3 id="oneM2M-Release-3"><a href="#oneM2M-Release-3" class="headerlink" title="oneM2M Release 3"></a>oneM2M Release 3</h3><p><code>Release 3 표준은 기존 연동, 시맨틱, 보안 등의 기능을 향상하고, oneM2M 시장 확대를 위한 개발자 가이드, Product Profile을 추가 개발</code></p>
<p>1.3GPP Rel-13/14 네트워크 연동</p>
<ul>
<li>UE Reachability Schedule, Location Update, Roaming, Schedule sync 지원 등</li>
</ul>
<p>2.Interworking</p>
<ul>
<li>추가된 Proximal IoT 연동 규격(TS-0033)에서 oneM2M 시스템이 아닌 디바이스나 서비스를 연동하기 위한 범용적인 연동 기술을 정의</li>
<li>OSGi, Modbud, DDS, OPC-UA에 대한 연동 기술 스터디 진행</li>
</ul>
<p>3.Transaction 지원</p>
<ul>
<li>어플리케이션의 다중 리소스 엑세스(Create, Retrieve,Update, Delete)에 대한 oneM2M 플랫폼의 트랜잭션 관리<br>(Execute, Commit, Abort, Lock) 기능 제공</li>
</ul>
<p>4.Semantics 지원 기능 향상</p>
<ul>
<li>시맨틱 매쉬업, 트리플(Triple) 쿼리, 트리플 데이터 검증 기능 추가</li>
</ul>
<p>5.멀티캐스트 기반 그룹 관리</p>
<ul>
<li>기존 그룹 관리 기능을 IP 멀티캐스트 및 3GPP MBMS (Multimedia Broadcast Multicast Service)를 활용할 수 있도록 기능 확장</li>
</ul>
<p>6.기타 추가 기능</p>
<ul>
<li>멀티미디어 스트리밍, 다중 리소스 구독(Cross-resource Subscription),AE Reachability Management, Distributed Authorization 등 개발자 가이드 추가</li>
<li>HTTP, CoAP, MQTT 프로토콜 바인딩, Long polling, device managment, semantics 기능 구현 개발자 가이드 작성 완료</li>
<li>보안 기능 개발자 가이드 작성 중</li>
</ul>
<p>7.Product Profile</p>
<ul>
<li>oneM2M 플랫폼 기능을 요약한 Feature Catalogue (TS-0031) 과 연계하여 oneM2M 제품 개발 시 구현할 기능을 프로파일 화로 정의하고 해당 기능들은 시험인증 규격에 반영됨</li>
</ul>
<hr>
<h3 id="oneM2M-공통-플랫폼-기능-모델"><a href="#oneM2M-공통-플랫폼-기능-모델" class="headerlink" title="oneM2M 공통 플랫폼 기능 모델"></a>oneM2M 공통 플랫폼 기능 모델</h3><img src="/2019/02/07/onem2m/image2.PNG" alt="oneM2M 공통 플랫폼 기능 모델" title="oneM2M 공통 플랫폼 기능 모델">
<p><code>Application Entity (AE) :</code> <u>M2M 서비스를 제공하기 위한 어플리케이션 기능 로직을 포함하는 논리적인 엔티티를 의미하며</u> 각각의 AE는 유일한 AE 식별자인 AE-ID로 구별된다. AE에 대한 예로서는 관제 시스템, 스마트그리드 시스템, 헬스케어 시스템을 위한 어플리케이션 등이 고려되어질 수 있다.</p>
<p><code>Common Service Entity (CSE) :</code> <u>oneM2M 서비스 플랫폼에서 공통적으로 제공되어야 하는 공통 서비스 기능을 제공하는 부분</u>으로서, <u>oneM2M 에서 정의한 CSE에는 총 12개의 Common Service Function (CSF) 공통 서비스 기능을 포함</u>하고 있다. CSF는 CSE에서 제공되어져야 하는 기능들 중 비슷한 기능들을 그룹화 한 논리적인 그룹으로, 각각의 CSF 들은 이후에 설명되어질 리소스를 통해서 외부에 노출되어 서비스를 제공할 수 있다. 해당 CSE는 AE를 구별하는 방식과 마찬가지로 CSE의 식별자인 CSE-ID를 통해서 유일하게 식별 가능하다.</p>
<p><code>Network Service Entity (NSE) :</code> CSE가 위치한 미들웨어의 <u>하부 네트워크 서비스에 대한 추상화 영역으로 CSE에게 네트워크 서비스를 제공한다</u>. 제공 가능한 네트워크 서비스의 예로서는 디바이스 관리, 위치관리, 3GPP 이동통신망에 연결되어있는 IoT 디바이스 트리거링 서비스 등이며 해당 서비스를 위해서는 네트워크 서비스가 관여되어진다.</p>
<p><code>Mca (M2M Communication with AE) 참조 포인트 :</code> <u>AE 와 CSE 간의 포인트를 가리키며</u>, 해당 AE가 CSE에서 제공하는 공통 서비스 기능을 이용하기 위한 API 의 연결 포인트이고, CSE 와 AE간의 통신을 위한 연결 포인트이다.</p>
<p><code>Mcc (M2M Communication with CSE) 참조 포인트</code> : <u>두 개의 CSE간의 포인트를 가리키며</u>, CSE와 다른 CSE간의 서비스 공개 및 통신을 가능하게 하는 연결 포인트이다.</p>
<p><code>Mcn (M2M Communication with NSE) 참조 포인트 :</code><u>CSE와 NSE간의 포인트를 가리키며</u>, CSE가 NSE에서 제공되는 네트워크 서비스 기능을 이용할 수 있는 연결 포인트이면서 네트워크 망으로의 데이터 전달 연결 포인트이다.</p>
<p><code>Mcc’(M2M Commmunication with CSE of different M2M Service Provider) 참조 포인트 :</code> <u>서로 다른 서비스 프로바이더에 종속적인 CSE간의 포인트를 가리키며</u>, 서비스 프로바이더 간 CSE사이의 서비스 공개 및 통신을 지원하는 연결 포인트이다.</p>
<h3 id="oneM2M-노드-구성모델-아키텍처"><a href="#oneM2M-노드-구성모델-아키텍처" class="headerlink" title="oneM2M 노드 구성모델 아키텍처"></a>oneM2M 노드 구성모델 아키텍처</h3><img src="/2019/02/07/onem2m/image3.PNG" alt="노드 구성모델" title="노드 구성모델">
<p>oneM2M의 노드 구성모델은 다음과 같다.</p>
<p><code>Infrastructure Node (IN) :</code> <u>인프라스트럭쳐 도메인에 위치하고 있는 IN-CSE를 포함하는 서버단에 위치하는 기기를 의미한다. 해당 IN은 서비스 프로바이더 당 한 개의 IN을 지원하는 것으로 정의되며 IN은 한 개의 CSE로만 구성이 되거나 1개 이상의 AE를 포함하는 형태로 구성되어질 수 있다.</u> 논리적 기기인 IN에 매칭되는 물리적 기기로는 서버를 예로 들 수 있다. IN은 Mcc 참조 포인트를 통해서 한 개 이상의 MN과 한 개 이상의 ASN과 연동되며 Mca 참조 포인트를 통해서 한 개 이상의 ADN과 연동될 수 있다. Mcc’을 통한 연동은 다른 서비스 프로바이더 영역에 위치한 IN노드와 연동된다.</p>
<p><code>Middle Node (MN) :</code> <u>필드 도메인에 위치한 MN-CSE를 포함하는 논리적 기기로 일반적으로 여러 센서나 엑추에이터들이 연결되는 게이트웨이가 이에 해당한다고 보면 된다. MN은 한 개의 CSE로 구성이 되거나, 하나의 CSE에 1개 이상의 AE 를 포함하는 형태로 구성되어질 수 있다.</u> MN은 Mcc참조 포인트를 통해서 적어도 하나의 IN 또는 MN과 연동되며 Mcc 참조 포인트를 통해서 ASN과 연동 및 Mca 참조 포인트를 통한 ADN과 연동될 수 있다.</p>
<p><code>Application Service Node (ASN) :</code> <u>필드 도메인에 위치한 ASN-CSE와 ASN-AE를 포함하고 있는 논리적 기기이다. 해당 ASN은 한 개의 CSE와 1개 이상의 AE를 포함하는 형태로 구성되며 논리적 ASN에 매칭되는 물리적 기기로는 M2M 디바이스를 예로 들 수 있다. ASN 은 Mcc 참조 포인트를 통해서 한 개의 MN 또는 한 개의 IN에 연동된다.</u></p>
<p><code>Application Dedicated Node (ADN) :</code> <u>필드 도메인에 위치한 ADN-AE를 포함하고 CSE를 포함하지 않는 논리적 기기이다.</u> 즉 해당 ADN는 CSE가 없고, 1개 이상의 AE를 포함한다. 논리적 ADN에 매칭되는 물리적 기기로는 센서 및 액츄에이터와 같은 자원제약적인 M2M 디바이스를 예로 들 수 있다. ADN은 Mca 참조 포인트를 통해서 MN 또는 IN과 연동되는 구조를 갖는다.</p>
<hr>
<h3 id="oneM2M-공통-서비스-기능"><a href="#oneM2M-공통-서비스-기능" class="headerlink" title="oneM2M 공통 서비스 기능"></a>oneM2M 공통 서비스 기능</h3><p><u>oneM2M 공통 서비스 플랫폼 개발과 관련하여 아키텍처 표준 문서에서 다루고 있는 부분은 Common Service Entity (CSE)에 대한 기능들을 표준화하는 것이다.</u> 그리고 해당 기능들은 oneM2M이 지향하고 있는 리소스 기반 아키텍처 구조를 기반으로 각각의 리소스 타입으로 해당 공통 서비스 기능들이 표현되고 있다. oneM2M 표준화 작업 진행방식은 전체적으로 유스케이스 및 요구사항을 다루고, 이를 통해 필요한 기능들을 도출해 내어 시스템 아키텍처를 디자인하고, 상세 프로토콜을 개발하는 3GPP 표준화 방식에서 취한 Stage 기반의 접근 방식으로 표준 개발을 진행하였다.</p>
<p>각각의 기능은 리소스 타입으로 표현되고 Mcc, Mca, Mcn 참조 포인트를 통해서 서비스가 제공된다.<br><img src="/2019/02/07/onem2m/image4.PNG" alt="공통 서비스 기능" title="공통 서비스 기능"></p>
<p><code>Common Service Function (CSF) :</code> 기능설명<br><code>Registration (REG) :</code> REG CSF는 AE와 CSE 또는 CSE와 CSE간의 등록을 담당하며, 이러한 등록 관계를 통해서 oneM2M 엔티티간의 접속 및 접근이 가능하며 oneM2M 엔티티간의 데이터 전달을 통한 oneM2M 서비스 구성이 가능해진다<br><code>Discovery (DIS) :</code> DIS CSF는 기본적으로 oneM2M 리소스 및 어트리뷰트에 담긴 서비스 정보에 대한 검색 기능을 제공한다. 기본적으로 텍스트 기반의 검색이 제공 되어지며, 그 이외에도 특징 기반의 검색 등이 제공되어질 수 있다.<br><code>Security (SEC) :</code> SEC CSF는 oneM2M 공통 서비스 플랫폼의 공통 기능으로서 접근권한, 키 관리와 같은 보안 메커니즘을 제공하는 기능을 담당한다.<br><code>Group Management (GMG) :</code> GMG CSF는 리소스들을 그룹으로 관리할 수 있도록 하는 기능을 담당한다. 이를 통해, 비슷한 역할을 하거나, 공동으로 관리되어져야 하는 리소스들을 그룹으로 관리할 수 있다.<br><code>Data Management &amp; Repository (DMR) :</code>DMR CSF는 기본적으로 데이터 저장소의 기능을 제공하는 것이다. 또한 데이터의 타입, 시맨틱 정보, 시간, 위치와 관련한 데이터의 분류 및 데이터 포맷의 변경 및 데이터 처리 기능을 제공한다.<br><code>Subscription &amp; Notification (SUB) :</code> SUB CSF는 리소스에 대한 구독정보를 관리하고 리소스 및 어트리뷰트에 대한 업데이트 발생, Child 리소스의 생성, 삭제 등 해당 리소스에 대한 트랙킹 및 관련된 변화 정보를 통지하는 역할을 담당한다.<br><code>Device Management (DMG) :</code> DMG CSF는 디바이스 관리 기능을 제공하는 공통 서비스 기능이다. 디바이스 관리라고 함은 디바이스에 설치된 펌웨어에 대한 관리, 디바이스 하드웨어 리소스 관리, 디바이스 동작 설정 관리, 진단을 포함한다.<br><code>Application &amp; Service Management (ASM) :</code> ASM CSF는 ADN, ASN, MN, IN에 위치한 AE와 CSE 소프트웨어에 대한 관리 기능을 담당한다. 해당 기능은 AE와 CSE의 재설치, 업데이트, 고장탐지, 설정에 관한 기능을 제공한다.<br><code>Communication Management &amp; Delivery Handling (CMDH) :</code> CSE간, AE와 CSE간, 데이터 전달 시에 NSE를 통한 데이터 전달 서비스를 제공하는 기능을 담당한다. CMDH CSF는 메시지 전달을 위해서 언제 보낼건지, 어떤 네트워크 연결을 활용하여 보낼지를 결정한다.<br><code>Network Service Exposure, Service Execution &amp; Triggering (NSSE) :</code>NSSE CSF는 기저 네트워크와 관련된 통신을 관리하며 Mcn 참조 포인트를 통한 네트워크 접근 서비스를 제공한다.<br><code>Location (LOC):</code> LOC CSF는 AE의 위치 정보 요청에 대해서 ASN, MN과 관련된 위치정보를 획득하기 위한 방법을 제공하는 CSF이다.<br><code>Service Charging &amp; Accounting (SCA) :</code> SCA CSF는 oneM2M 공통 서비스 플랫폼을 통해서 제공되는 서비스에 대한 과금 체계 및 방법에 대한 기능을 제공한다.</p>
<hr>
<h3 id="oneM2M의-장치관리-표준"><a href="#oneM2M의-장치관리-표준" class="headerlink" title="oneM2M의 장치관리 표준"></a>oneM2M의 장치관리 표준</h3><p>oneM2M의 장치관리 표준은 ETSI TC M2M 규약에서 정한 BBF <u>TR-069</u>와 <u>OMA(Open Mobile Alli-ance)-DM(Device Management)</u> 표준을 그대로 승계하였고, 더 나아가 제약 많은 IoT 장치를 위한 <u>OMA LWM2M</u>까지 포함한다.</p>
<p><code>OMA-DM, TR-069는 다음 포스트에서 다룬다</code></p>
<hr>
<h3 id="나만의-요약"><a href="#나만의-요약" class="headerlink" title="나만의 요약"></a>나만의 요약</h3><h2 id="oneM2M에서는-CSE가-핵심이다"><a href="#oneM2M에서는-CSE가-핵심이다" class="headerlink" title="oneM2M에서는 CSE가 핵심이다."></a>oneM2M에서는 CSE가 핵심이다.</h2><h3 id="별첨"><a href="#별첨" class="headerlink" title="별첨"></a>별첨</h3><h4 id="LwM2M-Lightweight-M2M"><a href="#LwM2M-Lightweight-M2M" class="headerlink" title="LwM2M(Lightweight M2M)"></a>LwM2M(Lightweight M2M)</h4><p>LwM2M(Lightweight M2M)은 M2M 또는 IoT 장치 관리를 위하여 LwM2M 서버와 LwM2M 장치에 있는 LwM2M 클라이언트 간의 응용 프로그램 계층 통신 프로토콜을 정의함. 소형기기를 포함하여 다양한 사물인터넷 기기를 지원하기 위한 기기 관리 표준임.<br>1)센서 또는 셀룰러 네트워크를 통한 장치 관리 기능 제공<br>2)네트워크에서 장치로 서비스 데이터 전송<br>3)대부분의 모든 응용 프로그램의 요구사항을 충족하도록 확장 을 위하여 설계됨. 자원이 제한된 LwM2M 디바이스를 감안하여 효율적인 리소스 데이터 모델을 기반으로 가볍고 간결한 프로토콜로 IETF CoAP을 사용하고 있음</p>
<h4 id="REST-Representational-State-Transfer"><a href="#REST-Representational-State-Transfer" class="headerlink" title="REST(Representational State Transfer)"></a>REST(Representational State Transfer)</h4><p>웹 상의 자료를 HTTP위에서 별도의 전송 계층 없이 전송하기 위한 아주 간단한 인터페이스이다. URI는 자원을 표현하는 데에 집중하고 행위에 대한 정의는 HTTP METHOD를 통해 하는 것이 REST한 API를 설계하는 중심 규칙이다.</p>
<h4 id="CoAP"><a href="#CoAP" class="headerlink" title="CoAP"></a>CoAP</h4><ul>
<li>Internet에서 IoT device처럼 제한된 computing 성능을 갖는 device들의 통신을 위해 IETF의 CoRE(Constrained RESTful Environment) working-group에서 표준화한 protocol</li>
<li>신뢰성 있는 동기 수송 방식의 TCP와 그 위의 HTTP는 많은 resource제약을 가진 IoT 환경에서는 적합하지 않아 비동기 수송 방식의 UDP상에서 <u>UDP의 단점을 보완하는 개념을 포함한 통신 protocol</u></li>
</ul>
<h4 id="OCF"><a href="#OCF" class="headerlink" title="OCF"></a>OCF</h4><p><code>사물인터넷 구현 시 REST 구조 기반으로 경량형 CoAP 프로토콜로 사물인터넷 장치들을 연결하고 장치에 존재하는 자원들을 상호제어 할 수 있게 하는 표준 플랫폼 기술</code></p>
<ul>
<li>OCF 아키텍처는 클라이언트-서버의 방식으로 RESTful 아키텍처를 기반으로 리소스를 관리하는 모델</li>
<li>사물인터넷 디바이스의 제한된 성능을 고려하여 CoAP(Constrained Application Protocol)을 활용하여 경량 기기에서의 동작도 고려함</li>
</ul>
<hr>
<h4 id="MQTT"><a href="#MQTT" class="headerlink" title="MQTT"></a>MQTT</h4><p>MQTT(Message Queue for Telemetry Transport)는 M2M 또는 IoT 기기와 G/W의 연동을 위해 정의된 프로토콜입니다. 경량 프로토콜로 저전력 장비에서도 운용 가능하며 network bandwidth가 작은 곳에서도 충분히 운용 가능하도록 설계된 프로토콜입니다.</p>
<hr>
<h4 id="참고자료"><a href="#참고자료" class="headerlink" title="참고자료"></a>참고자료</h4><p><a href="http://www.iotocean.org/common/download.asp?pach=/upload/Board/&amp;file=6VXFR20174271377.pdf" target="_blank" rel="external">http://www.iotocean.org/common/download.asp?pach=/upload/Board/&amp;file=6VXFR20174271377.pdf</a><br>(IoT 표준/기술 동향 2017-9호) 2017-9호_oneM2M Release 3 표준<br><a href="http://www.iotforum.kr/board1/read.asp?bdNum=101&amp;sc_field=&amp;sc_word=&amp;bdCode=13350" target="_blank" rel="external">http://www.iotforum.kr/board1/read.asp?bdNum=101&amp;sc_field=&amp;sc_word=&amp;bdCode=13350</a><br><a href="http://woowabros.github.io/experience/2017/08/11/ost_mqtt_broker.html" target="_blank" rel="external">http://woowabros.github.io/experience/2017/08/11/ost_mqtt_broker.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;M2M-Machine-to-Machine&quot;&gt;&lt;a href=&quot;#M2M-Machine-to-Machine&quot; class=&quot;headerlink&quot; title=&quot;M2M(Machine to Machine)&quot;&gt;&lt;/a&gt;M2M(Machine to Mach
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="IOT" scheme="http://KKimSangHeon.github.io/categories/CS/IOT/"/>
    
    
  </entry>
  
  <entry>
    <title>1.1 테이블과 인덱스의 분리</title>
    <link href="http://KKimSangHeon.github.io/2019/02/07/db/"/>
    <id>http://KKimSangHeon.github.io/2019/02/07/db/</id>
    <published>2019-02-07T11:29:44.000Z</published>
    <updated>2019-02-07T11:31:59.183Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-1-테이블과-인덱스의-분리"><a href="#1-1-테이블과-인덱스의-분리" class="headerlink" title="1.1 테이블과 인덱스의 분리"></a>1.1 테이블과 인덱스의 분리</h3><p>테이블과 인덱스가 분리되어 있는것은 관계형 DB의 일반적인 형태이다.<br>과거엔 키와 데이터가 붙어있었다면 현재는 키를 통해 데이터를 한번 더 찾아가야한다.</p>
<h4 id="1-1-1-분리형-테이블의-구조-7p"><a href="#1-1-1-분리형-테이블의-구조-7p" class="headerlink" title="1.1.1 분리형 테이블의 구조 7p"></a>1.1.1 분리형 테이블의 구조 7p</h4><p>활용가능한 블록을 Free List에 기록했다가 데이터를 저장할 때 제공한다.<br>로우가 끊어지게 될 경우 Free Space를 활용하여 재배치를 하도록 한다.</p>
<p>테이블스페이스 : 논리적인 저장공간을 의미하며 이는 물리적인 데이터 파일로 구성된다.<br>세그먼트 : 테이블 스페이스를 용도별로 나눈것<br>오브젝트 : 세그먼트에 들어올 수 있는것.<br>단위 오브젝트 : 테이블이나 인덱스의 파티션들 파티션된 테이블의 각 파티션이 서로 다른 테이블 스페이스에 존재할 수 있다.<br>ROW ID : 해당값을 통해 물리적인 저장 위치를 찾아낼 수 있다. 이는 논리적인 값으로서 블록 내에서 로우의 위치가 이동하더라도 변하지 않는다.<br>로우의 이주(Migration) : 블록 밖으로 로우가 이동할 경우 이전 블록에 옮긴 주소를 넣어놓는 방법이 있는데 이에 따른 오버헤드를 감수해야한다. 이를 로우의 이주라 한다.<br>체인 : 로우의 길이가 블록을 넘을 때 블록을 연결해서 저장해야하는데 이를 체인이 발생했다라고 한다.</p>
<h4 id="1-1-2-클러스터링-팩터"><a href="#1-1-2-클러스터링-팩터" class="headerlink" title="1.1.2 클러스터링 팩터"></a>1.1.2 클러스터링 팩터</h4><p>클러스터링 팩터 : 인덱스 로우의 순서와 테이블에 저장되어있는 데이터 로우의 위치가 얼마나 비슷한 순서로 저장되어 있느냐에 대한 정도를 의미.<br>클러스터링 팩터는 액세스 효율에 직접적인 영향 : 클러스터링 팩터가 좋은 인덱스로 액세스를 하면 적은 블록을 액세스 하게 되므로<br>클러스터링 팩터를 향상시키는 방법</p>
<ol>
<li>임의의 위치에 저장하는 방식.</li>
<li>주기적으로 테이블 재생성.</li>
</ol>
<h4 id="1-1-3-분리형-테이블의-액세스-영향-요소"><a href="#1-1-3-분리형-테이블의-액세스-영향-요소" class="headerlink" title="1.1.3 분리형 테이블의 액세스 영향 요소"></a>1.1.3 분리형 테이블의 액세스 영향 요소</h4><h5 id="가-넓은-범위의-액세스-처리에-대한-대처방안"><a href="#가-넓은-범위의-액세스-처리에-대한-대처방안" class="headerlink" title="가) 넓은 범위의 액세스 처리에 대한 대처방안"></a>가) 넓은 범위의 액세스 처리에 대한 대처방안</h5><p>이는 임의의 영역에 데이터가 저장되는 형태로서 액세스할 경우 대가가 크다.</p>
<ul>
<li>소형테이블의 경우 : 임의로 저장해도 액세스 할 때도 큰 영향이 없다.</li>
<li>중형테이블의 경우 : 어느컬럼에 맞추어 저장할것인지 결정</li>
<li>대형테이블의 경우 :<ol>
<li>단순 저장형(ex: log) : 신속한 저장이 요구되므로 분리형이 가장 적절하다. 또한 데이터의 양이 많으므로 파티션과 같은 조치 필요</li>
<li>주로 랜덤액세스이며 다양하지 않은 액세스 형태(ex: 고객): 분리형 구조가 적당. 한번에 대량의 급격히 들어오는 경우가 드물고 범위처리를 자주 하지도 않음.</li>
<li>데이터가 지속적으로 증가 및 다양하 형태의 액세스(ex: 매출) : 파티션을 진행하고 인덱스를 전략적으로 구성하고 SQL 실행계획 최적화.</li>
</ol>
</li>
</ul>
<h5 id="나-클러스터링-팩터-향상-전략"><a href="#나-클러스터링-팩터-향상-전략" class="headerlink" title="나) 클러스터링 팩터 향상 전략"></a>나) 클러스터링 팩터 향상 전략</h5><p>주기적으로 테이블을 재성성시켜주는 방법이 최고! (이때는 관련 인덱스를 모두 제거하거나 비활성화 할것- 저장속도 저하유발 및 인덱스 분할로 인한 저장밀도가 나빠짐)<br>이를 위해 가장 유리한 형태로 저장되도록 하고 자주 범위처리를 하는 컬럼들로 정렬하자!  </p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-1-테이블과-인덱스의-분리&quot;&gt;&lt;a href=&quot;#1-1-테이블과-인덱스의-분리&quot; class=&quot;headerlink&quot; title=&quot;1.1 테이블과 인덱스의 분리&quot;&gt;&lt;/a&gt;1.1 테이블과 인덱스의 분리&lt;/h3&gt;&lt;p&gt;테이블과 인덱스가 분리되어
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Data Base" scheme="http://KKimSangHeon.github.io/categories/CS/Data-Base/"/>
    
    
  </entry>
  
  <entry>
    <title>hexo command not found 에러 발생시</title>
    <link href="http://KKimSangHeon.github.io/2019/01/22/hexoerr/"/>
    <id>http://KKimSangHeon.github.io/2019/01/22/hexoerr/</id>
    <published>2019-01-21T15:12:31.000Z</published>
    <updated>2019-01-21T15:14:38.104Z</updated>
    
    <content type="html"><![CDATA[<p>npm이 global로 설치한 것을 찾지 못할 때 발생한다.</p>
<p>환경변수에 아래의 경로를 추가해 주도록 하자</p>
<p><code>C:\Users\SangHeon\AppData\Roaming\npm</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;npm이 global로 설치한 것을 찾지 못할 때 발생한다.&lt;/p&gt;
&lt;p&gt;환경변수에 아래의 경로를 추가해 주도록 하자&lt;/p&gt;
&lt;p&gt;&lt;code&gt;C:\Users\SangHeon\AppData\Roaming\npm&lt;/code&gt;&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
</feed>
