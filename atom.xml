<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kim Sang Heon&#39;s Bolg</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://KKimSangHeon.github.io/"/>
  <updated>2019-03-03T23:56:00.906Z</updated>
  <id>http://KKimSangHeon.github.io/</id>
  
  <author>
    <name>Kim Sang Heon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>FIFO, OPT, LRU, 전역/지역교체</title>
    <link href="http://KKimSangHeon.github.io/2019/03/04/operating-system24/"/>
    <id>http://KKimSangHeon.github.io/2019/03/04/operating-system24/</id>
    <published>2019-03-03T23:22:17.000Z</published>
    <updated>2019-03-03T23:56:00.906Z</updated>
    
    <content type="html"><![CDATA[<p>메모리 용량이 작을수록 페이지 폴트가 자주일어난다</p>
<h3 id="Belady’s-Anomaly"><a href="#Belady’s-Anomaly" class="headerlink" title="Belady’s Anomaly"></a>Belady’s Anomaly</h3><p>메모리 용량이 늘어나느데도 페이지 폴트가 발생하는 이상한 현상이 발생한다.<br>언제? FIFO를 사용할때!</p>
<h3 id="Optimal-OPT"><a href="#Optimal-OPT" class="headerlink" title="Optimal (OPT)"></a>Optimal (OPT)</h3><p>2를 몰아냈는데 2가 필요한 경우가 생길 수 있다. 즉 억울한 경우<br>이런일이 안일어나게 하기위해 <u>앞으로 사용되지 않을것을 희생자로 선택한다.</u><br><u>이는 비현실적이다. 앞으로 뭐가 사용안될지 잘 모르는것이다,</u><br>SJF와 비슷하다. 이 또한 어떤놈이 제일 짧은지 알 수 없다.</p>
<h3 id="Least-Recently-Used-LRU"><a href="#Least-Recently-Used-LRU" class="headerlink" title="Least-Recently-Used (LRU)"></a>Least-Recently-Used (LRU)</h3><p><u>최근에 가장 적게 사용된놈을 희생양으로 삼는다. 대부분의 컴퓨터가 사용하는 방식.</u><br>가장 좋은것은 앞으로 사용안될것을 희생양으로 삼는게 좋겠지만 현실적으로 판단하기 어려움으로,</p>
<h3 id="Global-vs-Local-Replacement"><a href="#Global-vs-Local-Replacement" class="headerlink" title="Global vs Local Replacement"></a>Global vs Local Replacement</h3><p><code>Global replacement</code> - 희생자를 선택할 때 메모리 상의 모든 프로세스 페이지에 대해 교체<br><code>Local replacement</code>- 희생자를 선택할 때 메모리 상의 자기 프로세스 페이지에 대해 교체</p>
<p><code>성능 비교</code> - Global replacement 가 더 효율적일 수 있다.</p>
<hr>
<p>CPU utilization vs Degree of multiprogramming</p>
<p>CPU utilization - CPU 이용률<br>Degree of multiprogramming - 메인메모리에 올라와있는 프로세스의 갯수</p>
<p>메모리 안에프로세스를 많이 올리니까 일정범위를 넘어서면 CPU의 이용률이 감소했다.<br><code>왜그럴까?</code> : 너무 많은 프로세스로 인해 빈번한 page in/out가 발생한다. 즉 디스크 IO가 많아져서 CPU이용율이 떨어진다. 이를 <u>쓰레싱(Thrashing)</u>라고 한다.</p>
<p><code>쓰레싱???</code> : 일정범위를 넘어서면 CPU이용율이 떨어지는데 이범위를 쓰레싱이라 한다.</p>
<h3 id="쓰레싱을-극복하기-위한-방법"><a href="#쓰레싱을-극복하기-위한-방법" class="headerlink" title="쓰레싱을 극복하기 위한 방법."></a>쓰레싱을 극복하기 위한 방법.</h3><p>Global replacement 보다는 local replacement 활용<br>프로세스당 충분한/적절한 수의 메모리(프레임) 할당</p>
<h3 id="프레임-할당-Allocation-of-Frames"><a href="#프레임-할당-Allocation-of-Frames" class="headerlink" title="프레임 할당(Allocation of Frames)"></a>프레임 할당(Allocation of Frames)</h3><p><u>프레임 할당은 크게 <u>정적할당 동적할당</u>으로 나뉜다.</u></p>
<h4 id="정적-할당-static-allocation-또한-균등할당-비례할당으로-나뉜다"><a href="#정적-할당-static-allocation-또한-균등할당-비례할당으로-나뉜다" class="headerlink" title="정적 할당 (static allocation) 또한 균등할당, 비례할당으로 나뉜다."></a>정적 할당 (static allocation) 또한 균등할당, 비례할당으로 나뉜다.</h4><p><code>균등 할당 (Equal allocation)</code> : 메인메모리에 프레임 수가 100개고 프로세스 수가 3개면 각 프레세스에 프레임을 33개씩 할당해주는것. 조금 적절하지 않다. hwp와 메모장이 올라와 있을 때 동일하게 분배한다는것은 옳지않다!! hwp는 조금더 무겁잖아<br><code>비례 할당 (Proportional allocation)</code> : 사이즈가 큰놈한텐 많이 나눠주고 작은놈한텐 적게 나눠주는것.</p>
<p>사실 hwp에서 특별한 기능은 많이 쓰지 않으므로 정적할당은 올바르지 않다,</p>
<h4 id="동적-할당-dynamic-allocation-또한-Working-set-model-Page-fault-frequency-등으로-나뉜다"><a href="#동적-할당-dynamic-allocation-또한-Working-set-model-Page-fault-frequency-등으로-나뉜다" class="headerlink" title="동적 할당 (dynamic allocation) 또한 Working set model , Page fault frequency 등으로 나뉜다."></a>동적 할당 (dynamic allocation) 또한 Working set model , Page fault frequency 등으로 나뉜다.</h4><p><code>Working set model</code> :<br><code>Page fault frequency</code> :</p>
<p>다음 포스팅에서….</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;메모리 용량이 작을수록 페이지 폴트가 자주일어난다&lt;/p&gt;
&lt;h3 id=&quot;Belady’s-Anomaly&quot;&gt;&lt;a href=&quot;#Belady’s-Anomaly&quot; class=&quot;headerlink&quot; title=&quot;Belady’s Anomaly&quot;&gt;&lt;/a&gt;Bel
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>23.페이지 교체 필요성, 희생 페이지 설정 원칙</title>
    <link href="http://KKimSangHeon.github.io/2019/02/28/operating-system23/"/>
    <id>http://KKimSangHeon.github.io/2019/02/28/operating-system23/</id>
    <published>2019-02-28T05:39:51.000Z</published>
    <updated>2019-02-28T05:40:18.477Z</updated>
    
    <content type="html"><![CDATA[<h3 id="가상메모리"><a href="#가상메모리" class="headerlink" title="가상메모리"></a>가상메모리</h3><p>프로세스를 페이지 크기로 쪼개서 메인메모리로 올리는데 당장 필요한 것들만 올리고 보자</p>
<p>그러다 메모리가 꽉차게 되면 한놈을 쫒아내고 필요한놈을 불러온다,</p>
<h3 id="Demand-Paging"><a href="#Demand-Paging" class="headerlink" title="Demand Paging"></a>Demand Paging</h3><p>프로세스 이미지는 backing store 에 저장<br>프로세스는 페이지의 집합</p>
<h3 id="가상메모리를-위한-하드웨어-지원"><a href="#가상메모리를-위한-하드웨어-지원" class="headerlink" title="가상메모리를 위한 하드웨어 지원"></a>가상메모리를 위한 하드웨어 지원</h3><p>valid 비트 추가된 페이지 테이블<br>backing store (= swap device)</p>
<h3 id="Memory-full"><a href="#Memory-full" class="headerlink" title="Memory full!"></a>Memory full!</h3><p>메모리가 가득 차면 추가로 페이지를 가져오기 위해<br>어떤 페이지는 backing store 로 몰아내고 (page-out)<br>그 빈 공간으로 페이지를 가져온다 (page-in) -  용어: victim page</p>
<h3 id="어느-페이지를-몰아낼-것인가"><a href="#어느-페이지를-몰아낼-것인가" class="headerlink" title="어느 페이지를 몰아낼 것인가?"></a>어느 페이지를 몰아낼 것인가?</h3><p>i/o 시간 절약을 위해 기왕이면 modify 되지 않은 페이지를 victim 으로 선택<br>방법: modified bit (= dirty bit)</p>
<h3 id="Page-reference-string"><a href="#Page-reference-string" class="headerlink" title="Page reference string"></a>Page reference string</h3><p>CPU 가 내는 주소: 100 101 102 432 612 103 104 611 612<br>Page size = 100 바이트라면<br>페이지 번호 = 1 1 1 4 6 1 1 6 6<br>Page reference string = 1 4 6 1 6</p>
<p><code>설명</code>: fault가 발생하면 100바이트씩 (한페이지씩) 갖고오게 되기 떄문에 100번지를 못찾을경우 100~199까지 갖고오므로 그다음의 101은 fault가 발생하지 않는다. 즉 연속적일 때 앞에서 한번만 갖고오게 한다.</p>
<h3 id="Page-Replacement-Algorithms"><a href="#Page-Replacement-Algorithms" class="headerlink" title="Page Replacement Algorithms"></a>Page Replacement Algorithms</h3><p><code>FIFO (First-In First-Out)</code> : 메인메모리에 먼저 올라온놈을 내보낸다.<br><code>OPT (Optimal)</code> :<br><code>LRU (Least-Recently-Used)</code></p>
<h3 id="FIFO-기법"><a href="#FIFO-기법" class="headerlink" title="FIFO 기법"></a>FIFO 기법</h3><p><code>Idea</code>: 초기화 코드는 더 이상 사용되지 않을 것이라는 생각을 바탕으로 만들어짐! 가장 간단하다.</p>
<p><code>예제</code><br>페이지 참조열 = 7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1<br>of frames = 3<br>15 page faults</p>
<h3 id="Optimal-OPT"><a href="#Optimal-OPT" class="headerlink" title="Optimal(OPT)"></a>Optimal(OPT)</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;가상메모리&quot;&gt;&lt;a href=&quot;#가상메모리&quot; class=&quot;headerlink&quot; title=&quot;가상메모리&quot;&gt;&lt;/a&gt;가상메모리&lt;/h3&gt;&lt;p&gt;프로세스를 페이지 크기로 쪼개서 메인메모리로 올리는데 당장 필요한 것들만 올리고 보자&lt;/p&gt;
&lt;p&gt;그러다
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>22.가상메모리 개요와 원리</title>
    <link href="http://KKimSangHeon.github.io/2019/02/27/operating-system22/"/>
    <id>http://KKimSangHeon.github.io/2019/02/27/operating-system22/</id>
    <published>2019-02-26T22:48:09.000Z</published>
    <updated>2019-02-26T23:48:40.479Z</updated>
    
    <content type="html"><![CDATA[<p>일정크기로 자르는 페이징<br>논리적 크기로 자르는 세그멘테이션</p>
<p><code>보호와 공유적인 측면에서는 세그먼트보다 페이징이 낫다.</code></p>
<p>세그먼트는 코드,데이터,스택이라고 잘랐을 때 각 크기는 다르다. 다른 데이터를 남는부분에 넣을라 하면 들어갈 수가 없다. 즉 외부단편화가 발생한다. 치명적인 문제! 외부단편화는 너무 치명적이다.</p>
<p><code>그럼 세그멘테이션과 페이징을 합치면 좋지않을까?</code><br>1.처음에는 코드,데이터,스택으로 나누어 세그먼트로 자르고<br>2.각 세그먼트를 일정한크기(페이지로) 자른다.</p>
<p>이를 Paged segmentation이라 한다.</p>
<p>하지만 이 경우 CPU - 세그먼트 테이블 - 페이지 테이블 - 메모리 를 거치게 되는데 두가지의 테이블을 거치기 때문에 느려진다.</p>
<h3 id="가상메모리"><a href="#가상메모리" class="headerlink" title="가상메모리"></a>가상메모리</h3><p>물리적인 메모리 크기의 한계를 극복하기 나옴,.<br>내 컴퓨터의 메모리가 1gb이면 2gb의 프로세스를 올리지는 못한다.</p>
<p>요즘 나오는 컴퓨터는 모두 가상메모리 기법이 적용되어 있다.</p>
<p><code>어떤원리로?</code>: 오류처리, 배열 등 지금은 불필요한것들은 올리지 않고 나중에 필요할 때 올린다. 동적 적재 (dynamic loading)과 비슷한 개념. 즉 각 프로세스를 페이지단위로 자르고 지금필요한것만 올린다. 이를 <u>요구페이징(Demand Paging)</u>이라고 한다.</p>
<h3 id="Demand-Paging"><a href="#Demand-Paging" class="headerlink" title="Demand Paging"></a>Demand Paging</h3><p>프로세스 이미지는 backing store 에 저장<br>프로세스는 페이지의 집합<br><u>지금 필요한 페이지만 메모리에 올린다(load) - 요구되는 (demand) 페이지만 메모리에 올린다</u></p>
<p>CPU가 페이지 테이블에 접근했을 때 자기가 읽고자 하는것의 valid 비트가 invalid 일 경우 인터럽트가 걸리게되고 CPU는 하던일을 정지하고 오류처리(필요한것을 들고오는 루틴)를 실행한다.</p>
<p>가상메모리를 만드는 방법은 Demand paging , virtual memory가 있다.</p>
<h3 id="Page-Fault"><a href="#Page-Fault" class="headerlink" title="Page Fault"></a>Page Fault</h3><p>Demand Paging에서 페이지를 읽으려 했는데 페이지가 없다!<br>이에따른 Page Falult Routine가 필요하다.</p>
<h3 id="pure-demand-paging-vs-prepaging"><a href="#pure-demand-paging-vs-prepaging" class="headerlink" title="pure demand paging vs prepaging"></a>pure demand paging vs prepaging</h3><p><code>pure demand paging</code> : 프로그램 실행할 때 아무것도 들고오지 않음. 그러므로 처음시작부터 page fault가 발생하여 처음부터 필요한것을 갖고온다. 즉 이로 인해속도가 느려진다. 하지만 필요한것만 불러오므로 메모리가 절약된다.</p>
<p><code>prepaging</code>: 미리 필요한것을 예측하여 들고온다. 메모리는 낭비될 수 있으나 page fault가 적게일어나므로 속도적인 측면에서 부담이 적다</p>
<h3 id="swaping-vs-demand-paging"><a href="#swaping-vs-demand-paging" class="headerlink" title="swaping vs  demand paging"></a>swaping vs  demand paging</h3><p><code>swaping</code> : 화장실 가면 프로세스를 백킹스토어로 몰아내는것. 이때 <u>왔다갔다하는 단위는 프로세스 단위</u>이다,<br><code>demand paging</code> : 백킹스토어를 <u>왔다갔다 하는 단위가 페이지 단위</u>이다,</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;일정크기로 자르는 페이징&lt;br&gt;논리적 크기로 자르는 세그멘테이션&lt;/p&gt;
&lt;p&gt;&lt;code&gt;보호와 공유적인 측면에서는 세그먼트보다 페이징이 낫다.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;세그먼트는 코드,데이터,스택이라고 잘랐을 때 각 크기는 다르다. 다른 데이터를
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>21.세그멘트 테이블, 주소변환</title>
    <link href="http://KKimSangHeon.github.io/2019/02/26/operating-system21/"/>
    <id>http://KKimSangHeon.github.io/2019/02/26/operating-system21/</id>
    <published>2019-02-26T11:40:29.000Z</published>
    <updated>2019-02-26T11:42:25.812Z</updated>
    
    <content type="html"><![CDATA[<h3 id="내부단편화-페이지-테이블"><a href="#내부단편화-페이지-테이블" class="headerlink" title="내부단편화, 페이지 테이블"></a>내부단편화, 페이지 테이블</h3><p>파워를 키면 OS가 메인 메모리로 올라간다. 프로세스들이 메모리에 연속으로 들어가게되면외부단편화 문제가 발생<br>그래서 메모리에 프로그램을 프레임 단위로 나눠 흩어져서 들어가게 했다.<br>하지만 CPU는 페이지 테이블로 인해 연속적으로 위치한다고 생각하게 된다.<br>페이지를 이용해서 내부단편화가 발생하지만 이는 미미한 정도이다!! 페이지 테이블은 고속의 SRAM으로 만드는데 이를 TLB (Translation Look-aside Buffer)라 한다.</p>
<p>페이지 테이블에서 물리주소를 찾을 수 있을 때 히트했다고 한다.</p>
<h3 id="보호"><a href="#보호" class="headerlink" title="보호"></a>보호</h3><p>모든 주소는 페이지 테이블을 경유한다. 그러므로 페이지테이블 엔트리(페이지 테이블의 끝쪽)마다 <u>R,W,X 비트를 두어 접근 제어를 한다.</u></p>
<h3 id="공유"><a href="#공유" class="headerlink" title="공유"></a>공유</h3><p>문서편집기를 세개 띄웠다고 가정하자. 각 프로그램마다 코드, 데이터, 스택이 따로 할당되면 메모리의 낭비이다. 코드는 공유가능하므로 하나만 만든다. 즉 페이지들이 코드영역은 셋다 똑같은 부분의 프레임을 가르키게 된다.<br>코드가 공유되려면 코드의 내용이 실행중에 변경되면 안된다, 이를  non-self- modifying code = reentrant code = pure code 라고 한다.<br><u>프로세스의 페이지 테이블 코드 영역이 같은 곳을 가리키게</u></p>
<h3 id="세그멘테이션-Segmentation"><a href="#세그멘테이션-Segmentation" class="headerlink" title="세그멘테이션 Segmentation"></a>세그멘테이션 Segmentation</h3><img src="/2019/02/26/operating-system21/image1.png" alt="세그먼트에서 주소변환" title="세그먼트에서 주소변환">
<p>페이지는 일정크기로 잘랐다.<br><u>세그멘테이션은 프로세스를 논리적 내용(=세그멘트)으로 잘라서 메모리에 배치!</u><br>코끼리를 자를때 페이지는 같은 크기로 자르지만 세그멘테이션은 논리적 크기(얼굴,몸통,꼬리)로 자른다.</p>
<p>프로세스는 세그멘테이션의 집합니다!. 프로세스는 코드 데이터 스택 세개의 뭉치가 존재한다. 하나의 프로세스는 세개의 프로세스의 집합이다! 일반적으로 세그먼트들의 크기는 다르다.</p>
<p>백킹스터어에 프로세스가 있을 때 메인메모리에 올리기 위해 세그먼트로 나누고 메모리로 올린다.(역시나 비연속적)<br>CPU를 속이기 위해 역시나 세그먼트 테이블을 만든다. 그리고 CPU가 낸 세그먼트 번호, 변위이고 세그먼트 테이블의 인덱스에 속한값+변위로 실제 주소를 알 수 있다. 또한 세그먼트 테이블에는 1차원 배열형태인 페이지 테이블과 다르게 base, limit로 즉 2차원배열형태로 구성된다. 만약 CPU가 낸 d의 값이 limit보다 클 경우 CPU로 인터럽트를 보내게 된다.</p>
<h4 id="논리주소-Logical-address"><a href="#논리주소-Logical-address" class="headerlink" title="논리주소 (Logical address)"></a>논리주소 (Logical address)</h4><p>CPU 가 내는 주소는 segment 번호(s) + 변위(d)</p>
<h4 id="주소변환-논리주소-→-물리주소-Physical-address"><a href="#주소변환-논리주소-→-물리주소-Physical-address" class="headerlink" title="주소변환: 논리주소 → 물리주소 (Physical address)"></a>주소변환: 논리주소 → 물리주소 (Physical address)</h4><p>세그멘트 테이블 내용: base 그리고 limit<br>세그멘트 번호(s)는 세그멘트 테이블 인덱스 값<br>s 에 해당되는 테이블 내용으로 시작 위치 및 한계값 파악<br>한계(limit)를 넘어서면 segment violation 예외 상황 처리</p>
<h2 id="물리주소-base-s-d"><a href="#물리주소-base-s-d" class="headerlink" title="물리주소 = base[s] + d"></a>물리주소 = base[s] + d</h2><h3 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h3><p>Limit / Base<br>1000 / 1400<br>400  / 6300<br>400  / 4300<br>1100 / 3200<br>1100 / 3200<br>1000 / 4700</p>
<ol>
<li><code>논리주소 (2,100) 는 물리주소 무엇인가?</code> 4400</li>
<li><code>논리주소 (1, 500) 은 물리주소?</code> 6800이라하면 틀렸다!!! 해당주소 없음!!(limit를 넘는다)</li>
</ol>
<h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h3><p>운영체제를 처음배울땐 프로세스들이 순차적으로 들어가는지 알았다. 그러다 보니 메모리 낭비가 심해서 자르기로 함.<br>그래서 일정크기로 자르는 페이징 기법이 나왔고 논리적 크기로 자르는 세그멘테이션이 나왔다.<br>페이징을 사용하는 방법이 더 일반적이다.</p>
<p>세그멘테이션은 보호와 공유측면에서 페이징보다 낫다.<br><code>왜 그럴까?</code> : 모든 주소는 세그멘트 테이블을 경유하므로, 세그멘트 테이블 엔트리마다 r, w, x 비트 두어 해당 세그멘트에 대한 접근 제어 가능<br><code>뭐야 페이지 뭐가다른데?</code> : 페이지 단위로 자르면 일정한 크기이기 때문에 코드,데이터가 섞이는 부분이 생길 수 있다. 즉 안심,등심이 섞인 부분이 생겨 r로만 줄지  rw로 줄지 논란이 생길 수 있다.</p>
<h3 id="그러나-대부분의-운영체제는-페이징을-쓴다"><a href="#그러나-대부분의-운영체제는-페이징을-쓴다" class="headerlink" title="그러나 대부분의 운영체제는 페이징을 쓴다"></a>그러나 대부분의 운영체제는 페이징을 쓴다</h3><p><code>왜?</code> 그건 다음포스팅에서..</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;내부단편화-페이지-테이블&quot;&gt;&lt;a href=&quot;#내부단편화-페이지-테이블&quot; class=&quot;headerlink&quot; title=&quot;내부단편화, 페이지 테이블&quot;&gt;&lt;/a&gt;내부단편화, 페이지 테이블&lt;/h3&gt;&lt;p&gt;파워를 키면 OS가 메인 메모리로 올라간다.
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>20.페이지 테이블, 주소변환/페이징에서의 주소변환</title>
    <link href="http://KKimSangHeon.github.io/2019/02/26/operating-system20/"/>
    <id>http://KKimSangHeon.github.io/2019/02/26/operating-system20/</id>
    <published>2019-02-25T23:57:15.000Z</published>
    <updated>2019-02-26T00:02:13.052Z</updated>
    
    <content type="html"><![CDATA[<p>페이지 테이블, 주소변환</p>
<h2 id="주소변환"><a href="#주소변환" class="headerlink" title="주소변환?"></a>주소변환?</h2><p>컴퓨터에는 CPU, 메모리, 보조기억장치가 존재.<br>파워를 켜면 메모리 안에 OS가 들어오고 요청하는 대로 프로그램들이 메모리로 들어온다.<br>프로그램들이 연속으로 들어갈 경우 외부단편화 문제가 발생한다. 그래서 메모리를 프레임 단위로 쪼개서 넣는다. 프로세스들은 흩어져서 프레임 단위로 저장된다. 이것이 가능한것은 CPU와 메모리 사이에 페이지테이블이 존재하기 때문에..<br>즉 CPU는 페이지 테이블로 인해 CPU는 프로세스가 연속한 상태로 착각한다.<br>메모리 빈곳(hole)을 다합치면 메모리가 큰데 프로세스를 넣을 수 없는것을 외부단편화라 함</p>
<h3 id="메모리-낭비를-위한기술"><a href="#메모리-낭비를-위한기술" class="headerlink" title="메모리 낭비를 위한기술"></a>메모리 낭비를 위한기술</h3><p>다이나믹 로딩<br>링킹<br>스와핑</p>
<h3 id="페이징-메모리-낭비를-줄이기-위한기술"><a href="#페이징-메모리-낭비를-줄이기-위한기술" class="headerlink" title="페이징(메모리 낭비를 줄이기 위한기술)"></a>페이징(메모리 낭비를 줄이기 위한기술)</h3><p>메모리를 꼭 연속된 공간에 넣을 필요는 없다. 프로그램을 프레임 단위로 잘라서 메모리에 흩어져서 넣는다.<br>프로세스는 페이지(page)의 집합<br>메모리는 프레임(frame)의 집합</p>
<p><code>페이지를 프레임에 할당</code><br>MMU 내의 재배치 레지스터 값을 바꿈으로서<br>CPU 는 프로세스가 연속된 메모리 공간에 위치한다고 착각<br>MMU 는 페이지 테이블 (page table) 이 된다.</p>
<p><code>예제</code><br>Page size = 4 bytes<br>Page Table: 5 6 1 2<br><u>논리주소 13 번지는 물리주소 몇 번지?</u></p>
<p>CPU가 내는 주소는 13이다. 이진수로 나타내면 1101(2) 인데 앞 두숫자 11이 p 이고 01이 d라고 볼 수 있다. (p는 페이지 사이즈 크기만큼 크기를 할당. 페이지 크기가 4이므로 두자리가 된다.) 페이지 테이블의 3번째 인덱스에 저장된 2가 f가 되고 d는 그대로 온다. 즉 10 01이 피지컬 어드레스가 된다. 즉 물리주소는 9번지가 된다. 9번지는 두번째 프레임에서 01만큼 떨어져있다고 할 수 있다.</p>
<p><code>예제</code><br>Page Size = 1KB<br>Page Table: 1 2 5 4 8 3 0 6<br><u>논리주소 3000번지는 물리주소 몇 번지?</u></p>
<p>1kb는 10bit. 3000은 101110111000(2) 이다. 페이지 사이즈는 2^10 이므로 10bit로 표현 가능하다. 즉 d는 뒤의 10자리(1110111000(2)) 이고 p는 앞에 두개(10(2))이다. 즉 2번째 인덱스인 101(2) 그리고 d를 붙인 1110111000 (2) 가 물리주소이다.</p>
<p><u>물리주소 0x1A53 번지는 논리주소 몇 번지?</u></p>
<p>1 1010 0101 0011 인데 뒤의 10개가 d 나머지 앞에 110이 프레임 넘버. 6은 페이지 테이블의 7번지에 저장되어 있으므로<br>111과  10 0101 0011 을 붙인것이 논리주소이다.</p>
<h3 id="내부단편화"><a href="#내부단편화" class="headerlink" title="내부단편화"></a>내부단편화</h3><p>페이지 사이즈가 4바이트일때 15바이트프로세스를 올리기 위해서는 페이지 4개가 필요하다.<br>4/4/4/3만큼 할당이 되는데 마지막 페이지의 1바이트가 비게된다. 이는 아무도 쓸수 없으므로 내부단편화 발생.</p>
<p>외부단편화를 페이지로 없앴는데 내부단편화가 발생한다. 내부단편화는 외부단편화에 비해 크기가 미미하므로 큰 문제가 되지 않는다.</p>
<p>페이지 테이블은 CPU안에 넣을 수 있다. 그러면 레지스터로 만들수도있다. 또는 메모리에 넣을 수도 있다.<br>‘CPU에 넣는경우’:페이지 테이블을 CPU레지스터로 만드면 주소변환이 정말 빠르다. 단점은 CPU에 넣어야 하므로 많은 데이터를 넣을 수없다.<br><code>메모리 안에 넣을 경우</code>: 페이지 테이블이 커도 문제가 되지 않는다. 그러나 변환속도가 느리다. 페이지테이블을 읽기위해 메모리를 한번읽고 또 한번 메모리를 읽어야 하므로 2배로 느려진다.</p>
<p><code>캐쉬메모리에 페이지 테이블을 넣는경우(실제로 사용됨)</code>: 페이지 테이블을 넣는 캐쉬메모리를 TLB (Translation Look-aside Buffer) 라 한다. 메모리에 넣는것보다 빠르고 CPU에 넣는것보다 많이 넣을 수 있다. 캐쉬메모리와 유사한 원리로 동작</p>
<p>CPU에서 낸 주소를 읽어오는덱 걸리는 시간을 유효메모리 접근시간이라 한다.<br>Tm(메모리 읽는속도) = 100ns, Tb(버퍼 읽는속도) = 20ns, hit ratio = 80%<br>CPU가 낸 주소가 페이지테이블 안에 존재할 경우 hit라고 한다,<br>유효 메모리 접근시간 : hit확률 <em>  (Tb+Tm) + hit되지 않을 확률 </em> (Tb+Tm)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;페이지 테이블, 주소변환&lt;/p&gt;
&lt;h2 id=&quot;주소변환&quot;&gt;&lt;a href=&quot;#주소변환&quot; class=&quot;headerlink&quot; title=&quot;주소변환?&quot;&gt;&lt;/a&gt;주소변환?&lt;/h2&gt;&lt;p&gt;컴퓨터에는 CPU, 메모리, 보조기억장치가 존재.&lt;br&gt;파워를 켜면 메
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>19.최초적합, 최적적합, 최악적합</title>
    <link href="http://KKimSangHeon.github.io/2019/02/25/operating-system19/"/>
    <id>http://KKimSangHeon.github.io/2019/02/25/operating-system19/</id>
    <published>2019-02-24T23:30:26.000Z</published>
    <updated>2019-02-25T13:54:57.309Z</updated>
    
    <content type="html"><![CDATA[<p>메모리 낭비를 줄이기 위한 기법<br>1.Dynamic Loading<br>2.Dynamic Linking<br>3.Swapping</p>
<h3 id="연속-메모리-할당"><a href="#연속-메모리-할당" class="headerlink" title="연속 메모리 할당"></a>연속 메모리 할당</h3><p>최초의 컴퓨터는 프로세스가 하나만 올라갔다. 그이 후 O/S가 올라가게 되었다.<br>하나의 운영체제에 여러개의 프로세스가 도는것이 다중프로그래밍. 즉 멀티프로그래밍이라 한다.<br>부팅을 하면 메모리가 비어있다가 OS가 자리잡게된다. OS이외에 부분은 비어있는데 이를 <u>big single hole 또는 hole</u>이라고 한다.</p>
<p><code>부팅 직후 메모리 상태</code>: O/S + big single hole<br><code>프로세스 생성 &amp; 종료 반복</code> : scattered holes(프로세스가 생성됐다가 없어지고 하다보면 곳곳에 hole 발생하게 된다.)</p>
<p>Hole 들이 불연속하게 흩어져 있기 때문에 프로세스 적재 불가한 경우가 생기는데 이를 <u>외부단편화(external fragmentation)</u>라 한다.</p>
<p><code>First-fit (최초 적합)</code>  : 메모리를 뒤져서 가장 처음에 들어갈 수 있는곳에 들어가는것.<br><code>Best-fit (최적 적합)</code> : 사이즈가 제일 비슷한놈에 들어가는것.<br><code>Worst-fit (최악 적합)</code> : 크기가 제일 안맞는놈한테 넣는것.(물론 큰것중에)</p>
<h4 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h4><p>Hole: 100 /500 / 600 / 300 / 200 KB<br>프로세스: 212 417 112 426 KB</p>
<p><code>First-fit (최초 적합)</code>의 경우 : 212는 500에 들어간다. 417은 600에 들어감. 112는 300에 들어감. 426은 못들어감.</p>
<p><code>Best-fit (최적 적합)</code> : 212는 300에 들어간다 . 417은 500 112는 200 .426은 500</p>
<p><code>Worst-fit (최악 적합)</code> : 212는 600에. 417은 500에. 112는 300에. 426은 못들어간다.</p>
<p>속도면에서는 First-fit가 빠르다.<br>나머지는 다 봐야하기 때문에 느리다.</p>
<p>이용률의 경우 first-fit, best-fit이 높은 이용율이 보임.<br>외부 단편화로 인한 메모리 낭비가 전체의 1/3 수준 (사용 불가)</p>
<p><code>이를 해결하기 위한 방법</code> : Compaction(hole들을 한곳으로 모으는것. 최적 알고리즘 없음, 고부담)<br>즉 OS가 지켜보다가 hole들을 한곳으로 모은다.(계산 부담)</p>
<p><code>다른방법은 없을까?</code> 페이징</p>
<h3 id="페이징"><a href="#페이징" class="headerlink" title="페이징"></a>페이징</h3><p>프로그램을 연속적으로 넣지 않고 일정한 단위로 잘라서 넣는다 이를 페이지라고 한다.(잘린것들을 말함).<br>메모리를 자른것을 프레임이라 함.</p>
<p>프로세스를 자른것을 페이지라 하고 메모리를 자른것을 프레임이라 한다.<br>페이지사이즈와 프레임사이즈 는 같으나 용어와 사용되는 위치가 다른것.</p>
<p>잘라서도 돌게하기 위해서는 CPU를 속여야한다. MMU 내의 Relocation Resgister을 여러개 둔다!<br>이러한 목적으로 사용되는 MMU를 페이지 테이블 (page table) 이라 한다.</p>
<p>이를 통해 외부단편화를 해결!</p>
<h3 id="페이징에서의-주소변환"><a href="#페이징에서의-주소변환" class="headerlink" title="페이징에서의 주소변환"></a>페이징에서의 주소변환</h3><img src="/2019/02/25/operating-system19/image1.png" alt="페이징에서의 주소변환" title="페이징에서의 주소변환">
<p>논리주소를 물리주소를 변환하는것을 주소변환이라한다.<br>CPU가 내는 주소가 m bit라 하자. 그럴 때 m-n은 페이지의 주소이고 n비트는 오프셋 또는 변위라고 한다.<br>즉 n은 페이지의 사이즈에 의존적이다. 페이지의 사이즈가 16일때 n은 4로 표현가능</p>
<p>메인메모리는 프레임 단위로 나뉘어져있다. 프레임의 크기는 페이지의 사이즈와 동일하다,<br>아까 말했듯 페이지 테이블(여러개의 mmu로 구성된것)은 프로세스가 페이지를 몇개쓰는가이 따라 달라진다.</p>
<p>p가 2라면 페이지 테이블의 두번째를 가르키는 것이고 d가 오프셋을 의미</p>
<p>만약 CPU가 50이라는 주소를 냈다하자. 그럼 110010(2) 이다. 이때 한 페이지가 16바이트라 가정했을 때 뒤의 네 수를 d로 보고 앞에 두개 11을 p로 본다. 즉 3번째 페이지에 저장되어있는 값(8이라 가정하자)에 맞는 프레임을 찾아가고 d를 활용하여 세부적인 값을 알아낸다. 이때는 10000010(2)가 된다,(앞에 네개는 8을 의미 뒤에 네개는 d를 그대로 가져다 쓴것)</p>
<p>정리하면 CPU가 내는 50번지는 10000010 즉 128번지 + d(2) 이므로 130번지를 찾아간다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;메모리 낭비를 줄이기 위한 기법&lt;br&gt;1.Dynamic Loading&lt;br&gt;2.Dynamic Linking&lt;br&gt;3.Swapping&lt;/p&gt;
&lt;h3 id=&quot;연속-메모리-할당&quot;&gt;&lt;a href=&quot;#연속-메모리-할당&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>18.동적적재, 동적연결, 스와핑</title>
    <link href="http://KKimSangHeon.github.io/2019/02/24/operating-system18/"/>
    <id>http://KKimSangHeon.github.io/2019/02/24/operating-system18/</id>
    <published>2019-02-24T02:25:43.000Z</published>
    <updated>2019-02-24T03:24:56.823Z</updated>
    
    <content type="html"><![CDATA[<p>컴퓨터에서 메모리는 CPU 만큼 중요하다.<br>하드디스크에 파일들이 들어있다. 파워를키면 OS가 메인메모리에 올라가고 특정 프로그램을 실행시키면 그 프로그램이 메인메모리로 올라간다. 이 메모리를 어떻게 잘 관리할것인가가 <code>메모리 매니지먼트</code></p>
<h3 id="실행파일을-메모리에-올리기"><a href="#실행파일을-메모리에-올리기" class="headerlink" title="실행파일을 메모리에 올리기"></a>실행파일을 메모리에 올리기</h3><p>src-obj-exe</p>
<p>메모리 몇 번지에?<br>다중 프로그래밍 환경에서는?</p>
<p>항상 똑같은 곳에 올리는것을 보장하지 못함. 그래서 MMU를 활용. CPU가 메모리에 몇번째 주소를 읽겠다 하면 메모리는 CPU로 데이터를 전송해준다. <u>MMU는 특정프로그램이 다른 프로그램으로 접근하지 못하게 해준다.</u> CPU가 메모리에 주소를 전달할 때 MMU를 거치는데 자기영역에 맞는 주소를요청하는지 파악한다.(base, limit 레지스터 활용)<br>MMU는 이뿐만 아니라 <u>Relocation register</u>을 둔다. 가령 A라는 프로그램이 있다고 하자. 개발자는 해당 프로그램이 0번지부터 시작한다고 생각하고 코딩을 했다. 하지만 이는 보장되지 않기 때문에 예측할 수 없다. 실제로는 프로그램이 1000번지에 로드되면 MMU 안에 Relocation register에 1000을 넣는다. 그러면 <u>CPU는 0번지를 요청하지만 MMU를 거치면서 1000이 더해져 실제로 저장되어 있는 1000번지로 접근하게 된다</u>. 즉 CPU를 속이게 된다.<br>그 다음날 A라는 프로그램이 실행되었을 때 5000번지에 실행될 경우 이때는 Relocation register에 5000이 들어가고 CPU는 5000번지에 접근하여 데이터를 읽어올 수 있다.</p>
<p>여기서 CPU가 보내는 주소를 <u>논리주소(logical address)</u> 라 하고 실제로 메인메모리로 들어가는 주소를 <u>물리주소 (physical address)</u>라 한다.</p>
<h3 id="메모리-낭비-방지"><a href="#메모리-낭비-방지" class="headerlink" title="메모리 낭비 방지"></a>메모리 낭비 방지</h3><p>운영체제는 컴퓨터 사용을 쉽게, 효율을 높게 하는것이 목표다.<br>이를 위해 어떤노력을 하는지 알아보자,<br>1.Dynamic Loading<br>2.Dynamic Linking<br>3.Swapping</p>
<p><code>Loading</code> : 프로그램(실행파일)을 메모리로 올리는것.<br><code>Booting</code> : OS를 메모리로 올리는것.</p>
<h4 id="메모리-낭비-방지-기법-Dynamic-Loading"><a href="#메모리-낭비-방지-기법-Dynamic-Loading" class="headerlink" title="메모리 낭비 방지 기법 : Dynamic Loading"></a>메모리 낭비 방지 기법 : Dynamic Loading</h4><p>프로그램을 메모리에 올릴때 오류처리 혹은 크게 생성한 배열 같은것들을 안올리고 오류가 일어나면 올린다.</p>
<p><code>나오게 된 배경</code>:<br>모든 루틴(routine)이 다 사용되는 것은 아니다 (예: 오류처리)<br>모든 데이터(data)가 다 사용되는 것은 아니다 (예: 배열)<br>자바: 모든 클래스가 다 사용되는 것은 아니다</p>
<p><u>즉 프로그램 실행에 반드시 필요한 루틴/데이터만 적재</u><br>현대의 운영체제는 이를 활용. 이전에는 모든것을 올리는 정적 적재(Static loading)를 활용했다.</p>
<h4 id="메모리-낭비-방지-기법-Dynamic-Linking"><a href="#메모리-낭비-방지-기법-Dynamic-Linking" class="headerlink" title="메모리 낭비 방지 기법 : Dynamic Linking"></a>메모리 낭비 방지 기법 : Dynamic Linking</h4><p><u>프로그램을 메인메모리에 올리는데 공통 라이브러리 루틴(library routine)를 메모리에 중복으로 올<br>리는 것은 낭비</u></p>
<p>이메일전송,  파일전송 둘다 네트워크를 사용한다. 즉 둘이 같은 라이브러리를 쓸것이다. 하나로 통 칠수있는경우이다. <u>이 기법은 오직 하나의 라이브러리 루틴만 메모리에 적재한다. 또한 exe파일을 만들때 link를 하지 않고 프로그램 실행 때 link하여 갖다 쓴게 한다. 그리고 다른 애플리케이션 실행 시 이 루틴과 연결(link)된다.</u><br>원래는 link를 exe파일이 만들어지기 전에 한다(정적 연결,Static Linking)</p>
<p>리눅스에서는 공유 라이브러리 (shared library)라 부른다 – Linux<br>윈도우에서는 동적 연결 라이브러리 (Dynamic Linking Library)라 부른다. - Windows</p>
<p>윈도우에서 .DLL파일을 본적이 있을것이다. 리눅스에는 .SO 파일.<br>C:\Windows\System32 에 많다.</p>
<h4 id="메모리-낭비-방지-기법-Swapping"><a href="#메모리-낭비-방지-기법-Swapping" class="headerlink" title="메모리 낭비 방지 기법 : Swapping"></a>메모리 낭비 방지 기법 : Swapping</h4><p><u>메모리에 적재되어 있으나 현재 사용되지 않고 있는 프로세스 이미지를 몰아낸다</u><br>프로그램을 사용하다 화장실에 갈경우 해당 프로그램은 아무것도 하지 않으면서 메모리를 잡아먹게 된다.<br>이 경우 해당 프로세스를 쫒아낸다. 즉 프로세스 이미지를 하드디스크 일부에 몰아낸다. 이는 메모리 활용도 높이기 위해 <u>Backing store (= swap device라고도 함)<u> 로 몰아낸다 한다.<br>Backing store (= swap device라고도 함)의 크기는 대략 메인메모리의 크기 정도면 충분하다.(메인메모리의 내용만 쫒아내는 구역이기 때문에.)</u></u></p>
<p>몰아내는것을 <u>Swap-out</u>라 하고 화장실에서 다시 돌아와 메모리로 다시 올리는것을 <u>Swap-in</u>이라고 한다. 서버는 Backing store 를위한 디스크를 따로 두기도 하며 슈퍼컴퓨터의 경우 Backing store를 하나의 메모리로 두기도 한다.(디스크 접근이 느리기 때문에)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;컴퓨터에서 메모리는 CPU 만큼 중요하다.&lt;br&gt;하드디스크에 파일들이 들어있다. 파워를키면 OS가 메인메모리에 올라가고 특정 프로그램을 실행시키면 그 프로그램이 메인메모리로 올라간다. 이 메모리를 어떻게 잘 관리할것인가가 &lt;code&gt;메모리 매니지
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>17.주기억장치 관리 개요</title>
    <link href="http://KKimSangHeon.github.io/2019/02/23/operating-system17/"/>
    <id>http://KKimSangHeon.github.io/2019/02/23/operating-system17/</id>
    <published>2019-02-23T00:48:52.000Z</published>
    <updated>2019-02-23T15:18:11.112Z</updated>
    
    <content type="html"><![CDATA[<p>CPU / 메모리 / 보조기억장치가 존재.<br>O/S는 프로세스 관리를한다. CPU 관리를 하는데 이를 프로세스 매니지먼트라함.<br>또한 O/S는 메모리 관리 즉 메모리 매니지먼트를 한다.</p>
<p>OS : 하드웨어를 어플리케이션이 활용할 수 있도록 함.<br><code>CPU 자원을 나눠주는 곳</code> : 프로세스 매니지먼트<br><code>메인메모리를 관리하는곳</code> : 메모리 매니지먼트.</p>
<h3 id="메모리-역사"><a href="#메모리-역사" class="headerlink" title="메모리 역사"></a>메모리 역사</h3><p><code>Core memory</code> : 반지모양의 철심에 자성물질을 바르고 전기를 흐르게 한 후 자석이 되게 한 후 메모리로 사용.<br><code>진공관 메모리</code> : 50~60년대 손가락 크기만함. 네다섯개가 한비트를 저장<br><code>트랜지스터 메모리</code> : 손톱만한 크기로 한비트를 저장하는데 네개의 트랜지스터 필. 반도체 소자안에 들어간다.<br><code>집적회로 메모리: SRAM, DRAM</code> : 보통 생각하는 메모리</p>
<h3 id="메모리-용량"><a href="#메모리-용량" class="headerlink" title="메모리 용량"></a>메모리 용량</h3><p>1970년대: 8-bit PC 64KB<br>1980년: 16-bit IBM-PC 640KB &gt; 1MB &gt; 4MB<br>1990년: 수MB &gt; 수십 MB<br>2000년~: 수백 MB &gt; 수 GB</p>
<h2 id="메모리가-지속적으로-커졌다"><a href="#메모리가-지속적으로-커졌다" class="headerlink" title="메모리가 지속적으로 커졌다!!"></a>메모리가 지속적으로 커졌다!!</h2><h3 id="메모리는-언제나-부족하다"><a href="#메모리는-언제나-부족하다" class="headerlink" title="메모리는 언제나 부족하다.."></a>메모리는 언제나 부족하다..</h3><h4 id="이유-프로그램의-변천"><a href="#이유-프로그램의-변천" class="headerlink" title="이유 : 프로그램의 변천"></a>이유 : 프로그램의 변천</h4><p>기계어/어셈블리어 작성<br>C언어<br>자바, 객체지향형 언어 작성<br>숫자 처리 &gt; 문자 처리 &gt; 멀티미디어 순으로 패러다임이 변화함.</p>
<h4 id="메모리-용량-증가-vs-프로그램-크기-증가"><a href="#메모리-용량-증가-vs-프로그램-크기-증가" class="headerlink" title="메모리 용량 증가 vs 프로그램 크기 증가"></a>메모리 용량 증가 vs 프로그램 크기 증가</h4><p>언제나 부족한 메모리 ㅠㅠ</p>
<h4 id="어떻게-메모리를-효과적으로-사용할-수-있을까"><a href="#어떻게-메모리를-효과적으로-사용할-수-있을까" class="headerlink" title="어떻게 메모리를 효과적으로 사용할 수 있을까?"></a>어떻게 메모리를 효과적으로 사용할 수 있을까?</h4><p>메모리 낭비를 없애고 가상메모리와 같은 기법을 활용!</p>
<h3 id="메모리-구조"><a href="#메모리-구조" class="headerlink" title="메모리 구조?"></a>메모리 구조?</h3><img src="/2019/02/23/operating-system17/image1.png" alt="CPU와 메모리" title="CPU와 메모리">
<p>CPU가 몇번지를 읽겠다고 주소를 메모리로 보낸다. 그러면 거기에 저장되어있는 정보를 메모리가 CPU에게 제공한다.<br>또한 데이터 저장을 위해서 CPU가 데이터를 전송하기도 한다<br>메모리는 주소(Address) + 데이터(Data)로 구성된다.</p>
<h3 id="프로그램은-어떻게-개발될까"><a href="#프로그램은-어떻게-개발될까" class="headerlink" title="프로그램은 어떻게 개발될까?"></a>프로그램은 어떻게 개발될까?</h3><p>컴파일러, 어셈블러, 링커, 로더에 대해 알아보자<br>프로그램이 실행되기까진 아래의 순서를 따른다.<br><u>main.c (고수준언어)-&gt;main.o(기계어) -&gt; link -&gt; 메인메모리로 올림</u><br>첫번째 화살표 컴파일러가 진행<br>두번째 화살표 링커가 진행<br>세번째 화살표 로더가 진행</p>
<p><code>원천파일 (Source file)</code>: 고수준언어 또는 어셈블리언어<br><code>목적파일 (Object file)</code>: 컴파일 또는 어셈블 결과<br><code>실행파일 (Executable file)</code>: 링크 결과<br>프로그램 실행을 위해 필요한것들: code + data + stack</p>
<p>실행파일을 메모리에 올리기 위해 메모리 몇번지에 올려야되지?(로더가 해결해준다)</p>
<h3 id="MMU의-사용"><a href="#MMU의-사용" class="headerlink" title="MMU의 사용"></a>MMU의 사용</h3><p>MMU 안에 base limit가 있다했는데 재배치 레지스터가 있다. 프로그램을 개발할 때 0번지에 들어간다고 생각했는데 실제로는 500번지에 들어간다면 Relocation register에 500을 넣어줘 CPU가 봤을땐 0번지 이지만 500을 더한 500번지에 저장되게 한다. 즉 CPU는 얘가 0번지에 있는줄 안다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CPU / 메모리 / 보조기억장치가 존재.&lt;br&gt;O/S는 프로세스 관리를한다. CPU 관리를 하는데 이를 프로세스 매니지먼트라함.&lt;br&gt;또한 O/S는 메모리 관리 즉 메모리 매니지먼트를 한다.&lt;/p&gt;
&lt;p&gt;OS : 하드웨어를 어플리케이션이 활용할
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>16.프로세스 동기화의 다른 도구인 모니터 사용</title>
    <link href="http://KKimSangHeon.github.io/2019/02/22/operating-system16/"/>
    <id>http://KKimSangHeon.github.io/2019/02/22/operating-system16/</id>
    <published>2019-02-22T13:51:04.000Z</published>
    <updated>2019-02-23T15:18:37.264Z</updated>
    
    <content type="html"><![CDATA[<h3 id="모니터"><a href="#모니터" class="headerlink" title="모니터"></a>모니터</h3><p>동기화 도구로 세마포어를 배웠다. 세마포어는 조금 오래된 동기화 도구인데 지금은 모니터를 많이쓴다. 주로 자바에서 많이쓴다.<br>즉 세마포 이후 프로세스 동기화 도구 이며 세마포 보다 고수준 개념</p>
<h3 id="세마포어의-구조"><a href="#세마포어의-구조" class="headerlink" title="세마포어의 구조"></a>세마포어의 구조</h3><p>정수변수, 큐, P(acquire)동작, V(release)동작</p>
<h3 id="모니터의-구조"><a href="#모니터의-구조" class="headerlink" title="모니터의 구조"></a>모니터의 구조</h3><p>공유자원 , 공유자원 접근함수 , 2개의 큐</p>
<p>2개의 큐?<br>하나는 배타동기. 즉 한쓰레드만 공유자원에 접근할 수 있도록 하는 큐<br>하나는 조건동기를 위한 큐</p>
<p>베타동기를 위한큐 | 다양한 함수 | 조건동기를 위한큐</p>
<img src="/2019/02/22/operating-system16/image1.png" alt="모니터의구조" title="모니터의구조">
<p>1.쓰레드 한개만 공유자원 접근 함수에 접근할 수 있다. 즉 들어오고 싶어하는 애들은 베타동기를 위한 큐에서 기다려야 한다.<br>2.진입 쓰레드가 조건을 만족하면(wait을 호출하여) 조건동기 큐로 들어가는데 이땐 블록된다. 그러면 새 쓰레드가 진입가능<br>3.새 쓰레드는 조건동기로 블록된 쓰레드를 notify를 호출하여 깨울 수 있다<br>4.깨워진 쓰레드는 현재 쓰레드가 나가면 재진입할 수 있다.<br>(하나의 쓰레드만 접근 가능하므로)</p>
<p>세마포어에 비해 복잡하나 사용하기 편리하다.</p>
<p><code>배타동기</code>: synchronized 키워드 사용하여 지정<br><code>조건동기</code>: wait(), notify(), notifyAll() 메소드 사용</p>
<p>베타동기: 하나만 특정함수에 들어갈 수 있다. 자바에서는 함수 정의 앞에 synchronized 키워드를 붙인다.<br>조건동기는 wait 함수를 호출하여 조건동기를 위한 큐에 갇히게 할 수 있고 notify(하나깨우기) 혹은 notify all(전체깨우기) 을 호출하여 깨울 수 도 있다.</p>
<h4 id="상호배제-용도로-사용"><a href="#상호배제-용도로-사용" class="headerlink" title="상호배제 용도로 사용"></a>상호배제 용도로 사용</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankAccount</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> balance;</div><div class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">int</span> amt)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> temp = balance + amt;</div><div class="line">		System.out.print(<span class="string">"+"</span>);</div><div class="line">		balance = temp;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> amt)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> temp = balance - amt;</div><div class="line">		System.out.print(<span class="string">"-"</span>);</div><div class="line">		balance = temp;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> balance;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>위처럼 하면 동기화가 가능하다. 세마포어 보다 쉽다!</p>
<h4 id="Ordering-용도로-사용"><a href="#Ordering-용도로-사용" class="headerlink" title="Ordering 용도로 사용"></a>Ordering 용도로 사용</h4><p>P1은 공백/ S1/notify();<br>P2는 wait/S2/공백</p>
<p>P1이 입금, P2가 출금 로직이라고 가정하고 생각해보자.</p>
<p>P1,P2 반복해서 출력되게 하려면 boolean 변수 하나를 둬서 처리<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">int</span> balacne = <span class="number">0</span>;</div><div class="line"><span class="keyword">boolean</span> p_turn;</div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">int</span> amt)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> temp = balance + amt;</div><div class="line">	balance = temp;</div><div class="line">	notify();</div><div class="line">	p_turn = <span class="keyword">false</span>;</div><div class="line">	wait();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">int</span> amt)</span> </span>&#123;</div><div class="line">	<span class="keyword">while</span>(p_turn)</div><div class="line">		wait();</div><div class="line"></div><div class="line">	<span class="keyword">int</span> temp = balance - amt;</div><div class="line">	balance = temp;</div><div class="line">	p_turn = <span class="keyword">true</span>;</div><div class="line">	notify();</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">---</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Buffer</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span>[] buf;</div><div class="line">	<span class="keyword">int</span> size, count, in, out;</div><div class="line">	Buffer(<span class="keyword">int</span> size) &#123;</div><div class="line">		buf = <span class="keyword">new</span> <span class="keyword">int</span>[size];</div><div class="line">		<span class="keyword">this</span>.size = size;</div><div class="line">		count = in = out = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> item)</span> </span>&#123;</div><div class="line">	<span class="keyword">while</span> (count == size)</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		wait();</div><div class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</div><div class="line">	buf[in] = item;</div><div class="line">	in = (in+<span class="number">1</span>)%size;</div><div class="line">	notify();</div><div class="line">	count++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">while</span> (count == <span class="number">0</span>)</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		wait();</div><div class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</div><div class="line">	<span class="keyword">int</span> item = buf[out];</div><div class="line">	out = (out+<span class="number">1</span>)%size;</div><div class="line">	count--;</div><div class="line">	notify();</div><div class="line">	<span class="keyword">return</span> item;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">---</div><div class="line">교착상태에 대한 고려는 되지 않음.</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chopstick</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> inUse = <span class="keyword">false</span>;</div><div class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">		<span class="keyword">while</span> (inUse)</div><div class="line">		wait();</div><div class="line">		inUse = <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</div><div class="line">		inUse = <span class="keyword">false</span>;</div><div class="line">		notify();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;모니터&quot;&gt;&lt;a href=&quot;#모니터&quot; class=&quot;headerlink&quot; title=&quot;모니터&quot;&gt;&lt;/a&gt;모니터&lt;/h3&gt;&lt;p&gt;동기화 도구로 세마포어를 배웠다. 세마포어는 조금 오래된 동기화 도구인데 지금은 모니터를 많이쓴다. 주로 자바에서 많이
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>15.교착상태 필요조건, 교착상태의 해결법</title>
    <link href="http://KKimSangHeon.github.io/2019/02/22/operating-system15/"/>
    <id>http://KKimSangHeon.github.io/2019/02/22/operating-system15/</id>
    <published>2019-02-22T13:50:56.000Z</published>
    <updated>2019-02-22T13:56:55.165Z</updated>
    
    <content type="html"><![CDATA[<h3 id="교착상태"><a href="#교착상태" class="headerlink" title="교착상태"></a>교착상태</h3><p>발생이유 : 프로세스들이 자원을 많이 필요로 한다. 하지만 누가 사용하고 있으면 기다려야한다.<br>이러한 형태가 원을 이루면 교착상태가 발생한다.</p>
<h3 id="교창상태-필요조건"><a href="#교창상태-필요조건" class="headerlink" title="교창상태 필요조건."></a>교창상태 필요조건.</h3><p>Mutual exclusion (상호배타) : 자원을 서로 공유하지 못함<br>Hold and wait (보유 및 대기) : 하나를 잡고있으면서 다른것을 원함<br>No Preemption (비선점) : 다른것을 강제로 뺏어오지 못함.<br>Circular wait (환형대기) : 자원을 갖고있으면서 기다리는데 원형형태</p>
<p><u>네가지가 만족되면 일어날 수 있다. 반드시 일어나는것은 아님</u></p>
<h3 id="교착상태-처리"><a href="#교착상태-처리" class="headerlink" title="교착상태 처리"></a>교착상태 처리</h3><p>교착상태 처리는 크게 네가지가 있다.<br>1.교착상태 방지<br>Deadlock Prevention</p>
<p>2.교착상태 회피<br>Deadlock Avoidance</p>
<p>3.교착상태 검출 및 복구<br>Deadlock Detection &amp; Recovery</p>
<p>4.교착상태 무시<br>Don’t Care</p>
<h3 id="1-교착상태-방지"><a href="#1-교착상태-방지" class="headerlink" title="1.교착상태 방지"></a>1.교착상태 방지</h3><p><code>설명</code> : 필요조건 중 네가지 조건중에 하나라도 깨도록 하는것.<br><code>상호베타 조건을 깨기</code>: 이를 위해 공유가 가능하게 해야한다. 현실적으로 어렵다. 읽어내기만 하는 파일 같은 경우에는 가능하지만 일반적으로는 부적절</p>
<p><code>보유 및 대기 깨기</code>: 동시에 젓가락 갖게하기. 왼쪽 젓가락 잡고 오른쪽 젓가락 잡을라 했는데 누가 오른쪽을 갖고있으면 왼쪽도 놓기. 이는 굶어 죽을 확률이 생김. 자원의 활용도가 떨어진다. 상호베타 조건깨는것보다는 쉽다.<br>자원을 가지고 있으면서 다른 자원을 기다리지 않게 즉 자원이 없는 상태에서 모든 자원 대기; 일부 자원만 가용하면 보유 자원을 모두 놓아주기<br>단점: 자원 활용률 저하, 기아 (starvation)</p>
<p><code>비선점 깨기</code>: CPU의 경우에는 일부 가능하겠으나 일반적으로 불가능</p>
<p><code>환형대기 깨기</code> : 자원에다 번호 부여하고 자원의 오름차순으로 자원을 요청토록 함. 즉 R1,R2,R3 가 있을때 R1, R2 요청/ R2,R3 요청/ R1,R3요청처럼 구현. 자원의 활용도가 떨어진다.</p>
<p>보통 보유 및 대기 깨기 혹은 환형대기 깨기를 사용한다.</p>
<h3 id="2-교착상태-회피"><a href="#2-교착상태-회피" class="headerlink" title="2.교착상태 회피"></a>2.교착상태 회피</h3><p><code>설명</code> : 자원을 할당할 때 위험한 할당이 되지 않도록 하는것.<br>자원을 프로세스 한테 골고루 나눠주는것을 OS가 한다. 이를 리소스 매지저 / 올로케이터라 한다.<br>교착상태는 자원요청에 대한 잘못된 승인에 기인한다고 본다.</p>
<p>불안전한 할당 (Unsafe allocation)<br>운영체제는 자원을 할당할 때 불안전 할당 되지 않도록<br>불안전 할당 → 교착상태 유발<br>대출전문 은행과 유사: Banker’s Algorithm</p>
<h3 id="3-교착상태-검출-및-복구"><a href="#3-교착상태-검출-및-복구" class="headerlink" title="3.교착상태 검출 및 복구"></a>3.교착상태 검출 및 복구</h3><p><code>설명</code> : 프로세스가 필요한 대로 자원을 나눠주고 데드락이 발생하면 OS의 프로세스 복구.<br>교착상태가 일어나는 것을 허용 그리고 주기적 검사진행. 주기적 검사는 이를 하기 위한 오버헤드가 크다.<br>교착상태 발생 시 복구하기위해 주기적으로 이전의 상태를 기억하고 있어야 한다.<br>이를 위해 한 프로세스를 강제로 종료시키거나 혹은 자원을 선점하여 일부 프로세스에게 할당.</p>
<h3 id="4-교착상태-무시"><a href="#4-교착상태-무시" class="headerlink" title="4. 교착상태 무시"></a>4. 교착상태 무시</h3><p><code>설명</code> : 교착상태는 실제로 잘 일어나지 않으므로 그냥 무시해버린다.<br>교착상태 발생 시 재시동.</p>
<p>컴퓨터에서 가장 중요한것은 메모리 관리이다. 이를 프로세스 매니지먼트 부서가 하는데 이는 CPU 스케줄링 부서, 프로세스 싱크로나이즈 부서로 구성된다. 싱크로나이즈에서는 데드락관리또한 중요.</p>
<p>메인메모리 관리가 메모리 매니지 부서가 있다. 다음부터 공부한다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;교착상태&quot;&gt;&lt;a href=&quot;#교착상태&quot; class=&quot;headerlink&quot; title=&quot;교착상태&quot;&gt;&lt;/a&gt;교착상태&lt;/h3&gt;&lt;p&gt;발생이유 : 프로세스들이 자원을 많이 필요로 한다. 하지만 누가 사용하고 있으면 기다려야한다.&lt;br&gt;이러한 형태
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>14.읽기-쓰기 문제, 식사하는 철학자 문제</title>
    <link href="http://KKimSangHeon.github.io/2019/02/22/operating-system14/"/>
    <id>http://KKimSangHeon.github.io/2019/02/22/operating-system14/</id>
    <published>2019-02-22T13:50:49.000Z</published>
    <updated>2019-02-22T13:53:18.540Z</updated>
    
    <content type="html"><![CDATA[<p>읽기-쓰기 문제, 식사하는 철학자 문제</p>
<h3 id="Reader-amp-Writer"><a href="#Reader-amp-Writer" class="headerlink" title="Reader &amp; Writer"></a>Reader &amp; Writer</h3><p>DB 읽기만 하는 프로세스 DB를 바꾸는 프로세스</p>
<p>A가 DB를 읽고 있을 때 B가 읽을 수 있다.<br>즉 한 프로세스가 DB를 읽을 때 다른 프로세스도 읽을 수 있게 허용해줘야 한다.</p>
<p>The first R/W problem (readers-preference)<br>리더가 있으면 라이터가 미뤄지는것</p>
<p>The second R/W problem (writers-preference)<br>라이터가 먼저 우선순위가 주어지는것</p>
<p>The Third R/W problem<br>아무한테도 주지 않는것</p>
<p><code>정리</code> : 즉 리더가 들어왔는데 라이터가 들어오려면 블록되어야 하고<br>라이터가 들어왔는데 리더가 들어오려면 블록되어야 하고<br>리더가 들어와있는데 리더가 들어오면 허용해야한다</p>
<h3 id="Dining-Philosopher-Problem"><a href="#Dining-Philosopher-Problem" class="headerlink" title="Dining Philosopher Problem"></a>Dining Philosopher Problem</h3><p><code>다음 프로그램 설명</code><br>철학자 5명이 둥근탁상에 앉아있다. 젓가락은 5개뿐. 즉 자신의 왼쪽 오른쪽에 젓가락이 위치.<br>젓가락을 세마포어로 만들고 초기화를 1로한다.<br>무한루프를 돌면서 왼쪽젓가락, 오른쪽 젓가락을 acquire 하고. 먹고 다시 왼쪽 오른쪽 젓가락을 release한다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> id; <span class="comment">// philosopher id</span></div><div class="line">	Semaphore lstick, rstick; <span class="comment">// left, right chopsticks</span></div><div class="line">	Philosopher(<span class="keyword">int</span> id, Semaphore lstick, Semaphore rstick) &#123;</div><div class="line">		<span class="keyword">this</span>.id = id;</div><div class="line">		<span class="keyword">this</span>.lstick = lstick;</div><div class="line">		<span class="keyword">this</span>.rstick = rstick;</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">				lstick.acquire();</div><div class="line">				rstick.acquire();</div><div class="line">				eating();</div><div class="line">				lstick.release();</div><div class="line">				rstick.release();</div><div class="line">				thinking();</div><div class="line">			&#125;</div><div class="line">		&#125;<span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">eating</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"["</span> + id + <span class="string">"] eating"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"["</span> + id + <span class="string">"] thinking"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">5</span>; <span class="comment">// number of philosphers &amp; chopsticks</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> i;</div><div class="line">		<span class="comment">/* chopsticks */</span></div><div class="line">		Semaphore[] stick = <span class="keyword">new</span> Semaphore[num];</div><div class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;num; i++)</div><div class="line">			stick[i] = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</div><div class="line"></div><div class="line">		<span class="comment">/* philosophers */</span></div><div class="line">		Philosopher[] phil = <span class="keyword">new</span> Philosopher[num];</div><div class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;num; i++)</div><div class="line">			phil[i] = <span class="keyword">new</span> Philosopher(i, stick[i], stick[(i+<span class="number">1</span>)%num]);</div><div class="line"></div><div class="line">		<span class="comment">/* let philosophers eat and think */</span></div><div class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;num; i++)</div><div class="line">			phil[i].start();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>위의 프로그램은 쭉 가다가 정지된다. 그 이유는 <u>기아상태</u> 유발<br>모든사람이 각자의 왼쪽 젓가락을 들었을 때 해당상황이 발생<br>이를 <u>교착상태</u>라 한다.</p>
<p>운영체제에서 중요한것은 프로세스 관리. 이중 중요한것이 CPU 스케줄링, 동기화 문제이다.<br>동기화에서 중요한건 크리티컬 섹션문제, 효율성 증대 즉 ordering 인데 ordering를 잘못하면 <u>교착상태(Deadlock)</u>에 빠지게 된다.</p>
<h3 id="교착상태-Deadlocks"><a href="#교착상태-Deadlocks" class="headerlink" title="교착상태(Deadlocks)"></a>교착상태(Deadlocks)</h3><p>프로세스가 실행되기 위해서는 하드웨어 자원이 필요하다. 이를 리소스 즉 자원이라 한다. 자원을 사용하는 애플리케이션 즉 프로세스가 있고 중간에 OS가 있다. OS는 애플리케이션한테 자원을 잘 나눠줘야 한다. 자원은 한정되어 있는데 이를 사용하고자 하는 프로세스는 많다. 여기서 잘 나눠주지 못하면 교착상태가 발생한다.</p>
<p>어떤 자원은 갖고 있으나 다른 자원은 갖지 못할 때 (e.g., 다른 프로세스가 사용 중) 대기해야 한다.<br>다른 프로세스 역시 다른 자원을 가지려고 대기할 때 교착상태 가능성 발생</p>
<p>교착상태는 어떤자원을 갖고있을 때 다른 자원을 갖고자 할 때 발생</p>
<h3 id="교착상태-필요-조건-Necessary-Conditions"><a href="#교착상태-필요-조건-Necessary-Conditions" class="headerlink" title="교착상태 필요 조건 (Necessary Conditions)"></a>교착상태 필요 조건 (Necessary Conditions)</h3><p>Mutual exclusion (상호배타) : 리소스가 상호 배타적이다. 즉 한프로세스가 A를 쓰고 있다면 다른 프로세스는 A를 쓰지 못한다.<br>Hold and wait (보유 및 대기) : 왼쪽 젓가락 잡고있으면서 오른쪽 젓가락을 기다리는것.<br>No Preemption (비선점) : 다른사람의 젓가락 하나를 강제로 뺏을 수 없다.<br>Circular wait (환형대기) : 대기하는 형태가 원을 이룸.</p>
<h3 id="교착상태"><a href="#교착상태" class="headerlink" title="교착상태"></a>교착상태</h3><p>OS에서는 데드락이 일어나지 않도록 미리 조취를 해야한다.</p>
<h4 id="자원의-사용"><a href="#자원의-사용" class="headerlink" title="자원의 사용"></a>자원의 사용</h4><p><u>요청 (request) → 사용 (use) → 반납 </u><br>프로세스가 자원을 쓰려면 OS에게 요청을 한다. 그 요청이 올바르면 OS는 그것을 허용하고 프로세스가 자원을 다 쓰면 OS에게 반납한다.</p>
<h4 id="동일-자원"><a href="#동일-자원" class="headerlink" title="동일 자원"></a>동일 자원</h4><p>동일 형식 (type) 자원이 여러 개 있을 수 있다 (instance) - 예: 동일 CPU 2개, 동일 프린터 3개 등</p>
<h3 id="자원-할당도-Resource-Allocation-Graph"><a href="#자원-할당도-Resource-Allocation-Graph" class="headerlink" title="자원 할당도 (Resource Allocation Graph)"></a>자원 할당도 (Resource Allocation Graph)</h3><p><u>시스템 내에 어느 자원이 있고 어떤 프로세스에게 할당되었는가에 대한 그래프</u><br>어떤 자원이 어떤 프로세스에게 할당되었는가?<br>어떤 프로세스가 어떤 자원을 할당 받으려고 기다리고 있는가?<br><u>자원: 사각형, 프로세스: 원, 할당: 화살표</u></p>
<p>그래프 강의는 37분부터 보자</p>
<h4 id="교착상태-필요조건"><a href="#교착상태-필요조건" class="headerlink" title="교착상태 필요조건"></a>교착상태 필요조건</h4><p>자원 할당도 상에 원이 만들어져야 (환형대기) - 충분조건은 아님!<br>자원에서 프로세스를 가르키면 프로세스가 자원을 할당받은 상태<br>프로세스에서 자원을 가르키면 자원을 요청한 상태</p>
<p>짝수번 철학자는 왼쪽들고 오른쪽 들고<br>홀수번 철학자는 오른쪽들고 왼쪽거 들기. 그러면 원형이 깨지게 되어 교착상태가 발생하지 않게된다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;읽기-쓰기 문제, 식사하는 철학자 문제&lt;/p&gt;
&lt;h3 id=&quot;Reader-amp-Writer&quot;&gt;&lt;a href=&quot;#Reader-amp-Writer&quot; class=&quot;headerlink&quot; title=&quot;Reader &amp;amp; Writer&quot;&gt;&lt;/a&gt;Read
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>13.전통적 동기화 문제, 생산자-소비자 문제</title>
    <link href="http://KKimSangHeon.github.io/2019/02/21/operating-system13/"/>
    <id>http://KKimSangHeon.github.io/2019/02/21/operating-system13/</id>
    <published>2019-02-21T13:10:14.000Z</published>
    <updated>2019-02-22T13:52:46.125Z</updated>
    
    <content type="html"><![CDATA[<p>OS에서 가장중요한게 프로세스 관리<br>이중 CPU 스케줄링, 프로세스 동기화가 중요하다.<br>이때 임계구역 처리를 잘해야한다.</p>
<h3 id="전통적-동기화-예제"><a href="#전통적-동기화-예제" class="headerlink" title="전통적 동기화 예제"></a>전통적 동기화 예제</h3><p>1.Producer and Consumer Problem(생산자-소비자 문제, 유한버퍼 문제 (Bounded Buffer Problem))<br>2.Readers-Writers Problem(공유 데이터베이스 접근)<br>3.Dining Philosopher Problem(식사하는 철학자 문제)</p>
<hr>
<h3 id="Producer-Consumer-Problem"><a href="#Producer-Consumer-Problem" class="headerlink" title="Producer-Consumer Problem"></a>Producer-Consumer Problem</h3><h4 id="생산자-소비자-문제"><a href="#생산자-소비자-문제" class="headerlink" title="생산자-소비자 문제"></a>생산자-소비자 문제</h4><p>생산자가 데이터를 생산하면 소비자는 그것을 소비<br>예: 컴파일러 &gt; 어셈블러, 파일 서버 &gt; 클라이언트, 웹 서버 &gt; 웹 클라이언트</p>
<h4 id="Bounded-Buffer"><a href="#Bounded-Buffer" class="headerlink" title="Bounded Buffer"></a>Bounded Buffer</h4><p>보통 생산소비와 소비속도는 다르다.<br>그래서 보통 창고(버퍼)에 저장하고 컨슈머가 조금씩 빼먹는다.</p>
<p>생산된 데이터는 버퍼에 일단 저장 (속도 차이 등)<br>현실 시스템에서 버퍼 크기는 유한<br>생산자는 버퍼가 가득 차면 더 넣을 수 없다.<br>소비자는 버퍼가 비면 뺄 수 없다</p>
<p>버퍼가 가득차면 생산자는 버퍼가 비워질때까지 기다려야한다.<br>버퍼가 비면 소비자는 빼갈것이 없다.</p>
<p>생산자가 10000번 넣고 소비자가 10000번 넣으면 0이되지 않을 수 있다.<br><code>이유</code> : 공통변수 count, buf[] 에 대한 동시 업데이트<br>공통변수 업데이트 구간(= 임계구역)에 대한 동시 진입</p>
<p><code>해결법</code> : 임계구역에 대한 동시 접근 방지 (상호배타)<br>세마포를 사용한 상호배타 (mutual exclusion, mutex)</p>
<h3 id="Busy-wait"><a href="#Busy-wait" class="headerlink" title="Busy-wait"></a>Busy-wait</h3><p>바쁘게 기다린다.<br>생산자: 버퍼가 가득 차면 기다려야 == 빈(empty) 공간이 있어야 한다<br>소비자: 버퍼가 비면 기다려야 == 찬(full) 공간이 있어야 한다</p>
<p>이때 무한루프를 돌면서 기다리면 CPU는 다른일을 못하고 잡히게 된다. -&gt; 비효율적<br><code>해결법</code> : 두개의 세마포어를 사용. empty의 초깃값은 BUF_SIZE 만큼 full의 초깃값은 0으로 하여 사용<br>생산자 :<br>empty.acquire();<br>PRODUCE;<br>full.release();</p>
<p>소비자 :<br>full.acquire();<br>CONSUME;</p>
<h2 id="empty-release"><a href="#empty-release" class="headerlink" title="empty.release();"></a>empty.release();</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OS에서 가장중요한게 프로세스 관리&lt;br&gt;이중 CPU 스케줄링, 프로세스 동기화가 중요하다.&lt;br&gt;이때 임계구역 처리를 잘해야한다.&lt;/p&gt;
&lt;h3 id=&quot;전통적-동기화-예제&quot;&gt;&lt;a href=&quot;#전통적-동기화-예제&quot; class=&quot;headerlink
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>12.세마포를 사용한 프로세스 동기화</title>
    <link href="http://KKimSangHeon.github.io/2019/02/20/operating-system12/"/>
    <id>http://KKimSangHeon.github.io/2019/02/20/operating-system12/</id>
    <published>2019-02-20T14:16:51.000Z</published>
    <updated>2019-02-20T14:17:22.281Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h3 id="프로세스-관리에서-중요한것들"><a href="#프로세스-관리에서-중요한것들" class="headerlink" title="프로세스 관리에서 중요한것들"></a>프로세스 관리에서 중요한것들</h3><p>CPU 스케줄링 : 이전포스팅 참고</p>
<p>프로세스(쓰레드) 동기화<br><code>필요이유</code> : 보통컴퓨터 안에있는 프로세스들은 독립적이지 않고 협조적이므로 즉 공통된 자원에 접근함<br><code>동기화가 되지 않으면?</code> : 누군가는 계속 입금하고 누군가는 출금하는 로직이 있을 때 다 더한값이 0이 아닐 수 있다.<br><code>임계구역</code> : 공통적으로 사용되는 부분</p>
<p><code>임계구역 문제 해결</code> : 상호베타, 진행, 유한대기 ( 모르겠으면 이전포스팅 보자)<br>우리가 원하는대로 프로세스 순서를 맞추는것.</p>
<h3 id="동기화-툴"><a href="#동기화-툴" class="headerlink" title="동기화 툴"></a>동기화 툴</h3><p><code>세마포어</code> : acquire P동작 release V동작이 있음<br>누가 CPU 서비스를 받다가 acquire를 호출했는데 if문이 만족하면 세마포어 큐안에 잡혀들어간다. 이 후 누가 wake를 시켜주면 다시 레디큐로 들어가게 된다.<br>세마포어는 Mutual exclusion을 위해 사용한다. 즉 크리티컬 섹션에는 한명만 들어갈 수 있다.</p>
<p>세마포어의 일반적 사용은 <u>Mutual exclusion</u> 그리고 <u>Ordering</u>으로 나뉜다.<br>그 중 Ordering를 구현하기 위해서는 다음과 같이 하면 된다.</p>
<p>P1    P2<br>S1    S2</p>
<p><code>P1, P2가 있을 때 P1을 먼저 실행하고자 할 때(Ordering)</code> : 세마포어의 value를 0으로 셋팅한다. 그 후 P2 앞에 sem.acquire를 호출한다.<br>이러면 P1이 먼저 호출되면 우리가 원하던 대로 되는것이고 그렇지 않고 P2가 먼저 실행될 경우 세마포어 큐에 들어가서 block이 된다. 아무튼 P1이 먼저 실행되게 되고 실행을 완료하면 release를 호출하여 P2가 실행 될 수 있도록 한다.<br>즉 다음과 같은 형태</p>
<p>P1        P2<br>        acquire<br>S1        S2<br>release</p>
<h3 id="세마포어-정리"><a href="#세마포어-정리" class="headerlink" title="세마포어 정리"></a>세마포어 정리</h3><p>세마포어는 임계구역 문제 해결, 프로세스 실행 순서 제어를 한다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h3 id=&quot;프로세스-관리에서-중요한것들&quot;&gt;&lt;a href=&quot;#프로세스-관리에서-중요한것들&quot; class=&quot;headerlink&quot; title=&quot;프로세스 관리에서 중요한것들&quot;&gt;&lt;/a&gt;프로세스 관리에서 중요한것들&lt;/h3&gt;&lt;p&gt;CPU 스케줄링 : 이전
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>11.임계구역 문제, 동기화 도구</title>
    <link href="http://KKimSangHeon.github.io/2019/02/19/operating-system11/"/>
    <id>http://KKimSangHeon.github.io/2019/02/19/operating-system11/</id>
    <published>2019-02-19T11:04:12.000Z</published>
    <updated>2019-02-20T14:16:20.363Z</updated>
    
    <content type="html"><![CDATA[<h3 id="임계구역-문제-critical-section-problem"><a href="#임계구역-문제-critical-section-problem" class="headerlink" title="임계구역 문제(critical-section problem)"></a>임계구역 문제(critical-section problem)</h3><p>여러개의 쓰레드로 이뤄진 시스템에서 각각의 쓰레드는 코드영역을 갖고있는데 이를 크리티컬 섹션이라한다. 또한 쓰레드로 부터 공통으로 사용되고 변경될 수 있는 부분을 의미한다.</p>
<p><u>어떤 복수개의 쓰레드들이 공통적으로 사용하는 부분.</u></p>
<h3 id="임계영역-해결"><a href="#임계영역-해결" class="headerlink" title="임계영역 해결"></a>임계영역 해결</h3><p>이를 해결하기 위해 다음 세가지가 만족되어야 한다.</p>
<p><code>Mutual exclusion (상호배타)</code>: 오직 한 쓰레드만 진입<br><code>Progress (진행)</code>: 진입 결정은 유한 시간 내. 즉 누가 먼저 들어가야되는지 유한시간내에 결정해야 한다.<br><code>Bounded waiting (유한대기)</code>: 어느 쓰레드라도 유한 시간 내 크리티컬 섹션안에 들어갈 수 있어야한다. 기다리는 시간이 한계가 정해져 있다.</p>
<h3 id="동기화의-목적"><a href="#동기화의-목적" class="headerlink" title="동기화의 목적"></a>동기화의 목적</h3><p><u>우리가 원하는대로 프로세스 혹은 쓰레드의 실행 순서를 결정 지을 수 있는것.</u></p>
<p>O/S 가 가진 여러 매니지먼트(프로세스 매니지먼트,메모리 매니지먼트,파일 시스템 매니지먼트, I/O 매니지먼트) 중 가장 중요한것은 프로세스 매니지먼트. 프로세스 매니지먼트는 두 가지로 나뉘는데 하나는 <u>CPU Scheduling, Synchronization</u></p>
<h3 id="Synchronization를-위한도구"><a href="#Synchronization를-위한도구" class="headerlink" title="Synchronization를 위한도구"></a>Synchronization를 위한도구</h3><p>세마포어 모니터가 있다.</p>
<p><code>Semaphores</code> : 기차역에서 출발신호를 의미하는 깃발이다. 네덜란드사람 딕스트라가 만듦.<br>내부구조는 정수 하나와 동작 두개로 구성된다. <u>하나는 P 동작 하나는 V 동작</u><br>P: Proberen (test) 즉 acquire()  검사<br>V: Verhogen (increment) 즉 release() 증가.</p>
<p>스택에는 푸쉬, 팝이라는 동작이 있다. 마찬가지로 세마포어도 내부에 정수가 있고 P,V가 존재한다.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> </span>&#123;</div><div class="line">  value--;</div><div class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>) &#123;</div><div class="line">        add <span class="keyword">this</span> process/thread to list;  <span class="comment">// 누가 호출하면 큐안에 넣는다.</span></div><div class="line">        block;</div><div class="line">      &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</div><div class="line">  value++;</div><div class="line">    <span class="keyword">if</span> (value &lt;= <span class="number">0</span>) &#123;</div><div class="line">        remove a process P from list; <span class="comment">//누군가 갇혀있으면 깨워준다.</span></div><div class="line">        wakeup P;</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>저번에 배웠듯이 레디큐에서 CPU의 서비스를 받기 위해 기다리던 프로세스들이 CPU 서비스를 받다 IO를 만나면 IO서비스를 받으려 하는데 누가 IO서비스를 받고있다면 IO Queue(Device Queue)에서 대기하다 IO서비스를 받고 끝나면 다시 레디큐로 돌아온다.</p>
<p>타임쉐어링 시스템의 경우엔 IO를 만나지 않더라도 시간이 지나면 다시 레디큐로 돌아간다.</p>
<p>이는 프로세스의 큐잉 모델 즉 줄서서 기다리는 모델이다.</p>
<p>세마포어는 정수값도 있고 세마포어 큐도 있다. 어떤 프로세스가 레디큐에 있다 CPU를 쓰다가 acquire를 호출했는데 if문이 맞으면 갇혀버린다.(like 감옥) 이후에 누가 release를 해주면 감옥에서 탈출하여 다른 레디큐로 갈 수 있다.</p>
<p>위에서 value는 권한의 갯수로 생각하면 된다.</p>
<h3 id="세마포어는-Mutual-exclusion-상호베타를-위해-동작한다"><a href="#세마포어는-Mutual-exclusion-상호베타를-위해-동작한다" class="headerlink" title="세마포어는 Mutual exclusion 상호베타를 위해 동작한다."></a>세마포어는 Mutual exclusion 상호베타를 위해 동작한다.</h3><p>세마포어의 초깃값이 1이라 하자. 이때 레디큐에 A, B가 있다고 하자.<br>먼저 A가 acquire(); 을 호출하면 0이 되고 크리티컬 섹션 안으로 들어간다.(블록 걸리지 않음)<br>이때 컨텍스트 스위칭이 되고 B가 acquire를 호출하면 이때는 value가 -1이므로 세마포어 큐에 갇히게 된다.  (크리티컬 섹션 안으로 못들어간다). 그 후 A가 작업을 마치고 release를 호출하게 되면 value를 늘리고 세마포어 큐에 갇혀있는 B를 깨워 다시 레디큐로 들어가게 한다.</p>
<p> 이를 상호베타라 한다.</p>
<p><code>Monitors</code> :</p>
<p>메모리 매니지먼트라<br>파일 시스템 매니지먼트<br>I/O 매니지먼트</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;임계구역-문제-critical-section-problem&quot;&gt;&lt;a href=&quot;#임계구역-문제-critical-section-problem&quot; class=&quot;headerlink&quot; title=&quot;임계구역 문제(critical-section pro
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>10.프로세스 동기화의 중요성, 은행계좌 문제</title>
    <link href="http://KKimSangHeon.github.io/2019/02/18/operating-system10/"/>
    <id>http://KKimSangHeon.github.io/2019/02/18/operating-system10/</id>
    <published>2019-02-18T13:31:45.000Z</published>
    <updated>2019-02-18T13:34:32.742Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-쓰레드란"><a href="#1-쓰레드란" class="headerlink" title="1. 쓰레드란?"></a>1. 쓰레드란?</h3><p>프로그램 내부의 흐름, 맥</p>
<p>맥이 하나만 있는 프로그램 : 싱글쓰레드<br>여러개있는것: 멀티(다중)쓰레드</p>
<p>쓰레드가 여러개가 빠르게 동시에(왔다갔다하면서) 실행됨. 우리는 CPU하나임을 가정하고 공부하기 때문에</p>
<h3 id="1-1-쓰레드-구조"><a href="#1-1-쓰레드-구조" class="headerlink" title="1.1 쓰레드 구조"></a>1.1 쓰레드 구조</h3><p>프로세스의 메모리 공간 공유 : (code, data)<br>프로세스의 자원 공유 : (file, i/o, …)<br>비공유: 개별적인 PC, SP, registers, stack</p>
<p>운영체제의 프로세스 관리부서에서 중요한것은 프로세스 동기화 또는 쓰레드 동기화이다.</p>
<h3 id="프로세스는-크게-두가지로-나뉜다"><a href="#프로세스는-크게-두가지로-나뉜다" class="headerlink" title="프로세스는 크게 두가지로 나뉜다."></a>프로세스는 크게 두가지로 나뉜다.</h3><p>Independent process : p1, p2가 영향이 없다<br>Cooperating process : p1, p2가 영향을 주던지 받던지 한다. 이런경우가 훨씬 많다.<br>프로세스간 통신: 전자우편, 파일 전송<br>프로세스간 자원 공유: 메모리 상의 자료들, 데이터베이스 등<br>명절 기차표 예약, 대학 온라인 수강신청, 실시간 주식거래</p>
<h3 id="2-프로세스-쓰레드-동기화"><a href="#2-프로세스-쓰레드-동기화" class="headerlink" title="2. 프로세스(쓰레드) 동기화"></a>2. 프로세스(쓰레드) 동기화</h3><p><code>공통데이터에 접근하는것은 문제가 발생할 수 있다. (공유되는 프로세스가 동시에 접근할 때.)</code><br>동기화가 제대로 이뤄지지 않으면 똑같은 자리에 두명이상이 배정된다던가 하는 문제가 생긴다.</p>
<p><u>프로세스간에 순서를 잘 지정해서 이상한 상태에 빠지지 않도록 하여 데이터의 일관성을 유지</u></p>
<h3 id="2-1-BankAccount-Problem-은행계좌문제"><a href="#2-1-BankAccount-Problem-은행계좌문제" class="headerlink" title="2.1 BankAccount Problem (은행계좌문제)"></a>2.1 BankAccount Problem (은행계좌문제)</h3><p>부모님은 은행계좌에 입금; 자녀는 출금<br>입금(deposit)과 출금(withdraw) 은 독립적으로 일어난다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-쓰레드란&quot;&gt;&lt;a href=&quot;#1-쓰레드란&quot; class=&quot;headerlink&quot; title=&quot;1. 쓰레드란?&quot;&gt;&lt;/a&gt;1. 쓰레드란?&lt;/h3&gt;&lt;p&gt;프로그램 내부의 흐름, 맥&lt;/p&gt;
&lt;p&gt;맥이 하나만 있는 프로그램 : 싱글쓰레드&lt;br&gt;여러
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>9.다중 큐 스케쥴링, 프로세스 생성과 소멸, 쓰레드</title>
    <link href="http://KKimSangHeon.github.io/2019/02/18/operating-system9/"/>
    <id>http://KKimSangHeon.github.io/2019/02/18/operating-system9/</id>
    <published>2019-02-18T13:29:58.000Z</published>
    <updated>2019-02-18T13:31:23.624Z</updated>
    
    <content type="html"><![CDATA[<h3 id="다중-큐-스케쥴링-프로세스-생성과-소멸-쓰레드"><a href="#다중-큐-스케쥴링-프로세스-생성과-소멸-쓰레드" class="headerlink" title="다중 큐 스케쥴링, 프로세스 생성과 소멸, 쓰레드"></a>다중 큐 스케쥴링, 프로세스 생성과 소멸, 쓰레드</h3><h3 id="다양한-CPU-스케줄링-알고리즘"><a href="#다양한-CPU-스케줄링-알고리즘" class="headerlink" title="다양한 CPU 스케줄링 알고리즘"></a>다양한 CPU 스케줄링 알고리즘</h3><p>First-Come, First-Served (FCFS)<br>Shortest-Job-First (SJF)<br>Priority<br>Round-Robin (RR)<br>Multilevel Queue<br>Multilevel Feedback Queue</p>
<h3 id="1-Multilevel-Queue-Scheduling"><a href="#1-Multilevel-Queue-Scheduling" class="headerlink" title="1. Multilevel Queue Scheduling"></a>1. Multilevel Queue Scheduling</h3><h3 id="1-1-Process-groups-프로세스는-그룹별로-묶일-수-있다"><a href="#1-1-Process-groups-프로세스는-그룹별로-묶일-수-있다" class="headerlink" title="1.1 Process groups : 프로세스는 그룹별로 묶일 수 있다."></a>1.1 Process groups : 프로세스는 그룹별로 묶일 수 있다.</h3><p>System processes : 가장 긴급하고 먼저 처리되어야 하는것.<br>Interactive processes : 대화형 프로세스<br>Interactive editing processes : ex 워드프로세스<br>Batch processes : 인터액션이 따로 없다.<br>Student processes</p>
<p>성격이 다양한것을 동일한 큐에 세우는것이 맞지 않다라고 판단.<br>입출금은 빠르게 끝나는데 대출은 오래 끝나니까!<br>이를 위해 <u>큐를 여러개를 두자 이를 멀티레벨 큐</u>.</p>
<h3 id="1-2-Single-ready-queue-→-Several-separate-queues"><a href="#1-2-Single-ready-queue-→-Several-separate-queues" class="headerlink" title="1.2 Single ready queue → Several separate queues"></a>1.2 Single ready queue → Several separate queues</h3><p>각각의 Queue 에 절대적 우선순위 존재<br>또는 CPU time 을 각 Queue 에 차등배분<br>각 Queue 는 독립된 scheduling 정책</p>
<p>큐가 여러개이므로 우선순위를 둬서 차등반영한다.<br>또한 각 큐별로 다른 스케줄링 기법을 사용한다.</p>
<h3 id="2-Multilevel-Feedback-Queue-Scheduling"><a href="#2-Multilevel-Feedback-Queue-Scheduling" class="headerlink" title="2. Multilevel Feedback Queue Scheduling"></a>2. Multilevel Feedback Queue Scheduling</h3><p>큐를 여러개 둔다는점은 Multilevel Queue Scheduling와 같은데 <code>하나의 입구로 진입해서 거의 실행되지 않는다면 다른큐로 이동한다.</code></p>
<h3 id="2-1-다른-Queue-로의-점진적-이동"><a href="#2-1-다른-Queue-로의-점진적-이동" class="headerlink" title="2.1 다른 Queue 로의 점진적 이동"></a>2.1 다른 Queue 로의 점진적 이동</h3><p>모든 프로세스는 하나의 입구로 진입<br>너무 많은 CPU time 사용 시 다른 Queue 로<br>기아 상태 우려 시 우선순위 높은 Queue 로</p>
<p>상용운영체제는 여러 큐를 갖고있어 다양한 스케줄링 정책을 두어 적절히 활용한다.</p>
<h3 id="3-Process-Creation"><a href="#3-Process-Creation" class="headerlink" title="3. Process Creation"></a>3. Process Creation</h3><p>프로세스는 사람과 비슷하다. <u>프로세스는 프로세스에 의해 만들어진다.</u></p>
<p><code>그렇다면 제일 첫번째 프로세스는 어떻게 만들어졌을까??</code><br>O/S가 메모리로 올라가고 초기화 작업을 하면 제일 처음 프로세스를 만든다. 제일 첫번째 프로세스 이름을 유닉스의 경우 init프로세스(OS마다 다름)라 한다. 이 프로세스가 다른 프로세스를 만든다.</p>
<h3 id="3-1-Process-Identifier-PID"><a href="#3-1-Process-Identifier-PID" class="headerlink" title="3.1 Process Identifier (PID)"></a>3.1 Process Identifier (PID)</h3><p>사람의 주민등록번호와 같은것.<br>처음 만들어지는 프로그램은 0이다.<br>PPID? 부모 PID</p>
<h3 id="3-2-프로세스-생성"><a href="#3-2-프로세스-생성" class="headerlink" title="3.2 프로세스 생성"></a>3.2 프로세스 생성</h3><p>fork() system call - 새로운 프로세스 만드는것.<br>exec() - 만들어진 프로세스의 실행파일을 메모리로 갖고오는것.</p>
<h3 id="3-3-프로세스-종료"><a href="#3-3-프로세스-종료" class="headerlink" title="3.3 프로세스 종료"></a>3.3 프로세스 종료</h3><p>exit() system call - 해당 프로세스가 가졌던 모든 자원은 OS에게 반환 (메모리, 파일, 입출력장치 등)</p>
<h3 id="4-쓰레드"><a href="#4-쓰레드" class="headerlink" title="4. 쓰레드"></a>4. 쓰레드</h3><p><u>프로그램 내부의 흐름, 맥이라고 한다.</u></p>
<h3 id="4-1-다중-쓰레드-Multithreads"><a href="#4-1-다중-쓰레드-Multithreads" class="headerlink" title="4.1 다중 쓰레드(Multithreads)"></a>4.1 다중 쓰레드(Multithreads)</h3><p><u>하나의 프로그램에 맥이 2개이상 있는것.</u><br>맥이 빠른 시간 간격으로 스위칭 된다 →  여러 맥이 동시에 실행되는 것처럼 보인다<br>Web browser : 화면 출력하는 쓰레드 + 데이터 읽어오는 쓰레드<br>Word processor : 화면 출력하는 쓰레드 + 키보드 입력 받는 쓰레드 + 철자/문법오류 확인 쓰레드</p>
<p>이전강의까지는 P1이 끝나면 P2로 넘어간다 했는데 그건 예전의 OS이다.<br>즉 <u>현재의 컴퓨터는 컨텍스트 스위칭 단위가 프로세스가 아니라 쓰레드 단위이다</u>.</p>
<p>각 쓰레드는 코드와 데이터 공유하고 스택은 공유하지 않는다.</p>
<p>한 프로세스에는 기본 1개의 쓰레드 : <code>단일 쓰레드 (single thread) 프로그램</code><br>한 프로세스에 여러 개의 쓰레드 : <code>다중 쓰레드 (multi-thread) 프로그램</code></p>
<h3 id="4-2-쓰레드-구조"><a href="#4-2-쓰레드-구조" class="headerlink" title="4.2 쓰레드 구조"></a>4.2 쓰레드 구조</h3><p>프로세스의 메모리 공간 공유 : (code, data)<br>프로세스의 자원 공유 : (file, i/o, …)<br>비공유: 개별적인 PC, SP, registers, stack</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;다중-큐-스케쥴링-프로세스-생성과-소멸-쓰레드&quot;&gt;&lt;a href=&quot;#다중-큐-스케쥴링-프로세스-생성과-소멸-쓰레드&quot; class=&quot;headerlink&quot; title=&quot;다중 큐 스케쥴링, 프로세스 생성과 소멸, 쓰레드&quot;&gt;&lt;/a&gt;다중 큐 스케쥴링
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>8.SJF, Priority, RR 스케쥴링</title>
    <link href="http://KKimSangHeon.github.io/2019/02/16/operating-system8/"/>
    <id>http://KKimSangHeon.github.io/2019/02/16/operating-system8/</id>
    <published>2019-02-16T04:17:07.000Z</published>
    <updated>2019-02-17T11:46:28.048Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CPU-스케줄링-알고리즘"><a href="#CPU-스케줄링-알고리즘" class="headerlink" title="CPU 스케줄링 알고리즘"></a>CPU 스케줄링 알고리즘</h3><p><u>CPU 스케줄링은 레디큐에서 프로세스들이 CPU의 작업을 기다리고있을 때 누가 먼저 들어갈것인가에 대한것.</u></p>
<p>FCFS는 이전포스트 참고</p>
<p><code>AWT</code>를 평균대기시간이라 함.<br><code>ATT</code>를 Average turnaround time 반환시간이라함.</p>
<h3 id="SJF"><a href="#SJF" class="headerlink" title="SJF"></a>SJF</h3><p><u>가장 짧은것을 먼저하는것.</u><br>P1 6<br>P2 8<br>P3 7<br>P4 3<br>의 프로세스가있을 때 대기시간.</p>
<p>p4, p1,p3,p2의 순서로 진행된다.<br>평균 대기시간은 (3+16+9+0)/4 = 7 이다.<br>FCFS로 하면<br>(0+6+14+21) /4 = 10.25 이다.</p>
<p>실제로 프로세스가 얼마나 사용할지는 모른다. 해봐야 한다.<br>대기시간을 줄이기 위해 적절한 방법이긴 한데 CPU 사용시간을 예측을 해야한다.(이를 정확하게 예측하기 위해서는 과거를 기억해야 하는등 계산하는데 오버헤드가 발생한다.)</p>
<p>실제로 적용하기엔 어렵다!</p>
<p>Preemptive or Nonpreemtive 둘다 적용가능하다.</p>
<h3 id="Priority-Scheduling"><a href="#Priority-Scheduling" class="headerlink" title="Priority Scheduling"></a>Priority Scheduling</h3><p><u>우선순위가 높은것을 먼저 처리</u></p>
<p>우선순위는 내부적요소, 외부적 요소로 결정된다.<br>내부요소: 타임 리밋이 짧은것을 높게주기, 메모리 적게잡는놈 높게주기, IO가 길고 CPU burst가 짧은거 높게주기 등등<br>외부요소: 돈 많이 낸사람, 정치적요소</p>
<p>일반적으로 많이 사용된다.</p>
<p>이 또한 Preemptive or Nonpreemtive 둘다 적용가능하다.</p>
<p>문제점: 기아상태<br>우선순위가 낮은 프로세스가 기다리는데 우선순위 높은것들이 자꾸 들어온다면 아무리 기다려도 자기 차례가 오지 않는다.<br>해결방법 : againg 어떤 프로세스가 오래머물러 있다면 점진적으로 우선순위를 높여준다</p>
<h3 id="Round-Robin"><a href="#Round-Robin" class="headerlink" title="Round Robin"></a>Round Robin</h3><p><u>시간을 쪼개서 진행</u><br>Time quantum 시간양자 = time slice (보통 10 ~ 100msec으로 잡는)<br>Preemptive scheduling</p>
<p>타임퀀텀을 얼마로 잡느냐에 따라 AWT가 달라진다.<br>즉 Time quantum에 의존적이다<br>Time quantum을 무한대로 주면 FCFS와 동일하다</p>
<p>반대로 Time quantum을 0으로 주면 동시에 도는것과 같이느낄 수있다,<br>context switching overhead 가 발생함.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CPU-스케줄링-알고리즘&quot;&gt;&lt;a href=&quot;#CPU-스케줄링-알고리즘&quot; class=&quot;headerlink&quot; title=&quot;CPU 스케줄링 알고리즘&quot;&gt;&lt;/a&gt;CPU 스케줄링 알고리즘&lt;/h3&gt;&lt;p&gt;&lt;u&gt;CPU 스케줄링은 레디큐에서 프로세스들이 
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>7.스케쥴링 척도, FCFS</title>
    <link href="http://KKimSangHeon.github.io/2019/02/15/os7/"/>
    <id>http://KKimSangHeon.github.io/2019/02/15/os7/</id>
    <published>2019-02-15T12:27:56.000Z</published>
    <updated>2019-02-17T11:45:42.025Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CPU-스케쥴링"><a href="#CPU-스케쥴링" class="headerlink" title="CPU 스케쥴링"></a>CPU 스케쥴링</h3><p>프로그램은 하드디스크안에 들어있고 아무런 동작도 하지안흔다. 메인메모리에 올라가서 실행이 되면 활동한다.</p>
<p>활동중에 있는 프로그램을 프로세스라함.</p>
<p>프로세스에 대한 것들을 PCB안에 넣어놓는다.</p>
<p>컴퓨터 안에는 여러가지 큐가 있는데 <code>job queue, ready queue, device queue</code>가 있다.</p>
<p>메인메모리에 여러 프로그램이 올라와있는게 멀티 프로그래밍<br>프로그램이 몇개인가에 대한것이 Degree of multiprogramming</p>
<p><u>잡스케줄러가 하는일은 i/o-bound 를 CPU-bound process 적절히 분배하는것.</u></p>
<p><code>short-term scheduler</code> : <u>메모리에 올라온 프로세스들은 CPU를 받기위해 줄서있는데 어느놈을 선택해서 서비스해줄지에 대한것</u><br><code>Long-term scheduler</code> : 하드디스크에서 메인메모리에 올라가기 위해 <u>job queue에 대기하는 프로그램중 어느놈을 먼저 올려야하는지에 대한것</u></p>
<p>메인메모리에 올라온 프로세스중에 일정시간동안 사용되지 않는것을 물리적인 하드디스크에 Swap out 한다.<br><code>Medium-term scheduler</code> : Swap out 리스트중 어느것을 Swap in 할지에 대한것을 의미함.</p>
<p>하드디스크는 파일시스템목적, Backing store(물리적인 하드디스크에 Swap out할 때 목적지) 용도로 사용된다.</p>
<h3 id="Context-switching"><a href="#Context-switching" class="headerlink" title="Context switching"></a>Context switching</h3><p>CPU가 p1을 실행하다 p2로 넘어가는데 이를 문맥교환이라 한다.</p>
<h3 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h3><p>레디큐에 있는 놈 중 어느놈을 CPU로 보내줄까에 대한것.<br>지금있는 프로세스가 끝나면 어느놈을 선택할것인가에 대한것.<br>O/S안에 들어있는 컴퓨터 프로그램이다.</p>
<h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><p><u>스케줄러가 선택한 프로세스를 실행하도록 여러가지 상태를 변경해주는것.<br>p2가 선택되었다면 p2를 돌리기 위해 p1의 현재상태 프로그램카운터,스택포인터,레지스터,베이스레지스터 등을 P1의 PCB 에 저장해 놓아야한다.</u><br>즉 p1의 현재상태를 pcb1에 저장해놓는다. p2의 PCB에저장된 값을 복원(restore)<br>이런일을 하는것이 디스패처라 한다.<br>이런일을 하는것은 오버헤드(부담)이 발생하게 된다. 이를 Context Switching Overhead라고 한다.</p>
<p>즉 컨텍스트 스위칭을 자주하는것은 손해이다.<br>Dispatcher는 주로 어셈블리어와같은 low 레벨로 짜서 효율을 높인다.</p>
<h3 id="CPU스케줄링"><a href="#CPU스케줄링" class="headerlink" title="CPU스케줄링"></a>CPU스케줄링</h3><p>현재 실행중인 프로세스가 끝나면 어느것을 실행해줄까</p>
<h3 id="Preemptive-vs-Non-preemptive"><a href="#Preemptive-vs-Non-preemptive" class="headerlink" title="Preemptive vs Non-preemptive"></a>Preemptive vs Non-preemptive</h3><p><code>Preemptive</code> : CPU가 어떤일을 하고 있는데 IO를 만나거나 끝나지도 않았는데 강제로 끝내고 들어갈 수 있는것<br><code>Non-preemptive</code> : 이미 어떤프로세스가 실행중이면 끝나거나 IO를 만나지 않으면 변경되지 않는것</p>
<h3 id="Scheduling-criteria-척도"><a href="#Scheduling-criteria-척도" class="headerlink" title="Scheduling criteria(척도)"></a>Scheduling criteria(척도)</h3><p>특정 Scheduling 기법을 판단하는 기준</p>
<ul>
<li><p>CPU Utilization (CPU 이용률) : CPU가 놀지않고 얼마나 열심히 일하는가. a방법은 100%로 돌고 b방법은 80%로 들 때 a방법을 채택</p>
</li>
<li><p>Throughput (처리율) : 시간당 몇개의 작업을 처리하는가.</p>
</li>
<li><p>Turnaround time (반환시간) : 작업이 ready queue로 들어가 작업을 끝내고 나오는 시간.</p>
</li>
<li><p>Waiting time (대기시간) : CPU를 받기위해 ready queue에서 얼마나 기다려야 하는가. 당연히 짧을수록 좋다.</p>
</li>
<li><p>Response time (응답시간) : interactive 환경에서 중요하다. 처음 응답이 나올때 까지 걸리는 시간. 주로 대화형 컴퓨터에서 척도로 삼음</p>
</li>
</ul>
<p>기타 요소 존재….</p>
<hr>
<h3 id="First-Come-First-Served-FCFS"><a href="#First-Come-First-Served-FCFS" class="headerlink" title="First-Come, First-Served (FCFS)"></a>First-Come, First-Served (FCFS)</h3><p><u>먼저온놈을 먼저 처리해준다.</u>  - Non-preemptive schedulling<br>레디큐에 프로세스가 대기중이다.</p>
<p>p1은 burst time 24<br>p2는 3<br>p3는 3 일때</p>
<p>평균적으로 기다린 시간은 (0 +24 + 27)/3 = 17 이다.</p>
<p>P3,P2,P1 순으로 들어왔다고 할 경우 (0+3+6)/3 = 3 이라고 할 수 있다.<br>당연히 아래방식이 더 좋다.</p>
<p>간트차트 추가</p>
<p>즉 이런방식으로 해주면 평균 대기시간을 고려할 때 그리 좋은방법이 아니다.</p>
<p>Convoy Effect (호위효과) : CPU를 많이 잡아먹는놈이 앞에있으면 뒤에놈들이 오래 기다려야 한다.</p>
<h3 id="Shortest-Job-First-SJF"><a href="#Shortest-Job-First-SJF" class="headerlink" title="Shortest-Job-First (SJF)"></a>Shortest-Job-First (SJF)</h3><p><u>짧은 작업을 먼저 처리해준다.</u></p>
<h3 id="Shortest-Remaining-Time-First"><a href="#Shortest-Remaining-Time-First" class="headerlink" title="Shortest-Remaining-Time-First"></a>Shortest-Remaining-Time-First</h3><h3 id="Priority"><a href="#Priority" class="headerlink" title="Priority"></a>Priority</h3><h3 id="Round-Robin-RR"><a href="#Round-Robin-RR" class="headerlink" title="Round-Robin (RR)"></a>Round-Robin (RR)</h3><h3 id="Multilevel-Queue"><a href="#Multilevel-Queue" class="headerlink" title="Multilevel Queue"></a>Multilevel Queue</h3><h3 id="Multilevel-Feedback-Queue"><a href="#Multilevel-Feedback-Queue" class="headerlink" title="Multilevel Feedback Queue"></a>Multilevel Feedback Queue</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CPU-스케쥴링&quot;&gt;&lt;a href=&quot;#CPU-스케쥴링&quot; class=&quot;headerlink&quot; title=&quot;CPU 스케쥴링&quot;&gt;&lt;/a&gt;CPU 스케쥴링&lt;/h3&gt;&lt;p&gt;프로그램은 하드디스크안에 들어있고 아무런 동작도 하지안흔다. 메인메모리에 올라가서 
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>6.프로세스의 정의, CPU 스케쥴러, 멀티프로그래밍</title>
    <link href="http://KKimSangHeon.github.io/2019/02/15/os6/"/>
    <id>http://KKimSangHeon.github.io/2019/02/15/os6/</id>
    <published>2019-02-15T12:24:01.000Z</published>
    <updated>2019-02-22T14:32:45.181Z</updated>
    
    <content type="html"><![CDATA[<h3 id="프로세스-관리"><a href="#프로세스-관리" class="headerlink" title="프로세스 관리"></a>프로세스 관리</h3><p>CPU를 프로세스한테 어떻게 잘 나눠주는가에 대한것.</p>
<p>Process<br>실행중인 프로그램.</p>
<p>프로그램은 무덤속에 있는것. 프로세스는 살아있는것.<br>program in execution: text + data + stack, pc, sp, registers, …</p>
<h3 id="프로세스의-상태"><a href="#프로세스의-상태" class="headerlink" title="프로세스의 상태"></a>프로세스의 상태</h3><p>new - 메인 메모리로 올라온 상태.<br>ready - 실행할 준비가 모두 다 된상태 ( waiting이 끝나도 ready로 돌아옴)<br>running - CPU가 실행중인 상태 (CPU를 잡게된 상태)<br>waiting - 기다리는 상태. ( hwp 프로그램이 프린터를 요청하고 기다림. 즉 IO를 만나는 경우에도 wating상태가 된다,)<br>terminated - 끝난상태.</p>
<p>ready, running, wating의 반복으로 프로세스가 동작</p>
<p>타임쉐어링 시스템은 일정시간이 지나면 바로 ready 상태로 간다</p>
<h3 id="PCB-Process-Control-Block"><a href="#PCB-Process-Control-Block" class="headerlink" title="PCB(Process Control Block )"></a>PCB(Process Control Block )</h3><p>Task == Process<br>프로세스 제어 블록이며 Task Control Block (TCB) 이라고도 함.</p>
<p>PCB는 프로세스에 대한 모든 정보를 담고있다.<br><u>하나의 프로세스에 대해 PCB를 갖고있다. 다른 프로세스로 처리가 넘어가다러도 다시 돌아올 수 있도록 관리.</u><br>상태정보, PC(지금은 몇번지인지. 번지정보), registers, MMU info (base, limit), CPU time(CPU 이용시간), process id, list of open files(얘가 지금 어떤파일을 사용하고 있는지)…</p>
<p>PCB는 OS의 프로세스 관리 부서(프로세스 매니지먼트,모르겠으면 이전포스팅 참고) 안에 들어있다.</p>
<p>모든프로그램은 원래 하드디스크 안에 들어있다.  </p>
<h3 id="여러가지-Queue"><a href="#여러가지-Queue" class="headerlink" title="여러가지 Queue"></a>여러가지 Queue</h3><p>하드디스크에서 메모리로 올라가기 위해서는 줄서서 기다려야한다. 그런것을 <code>Job queue</code>라고 한다.</p>
<p>메인메모리에 올라와서 CPU를 받으려면 줄서야 하는데 이를 <code>Ready queue</code>라고 한다.</p>
<p>I/O를 사용하려 해도 줄서서 기다려야 한다. 이를 <code>Device queue</code> 라고 한다.</p>
<p>I/O를 끝내면 ready상태로 가는데 여기서도 줄서서 기다려야 한다.</p>
<hr>
<img src="/2019/02/15/os6/image1.png" alt="여러가지의 Queue" title="여러가지의 Queue">
<h3 id="Job-scheduling-Long-term-scheduler"><a href="#Job-scheduling-Long-term-scheduler" class="headerlink" title="Job scheduling(Long-term scheduler)"></a>Job scheduling(Long-term scheduler)</h3><p>하드디스크에서 메인메모리에 올라가기 위해 <u>job queue에 대기하는 프로그램중 어느놈을 먼저 올려야하는지에 대한것</u>을 <code>Job scheduling(Long-term scheduler)</code>라 한다. 잡 스케줄링은 역시 O/S 안에 프로세스 관리안에 존재한다.<br>일반적으로 프로세스가 끝나고 메모리가 비워져야 일어나기 때문에 Long-term scheduler 라고도 한다. 즉 스케줄러가 일어나는 시간이 몇분이 걸린다.</p>
<h3 id="CPU-Scheduler-Short-term-scheduler"><a href="#CPU-Scheduler-Short-term-scheduler" class="headerlink" title="CPU Scheduler( Short-term scheduler )"></a>CPU Scheduler( Short-term scheduler )</h3><p><u>메모리에 올라온 프로세스들은 CPU를 받기위해 줄서있는데 어느놈을 선택해서 서비스해줄지에 대한것</u>을 <code>CPU Scheduler( Short-term scheduler )</code>이라 한다.<br>메인 메모리에 여러 프로그램이 있는데 스위칭이 빠르게 일어난다. 1초에 수십번,수백번도 발생한다.  그래서 Short-term scheduler 라고도 부른다. <u>다른 스케줄링 보다도 가장 중요한 스케줄링이다.</u></p>
<h3 id="Device-Scheduler"><a href="#Device-Scheduler" class="headerlink" title="Device Scheduler"></a>Device Scheduler</h3><p>디바이스 서비스를 받기위해 기다리는것을 <code>Device Scheduler</code>이라 한다.</p>
<h3 id="멀티프로그래밍"><a href="#멀티프로그래밍" class="headerlink" title="멀티프로그래밍"></a>멀티프로그래밍</h3><p><u>메인메모리에 하나의 프로그램, 프로세스를 올리는것이 아니라 여러개를 올리는것.</u></p>
<p><code>Degree of multiprogramming</code> - 멀티프로그래밍의 정도 ( 메인메모리에 몇개의 프로세스가 올라와있는가)</p>
<h3 id="프로세스의-구분"><a href="#프로세스의-구분" class="headerlink" title="프로세스의 구분"></a>프로세스의 구분</h3><p>프로세스는 크게 두가지로 나눌 수 있다,<br>i/o-bound : 프로세스가 하는게 주로 I/O를 사용하는것(ex. 워드프로세서)<br>CPU-bound process  : 프로세스가 주로 cpu를 사용함.(ex. 일기예보와 같은 계산)</p>
<p>O/S는 작업을 적당히 섞어서 잡 스케줄링결과로 CPU 혹은 IO에만 작업이 치중해 한쪽이 놀지 않도록 한다.</p>
<h3 id="Medium-term-scheduler"><a href="#Medium-term-scheduler" class="headerlink" title="Medium-term scheduler"></a>Medium-term scheduler</h3><p>서버컴퓨터에 여러명이 사용중이라 가정하자. B라는 사람이 심심해서 커피를 마시러 갔다하자. 그동안 B를 위한 메모리는 올라와있지만 CPU는 아무역할도 하지 않는다. 즉 낭비다. B를 위한 자원을 쫒아내는것이 이득인데 이를 위해 디스크로 쫒아내고 비어있는 메모리공간을 확보한다. 여기서 쫒아내는 것을 <code>Swap out</code>라고 한다. 이처럼 디스크를 프로세스 이미지를 쫒아내는 목적으로 사용하는것을 <code>swap device</code> 라고 한다. 다시 B가 커피를 마시고 돌아와 마우스를 움직이면 Swap device로 갔던 프로세스를 불러들이는데 이를 <code>Swap in</code>이라 한다. swap device로 swap in되고 swap out 되는것을 Swapping 이라 한다.</p>
<p>이때 쫒겨났을때 쫒겨난 자리로 그대로 들어가는것을 보장하지는 않는다.</p>
<p>즉 Medium-term scheduler 는 현재 사용되고 있지 않은 어떤놈을 쫒아낼지 결정하는것이다.</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;프로세스-관리&quot;&gt;&lt;a href=&quot;#프로세스-관리&quot; class=&quot;headerlink&quot; title=&quot;프로세스 관리&quot;&gt;&lt;/a&gt;프로세스 관리&lt;/h3&gt;&lt;p&gt;CPU를 프로세스한테 어떻게 잘 나눠주는가에 대한것.&lt;/p&gt;
&lt;p&gt;Process&lt;br&gt;실행
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
  <entry>
    <title>5.운영체제의 주요 서비스 프로세스, 메모리, 파일관리, 시스템 호출</title>
    <link href="http://KKimSangHeon.github.io/2019/02/14/operating-system/"/>
    <id>http://KKimSangHeon.github.io/2019/02/14/operating-system/</id>
    <published>2019-02-14T13:01:23.000Z</published>
    <updated>2019-02-17T11:02:54.527Z</updated>
    
    <content type="html"><![CDATA[<h3 id="운영체제-서비스"><a href="#운영체제-서비스" class="headerlink" title="운영체제 서비스"></a>운영체제 서비스</h3><p>지금은 서버컴퓨터 하나에 여러명이 동시에 사용하는 구조.<br>이러한 구조에선 한사람이 잘못된 것을 할 경우 해악이 될 수있다.</p>
<p>다중유저시스템, 다중프로그래밍시스템에서 필요한 보호들</p>
<p>1.입출력장치 보호<br>A,B가 바로 하드웨어에 접근하지 못하도록 함<br>어떻게? In(입력),Out(출력) 명령을 특권명령으로 만들어 A,B는 이를 실행하지 못하고 O/S에게 부탁하여 실행토록 함.<br>그러면 O/S가 프린터를 구동시켜줌</p>
<p>2.메모리 보호<br>자기에게 넘어간 메모리 접근을 못하도록 하는것.<br>유저1이 OS영역이나 다른사람 영역을 못들어가도록 함.<br><code>어떻게?</code> MMU를 활용하여 base, limit 값을 넘지 못하도록한다. 넘을경우 인터럽트를 발생시켜 프로그램 강제종료</p>
<p>3.CPU 보호<br>while(a=1)…<br>위의 경우 CPU가 한 사용자에 독점되게 된다.<br><code>어떻게?</code> 타이머를 걸어서 일정시간이 지나면 인터럽트를 걸도록 한다.<br>인터럽트 서비스 루틴에는 CPU가 골고루 돌아가고 있는지. 한 프로그램에만 돌아가고 있지 않은지 파악하도록 짠다.<br>인터럽트 &gt; 운영체제 &gt; 다른 프로그램으로 강제 전환</p>
<h3 id="운영체제가-하는일"><a href="#운영체제가-하는일" class="headerlink" title="운영체제가 하는일"></a>운영체제가 하는일</h3><p>정부가 하는일과 비슷하다.<br>자원을 효율적으로 나눠주는 시스템을 OS라 한다.<br>모든애플리케이션은 하드웨어를사는데 이 하드웨어를 적절하게 분배하는것을 OS라 한다.</p>
<h4 id="프로세스-매니지먼트"><a href="#프로세스-매니지먼트" class="headerlink" title="프로세스 매니지먼트"></a>프로세스 매니지먼트</h4><p>이 중 CPU를 나눠주는 부분이 프로세스 매니지먼트</p>
<p>프로세스는 ? <u>메인 메모리에서 실행중인 프로그램. 실행상태에 있는 프로그램</u><br>하드디스크에는 많은 프로그램이 있지만 메인메모리로 올라와 있는 것을 프로세스라 함.<br>그래서 프로그램 매니지먼트라 하지않고 프로세스 매니지먼트라 함.</p>
<p>프로세스들이 많아지만 교착상태가 발생할 수 있는데 이를 프로세스 관리부분이 처리해준다.</p>
<h4 id="메인메모리-매니지먼트"><a href="#메인메모리-매니지먼트" class="headerlink" title="메인메모리 매니지먼트"></a>메인메모리 매니지먼트</h4><p>주기억장치를 나눠주는 부분이 메인메모리 매니지먼트</p>
<p>프로세스한테 메인메모리를 할당한다.<br>메모리의 어느 부분이 어느 프로세스에게 할당되었는가 추적 및 감시<br>프로세스 종료 시 메모리 회수 (deallocation)<br>메모리의 효과적 사용<br>가상 메모리: 물리적 실제 메모리보다 큰 용량 갖도록</p>
<h4 id="파일-매니지먼트"><a href="#파일-매니지먼트" class="headerlink" title="파일 매니지먼트"></a>파일 매니지먼트</h4><p>하드디스크 안에 파일을 관리하는것이 파일 매니지먼트</p>
<p>판 위에 트랙을 만들고 이를 잘라서 섹터라 한다. 즉 트랙, 섹터의 집합</p>
<p>파일을 만들기도 하고 없애기도 하고 디렉토리 생성 삭제에 관여<br><u>파일에 대한 기본동작(open, close, read, write, create, delete) 지원</u><br>백업(backup)</p>
<h4 id="보조기억장치관리-Secondary-storage-management"><a href="#보조기억장치관리-Secondary-storage-management" class="headerlink" title="보조기억장치관리(Secondary storage management)"></a>보조기억장치관리(Secondary storage management)</h4><p>보조기억장치는 트랙, 섹터의 집합인데 이를 어떻게 관리할것인가</p>
<p>하드 디스크, 플래시 메모리 등</p>
<p>섹터들을 모아서 block이라 하는데 block들에 데이터를 저장하게 되는데 빈 공간 관리, 저장공간 할당, 디스크 스케쥴링을 제공한다.</p>
<h4 id="입출력-장치-관리"><a href="#입출력-장치-관리" class="headerlink" title="입출력 장치 관리"></a>입출력 장치 관리</h4><p>장치드라이브 관리(웹켐, 사운드카드 등)<br>입출력 장치의 성능향상을 위해 버퍼링, 캐싱, 스풀링을 활용한다</p>
<p>스풀링 메모리 대신 하드디스크를 중간 매체로 사용한다.<br>스풀링 : 프린터는 일반적으로 느리기때문에 씨피유에 저장하기 보다는 씨피유보다 느리고 프린터 보다 빠른 하드디스크에 저장하는것.<br>빈 공간 관리 (free space management)<br>저장공간 할당 (storage allocation)<br>디스크 스케쥴링 (disk scheduling)</p>
<h4 id="네트워킹"><a href="#네트워킹" class="headerlink" title="네트워킹"></a>네트워킹</h4><h4 id="보호"><a href="#보호" class="headerlink" title="보호"></a>보호</h4><h4 id="기타-등등…"><a href="#기타-등등…" class="headerlink" title="기타 등등…"></a>기타 등등…</h4><h3 id="시스템-콜"><a href="#시스템-콜" class="headerlink" title="시스템 콜"></a>시스템 콜</h3><p><u>O/S가 제공하는 여러가지 기능을 받기 위해 호출하는것.</u></p>
<p>OS에는 여러가지 관리 부서가 있다.<br>또한 여러가지 프로그램이 메모리로 올라가 여러 프로세스가 존재한다,<br>각 프로세스는 OS가 제공하는 관리 기능들이 필요한데 이때 이를 사용하기 위한것이 시스템 콜이라 한다.</p>
<h3 id="주요-시스템-콜"><a href="#주요-시스템-콜" class="headerlink" title="주요 시스템 콜"></a>주요 시스템 콜</h3><p>– Process: end, abort, load, execute, create, terminate, get/set<br>attributes, wait event, signal event<br>– Memory: allocate, free<br>– File: create, delete, open, close, read, write, get/set attributes<br>– Device: request, release, read, write, get/set attributes, attach/detache devices<br>– Information: get/set time, get/set system data<br>– Communication: socket, send, receive</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;운영체제-서비스&quot;&gt;&lt;a href=&quot;#운영체제-서비스&quot; class=&quot;headerlink&quot; title=&quot;운영체제 서비스&quot;&gt;&lt;/a&gt;운영체제 서비스&lt;/h3&gt;&lt;p&gt;지금은 서버컴퓨터 하나에 여러명이 동시에 사용하는 구조.&lt;br&gt;이러한 구조에선 한사
    
    </summary>
    
      <category term="CS" scheme="http://KKimSangHeon.github.io/categories/CS/"/>
    
      <category term="Operating System" scheme="http://KKimSangHeon.github.io/categories/CS/Operating-System/"/>
    
    
  </entry>
  
</feed>
