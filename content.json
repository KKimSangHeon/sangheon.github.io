{"meta":{"title":"Kim Sang Heon's Bolg","subtitle":null,"description":"Welcome to Sang Heon's Blog.","author":"Kim Sang Heon","url":"http://KKimSangHeon.github.io"},"pages":[],"posts":[{"title":"ThisIsLinux18","slug":"ThisIsLinux18","date":"2017-07-07T00:47:34.000Z","updated":"2017-07-07T00:49:43.069Z","comments":true,"path":"2017/07/07/ThisIsLinux18/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/07/ThisIsLinux18/","excerpt":"","text":"1","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"RAID 0,1,5 의 고장과 원상 복구","slug":"ThisIsLinux17","date":"2017-07-06T03:33:07.000Z","updated":"2017-07-06T09:26:17.105Z","comments":true,"path":"2017/07/06/ThisIsLinux17/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/06/ThisIsLinux17/","excerpt":"","text":"SCSI 2,4,6,9를 고장내 놓고 잘동작하는 지 확인 해 보겠다. 잘 동작하나 확인하기 위해 고장내기 전에 파일을 옮긴다.123456# cp /boot/vmlinuz-3* /raidLinear/testFile# cp /boot/vmlinuz-3* /raid0/testFile# cp /boot/vmlinuz-3* /raid1/testFile# cp /boot/vmlinuz-3* /raid5/testFile# halt -pvmplayer을 켜고 SCSI 2,4,6,9 디스크를 제거쫌 지나면 응급복구모드로 실행이됨암호를 입력해주자 ls -l /dev/sd* 을 하니까 당겨져 있다. sdc가 sdb 이런식으로 RAID 1, 5 는 데이터가 살아있어야 한다. RAID 1 확인1234567# df //마운트가 다 끊겨있다.# mdadm --run /dev/md1 //강제로 가동시키는 것시작되었다.# df //raid1가 마운트 된것을 확인.# ls -l /raid1 //데이터가 잘 있는지 확인# mdadm --detail /dev/md1 //하나는 살아있고 하나는 removed인것을 확인 RAID 5 확인12345# mdadm --run /dev/md5 //강제로 가동시키는 것시작되었다.# df //raid5가 마운트 된것을 확인.# ls -l /raid5 //데이터가 잘 있는지 확인# mdadm --detail /dev/md5 //하나는 살아있고 하나는 removed인것을 확인 RAIDLinear 확인12# mdadm --run /dev/md9 //강제로 가동시키는 것실행할 수 없다. 결함을 허용하지 않음 RAID 0 확인12# mdadm --run /dev/md0 //강제로 가동시키는 것실행할 수 없다. 결함을 허용하지 않음 시스템이 재대로 실행되도록 해보자1234567891011# mdadm --stop /dev/md9 //종료# mdadm --stop /dev/md0 //종료# vi /etc/fstabmd9,md0 주석 하고# reboot리부트를 했는데 복구모드로 실행이 된다면 컨트롤 D를 누르고실행한 다음에 재 마운트를 해주면 된다.# df //마운트가 되어있는것 확인. 새로운 디스크를 장착하여 원상복구를 시켜보자Linear RAID, RAID 0 은 데이터를 살릴 순 없다.그러나 RAID 1, RAID 5는 데이터를 살릴 수 있다. vmplayer에서 디스크 4개를 1기가씩 주고 추가하자. 알아서 빈곳을 잘 찾아간다. 우리가 조금전 추가했던것은 sdc, sde, sdg, sdi 이다.2,4,6,9 로 들어갔으므로.. RAID 0, Linear Raid는 새로 만들어주어야 한다.12345678910111213141516# ls -l /dev/sd* //# fdisk /dev/sdc~sdi 까지 n 입력 p 입력 엔터 엔터 t 입력 fd 입력 w 입력# mdadm --stop /dev/md9 //다시만들기위해 stop# mdadm --create /dev/md9 --level=linear --raid-devices=2 /dev/sdb1 /dev/sdc1#mdadm --detail /dev/md9 //확인해보자# mdadm --stop /dev/md0 //다시만들기위해 stop# mdadm --create /dev/md0 --level=0 --raid-devices=2 /dev/sdd1 /dev/sde1# mdadm --detail /dev/md9 //확인해보자 RAID 1, RAID 5는 새로만들면 안되고 추가해주어야 한다.1234567891011121314# mdadm /dev/md1 --add /dev/sdg1# mdadm /dev/md5 --add /dev/sdi1# vi /etc/fstab/dev/md9 /raidLinear ext4 defaults 1 2/dev/md0 /raid0 ext4 defaults 1 2/dev/md1 /raid1 ext4 defaults 1 2/dev/md5 /raid5 ext4 defaults 1 2이렇게 바꿔준다.# reboot# df //마운트 확인. 데이터를 한번 확인해보자. 123456789101112131415# ls -l /raid0drwx------ 2 root root 16384 7월 6 17:26 lost+found-rwxr-xr-x 1 root root 4902656 7월 6 17:31 testFile# ls -l /raid1drwx------ 2 root root 16384 7월 6 17:27 lost+found-rwxr-xr-x 1 root root 4902656 7월 6 17:31 testFile# ls -l /raid5drwx------ 2 root root 16384 7월 6 17:29 lost+found-rwxr-xr-x 1 root root 4902656 7월 6 17:31 testFile# ls -l /raidLineardrwx------ 2 root root 16384 7월 6 17:25 lost+found-rwxr-xr-x 1 root root 4902656 7월 6 17:31 testFile raid 1그리고 raid5 는 데이터가 있을것이라 예상했지만 raid0 그리고 raidLinear도 데이터가 존재한다. 어떻게 된 것일까? 운이 좋게 지워지지않은 영역에 존재하는 것일 것이다. 그러므로 데이터를 신뢰 할 수 없으며 이는 포멧을 해주는 것이 좋다. 12345678# umount /dev/md0 //포멧하기전에 마운트를 끊음# umount /dev/md9# mkfs.ext4 /dev/md0 //포멧# mkfs.ext4 /dev/md9# reboot //리부트를 하지않고 바로 마운트를 해줘도됨. //어차피 리부트하면 마운트되어있으니까 아무거나 선택! raid 1, raid 5 의 고장난 디스크에 대해서 따로 작업을 해 줘야할줄 알았는데 –add만 하면 되어서 생각보다 간단하다고 생각했다.","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"6장. RAID 정의 및 개념,구현","slug":"ThisIsLinux16","date":"2017-07-06T00:13:09.000Z","updated":"2017-07-06T07:00:53.610Z","comments":true,"path":"2017/07/06/ThisIsLinux16/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/06/ThisIsLinux16/","excerpt":"","text":"RAIDRedundant Array of Inexpensive Disks여러개의 디스크를 하나처럼 사용하는 RAID를 알아보자비용절감 + 신뢰성 향상 + 성능 향상1테라 디스크 3개를 하나로 묶어서 3테라 디스크처럼 쓴다 하드웨어 RAID여러개의 하드디스크를 가지고 장비를 만들어서 사용. 장비업체에서 제공하기 떄문에 사용법이 다를 수 있다. 그리고 상당히 고가이다. 하드웨어RAID가 안정성이 높다. 소프트웨어 RAID디스크를 장착만하면 운영체제 레벨에서 하나로 묶을 수 있다. Linear RAID (339p 그림보기)최소 2개이상의 디스크를 하나로 묶음앞 디스크 부터 차례로 저장100TB 100TB 100TB 를 사용하면 총 300TB가 된다. 즉 공간효율성이 100%임. RAID 0 (339p 그림보기)모든 디스크에 동시에 저장되는 개념그러므로 하드디스크가 3개면 /3 시간으로 저장됨신뢰성이 낮다.빠르지만 전부 잃어버려도 큰 문제가 되지 않는 자료가 적당하다.3TB 100TB 100TB 를 사용하면 총 9TB가 된다. 즉 디스크 크기가 다르면 공간효율성이 100%가 되지 않음.그래서 RAID를 구성할 떈 같은회사 같은 용량의 디스크로 구성한다.디스크 세개중에 하나만 고장나도 디스크를 못쓴다. RAID 1미러링이라 부름1TB 1TB 를 사용하면 1TB 사용가능결함 허용을 제공= 신뢰성 높음. 즉 둘중에 하나가 고장나도 데이터가 보존된다.공간효율이 나쁘므로 비용이 비싸다는 단점이 있다. RAID 5RAID 2,3,4의 장점을 포용하기 때문에 2,3,4를 사용할 필요가 없다.RAID1의 데이터 안정성 +RAID0의 공간 효율성을 추구 디스크 개수 -1개의 공간을 사용. 즉 4개일 경우 3개를 사용(75%) 100개일 경우 99개를 사용(99%)즉 가격이 저렴하면서 안정적인것.최소한 3개 이상의 하드디스크가 필요하며 오류가 발생했을 때는 패리티(Parity)를 이용해서 데이터를 복구결함 허용을 제공 - 즉 디스크 하나가 고장나도 사용 복구 가능하지만 디스크가 하나가 고장났을 때는 복구가 가능하지만 디스크가 2개가 고장날 경우에는 복구 불가능.그래서 100개를 사용하였을 경우에는 불안하다.(2개 이상 고장날 확률이 높아지므로)즉 적은 디스크를 활용할 경우 공간효율은 낮아지지만 신뢰도는 높아진다.일반적으로 RAID 5는 7개에서 10개정도의 디스크로 구성 RAID 6패리트를 2개 쓴다. 즉 디스크가 2개가 고장나도 복구가능. 최소 4개이상의 디스크가 필요함.(패리티를 2개 쓰므로)패리티를 2개 쓰는 알고리즘의 효율성이 떨어져서 성능이 떨어지는 단점이 있어 많이 사용하지는 않음. RAID1 + 0 = RAID + RAID0신뢰성(안정성)과 성능(속도)이 동시에 뛰어난 방법RAID1로 구성된것을 RAID 0 으로 묶음. 그림참고 실습SCSI 0:1 부터 0:10 까지 진행. SCSI 0:1 SCSI 0:2 - Linear RAID SCSI 0:3 SCSI 0:4 - RAID 0 SCSI 0:5 SCSI 0:6 - RAID 1 SCSI 0:8 SCSI 0:9 SCSI 0:10 - RAID 5 SCSI 0:1 만 2GB로 구성하고 나머지는 다 1GB로 구성 에디트 쪽에서 디스크 2기가 1개 1기가 8개 추가. 1# ls -l /dev/sd* //장착이 잘 되었나 확인 9번 반복12345678# fdisk /dev/sdb ~sdj 까지 반복n p 엔터 엔터p //로 확인해보면 시스템이 리눅스인데 RAID로 변경해야한다.t 엔터L 누르면 도움말이 나온다.fd를 입력 후 엔터p를 눌러 확인w를 눌러 저장 1# ls -l /dev/sd* //장착이 잘 되었나 확인 과정 설명1.mdadm 명령어로 논리 볼륨 생성2.mkfs.ext4 명령어로 파일시스템 생성(포멧)3.mount 적용위 3가지 과정은 6장에서 하드디스크 1개추가 과정과 같다. Linear RAID 만들기sdb1 sdc1 이용mdadm RAID를 만들고 없애는 명령어 1234567891011121314151617181920212223# fdisk -l /dev/sdb /dev/sdc // 아까 한것이 잘 적용되었나 확인# mdadm --create /dev/md9 --level=linear --raid-devices=2 /dev/sdb1 /dev/sdc1 //RAID md9를 만드는데 리니어로 디바이스는 //개수 2개로 2개는 /dev/sdb1 /dev/sdc1 로# mdadm --detail --scan //돌고있는지 확인# mdadm --detail /dev/md9 //md9에 대해 자세히 보자# mkfs.ext4 /dev/md9 //포멧하자# mkdir /raidLinear //디렉토리 생성# mount /dev/md9 /raidLinear/ //마운트# df //마운트 확인# vi /etc/fstab //재부팅하면 마운트가 풀리므로 설정/dev/md9 /raidLinear ext4 defaults 0 0 맨 아래 추가# reboot# df //마운트 확인 RAID 0 만들기sdd sde로 한다1234567891011121314151617# mdadm --create /dev/md0 --level=0 --raid-devices=2 /dev/sdd1 /dev/sde1# mdadm --detail --scan //돌고있는지 확인# mdadm --detail /dev/md0 //md9에 대해 자세히 보자# mkfs.ext4 /dev/md0 //포멧하자# mkdir /raid0 //디렉토리 생성# mount /dev/md0 /raid0/ //마운트# df //마운트 확인# vi /etc/fstab //재부팅하면 마운트가 풀리므로 설정/dev/md0 /raid0 ext4 defaults 0 0 추가 RAID 1sdf sdg 사용12345678910111213141516# mdadm --create /dev/md1 --level=1 --raid-devices=2 /dev/sdf1 /dev/sdg1y입력 // raid1은 부트 디바이스로 사용 할 수 없는데 만들겠냐는 뜻# mdadm --detail /dev/md1 //확인해보자# mkfs.ext4 /dev/md1 //포멧하자# mkdir /raid1 //디렉토리 생성# mount /dev/md1 /raid1/ //마운트# df //마운트 확인# vi /etc/fstab //재부팅하면 마운트가 풀리므로 설정/dev/md1 /raid1 ext4 defaults 0 0 추가 RAID 5sdh sdi sdj 사용1234567891011121314151617# mdadm --create /dev/md5 --level=5 --raid-devices=3 /dev/sdh1 /dev/sdi1 /dev/sdj1망가졌다는 메세지 나오는데 무시하면된다. (컴퓨터가 착각함!)# mdadm --detail /dev/md5 //확인해보자# mkfs.ext4 /dev/md5 //포멧하자# mkdir /raid5 //디렉토리 생성# mount /dev/md5 /raid5/ //마운트# df //마운트 확인# vi /etc/fstab //재부팅하면 마운트가 풀리므로 설정/dev/md5 /raid5 ext4 defaults 0 0","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"6장. IDE/SCSI 장치 구성, 하드디스크 1개 추가","slug":"ThisIsLinux15","date":"2017-07-05T07:33:36.000Z","updated":"2017-07-05T11:05:49.132Z","comments":true,"path":"2017/07/05/ThisIsLinux15/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/05/ThisIsLinux15/","excerpt":"","text":"하드디스크 관리는 관리자 입장에서 기본적인것이다.디스크가 모자르면 디스크를 추가해야한다.. 이런걸 어떻게 할지 알아보자 IDE SCSI 장치에 대해IDE는 케이블을 2개 꽂을수가 있다. 여기에 하드디스크를 장착하거나 DVD롬을 장착할 수 있다. 즉 두개의 IDE가 있으면 4개를 장착할 수 있다. 0:0 , 0:1, 1:0 , 1:1 이렇게 구분된다(4개일 경우) SCSI는 총 16개의 SCSI 하드디스크를 꽂을 수 있는 케이블이 따져있다. 0,7번은 VMware가 사용하므로 사용할 수 없다.마찬가지로 SCSI 0:0 ,0:1 로 구분된다. 326p를 통해 그림으로 확인가능 우리가 80GB 의 하드디스크를 추가했는데 이를 sda라 그런다만일 하나더 추가하면 sdb라 그런다.정식이름은 /dev/sda 이다.여기서 파티션을 나누면 sda1,sda2로 나뉜다. 즉 sda는 하드디스크 자체를 의미하며 sda1은 파티션1 sda2는 파티션2를 의미한다. 땅 자체를 사는것을 하드디스크를 추가하는것으로 보면되고 축구장으로 사용하기 위해 특정부분에 선을 긋는것을 파티션을 나눈다고 보면된다. 또한 파티션은 특정디렉터리에 마운트를 해줘야함. 하드디스크 1개 장착과정1.SCSI 0:1에 물리적인 하드디스크 하나 장착 이는 /dev/sdb이다. 2.fdisk 명령어를 통해 파티션을 나눔(실습에서는 파티션1개로)./dev/sdb1 파티션이 생긴다. 3.파티션을 사용하기 위해서는 포멧을 해줘야한다.(mkfs.ext4를 사용) 4.그러면 완전히 준비된 하드디스크가 생기는데 이를 특정 폴더에 마운트해야한다. 5.마운트는 컴퓨터를 끄면 마운트가 끊어지므로 /etc/fstab 파일을 편집해 주어야 한다. 1.SCSI 0:1에 물리적인 하드디스크 하나 장착 이는 /dev/sdb이다.에디트에서 애드를 선택하고 다음스카시를 선택하고 다음맨위를 하고 다음1기가로 선택하고 싱글파일 선택하고 다음어드밴스드를 눌러 0:1로 되어있는것을 확인 123456789# ls -l /dev/sd*brw-rw---- 1 root disk 8, 0 7월 5 18:02 /dev/sdabrw-rw---- 1 root disk 8, 1 7월 5 18:02 /dev/sda1brw-rw---- 1 root disk 8, 2 7월 5 18:02 /dev/sda2brw-rw---- 1 root disk 8, 16 7월 5 18:02 /dev/sdbsda는 초기 설정때 설정한것. 파티션을 두개로 나눠서 sda1, sda2로 나뉜다.왜 sdb1은 없지? 파티션을 나누지 않았으므로! 2.fdisk 명령어를 통해 파티션을 나눔(실습에서는 파티션1개로)./dev/sdb1 파티션이 생긴다.파티션을 나눠보자1234567891011121314151617181920# fdisk /dev/sdbn //새로운 파티션 추가p // p(primary)는 주 파티션 e(extended)는 확장파티션을 의미 //p는 4개까지 나눌 수 있음 //4개 이상하고싶으면 3개는 p로하고 하나는 e로 잡아서 //e 파티션안을 나눠서 늘리면 된다. 이는 굉장히 드문경우 //일반적으로는 p를 쓰면 충분하다.1 //sdb1로 하겠다. 엔터 // 2047까지는 시스템 부분이므로 // 어디서 부터 시작할꺼냐. 엔터하면 2048부터엔터 //끝까지 쓰겠다. p //최종확인w //적용 # ls -l /dev/sd* //생성된 것 확인brw-rw---- 1 root disk 8, 0 7월 5 18:02 /dev/sdabrw-rw---- 1 root disk 8, 1 7월 5 18:02 /dev/sda1brw-rw---- 1 root disk 8, 2 7월 5 18:02 /dev/sda2brw-rw---- 1 root disk 8, 16 7월 5 18:11 /dev/sdbbrw-rw---- 1 root disk 8, 17 7월 5 18:11 /dev/sdb1파일 시스템을 생성하자. 3.파티션을 사용하기 위해서는 포멧을 해줘야한다.(mkfs.ext4를 사용)1# mkfs.ext4 /dev/sdb1 4.그러면 완전히 준비된 하드디스크가 생기는데 이를 특정 폴더에 마운트해야한다.12345678# mkdir /mydata# mount /dev/sdb1 /mydata# df // 마운트 된것을 확인# cp /boot/vmlinuz-3.10.0-123.el7.x86_64 /mydata/data1 // 새로운 디스크에 데이터 복사# df //확인 (용량 늘어난것 확인) 5.마운트는 컴퓨터를 끄면 마운트가 끊어지므로 /etc/fstab 파일을 편집해 주어야 한다.123# vi /etc/fstab /dev/sdb1 /mydata ext4 defaults 0 0 입력 후 vi종료 //dev/sdb1을 /mydata에 마운트하는것. ext4를 이용해 1","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"5장. 리눅스에 Windows 설치 KDE데스크톱 설치","slug":"ThisIsLinux14","date":"2017-07-05T06:37:05.000Z","updated":"2017-07-05T07:35:30.122Z","comments":true,"path":"2017/07/05/ThisIsLinux14/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/05/ThisIsLinux14/","excerpt":"","text":"리눅스 안에서 윈도우를 깔아보자CentOS에서 제공하는 가상머신을 이용하자즉 가상머신에서 가상머신을 만드는…램 올리고, 가상화 켜주고 311p참고 iso 파일을 받고 내폴더에 붙여넣기 해준다. 123# mkdir /iso# mv 600* /iso //파일이름이 600으로 시작함.# ls -l /iso 실습에서는 313p 의 2-0을 생략한다.프로그램 -시스템 도구 -가상머진 관리자로컬 선택 후 새가상머신 생성 왼쪽위 그림(노란색)Win2008 입력후 로컬설치매체 선택후 앞으로iso파일 선택하고 윈도우서버 2008 선택하고 앞으로그대로 두고 앞으로설치전에 사용자 설정 선택 후 완료디스플레이를 VNC로 하고 적용왼쪽 위 설치시작 KDE 데스크톱을 설치해보자센토스는 기본적으로 그놈데스크탑이 들어있다. 윈도우와 비슷한 KDE 데스크탑을 운영할 수 있다.123456$ yum grouplist | grep KDE //KDE 패키지그룹을 조회su -c &apos;yum -y groupinstall &quot;KDE Plasma Workspaces&quot;&apos; //조회됨$ su -c &apos;yum -y groupinstall &quot;KDE Plasma Workspaces&quot;&apos; //루트권한으로 &apos;&apos;안에 있는 명령어 실행(KDE 설치)자동로그인 해제 . 321p 참고1$ reboot톱니 누르고 KDE Plasma 작업공간 선택후 암호 입력 후 로그인","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"5장. 노틸러스, FireFox업그레이드, 기타 X윈도 유틸리티","slug":"ThisIsLinux13","date":"2017-07-05T04:47:34.000Z","updated":"2017-07-05T06:36:48.389Z","comments":true,"path":"2017/07/05/ThisIsLinux13/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/05/ThisIsLinux13/","excerpt":"","text":"노틸러스윈도우 탐색기와 비슷하다.실행법 : 프로그램-보조프로그램-파일 내폴더가 홈 디렉토리이다.컴퓨터가 / 폴더이다.rpm 파일도 설치 가능복붙도 가능 컨트롤 씨브이289p 참고 파이어폭스 업그레이드설치하고압축풀고 12345678910# mv firefox /usr/local //압축푼것 위치이동# chown -R root.root /usr/local/firefox/ 루트에게 권한줌# cd /usr/local/bin# ln -s /usr/local/firefox/firefox . //링크를 걸어줌파폭을 실행하면 에러가 나는데# cd /usr/local/firefox/browser/extensions/# rm -rf *해주고 리부트 어도비리더 설치123# wget http://download.hanbit.co.kr/centos/7/AdobeReader_kor-8.1.7-1.i486.rpm# su -c &apos;yum -y localinstall Adobe*&apos;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"5장. X윈도 테마, GRUB 배경화면","slug":"ThisIsLinux12","date":"2017-07-05T02:57:03.000Z","updated":"2017-07-05T04:38:22.934Z","comments":true,"path":"2017/07/05/ThisIsLinux12/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/05/ThisIsLinux12/","excerpt":"","text":"이 챕터는 책에서 중요도가 가장 떨어진다!서버관리자가 되었을 때 리눅스를 PC로 사용하는 사람에게 도움을 주기위해 알아둘 필요는 있다. 테마 설치하기12$ rpm -qa gnome-tweak-tool //설치되어있나 확인$ gnome-tweak-tool //툴 켜서 설정변경 GRUB 이미지 설정1234567891011121314$ su -c &apos;yum -y install grub2-starfield-theme&apos; //암호입력 //su -c는 슈퍼바이저 권한으로 실행하는것$ vi /etc/default/grubGRUB_TIMEOUT=5GRUB_DISTRIBUTOR=&quot;$(sed &apos;s, release .*$,,g&apos; /etc/system-release)&quot;GRUB_DEFAULT=savedGRUB_DISABLE_SUBMENU=true#GRUB_TERMINAL_OUTPUT=&quot;console&quot; //여기 주석처리GRUB_CMDLINE_LINUX=&quot;rd.lvm.lv=centos/swap vconsole.font=latarcyrheb-sun16 rd.lvm.lv=centos/root crashkernel=auto vconsole.keymap=us rhgb quiet&quot;GRUB_DISABLE_RECOVERY=&quot;true&quot;GRUB_THEME=&quot;/boot/grub2/themes/system/theme.txt&quot; //여기추가vi 저장후 종료 이미지 파일을 centos폴더에 저장 (ball.png)1mv /home/centos/ball.png /boot/grub2/themes/system실행하여 그림 이동 12345# vi /boot/grub2/themes/system/theme.txt //:set number34행가서 이미지 파일이름 변경# grub2-mkconfig -o /boot/grub2/grub.cfg //적용","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. 응급복구, GRUB, 커널 컴파일","slug":"ThisIsLinux11","date":"2017-07-04T07:09:17.000Z","updated":"2017-07-04T10:28:12.394Z","comments":true,"path":"2017/07/04/ThisIsLinux11/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/04/ThisIsLinux11/","excerpt":"","text":"응급복구261p 참고이게 문제가 될 소지가 있지않냐?그래서 처음 켤때 선택하는거에서 암호를 걸어야 한다. GRUB 부트로더/etc/default/grub 파일과 /etc/grup.d/ 디렉터리의 파일을 수정한 후 ‘grub2-mkconfig’ 명령어를 실행해 설정함 123456789101112131415161718# vi /etc/default/grubtimeout = 30 으로 변경distributor = &quot;Hello&quot; 로 변경# grub2-mkconfig -o /boot/grub2/grub.cfg // 변경사항 반영//여기서 부터 선택하는 곳에서 e 키 못누르게 비번 설정하는것# vi /etc/grub.d/00_header맨 아래 가서 다음코드 추가cat &lt;&lt; EOFset superusers=&quot;thisuser&quot;password thisuser 4321EOF여기까지!vi 빠져나와서# grub2-mkconfig -o /boot/grub2/grub.cfg // 변경사항 반영$ reboot선택하는곳에서 e 누르면 암호 누르도록 함 커널커널 : 하드웨어를 제어하는 기능모든 하드웨어를 제어하는 코드를 다 넣으면 커널이 너무 커지고 무거워진다. 그러므로 잘 안쓰는 하드웨어 코드는 모듈에 빼내서 필요할때마다 사용즉 모듈은 필요할때 쓸 수 있도록 커널의 코드를 밖으로 빼낸것이다! 1234567891011121314151617$ uname -r //커널버전확인$ wget &quot;https://kernel.org/pub/linux/kernel/v3.x/linux-3.17.4.tar.xz&quot; //교재와 동일한 커널 설치$ mv linux-3.17.4.tar.xz /usr/src$ cd /usr/src$ tar xfJ linux-3.17.4.tar.xz //압축을 풀자$ cd linux-3.17.4/커널은 c 코드이므로 설치를 위해 컴파일러를 깔자$ yum -y install gcc gcc-c++ qt qt-devel$ make mrproper // 커널설정 초기화$ make xconfig //커널의 환경설정 설정 후$ make clean$make ; make modules_install ; make install //순서대로 진행됨.","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. 파이프/필터, 프로세스, 서비스/소켓","slug":"ThisIsLinux10","date":"2017-07-04T05:52:52.000Z","updated":"2017-07-04T06:31:35.759Z","comments":true,"path":"2017/07/04/ThisIsLinux10/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/04/ThisIsLinux10/","excerpt":"","text":"파이프두개의 프로그램을 연결해주는 통로1$ ls -l /etc | more //앞에서 뒤로 넘김 필터필요한것만 걸러주는 명령어 123456$ ps -ef //현재 작동중인 프로세스 보여줌$ ps -ef | grep bash //bash와 관련된 프로세스만 //보여줌$ rpm -qa | grep gedit //gedit 관련된것만 보여줌 리다이렉션(보내는 것)123456789$ ls -l &gt; file.txt //결과를file.txt로 만드는것 //file.txt가 존재할 경우 덮어쓰고 //존재하지 않을경우 새로 만들고 작성$ ls -l &gt;&gt; file.txt //결과를file.txt로 만드는것 //file.txt가 존재할 경우 뒤에다 이어서 작성하고 //존재하지 않을경우 새로만들고 작성$ cat sort &lt; file.txt &gt; out.txt //file.txt를 정렬해서 out.txt에 넣어라 프로세스, 데몬프로세스는 하드디스크에 저장된 실행코드가 메모리에 로딩되어 활성화 된것. 포그라운드 프로세스실행하면 화면에 나타나서 사용자와 상호작용을 하는 프로세스 백그라운드 프로세스화면에 나타나지 않고 실행되는 프로세스백신 , 서버 데몬(=서비스,=서버 프로세스)등 프로세스번호각각의 프로세스는 할당된 번호가 있다.12345$ ps -ef | grep bash //bash관련된 프로세스만 보여줌root 693 1 0 13:43 ? 00:00:00 /bin/bash /usr/sbin/ksmtuned693은 자기 프로세스 번호고 1은 부모프로세스 번호이다. 작업 번호현재 실행되고 있는 백그라운드 프로세스의 순차번호 부모프로세스 ,자식프로세스모든 프로세스는 부모프로세스를 갖는다.부모 프로세스를 kill하면 자식프로세스도 자동으로 죽음. 프로세스 관련 명령ps 프로세스 보기1$ ps -ef | grep bash //bash 관련 프로세스 보여줌 kill 프로세스 종료파이어폭스 kill하기123456$ ps -ef | grep fire //파폭 관련 프로세스 보기root 2637 1934 0 13:49 ? 00:00:04 /usr/lib64/firefox/firefox//프로세스번호가 2637이다.$ kill 2637//가끔 킬 해도 죽지 않는 경우가 있는데 그경우 -9 옵션을 준다.$ kill -9 2637 pstree 프로세스 트리로 보기1$pstree //프로세스 구조를 트리로 보여줌 실습 (포그라운드-&gt;백그라운드-&gt;포그라운드)1234567$ yes &gt; /dev/null //y를 계속생성하는 프로세스 생성ctrl+ z 입력.$ bg //백그라운드 보는것. //처음에 했던 동작이 남아있다.[1]+ yes &gt; /dev/null &amp;$ fg 1 //1번작업을 다시 포그라운드로 갖고와라 실습 (포그라운드-&gt;백그라운드-&gt;포그라운드)1234567$ gedit &amp; //지에딧을 백그라운드로 돌려라. //콘솔을 계속 사용할 수 있게된다.$ vi &amp; //백그라운드로 돌아가긴 하는데 의미없다. //vi는 포그라운드로 돌려야 하므로 $ bg //vi의 백그라운드 번호를 알고$ fg 1 //vi를 포그라운드로 갖고옴 서비스와 소켓서비스웹 서버 = 웹 서비스FTP 서버 = FTP 서비스 서비스의 실행 스크립트 파일은 /usr/lib/systemd/system/ 디렉터리에 ‘서비스이름.service’라는 이름으로 확인할 수 있다. 예를들어 웹 서비스는 httpd.service라는 이름의 파일로 존재 소켓서비스는 항상 가동되지만 소켓은 필요할 떄만 구동된다. 외부에서 특정 서비스가 요청되었을 때. 그래서 약간 느리다./usr/lib/systemd/system/ 디렉터리에 소켓이름.socket 이름으로 존재","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. 네트워크 관련 개념과 명령어,SELinux","slug":"ThisIsLinux9","date":"2017-07-04T04:29:36.000Z","updated":"2017-07-04T05:09:11.039Z","comments":true,"path":"2017/07/04/ThisIsLinux9/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/04/ThisIsLinux9/","excerpt":"","text":"TCP/IP우리가 사용하는 인터넷은 tcp/ip 기반이다. 가장널리사용되는 프로토콜의 한 종류 호스트이름 도메인이름호스트이름 : 컴퓨터에 지정된 이름도메인 이름 : hanbit.co.kr rkxdms gudtlr IP 주소랜카드에 부여되는 중복되지 않는 유일한 주소 네트워크 주소같은 네트워크에 속해있는 공통된 주소 브로드캐스트 주소제일 뒤가 255인 주소내부 네트워크의 모든 컴퓨터가 듣게 되는 주소 게이트웨이, 라우터라우터=게이트웨이네트워크 간에 데이터를 전송하는 컴퓨터 또는 장비 넷마스크, 클래스넷마스크 : 네트워크의 규모를 결정ex(255.255.255.0) DNS 서버= 네임서버URL을 IP로 변환해주는 서버 12345678910111213141516$ nmtui //네트워크와 관련된 작업진행$ rdate -s time.bora.net //시간설정$ nmtui //설정 변경후 종료 네트워크매니저텍스트ui$ systemctl restart network //네트워크 재시작 (해줘야함)$ ifconfig //네트워크장치에 할당된 ip주소 확인$ ifdown ens32 //이거는 systemctl restart network //보다 강력하게 서버를 끄는것.$ ifup ens32 //서버 재시작 $ nslookup naver.com //DNS서버의 작동을 테스트$ ping www.yahoo.com //네트워크 응답 확인$ ping -3 www.yahoo.com //세번만 피을 때려라 주요 파일네트워크 기본적인 정보가 설정되어 있는 파일/etc/sysconfig/network /etc/sysconfig/network-scripts/ifcfg-ens32ens32 장치에 설정된 네트워크 정보가 모두 들어있는 파일ens32가 아니라 eno일수도 있다.BOOTPROTO = none 고정아이피를 쓰겠다.DNS1 DNS가 여러개 나올 수 있으므로 1이 필요ONBOOT =”yes” 네트워크를 쓰겠다 /etc/resolv.confDNS 서버의 정보와 호스트 이름이 들어있다.168.126.63.1 //kt에서 제공하는 네임서버이다 //네임서버가 없을 때 사용가능 SELinux보안에 취약한 리눅스를 보호하기 위해 탄생책에서는 실습을 위해 기능을 꺼두었다./etc/sysconfig/selinux를 편집하였다.SELINUX=disabled 이렇게..","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. 파일 압축과 묶기, CRON과 AT","slug":"ThisIsLinux8","date":"2017-07-04T00:26:28.000Z","updated":"2017-07-04T01:55:03.268Z","comments":true,"path":"2017/07/04/ThisIsLinux8/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/04/ThisIsLinux8/","excerpt":"","text":"파일 압축유닉스는 압축하는 파일이 여러개이다. 그래서 확장자도 여러개이다. 점점 개선이 되면서 여러개가 생긴것이다. 예전것도 쓰고 최신것도 쓰므로 모두 사용할줄 알아야함gzip-&gt;bzip2-&gt;xz 순으로 발전해옴 xz가 압축률도 제일좋다. 12345678910111213141516171819# cp glist.txt file1.txt //파일 복사# cp glist.txt file2.txt# cp glist.txt file3.txt# xz file1.txt# bzip2 file2.txt# gzip file3.txt# ls-l file*-rw-r--r-- 1 root root 1080 7월 4 09:31 file1.txt.xz-rw-r--r-- 1 root root 1072 7월 4 09:31 file2.txt.bz2-rw-r--r-- 1 root root 1053 7월 4 09:31 file3.txt.gz# xz -d file.txt.xz //압축해제# bzip2 -d file2.txt.bz2 //압축해제# gzip -d file3.txt.gz //압축해제# gunzip file3.txt.gz //위와 같음 gz로 압축한게 제일작은데? 파일마다 다르다!! 일반적으로는 gz가 효울이 제일 떨어진다. 그래서 일반적으로 커널파일을 xz로 배포한다.리눅스에서의 압축은 파일을 압축해서 원본파일이 사라진다는것을 주의하자. 파일 묶기리눅스는 압축, 묶기가 다르다묶기는 원본파일이 유지되며 하나로 묶은것이라 보면된다.12345678910# tar cvf bin.tar bin1 bin2 bin3 //bin1,2,3이 bin.tar로 묶임# rm -f bin? //bin1,2,3 제거# tar xvf bin.tar //풀기# ls -l-rw-r--r-- 1 root root 14714880 7월 4 09:41 bin.tar-rwxr-xr-x 1 root root 4902656 7월 4 09:40 bin1-rwxr-xr-x 1 root root 4902656 7월 4 09:40 bin2-rwxr-xr-x 1 root root 4902656 7월 4 09:40 bin3묶으면서 압축을 진행해보자12345678# rm -f bin.tar# tar cvfj bin.tar.bz2 bin1 bin2 bin3 //bz2형식으로 압축하면서 묶어줌# rm -f bin.tar.bz2# tar cvfJ bin.tar.xz bin1 bin2 bin3 //xz형식으로 압축하면서 묶어줌 //J가 대문자이다.# tar xvfJ bin.tar.xz /etc/sysconfig //xz압축해제 +tar 풀기 파일 위치 검색12345678910# find /etc -name &quot;*.conf&quot; //etc밑에 확장명이 conf 인것을 찾음# find /etc -name &quot;*.conf&quot; &gt; conf.txt //위 대상으로 conf.txt로 저장# find /home -user centos //centos 사용자의 파일들 검색# find /usr/bin -size +95k -size -100k //사이즈가 95kb 이상 //100kb 이하인것 검색# find /usr/bin -size +95k -size -100k -exec ls -l &#123;&#125; \\; // 윗줄의 결과가 중괄호 속에 들어가서 // ls -l 명령어 실행 시스템 설정123456# yum -y install system-config-date# system-config-date //날짜 설정 가능# nmtui //네트워크 설정# firewall-config CRON과 ATCRON : 주기적으로 반복되는 일을 자동적으로 실행될 수 있도록 실행 42 4 1 ** root run-parts /etc/cron.hourly42 : 42분4 : 4시1 : 1일* : 매 월* : 매 요일 01 * * * * root run-parts /etc/cron.daily맨 뒤는 요일이므로 제외하고매월매일매시1분마다. 02 4 * * * root run-parts /etc/cron.weekly매일 4시 2분마다 실행하라 03 4 * * 0 root run-parts /etc/cron.monthly일요일 4시 3분마다 실행해라 AT : 한번 실행되는것# at 3:00am tomorrow -&gt;내일 새벽 3시# at 11:00pm January 30 -&gt;1월 30일 오후 11시# at now + 1 hours -&gt;한시간 후그 후 예약 명령어 입력후 엔터완료되면 ctrl + d 쉘 스크립트 : 윈도우의 배치파일처럼 실행할 명령어가 쭉 나열되어있는것 CRON 실습123456789101112131415161718192021222324252627282930313233343536# systemctl status crond //크론이 돌고있는지 확인# vi /etc/crontab01 3 15 * * root run-parts /etc/cron.monthly //한줄 추가 매달 매 요일 15일마다 3시 1분에# cd /etc/cron.monthly/# vi myBackup.sh다음을 입력#!/bin/sh // 써줘야함set $(date) //날짜를 읽어옴fname=&quot;backup-$2$3.tar.xz&quot; //$2는 월 $3은 일tar cfJ /backup/$fname /home // /home폴더를 묶음vi 종료# chmod ugo+x myBackup.sh //쉘스크립트 파일 실행권한부여# mkdir /backup //백업파일 보관할 장소 생성# systemctl restart crond //예약하는 작업이 재시작된다.# date 011503002019 //테스트를 위해 시간을 변경 //월일시분년2019. 01. 15. (화) 03:00:00 KST 로 변경됨# systemctl restart crond // 시간적용을 위해 재시작1분이 지나고# ls-l /backup/ AT 실습12345678910111213# rdate -s time.bora.net //서버에 가서 정확한 시간을 세팅함# at 4:00 am tomorrow //내일 새벽 4시에 할 명령어 입력at&gt; yum -y updateat&gt; reboot입력 후 ctrl + d# at -l 예약된것 확인1 Wed Jul 5 04:00:00 2017 a root# atrm 1 //1번 목록 제거 1","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. RPM 사용법, YUM 사용법","slug":"ThisIsLinux7","date":"2017-07-03T09:58:51.000Z","updated":"2017-07-04T01:56:17.645Z","comments":true,"path":"2017/07/03/ThisIsLinux7/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/03/ThisIsLinux7/","excerpt":"","text":"RPM초창기 리눅스는 설치가 어려웠다 .소스코드를 갖고와서 적재적소에 컴파일을 해야했다. 그래서 일반사용자가 사용하기엔 거의 불가능했다. 이러한 이유로 외면을 받았었다. 결국 Redhat에서 RPM(Redhat Package Manager)을 내놓았다. 윈도우의 setup.exe 라고 생각하면 된다. gedit-3.8.3-6.el7.x86_64.rpm 패키지이름 : gedit -&gt; 패키지(프로그램)의 이름버전 : 3.8.3 -&gt; 대게 3자리수로 구성. 주버전, 부버전, 패치버전릴리즈번호 : 6 -&gt; 문제점을 개선할 때마다 붙여지는 번호 //noarch:모든CPUCentOS버전 : el7 -&gt; CentOS에서 배포할 경우에 붙여짐아키텍처 : x86_64 -&gt; 64비트 CPU를 의미 자주쓰는 RPM 명령어 옵션123456789101112131415$ rpm -Uvh 패키지파일이름.rpm // U -&gt; (대문자)패키지가 설치/업그레이드 // v -&gt; 설치진행과정의 확인 // h -&gt; 설치진행과정을 &quot;#&quot;마크로 화면에 출력$ rpm -e 패키지이름 //패키지 삭제$ rpm -qa 패키지이름 //패키지가 설치되었는지 확인$ rpm -qf 파일의 절대경로 // 파일이 어느 패키지에 포함된 것인지 확인$ rpm -qlp 패키지파일이름.rpm //패키지 파일에 어떤 파일들이 포함되었는지 확인$ rpm -qip 패키지파일이름.rpm //패키지 파일의 상세정보 실습12345678910111213$ rpm -qa mc //mc 패키지가 설치되었나 확인$ rpm -Uvh mc-4.8.7-8.el7.x86_64.rpm //설치$ rpm -qa mc //mc 패키지가 설치되었나 확인$ rpm -qi mc //mc 패키지 정보 출력$ rpm -e mc-4.8.7-8.el7.x86_64.rpm //삭제오류: mc-4.8.7-8.el7.x86_64.rpm 패키지가 설치되어 있지 않습니다//설치파일을 삭제하는것이다.!!!!$ rpm -e mc //패키지 이름만으로 삭제 YUM의 등장Yellowdog Updater Modified rpm의 경우 의존성 문제가 존재함. 이를 해결하기 위해 나온것이 YUM의존성 문제란? A를 설치하기 위해 B가 먼저 설치되어있어야 하는것.rpm은 B가 설치되어있지 않을 경우 A패키지 설치를 시도할 경우 B를 설치해야 한다고 알려주기는 하나 대략적으로 알려주고, B또한 다른 패키지에 의존성이 있을수도 있어 불편함을 유발한다. yum은 인터넷이 정상적으로 동작해야 작동함. yum은 의존성이 있는것을 모두 알아서 설치해준다!!! 즉 yum 명령어는 내부적으로 rpm명령을 실행하는것!! yum의 동작과정1.yum install을 입력한다2./etc/yum.repos.d/ 를 참고하여 URL을 확인하고3.전체 패키지 목록 파일을 요청한다(CentOS 7 패키지 저장소로)4.전체 패키지 목록 파일만 다운로드5.설치할 패키지와 관련된 패키지의 이름을 화면에 출력6.y를 입력하면 설치에 필요한 패키지 파일을 요청함7.설치할 패키지 파일을 다운로드해서 자동 설치12345678910111213141516$ yum install 패키지이름 //패키지 설치$ yum -y install 패키지이름 //패키지 설치(y안눌러도 됨)$ yum remove 패키지이름 //패키지 제거$ yum localinstall rpm파일이름.rpm //로컬에 존재하는 rpm으로 설치 // 만약 의존성이 있을경우 그 대상은 레파지토리에서 깐다.$ yum info mc //mc패키지에 관한 정보확인 $ yum groupinstall &quot;패키지 그룹이름&quot; //예로 자바를 깐다면 jdk //이클립스 등 한꺼번에 설치됭$ yum clean all //캐시를 지우는것. //yum이 이상할때 써보자 yum고급실습네트워크를 거치지 않고 마운트 시킨 dvd에서 받는다. 교재 221참고dvd에 없으면 네트워크에서 갖고온다. yum grouplist123456789101112$ yum grouplist //그룹리스트 조회$ yum grouplist hidden //숨겨진것까지 조회//영어로 그룹을 설치하는것이 좋다.. 그러므로$ chvt 2 //2번 가상터미널로 이동$ root password$ yum grouplist hidden &gt; glist.txt //glist.txt로 생성$ chvt 1 //x 윈도모드로 이동 226p 비타민퀴즈223p를 따라 설정 후 yum groupinstall “GNOME Desktop” 입력","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. 파일의 소유권/허가권, 링크","slug":"ThisIsLinux6","date":"2017-07-03T04:33:03.000Z","updated":"2017-07-03T05:45:36.399Z","comments":true,"path":"2017/07/03/ThisIsLinux6/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/03/ThisIsLinux6/","excerpt":"","text":"123# touch sample.txt //빈 파일생성# ls -l-rw-r--r-- 1 root root 0 7월 3 13:35 sample.txt 1.맨앞의 -는 파일의 유형을 의미. -: 일반파일 d: 디렉토리 l: 링크파일 2.rw-r–r–는 세개씩 끊어 읽으면 된다.2-1. 맨앞 세개는 소유자의 파일접근권한 (rw-)즉 소유자는 읽기, 쓰기 가능, 실행 불가 2-2. 두번째는 그룹의 파일접근권한읽기만 가능 2-3. 세번째는 그 외의 사용자의 파일접근권한이다.읽기만 가능또한 rw-r–r–는 3자리씩 끊어서 보면 644로 볼수 있다.rwxrwxrwx는? 666 3.1은 링크의 수 4.root는 파일 소유자 이름 5.root는 파일 소유 그룹이름 6.0은 파일의 크기 7.7월 3 13:35는 마지막 변경 날짜/시간 8.sample.txt는 파일이름 chmod 파일 허가권 변경1234567891011121314151617181920212223242526# chmod 655 sample.txt# ls -l sample.txt-rw-r-xr-x 1 root root 0 7월 3 13:35 sample.txt$ chmod o-x test //일반사용자(o : ordinary)는 -x (x:execute) 실행 못하도록$ ls -l test-rwxrwxrw- 1 centos centos 52 7월 3 13:52 test //마지막 x가 빠짐$ chmod ug-w test //소유주(u: user), 소유그룹(g: group) 쓰기권한 제거$ ls -l test-r-xr-xrw- 1 centos centos 52 7월 3 13:52 test //3번째 6번째 w가 빠짐$ chmod ugo-r test //전부다 읽기권한 제거$ ls -l test ---x--x-w- 1 centos centos 52 7월 3 13:52 test //r이 제거된것 확인$ chmod uo+rw test //소유주, 기타사용자에게 읽기,쓰기 허용$ ls -l test -rwx--xrw- 1 centos centos 52 7월 3 13:52 test//숫자를 넣지 않고 하는것을 심볼릭방법이라 하는데 이것이 더 편할 때가 있다.숫자로 할 경우 기존의 권한도 알아야 하기 때문에.. chown 파일 소유자 변경123# chown centos sample.txt //centos로 소유권을 넘김# ls -l sample.txt-rw-r-xr-x 1 centos root 0 7월 3 13:35 sample.txt //소유권 변경됨 chgrp 파일 소유 그룹 변경123# chgrp centos sample.txt# ls -l sample.txt-rw-r-xr-x 1 centos centos 0 7월 3 13:35 sample.txt chown 파일 소유자, 그룹 변경123# chown root.root sample.txt# ls -l sample.txt-rw-r-xr-x 1 root root 0 7월 3 13:35 sample.txt ./에 대한 이해파일을 실행하기 위해서는 아래의 명령어를 입력해야한다.1# ./파일명./는 왜 붙는것일까?그냥 파일명만 입력하면 찾지못하는데 그 이유는 현재 디렉토리가 경로에 없어서 그렇다.그래서 ./을 넣어주는 것이다. 앞에서 배웠듯이 . 은 현재 디렉토리를 의미하는것을 떠올려보자.즉 ./파일명 는 현재 디렉터리 아래에 있는 파일명을 실행하라는 것이다. su 해당사용자로 로그인1234# su - centos //centos계정으로 로그인 //루트계정일 경우 암호를 묻지않는다. //-를 붙이면 디렉토리가 centos디렉토리로 변경되가 //붙이지 않으면 변경되지 않는다. 실습해보자.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# touch test //test 파일 생성# vi test //이후 명령어(ex ls) 입력 그후 저장후 종료# ./test //test 파일 실행실행되지 않음. # chmod 755 test //실행권한을 모두 준다.# ./test //실행된다.현재 파일의 소유권은 root이다.# chown centos.centos test //소유자,그룹을 변경# su - centos //센토스 사용자로 접근 //이때 암호는 물어보지 않음. 루트에서 이동하는것이므로$ ls -l /root/test //허가 거부가 된다. //왜냐하면 /root 디렉토리가 일반사용자는 들어올수 없게 되어있음. //그러므로 파일을 이동시키거나, /root 디렉토리에 다른사용자가 들어 //올수 있게 허가해주어야 한다. 후자는 좋지 않은 방법이므로 전자를 //활용하자# exit //centos계정 로그아웃# mv test ~centos //centos 홈폴더로 test파일이동.# su - centos //다시 centos로 로그인$ chmod 777 test$ chown root.root test //소유권을 다시 root로 변경 //불가능하다. 어딜감히 root로 변경해 //악성코드를 심고 할 수도 있고..위험함.. //그래서 이 명령어는 루트사용자만 가능!!!$ chmod o-x test //일반사용자(o : ordinary)는 -x (x:execute) 실행 못하도록$ ls -l-rwxrwxrw- 1 centos centos 52 7월 3 13:52 test //마지막에 -가 들어간것을 확인$ chmod ug-w test //소유주(u: user), 소유그룹(g: group) 쓰기권한 제거$ ls -l test-r-xr-xrw- 1 centos centos 52 7월 3 13:52 test //3번째 6번째 w가 빠짐$ chmod ugo-r test //전부다 읽기권한 제거$ ls -l test ---x--x-w- 1 centos centos 52 7월 3 13:52 test //r이 제거된것 확인$ chmod uo+rw test //소유주, 기타사용자에게 읽기,쓰기 허용$ ls -l test -rwx--xrw- 1 centos centos 52 7월 3 13:52 test//숫자를 넣지 않고 하는것을 심볼릭방법이라 하는데 이것이 더 편할 때가 있다.숫자로 할 경우 기존의 권한도 알아야 하기 때문에.. 링크파일의 링크는 하드링크, 심볼릭 링크가 있다.윈도우의 바로가기처럼 연결되어있는것은 심볼릭링크 소프트 링크라 한다. 원본파일이 inode블록(실제 파일정보를 갖고있는것)을 가르키고 inode블록은 원본파일 데이터를 가르킨다. 하드링크파일은 inode를 직접 가르키며심볼링크파일은 새로운 inode를 만들고 새로운 inode는 원본파일 포인터를 하나 더만들고 그것을 가르킨다. 원본파일 포인터는 원본파일을 가르킨다. 교재 201p를 참고하자. 주로 하드링크보다는 심볼릭 링크를 생성한다. 실습해보기1234567891011121314151617181920212223242526272829# mkdir linktest# cd linktest/# vi basefile //아무거나 입력후 저장후 종료//원본파일이 생겼으므로 inode 블록이 생성되었을것이다.# ls -il basefile //inode 번호 확인405679049 -rw-r--r-- 1 root root 34 7월 3 14:36 basefile //405679049이 inode 번호# ln basefile hardlink //하드링크 생성# ln -s basefile softlink //소프트링크생성# ls -il405679049 -rw-r--r-- 2 root root 34 7월 3 14:36 basefile405679049 -rw-r--r-- 2 root root 34 7월 3 14:36 hardlink405679048 lrwxrwxrwx 1 root root 8 7월 3 14:40 softlink -&gt; basefile//basefile inode와 hardlink inode가 같다. softlink의 inode는 새로 만들어서 basefile을 가르킨다.# mv basefile ../ //원본파일을 앞 디렉토리로 이동시킴# ls -il# cat hardlink // 출력이 될까 안될까? //출력이 된다. 그 이유는 원본 inode를 가르키기 때문에!# cat softlink // 출력이 될까 안될까.? //안된다. 원본파일이 없어졌기 때문에.# mv ../basefile //다시 원상복구 시킴 (앞디렉토리로간 basefile 델꼬옴) 12","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. 사용자 및 그룹 관리","slug":"ThisIsLinux5","date":"2017-07-03T02:29:09.000Z","updated":"2017-07-03T04:32:32.265Z","comments":true,"path":"2017/07/03/ThisIsLinux5/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/03/ThisIsLinux5/","excerpt":"","text":"리눅스는 다중 사용자 시스템이다. 즉 서버 한대에 여러명이 접속한다. 그러므로 사용자를 관리하고 그룹을 관리하는게 중요한 이슈이다.기본적으로 rootㄹ는 슈퍼유저가 관리하며 모든 사용자는 하나 이상의 그룹에 소속되어야 한다.사용자는 /etc/passwd에 정의되어 있다.아래의 명령문을 실행시켜 vi 에디터로 확인해보자.1# vi /etc/passwd마지막 줄엔 다음과같은 코드가 존재한다.1centos:x:1000:1000:centos:/home/centos:/bin/bash이에 대해 자세히 알아보자. 1.centos = 사용자가 centos 이다. 2.x = 비밀번호 3.1000 = centos라는 사용자의 ID 4.1000 = centos사용자는 반드시 소속된 그룹이 있어야하는데 이는 소속된 그룹의 ID 즉 그룹번호이다.어떻게 그룹번호를 갖고 그룹명을 알까? /etc/group 파일에 정의되어 있다. 이 파일을 vi 에디터로 열면 그룹이름:그룹비밀번호:그룹의ID(그룹번호)의 형식을 갖는다.centos:x:1000:centos // 그룹이름:그룹비밀번호:그룹의ID(그룹번호)이게 무슨뜻일까? centos라는 사용자가 centos그룹에 속해 있다는 것이다. 마지막 centos 는 생략이 가능하며 신경쓰지 않아도 된다.예를 들면 홍길동이라는 부서에 홍길동 사원이 존재하는것이다. 회사에서는 부서를 만들고 사원을 뽑는다. 마찬가지로 centos도 새로운 사용자를 만들면 사용자 이름과 같은 그룹을 만들고 이 그룹에 해당시킨다.이것과 관련해 실습을 진행해보자.12345678# useradd myuser //유저 등록# tail -5 /etc/passwd //해당파일의 마지막 5줄만 보기myuser:x:1001:1001::/home/myuser:/bin/bash //그룹번호 1001을 기억# tail -5 /etc/group //해당파일의 마지막 5줄만 보기myuser:x:1001: //사용자 이름과 같은 그룹이 만들어졌고 그 그룹에 사용자가 속해있다. 5.centos = 전체이름이다. 생략이 가능하다 6./home/centos centos = 사용자의 홈 디렉토리 7./bin/bash = 사용할 기본 쉘 실습해보자디렉토리 설명/etc/passwd : 사용자 정보가 있음/etc/shadow : 사용자 비밀번호가 있음(비밀번호는 암호화되어서 저장됨)/etc/group : 그룹정보가 있음 실습 1유저 생성, 유저 그룹지정, 그룹생성1234567891011121314151617181920212223242526272829303132333435363738# useradd user1 //user1생성# tail -5 /etc/passwd //생성되었는지 확인user1:x:1001:1001::/home/user1:/bin/bash //잘생성됨# tail -5 /etc/shadow //사용자의 비밀번호를 확인해보자user1:!!:17350:0:99999:7::: //비밀번호를 설정하지 않았지만 암호화 되어있다.# tail -5 /etc/group //사용자의 그룹이 생성되었나 확인해보자user1:x:1001: //잘 생성되었다하지만 바람직하지 않다.! user1의 그룹이 user1이라니 말이되나!다시실습해보자 이번에는 그룹을 먼저 생성하고 사용자를 소속시키자# userdel -r user1 //보통 현업에선 -r옵션을 넣어 디렉토리까진 지우지 않는다. //하지만 실습이므로 과감하게 지운다.# groupadd centosGroup //그룹생성# tail -5 /etc/group //잘생성되었나 확인centosGroup:x:1001: //잘생성됨# useradd -g centosGroup user1 //centosGroup에 소속된 user1생성# useradd -g centosGroup user2 //centosGroup에 소속된 user2생성# tail -5 /etc/passwd //잘 생성되었나 확인.user1:x:1001:1001::/home/user1:/bin/bashuser2:x:1002:1001::/home/user2:/bin/bash //잘 생성되었고 사용자 ID는 다르지만 같은 그룹ID를 갖는다.# passwd user1 //암호지정. 이후 1234 1234입력 //일반사용자는 암호를 8자 미만으로 지정못하지만 //루트사용자는 8자 미만으로 지정해줄수 있다.# passwd user2 //암호지정. 이후 1234 1234입력# tail -5 /etc/shadow //user1,user2의 암호를 보자 //user1,user2의 암호를 1234로 지정하였지만 //암호화된 값이 다르다!! 실습 2x윈도에서 사용자권한관리 - x윈도가 없으면 안되므로 비추12# yum -y install system-config-users //system-config-users패키지 설치# system-config-users //x윈도우 상에서 사용자 관리가 가능하다! 관련 명령어189p 참고1234567891011121314151617181920212223242526-u : ID 지정-g : 그룹지정-d : 홈디렉터리지정-s : 쉘 지정# useradd shkim //새로운 사용자를 추가# passwd shkim //사용자의 비밀번호를 지정하거나 변경# usermod -g root shkim //사용자의 속성을 변경# userdel shkim //사용자는 지우나 디렉토리를 제거하지 않음. //-r 옵션이 존재. 이는 사용자가 사용하던 디렉토리까지 제거# change -m 2 shkim //사용자의 암호를 주기적으로 변경하도록 설정 //-m 2는 최소 이틀이상 써야한다.(189p 참고)# groups // 사용자가 속한 그룹을 보여줌# groupadd newgroup //새로운 그룹을 새성 # groupmod -n newgroup mygroup//그룹의 속성을 변경 newgroup을 mygroup로 변경# groupdel newgroup //그룹을 삭제# gpasswd newgroup //그룹의 암호설정","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. 리눅스 기본 명령어","slug":"ThisIsLinux4","date":"2017-07-02T06:25:50.000Z","updated":"2017-07-02T08:19:39.298Z","comments":true,"path":"2017/07/02/ThisIsLinux4/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/02/ThisIsLinux4/","excerpt":"","text":"기본명령어당연히 알고있어야 하는것들이다! 자연스럽게 사용할줄 알아야함! 폴더 == 디렉토리리눅스는 숨김파일일 경우 파일명 앞에 . 이 붙는다. (폴더도 마찬가지) $ ls -l 명령어를 실행하였을 때-로 시작하면 파일 d로 시작하면 디렉토리 ls 파일 목록보기123456789101112131415$ ls // 파일이나 폴더의 목록을 보는것 윈도우의 dir.$ ls /etc/sysconfig //특정 폴더내의 목록을 보는것$ ls -a //숨김파일까지 보는것.$ ls -l // 자세히 보는것 //-로 시작하면 파일 d로 시작하면 디렉토리$ ls *.cfg //확장자가 cfg인것$ ls ls my* // my로 시작하는것들 조회$ ls -al //숨김파일까지 자세히 조회 // -a, -l 의 결합 cd 디렉토리 이동x윈도가 있으면 편하겠지만 없으면 이동이 명령어로만 가능하기 때문에 익숙해지자. cd 명령어를 쓴 후에는 pwd 를 통해 현재 디렉토리를 보자. 리눅스의 디렉터리 구조를 이해 할 수 있게된다. 1234567891011121314151617181920212223$ cd /etc/sysconfig/$ pwd //현재 디렉터리 위치 출력$ cd / // 최상위폴더로 이동(루트 디렉토리라함) // $ cd / 명령어의 경우 다음 명령창이 아래와 같이 나온다. // [root@localhost /]#$ cd // &quot;/루트 디렉토리&quot;(현재 사용자의 홈폴더)로 이동 // $ cd 명령어의 경우 다음 명령창이 아래와 같이 나온다. // [root@localhost ~]$ cd /etc //루트 디렉토리의 etc로 이동(절대경로)$ cd etc //현재 디렉토리에서 etc로 이동 (상대경로)$ cd .. //현재 디렉토리의 바로 앞 디렉토리로 이동$ cd . //현재 디렉토리 반환$ cd ~centos //해당 사용자의 홈 디렉토리로 이동 //즉 $ cd~사용자 == $ cd 여기서 주의할점!우리가 서버에서 사용하는 계정은 root이라는 점을 잊지말자.$ cd / 명령어를 실행하면 루트 디렉토리 즉 최상위 폴더로 이동하는데 여기서 ls를 입력하면 root 폴더가 하나 있다. 이 두가지를 혼동하는 경우가 많은데 주의 하도록 하자. 루트 디렉토리 그리고 루트 디렉토리에 존재하는 root 폴더는 다르며 루트 디렉토리안의 root 폴더는 root계정이기 때문에 존재하는것이다. 강의에서는 루트 디렉토리 그리고 /root 디렉토리 로 구분한다. ..에 대한 이해다음을 이해해보자1234[root@localhost /]# cd /etc/sysconfig/network-scripts/[root@localhost network-scripts]# cd ../../../root[root@localhost ~]# pwd/root .에 대한 이해다음을 이해해보자이거를 어디다 쓸까 싶지만 현재 디렉토리의 어떤것을 실행하거나 어떤 것을 현재 디렉토리로 옮길 때 사용된다.123[root@localhost ~]# cd .[root@localhost ~]# pwd/root touch 비어있는 파일 생성1$ touch //비어있는 파일 생성 rm 파일 삭제123$ rm file1 // 삭제명령어 (삭제할것인지 재확인함)$ rm -f file1 // 삭제 명령어(삭제할것인지 확인하지 않고 삭제) cp 복사123$ cp file3 file4 //file3가 file4로 복사됨$ cp -r /etc/sysconfig . // /etc/sysconfig폴더를 현재 폴더에 복사한다. -r은 디렉토리 복사일 때 필요함 mv 이동 및 파일명 변경123$ mv myfile3.txt /root/sysconfig //myfile3.txt파일을 /root/sysconfig 로 이동$ mv file file3 //파일이름을 file에서 file3로 변경 mkdir 디렉토리 생성1234$ mkdir folder1 //folder1 디렉토리 생성$ mkdir -p dir1/dir2/dir3 // dir1/dir2/dir3 디렉토리를 생성 // 디렉토리가 3개가 만들어지는것이 아니라 dir1 안에 dir2 안에 dir3가 만들어진다. rmdir 디렉토리 제거1234567$ rmdir folder1 //디렉토리 제거 (폴더가 비어있을 경우 가능)$ rmdir -r folder1 //내부에 파일이 있는 디렉토리 제거 //(안에 들어있는 파일 하나하나 지울것인지 다물어본다.)$ rm -rf dir1 //묻지도 따지지도 않고 dir1 디렉토리 제거 //매우 위험하다!! 주의해서 사용 cat 파일 읽기사실 vi를 써도 되지만 그게 귀찮을 떄 사용1$ cat anaconda.ks.cfg head 파일 읽기맨 위의 10줄만 보기1$ head anaconda-ks.cfg tail 파일 읽기맨 밑의 10줄만 보기1$ tail anaconda-ks.cfg more,less 페이지 단위로 읽기페이지 단위로 끊어 읽기 스페이스는 다음페이지 B는 이전페이지 종료하려면 Q123$ more anaconda-ks.cfg$ less anaconda-ks.cfg //less more보다 몇가지 명령어가 더 존재함 file 파일이 어떤 파일인지 확인1$ file file1 //디렉터리인지, 링크인지, 비었는지 등을 알려준다. $ file /dev/cdrom 은 링크이다. 내 환경에서는 sr0을 가르키지만 다를 수 있다는 점을 알고있자. clear1$ clear //화면을 깨끗하게 해준다.","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. vi에디터, CD/DVD마운트","slug":"ThisIsLinux3","date":"2017-07-02T04:13:19.000Z","updated":"2017-07-02T06:19:38.179Z","comments":true,"path":"2017/07/02/ThisIsLinux3/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/02/ThisIsLinux3/","excerpt":"","text":"에디터gedit / vi 로 나뉜다. gedit는 윈도우의 메모장으로 생각하면 되며 단순하다. vi는 리눅스에서 자주 사용되므로 반드시 익혀야 한다. gedit1234$ gedit //gedit 실행 //윈도우 + 스페이스 : 한영전환$ gedit 파일명 // 파일열기 vi 에디터x윈도우가 설치되지 않은곳에서도 사용 가능하기에 공통적으로 사용가능하다!초기 실행시 vi에디터는 명령모드이다. 즉 입력이 불가능한 상태이다. 새파일 작성시 , 수정시 12345678$ vi 파일명 //vi 에디터가 실행된다.i 또는 a 입력 //이후 편집, 입력작업진행esc //작업이 끝난 후 명령모드로 변경:wq //저장하고 종료한다.:q! //수정사항 무시하고 종료.코드의 행 번호를 확인하고 싶을경우1$ :set number swp 파일?중간에 작업을 하다 터미널이 비정상적으로 종료될 경우 swp파일이 생성된다. vi를 실행하면 에러가 뜨는데 엔터를 누르면 작업이 가능하다. 이 파일을 확인하기 위해서는 다음명령어를 입력한다.1$ ls -a //숨김파일까지 조회 그 후 파일을 swp 파일을 지우려면 다음을 입력한다.1$ rm .myfile3.txt.swp 도움말기능도움말 사용방법1$ mas ls //ls에 대한 도움말을 확인 . 스페이스바로 페이지 이동가능 마운트물리적인 장치와 디렉터리를 연결시켜주는 과정무슨소리지? 윈도우는 CD를 넣으면 D 드라이드 등으로 연결시켜 주지만 리눅스는 이과정이 없어서 특정 디렉토리로 연결시켜 주는것이다. X윈도우에서 가능하며, 텍스트 모드에서 가능하다1.우선 vmware상으로 cd를 삽입해야 하므로 그 과정을 거친다. 좌측상단 Player을 누르고 Removable Decices -&gt; CD/DVD -&gt; Setting 을 들어간다.혹은 우측상단 CD 모양 누르고 Setting 2.CD/DVD 탭으로 가서 Connected 키고 Use ISO…. 에 iso 이미지 선택 3.자동으로 인식이 되는데???? 리눅스는 자동으로 안된다며…하지만 이게 되는 리눅스가 있고 안되는게 있다. 또한 텍스트 모드는 자동으로 인식이 되지 않으므로 수동으로 연습하는 것이 필요! 마운트 사용법사전지식 :dvd장치의 경로 : /dev/cdrom보통 /media/cdrom 디렉토리를 마운트 할 떄 많이씀 12345678910111213141516171819$ umount /dev/cdrom //마운트 된것을 끊는것. 연결이 되지 않았을 경우 오류메시지가 나온다. 하지만 상관없다.$ ls /media //마운트 대상 디렉터리를 생성하기 전에 존재유무 확인$ mkdir /media/cdrom //마운트 대상 디렉토리 생성$ mount /dev/cdrom /media/cdrom //마운트!$ cd /media/cdrom //디렉토리 이동$ ls //마운트가 잘 되었는지 확인$ umount /dev/cdrom //마운트 끊기 하지만 에러가 난다. 현재 cdrom 안에 존재하기 때문에.$ cd // 홈디렉토리로 이동$ umount /dev/cdrom //마운트 끊기 재시도$ ls /media/cdrom //정상적으로 끊어진것을 확인 ISO 파일 제작p180 보고 진행하세요~ 앞으로 사용할 일은 없지만 가볍게 실습해보세요ISO 파일을 생성하는 명령어는 genisoimage 이다. 또 iso 파일을 CD로 굽기 위한 명령어는 cdrecord이며 DVD로 굽는 명령어는 growisofs 이다. 먼저 아래의 명령어로 패키지가 설치되어있는지 확인해보자.1$ rpm -qa 패키지이름설치되어있지 않다면1$ yum -y install 패키지명 으로 설치를 한다. 그 후 아래와 같이 입력하자. /boot디렉토리의 모든 파일을 test1.iso파일로 만드는 것이다.-r -J 는 8글자 이상의 파일 이름 및 대소문자를 구분해서 인식하는 옵션이며 -o는 출력할 파일을 위한 옵션이다.1$ genisoimage -r -J -o test1.iso /boot 테스트 해보기 위해 디렉토리를 만들고 마운트 시킨다.1234$ mkdir /media/iso$ mount -o loop test1.iso /media/iso$ ls -l /media/iso$ ls -l /boot 테스트를 했으면 마운트를 취소시켜준다1$ umount /media/iso","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. 시작과종료, 가상콘솔, 런레벨, 자동완성","slug":"ThisIsLinux2","date":"2017-07-01T13:53:50.000Z","updated":"2017-07-02T04:12:47.584Z","comments":true,"path":"2017/07/01/ThisIsLinux2/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/01/ThisIsLinux2/","excerpt":"","text":"참고사항lrwxrwxrwx. 어쩌구가 있을경우 맨앞의 l은 링크파일임을 의미한다. 윈도우의 바로가기를 생각하자! 종료관련 명령어리눅스는 기본개념이 멀티유저 이므로 함부러 누군가 종료하거나 재시작하면 문제의 소지가 있다. ex) 네이버 서버를 누군가 종료시킨다면? 리눅스를 서버로 사용할 경우 리눅스는 종료가 아닌 로그아웃이 일반적인 개념이다! 12345678910111213141516171819202122$ shutdown -P now // 종료$ shutdown -P +10 //10분후에 종료$ shutdown -c //종료예약한것 취소$ shutdown -r 23:00 //23시에 재부팅$ shutdown -r +10 //10분후에 재부팅$ shutdown -c // 리부팅예약한것 취소$ shutdown -k +15 //20분 후에 종료된다는 메세지가 날라감 //루트를 제외한 모든 사용자에게.. //실제 종료는 안됨. //필요한 이유: 서버에 많은 사용자가 접속하였을 경우 사용자들의 로그아웃을 유도.$ init 0~6 // 0-종료모드 2-멀티유저모드 5-그래픽모드의 다중사용자모드 6-리부트모드$ startx //x윈도우 모드로 변경 주의) 예로 단순히 init4에서 init1로가는것과 다르다. //명령어 모드에서 x윈도우 모드로 변경되는것 가상콘솔 명령어CentOS는 6개의 가상콘솔을 제공하는데 ctrl+alt+F2~F6으로 이동이 가능하다. F1은 X윈도우 모드이다. 1$ chvt 1~6 입력 //가상콘솔 이동 자동완성일부만 입력하고 탭을 누르면 자동완성된다.12345678910$ /abcdef를 입력하고자 할 경우$ /abc만 입력하고 탭키를 누르면$ /abcdef 가 입력된다.먄약 abcde, abcdef 라는 디렉토리가 존재할 경우에는$ /abc입력 후 탭키를 누르면 자동완성이 되지않는다. 이 경우 탭키를 두번누르면 abcde, abcdef 라는 디렉토리가 있다는 사실을 알려준다. 히스토리123$ history //자신이 입력했던 명령어들이 출력된다.$ history //히스토리 리스트를 제거한다.","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"리눅스 명령어","slug":"Instruction","date":"2017-07-01T04:57:06.000Z","updated":"2017-07-03T23:54:23.515Z","comments":true,"path":"2017/07/01/Instruction/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/01/Instruction/","excerpt":"","text":"참고사항 $: 일반사용자 #: 루트사용자 명령어123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224$ halt -p // 종료$ gedit 파일명 //편집기 열기$ ifconfig //윈도우 ipconfig와 동일$ reboot //리부트 명령어$ su - //루트사용자의 권한을 얻음(폴더가 이동됨)$ su //루트사용자의 권한을 얻음(폴더 이동되지 않고)$ setfont sun12x22 //글자크기 변경$ vi 파일명 //vi 에디터 열기$ ip addr //ip 확인$ clear //콘솔창 초기화$ yum 프로그램 //프로그램 설치$ cd //홈디렉터리로 이동$ shutdown -P now // 종료$ shutdown -P +10 //10분후에 종료$ shutdown -c //종료예약한것 취소$ shutdown -r 23:00 //23시에 재부팅$ shutdown -r +10 //10분후에 재부팅$ shutdown -c // 리부팅예약한것 취소$ shutdown -k +15 //20분 후에 종료된다는 메세지가 날라감 //루트를 제외한 모든 사용자에게.. //실제 종료는 안됨. //필요한 이유: 서버에 많은 사용자가 접속하였을 경우 사용자들의 로그아웃을 유도.$ init 0~6 // 0-종료모드 2-멀티유저모드 5-그래픽모드의 다중사용자모드 6-리부트모드$ startx //x윈도우 모드로 변경 주의) 예로 단순히 init4에서 init1로가는것과 다르다. //명령어 모드에서 x윈도우 모드로 변경되는것$ chvt 1~6 입력 //가상콘솔 이동$ gedit //gedit 실행 //윈도우 + 스페이스 : 한영전환$ gedit 파일명 // 파일열기$ vi 파일명 //vi 에디터가 실행된다.i 또는 a 입력 //이후 편집, 입력작업진행esc //작업이 끝난 후 명령모드로 변경:wq //저장하고 종료한다.:q! //수정사항 무시하고 종료$ :set number //코드의 행번호 확인$ ls -a //숨김파일까지 조회$ rm .myfile3.txt.swp //파일삭제$ mas ls //ls에 대한 도움말을 확인 . 스페이스바로 페이지 이동가능$ umount /dev/cdrom //마운트 된것을 끊는것. 연결이 되지 않았을 경우 오류메시지가 나온다.$ mount /dev/cdrom /media/cdrom //마운트!$ rpm -qa 패키지이름 //패키지 설치여부 확인$ yum -y install 패키지명 으로 설치를 한다.$ ls // 파일이나 폴더의 목록을 보는것 윈도우의 dir.$ ls /etc/sysconfig //특정 폴더내의 목록을 보는것$ ls -a //숨김파일까지 보는것.$ ls -l // 자세히 보는것 //-로 시작하면 파일 d로 시작하면 디렉토리$ ls *.cfg //확장자가 cfg인것$ ls ls my* // my로 시작하는것들 조회$ ls -al //숨김파일까지 자세히 조회 // -a, -l 의 결합$ cd /etc/sysconfig/$ pwd //현재 디렉터리 위치 출력$ cd / // 최상위폴더로 이동(루트 디렉토리라함) // $ cd / 명령어의 경우 다음 명령창이 아래와 같이 나온다. // [root@localhost /]#$ cd // &quot;/루트 디렉토리&quot;(현재 사용자의 홈폴더)로 이동 // $ cd 명령어의 경우 다음 명령창이 아래와 같이 나온다. // [root@localhost ~]$ cd /etc //루트 디렉토리의 etc로 이동(절대경로)$ cd etc //현재 디렉토리에서 etc로 이동 (상대경로)$ cd .. //현재 디렉토리의 바로 앞 디렉토리로 이동$ cd . //현재 디렉토리 반환$ cd ~centos //해당 사용자의 홈 디렉토리로 이동 //즉 $ cd~사용자 == $ cd $ touch //비어있는 파일 생성$ rm file1 // 삭제명령어 (삭제할것인지 재확인함)$ rm -f file1 // 삭제 명령어(삭제할것인지 확인하지 않고 삭제)$ cp file3 file4 //file3가 file4로 복사됨$ cp -r /etc/sysconfig . // /etc/sysconfig폴더를 현재 폴더에 복사한다. -r은 디렉토리 복사일$ mv myfile3.txt /root/sysconfig //myfile3.txt파일을 /root/sysconfig 로 이동$ mv file file3 //파일이름을 file에서 file3로 변경$ mkdir folder1 //folder1 디렉토리 생성$ mkdir -p dir1/dir2/dir3 // dir1/dir2/dir3 디렉토리를 생성 // 디렉토리가 3개가 만들어지는것이 아니라 dir1 안에 dir2 안에 dir3가 만들어진다.$ rmdir folder1 //디렉토리 제거 (폴더가 비어있을 경우 가능)$ rmdir -r folder1 //내부에 파일이 있는 디렉토리 제거 //(안에 들어있는 파일 하나하나 지울것인지 다물어본다.)$ rm -rf dir1 //묻지도 따지지도 않고 dir1 디렉토리 제거 //매우 위험하다!! 주의해서 사용$ cat anaconda.ks.cfg // 파일을 읽기$ head anaconda-ks.cfg //위에 10줄만 읽기$ head -5 anaconda-ks.cfg //위에 5줄만 읽기$ tail anaconda-ks.cfg //아래 10줄만 읽기$ more anaconda-ks.cfg //페이지 단위로 끊어읽기$ less anaconda-ks.cfg //페이지 단위로 끊어읽기 less가 more보다 몇가지 명령어가 더 존재함$ file file1 //디렉터리인지, 링크인지, 비었는지 등을 알려준다.# userdel -r user1 //보통 현업에선 -r옵션을 넣어 디렉토리까진 지우지 않는다. //하지만 실습이므로 과감하게 지운다.# groupadd centosGroup //그룹생성# useradd user1 //user1생성# useradd -g centosGroup user1 //centosGroup에 소속된 user1생성# useradd -g centosGroup user2 //centosGroup에 소속된 user2생성# passwd shkim //사용자의 비밀번호를 지정하거나 변경# usermod -g root shkim //사용자의 속성을 변경# userdel shkim //사용자는 지우나 디렉토리를 제거하지 않음. //-r 옵션이 존재. 이는 사용자가 사용하던 디렉토리까지 제거# change -m 2 shkim //사용자의 암호를 주기적으로 변경하도록 설정 //-m 2는 최소 이틀이상 써야한다.(189p 참고)# groups // 사용자가 속한 그룹을 보여줌# groupadd newgroup //새로운 그룹을 새성 # groupmod -n newgroup mygroup//그룹의 속성을 변경 newgroup을 mygroup로 변경# groupdel newgroup //그룹을 삭제# gpasswd newgroup //그룹의 암호설정$ chmod o-x test //일반사용자(o : ordinary)는 -x (x:execute) 실행 못하도록$ ls -l test-rwxrwxrw- 1 centos centos 52 7월 3 13:52 test //마지막 x가 빠짐$ chmod ug-w test //소유주(u: user), 소유그룹(g: group) 쓰기권한 제거$ ls -l test-r-xr-xrw- 1 centos centos 52 7월 3 13:52 test //3번째 6번째 w가 빠짐$ chmod ugo-r test //전부다 읽기권한 제거$ ls -l test ---x--x-w- 1 centos centos 52 7월 3 13:52 test //r이 제거된것 확인$ chmod uo+rw test //소유주, 기타사용자에게 읽기,쓰기 허용$ ls -l test -rwx--xrw- 1 centos centos 52 7월 3 13:52 test//숫자를 넣지 않고 하는것을 심볼릭방법이라 하는데 이것이 더 편할 때가 있다.숫자로 할 경우 기존의 권한도 알아야 하기 때문에..# chown centos sample.txt //centos로 소유권을 넘김# ls -l sample.txt-rw-r-xr-x 1 centos root 0 7월 3 13:35 sample.txt //소유권 변경됨# chgrp centos sample.txt //파일소유그룹 변경# ls -l sample.txt-rw-r-xr-x 1 centos centos 0 7월 3 13:35 sample.txt# chown root.root sample.txt //파일 소유자, 그룹 변경# ls -l sample.txt-rw-r-xr-x 1 root root 0 7월 3 13:35 sample.txt# su - centos //centos계정으로 로그인 //루트계정일 경우 암호를 묻지않는다. //-를 붙이면 디렉토리가 centos디렉토리로 변경되가 //붙이지 않으면 변경되지 않는다.","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"관련정보","slug":"Linux/관련정보","permalink":"http://KKimSangHeon.github.io/categories/Linux/관련정보/"}],"tags":[{"name":"리눅스 명령어","slug":"리눅스-명령어","permalink":"http://KKimSangHeon.github.io/tags/리눅스-명령어/"}]},{"title":"리눅스 에러","slug":"LinuxError","date":"2017-07-01T04:45:37.000Z","updated":"2017-07-01T14:39:51.881Z","comments":true,"path":"2017/07/01/LinuxError/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/01/LinuxError/","excerpt":"","text":"증상:Virtualized performance counters are not supported on the host CPU type. Module VPMC power on failed. Failed to start the virtual machine 이라는 에러메세지 출력. 해결법:.vmx 파일을 열고 vpmc.enable 부분을 “FALSE”로 수정.","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"관련정보","slug":"Linux/관련정보","permalink":"http://KKimSangHeon.github.io/categories/Linux/관련정보/"}],"tags":[{"name":"Linux Error","slug":"Linux-Error","permalink":"http://KKimSangHeon.github.io/tags/Linux-Error/"}]},{"title":"BinarySearch","slug":"BinarySearch","date":"2017-06-30T10:38:20.000Z","updated":"2017-06-30T11:01:37.840Z","comments":true,"path":"2017/06/30/BinarySearch/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/BinarySearch/","excerpt":"","text":"이진탐색데이터의 정렬이 선행되어야 한다. 시간복잡도는 O(log2n) 이다.BinarySearch.c 재귀적인 방법12345678910111213141516int ISearch(int ar[], int first, int last, int target)&#123; int mid; if(first &gt; last) return -1; // -1의 반환은 탐색의 실패를 의미 mid=(first+last) / 2 ; if(ar[mid] == target) return mid; // 탐색된 타겟의 인덱스 값 반환 else if(target &lt; ar[mid]) return ISearch(ar, first, mid-1, target); else return ISearch(ar, mid+1, last, target);&#125; BinarySearch.c 반복문 이용123456789101112131415161718BinarySearch(int DataSet[], int Size, int target)&#123; int Left,Right,Mid; Left=0; Right=Size-1; while(Left&lt;=Right)&#123; Mid=(Left+Rigth) / 2 ; if( Target==DataSet[Mid]) return DataSet[Mid]; else if(Target&gt;DataSet[Mid]) Left=Mid+1; else Right=Mid-1; &#125; return NULL;&#125; 이진탐색의 경우 비교대상이 되는 mid값을 단순히 (first+last)/2로 설정한다.그러나 보간 탐색의 경우 mid 값 설정방식이 다르며 이진탐색보다 우수한 성능을 보인다. 보간탐색탐색대상이 앞쪽에 위치 할 경우 앞쪽에서 탐색을 시작하고 뒤쪽에 위치할 경우 뒤쪽에서 탐색을 시작한다.이진탐색보다 우수하다.ISearch.c12345678910111213141516int ISearch(int ar[], int first, int last, int target)&#123; int mid; if(ar[first]&gt;target || ar[last]&lt;target) return -1; // 이진 탐색과의 차이점을 반영한 문장 mid = ((double)(target-ar[first]) / (ar[last]-ar[first]) *(last-first)) + first; if(ar[mid] == target) return mid; // 탐색된 타겟의 인덱스 값 반환 else if(target &lt; ar[mid]) return ISearch(ar, first, mid-1, target); else return ISearch(ar, mid+1, last, target);&#125; 보간탐색의 mid값 계산 방법 그림[1]에서 arr[s]는 찾는값을 의미함. 참고 : 윤성우의 열혈 자료구조","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/categories/Data-Structure/"},{"name":"Search","slug":"Data-Structure/Search","permalink":"http://KKimSangHeon.github.io/categories/Data-Structure/Search/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/tags/Data-Structure/"},{"name":"Search","slug":"Search","permalink":"http://KKimSangHeon.github.io/tags/Search/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"http://KKimSangHeon.github.io/tags/BinarySearch/"}]},{"title":"2장. CentOS 리눅스 소개","slug":"ThisIsLinux1","date":"2017-06-30T09:55:52.000Z","updated":"2017-07-01T05:14:51.441Z","comments":true,"path":"2017/06/30/ThisIsLinux1/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/ThisIsLinux1/","excerpt":"","text":"리눅스 리눅스란?리눅스 = 무료 유닉스 라 생각하면 된다.1991 ‘리누스 토르발스’가 버전 0.01을 최초로 완성. 리누스 토르발스는 커널(kernel)만 개발함(여기서 커널은 자동차 엔진이라고 보면된다.)모든 배포판은 리누스 토르발스가 개발한 커널을 갖고 사람들이 만들어진것이다. CentOS 또한 마찬가지..자동차로 비유하자면 A,B,C 회사가 하나의 엔진을 사용하여 각기 다른 자동차를 만들어내놓음.우리가 공부할 CentOS의 커널버전은 3.17.4인데 변경이 가능하다.!자동차로 비교하면 자동차를 그대로 두고 엔진만 변경하는것.이를 커널 업그레이드 라고 한다. GNU 프로젝트?GNU 프로젝트 - GPL(General Public License[자유 소프트웨어의 수정과 공유의 자유를 보장하는것.]) 에 따라 소스를 배포하여 공개하고 그것을 더 개선하여 배포하고 의 반복.. 리눅스 또한 마찬가지. 그래서 현재는 유닉스 보다 더 좋다고 말하는 사람들이 많다. 여기서 재미있는점 하나. 소스코드를 무료로 얻어서 기능개선 후 판매는 가능하다. 그러나 GPL에 의해 소스코드는 공유해야한다는점. 레드햇 리눅스와 CentOS 리눅스?전 세계적으로 유명하며 기업에서 많이쓴다. 무료버전은 없으며 상용버전만 존재한다. 하지만 GPL에 의해 소스코드는 공개되어 있어 레드햇 엔터프라이즈 리눅스의 소스코드를 그대로 가져와 로고만 바꾼것이 CentOS!!결국 레드햇 리눅스 == CentOS 리눅스","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"기수정렬 (RadixSort)","slug":"RadixSort","date":"2017-06-30T05:36:34.000Z","updated":"2017-06-30T11:02:17.317Z","comments":true,"path":"2017/06/30/RadixSort/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/RadixSort/","excerpt":"","text":"기수정렬버켓에 데이터를 작은 수 부터 넣고 빼내어 정렬하는 방식이다.기수정렬의 시간복잡도는 O(ln)이며 l은 버켓의 크기를 의미한다. red, why, few 정렬가능 - 버킷 3개 필요10,161,18,1 가능 - 버킷 3개 필요proffesor , red , why 불가능125 , -101, 167, -505 불가능 ##참고사항 1의자리 수 구하기-num/1%1010의자리 수 구하기 -num/10%10100의 자리 수 구하기 -num/100%10 InsertionSort.c123456789101112131415161718192021222324252627282930313233343536373839void RadixSort(int arr[], int num, int maxLen) // maxLen은 가장 긴 데이터의 길이&#123; Queue buckets[BUCKET_NUM]; int bi; int pos; int di; int divfac = 1; int radix; // 총 10개의 버킷 초기화 for(bi=0; bi&lt;BUCKET_NUM; bi++) QueueInit(&amp;buckets[bi]); // 가장 긴 데이터의 길이만큼 반복 for(pos=0; pos&lt;maxLen; pos++) &#123; // 정렬 대상의 수만큼 반복 for(di=0; di&lt;num; di++) &#123; // N번째 자리의 숫자 추출 radix = (arr[di] / divfac) % 10; // 추출한 숫자를 근거로 데이터 버킷에 저장 Enqueue(&amp;buckets[radix], arr[di]); &#125; // 버킷 수만큼 반복 for(bi=0, di=0; bi&lt;BUCKET_NUM; bi++) &#123; // 버킷에 저장된 것 순서대로 다 꺼내서 다시 arr에 저장 while(!QIsEmpty(&amp;buckets[bi])) arr[di++] = Dequeue(&amp;buckets[bi]); &#125; // N번째 자리의 숫자 추출을 위한 피제수의 증가 divfac *= 10; &#125;&#125; 참고 : 윤성우의 열혈 자료구조","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/categories/Data-Structure/"},{"name":"Sort","slug":"Data-Structure/Sort","permalink":"http://KKimSangHeon.github.io/categories/Data-Structure/Sort/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/tags/Data-Structure/"},{"name":"Sort","slug":"Sort","permalink":"http://KKimSangHeon.github.io/tags/Sort/"},{"name":"Radix Sort","slug":"Radix-Sort","permalink":"http://KKimSangHeon.github.io/tags/Radix-Sort/"}]},{"title":"퀵정렬 (QuickSort)","slug":"QuickSort","date":"2017-06-30T05:36:18.000Z","updated":"2017-06-30T11:02:24.397Z","comments":true,"path":"2017/06/30/QuickSort/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/QuickSort/","excerpt":"","text":"퀵정렬퀵 정렬 O(nlog2n)- 피벗을 정하여 분할하여 정복.. 피벗을 선택 할때 3개를 선택하여 평균치를 구하여 구하면 더 효율적으로 피벗을 정할 수 있다.피벗이 잘 선택될 경우 시간복잡도가 줄어든다. 최악의 경우 O(n^2)이 될 수 있다 (피벗값이 많이 안좋을 경우) O(nlog2n)의 시간복잡도를 갖는 다른 정렬 알고리즘 보다 평균적으로 빠르다.why ? 데이터 이동이 상대적으로 작고 병합정렬과 같이 별도의 메모리 공간을 요구하지 않기 때문에.. 나만의 요약! : 피벗값을 기준으로 처음지점부터 시작한 반복문은 피벗보다 작은값을 찾고 뒤에서 시작한 반복문은 피벗보다 큰값을 찾아 서로 바꾼다. ( 단 피벗을 지나치치 않음) QuickSort.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void Swap(int arr[], int idx1, int idx2)&#123; int temp = arr[idx1]; arr[idx1] = arr[idx2]; arr[idx2] = temp;&#125;int Partition(int arr[], int left, int right)&#123; int pivot = arr[left]; // 피벗의 위치는 가장 왼쪽! int low = left+1; int high = right; while(low &lt;= high) // 교차되지 않을 때까지 반복 &#123; while(pivot &gt; arr[low]) low++; while(pivot &lt; arr[high]) high--; /* while(pivot &gt;= arr[low] &amp;&amp; low &lt;= right) low++; while(pivot &lt;= arr[high] &amp;&amp; high &gt;= (left+1)) high--; */ if(low &lt;= high) // 교차되지 않은 상태라면 Swap 실행 Swap(arr, low, high); // low와 high가 가리키는 대상 교환 &#125; Swap(arr, left, high); // 피벗과 high가 가리키는 대상 교환 return high; // 옮겨진 피벗의 위치 정보 반환&#125;void QuickSort(int arr[], int left, int right)&#123; if(left &lt;= right) &#123; int pivot = Partition(arr, left, right); // 둘로 나눠서 QuickSort(arr, left, pivot-1); // 왼쪽 영역을 정렬 QuickSort(arr, pivot+1, right); // 오른쪽 영역을 정렬 &#125;&#125; 참고 : 윤성우의 열혈 자료구조","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/categories/Data-Structure/"},{"name":"Sort","slug":"Data-Structure/Sort","permalink":"http://KKimSangHeon.github.io/categories/Data-Structure/Sort/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/tags/Data-Structure/"},{"name":"Sort","slug":"Sort","permalink":"http://KKimSangHeon.github.io/tags/Sort/"},{"name":"Quick Sort","slug":"Quick-Sort","permalink":"http://KKimSangHeon.github.io/tags/Quick-Sort/"}]},{"title":"병합정렬 (MergeSort)","slug":"MergeSort","date":"2017-06-30T05:36:10.000Z","updated":"2017-06-30T11:02:44.760Z","comments":true,"path":"2017/06/30/MergeSort/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/MergeSort/","excerpt":"","text":"병합정렬재귀적으로 분할하여 병합하는 방식으로 재귀적으로 모든 요소들을 쪼갠 후 합쳐나간다. 시간복잡도는 O(nlog2n))이다. MergeSort.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void MergeTwoArea(int arr[], int left, int mid, int right)&#123; int fIdx = left; int rIdx = mid+1; int i; int * sortArr = (int*)malloc(sizeof(int)*(right+1)); int sIdx = left; while(fIdx&lt;=mid &amp;&amp; rIdx&lt;=right) &#123; if(arr[fIdx] &lt;= arr[rIdx]) sortArr[sIdx] = arr[fIdx++]; else sortArr[sIdx] = arr[rIdx++]; sIdx++; &#125; if(fIdx &gt; mid) &#123; for(i=rIdx; i&lt;=right; i++, sIdx++) sortArr[sIdx] = arr[i]; &#125; else &#123; for(i=fIdx; i&lt;=mid; i++, sIdx++) sortArr[sIdx] = arr[i]; &#125; for(i=left; i&lt;=right; i++) arr[i] = sortArr[i]; free(sortArr);&#125;void MergeSort(int arr[], int left, int right)&#123; int mid; if(left &lt; right) &#123; // 중간 지점을 계산한다. mid = (left+right) / 2; // 둘로 나눠서 각각을 정렬한다. MergeSort(arr, left, mid); MergeSort(arr, mid+1, right); // 정렬된 두 배열을 병합한다. MergeTwoArea(arr, left, mid, right); &#125;&#125; 참고 : 윤성우의 열혈 자료구조","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/categories/Data-Structure/"},{"name":"Sort","slug":"Data-Structure/Sort","permalink":"http://KKimSangHeon.github.io/categories/Data-Structure/Sort/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/tags/Data-Structure/"},{"name":"Sort","slug":"Sort","permalink":"http://KKimSangHeon.github.io/tags/Sort/"},{"name":"Merge Sort","slug":"Merge-Sort","permalink":"http://KKimSangHeon.github.io/tags/Merge-Sort/"}]},{"title":"힙정렬 (HeapSort)","slug":"HeapSort","date":"2017-06-30T05:35:38.000Z","updated":"2017-06-30T11:02:55.505Z","comments":true,"path":"2017/06/30/HeapSort/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/HeapSort/","excerpt":"","text":"힙 정렬힙을 만들어서 힙에 넣고 빼는것으로서 시간복잡도는 O(nlog2n) 이다. BubbleSort.c12345for(i=0;i&lt;n;i++) HInsert(&amp;heap,arr[i]);for(i=0;i&lt;n;i++) arr[i]=HDelete(&amp;heap); 참고 : 윤성우의 열혈 자료구조","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/categories/Data-Structure/"},{"name":"Sort","slug":"Data-Structure/Sort","permalink":"http://KKimSangHeon.github.io/categories/Data-Structure/Sort/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/tags/Data-Structure/"},{"name":"Sort","slug":"Sort","permalink":"http://KKimSangHeon.github.io/tags/Sort/"},{"name":"Heap Sort","slug":"Heap-Sort","permalink":"http://KKimSangHeon.github.io/tags/Heap-Sort/"}]},{"title":"삽입정렬 (InsertionSort)","slug":"InsertionSort","date":"2017-06-30T05:35:28.000Z","updated":"2017-06-30T11:03:11.884Z","comments":true,"path":"2017/06/30/InsertionSort/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/InsertionSort/","excerpt":"","text":"삽입정렬1~n까지 정렬해 나감 1~2 정렬 12묶음 3정렬 13묶음 4정렬첫 번째 데이터는 정렬이 되어있다고 봄. 그래서 i=0이아닌 1부터 시작.시간복잡도는 O(n^2) 이다. InsertionSort.c123456789101112for(i=1;i&lt;n;i++)&#123; insData=arr[i]; //정렬대상을 insData에 저장 for(j=i-1;i&gt;=0;j--) &#123; if(arr[j]&gt;insData) arr[j+1]=arr[j]; else break; &#125; arr[j+1]=insData;&#125; 참고 : 윤성우의 열혈 자료구조","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/categories/Data-Structure/"},{"name":"Sort","slug":"Data-Structure/Sort","permalink":"http://KKimSangHeon.github.io/categories/Data-Structure/Sort/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/tags/Data-Structure/"},{"name":"Sort","slug":"Sort","permalink":"http://KKimSangHeon.github.io/tags/Sort/"},{"name":"Insertion Sort","slug":"Insertion-Sort","permalink":"http://KKimSangHeon.github.io/tags/Insertion-Sort/"}]},{"title":"선택정렬 (SelectionSort)","slug":"SelectionSort","date":"2017-06-30T04:59:38.000Z","updated":"2017-06-30T11:03:24.859Z","comments":true,"path":"2017/06/30/SelectionSort/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/SelectionSort/","excerpt":"","text":"선택정렬오름차순일 경우 작은걸 맨앞에 넣고 그 다음 작은걸 두 번째 넣고 ..이 과정을 계속 반복한다. 시간복잡도는 O(n^2) 이다. SelectionSort.c12345678910for(i=0;i&lt;n-1;i++)&#123; maxIdx=i; for(j=i+1;j&lt;n;j++) //최소값 탐색 &#123; if(arr[i]&lt;arr[maxIdx]) maxIdx=j; &#125; swap;&#125; 참고 : 윤성우의 열혈 자료구조","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/categories/Data-Structure/"},{"name":"Sort","slug":"Data-Structure/Sort","permalink":"http://KKimSangHeon.github.io/categories/Data-Structure/Sort/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/tags/Data-Structure/"},{"name":"Sort","slug":"Sort","permalink":"http://KKimSangHeon.github.io/tags/Sort/"},{"name":"Selection Sort","slug":"Selection-Sort","permalink":"http://KKimSangHeon.github.io/tags/Selection-Sort/"}]},{"title":"작성논문","slug":"paper","date":"2017-06-30T04:40:14.000Z","updated":"2017-07-07T00:51:51.519Z","comments":true,"path":"2017/06/30/paper/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/paper/","excerpt":"","text":"A Survey of Fingerprint Indoor Positioning TechniquesintroductionThe location based service (LBS) industry is so flourishing that enumerating all LBSs available now is almost impossible. In the marketing field, LBSs may recognize the current location of tenta-tive customers and push advertisement messages and coupons to them when they enter a predefined area. When a person makes a call to 911, the location of the person is identified by the emergency response agency so that help can be provided quickly. The location-based information service deliv-ers information of points of interests located near to the user. The navigation service is another well-known type of location-based services.Location-based service cannot be realized unless the positioning problem is solved. The Global Positioning System (GPS) can be used as a general solution for outdoor positioning. However, posi-tioning for indoor area is still under development. We are especially interested in wireless local area network (WLAN)-based indoor positioning techniques because it is available in almost all huge man made constructions. Most of WLAN-based indoor positioning techniques use either the signal propa-gation model or fingerprints.Implementation of the signal propagation model based indoor positioning method can be done quickly whereas implementation of the fingerprint method takes a long time. However, the finger-print method is more accurate than the signal propagation model based method. This paper surveys recently published fingerprint indoor positioning techniques. 자세히 보기 Review of the Techniques for Smart Learning SystemsintroductionFlipped learning is said to be one of the most efficient teaching and learning methods. In flipped learning, students watch lecture videos at home. In the class, they solve interesting problems under the teacher’s guide. Nowadays, students watch videos through smart devices while they are on the way home. Therefore, schools should provide a smart learning system.A database of lecture videos, smart applications, content management systems, and streaming servers are essential parts of smart learning systems. There are many database management system (DBMS) with which we can develop database of lecture videos. Among them, this paper reviews techniques to use MySQL DBMS. 자세히 보기 Techniques for Group Management Application DevelopmentintroductionA group management system provides many types of valuable services. For example, a teacher can be aware of current locations of all the students in real time during a field trip using a group management mobile application. In the early stage of location based service, fleet management was one of the hottest research topics. This paper reviews group management related research results.Positioning, handling maps, handling a database and mobile programming are indispensable technologies for the development of fleet management systems. Usages of these technologies in fleet management system development are discussed.자세히 보기 Survey of Techniques for Location-Based Mobile Campus Guide SystemsintroductionLocation-based service provides useful information based on the place where the user is located. Smart phones are ideal devices that provide location-based services because they are equipped with various sensors with which we can determine the location of smart phones.As an example of location-based service, the authors of [1] introduced a campus guide mobile app. This paper surveys techniques needed in development of location-based mobile campus guide systems. Campus guide systems prints out texts and images. It also plays audios and videos. Therefore, video on demand (VOD) techniques will be discussed. Techniques to identify the context of user will also be discussed. Finally, this paper will propose a design of a campus guide 자세히 보기","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"작성 논문","slug":"작성-논문","permalink":"http://KKimSangHeon.github.io/tags/작성-논문/"}]},{"title":"시각장애인을 위한 길안내 app","slug":"For-blind","date":"2017-06-30T03:42:08.000Z","updated":"2017-06-30T04:32:05.752Z","comments":true,"path":"2017/06/30/For-blind/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/For-blind/","excerpt":"","text":"참가배경-교내 창업경진대회가 진행 중이라는 소식을 듣고 참가하게 되었습니다. 비콘과 관련된 프로젝트를 진행중이던 상황이라 비콘을 이용해서 창업아이템을 고안하게 되었습니다. Idea를 떠올린 계기 -지하철을 이용하던 어느 날 시각장애인이 길을 찾는데 어려움을 겪는 것을 보았습니다. 시각장애인이 길을 찾는데 어려움을 겪은 이유는 점형블록에 대한 인식이 부족한 상인이 올려둔 짐 때문이었고 결국 시각 장애인은 주변 사람들의 도움을 통해 올바른 길을 찾아 갈 수 있었습니다. 저는 그 이후 지하철 내 점형블록을 눈여겨보게 되었습니다. [그림1]의 좌측 사진과 같이 깨진 점형블록이 보수되지 않은 채 존재하며, 우측 사진과 같이 매트가 깔려있기도 했습니다. -또한 그들을 위한 시설인 음성유도기 또한 고장나있는경우가 많으며 가격이 비싸다는 단점이 존재하였습니다.(개당 약 270만원) Idea 소개역사에 10m^2당 비콘을 하나씩 설치하여 핑거프린팅 알고리즘을 적용한 후 현재위치를 파악합니다. (FingerPrinting Algorithm(참고)) 그 후 [그림3]과 같이 이동방향을 파악 후 이동방향에 따른 음성안내를 실시합니다.음성안내를 실시하기 위해서는 다음의 Newtone API 혹은 Naver의 음성합성 기능을 사용하면 가능합니다. 결과 운이 좋게도 장려상과 30만원의 장학금을 지급받았습니다 !","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://KKimSangHeon.github.io/tags/Android/"},{"name":"Beacon","slug":"Beacon","permalink":"http://KKimSangHeon.github.io/tags/Beacon/"},{"name":"창업경진대회","slug":"창업경진대회","permalink":"http://KKimSangHeon.github.io/tags/창업경진대회/"}]},{"title":"기숙사 외박계","slug":"Dormitory-Sleep-Out","date":"2017-06-30T01:22:14.000Z","updated":"2017-06-30T03:37:41.143Z","comments":true,"path":"2017/06/30/Dormitory-Sleep-Out/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/Dormitory-Sleep-Out/","excerpt":"","text":"프로그램 개발배경-교내 기숙사의 외박계 프로그램이 존재하지 않으며, 업체에 의뢰하여 제작하려했으나 비용상의 문제로 거절된것을 알게되었습니다. 그래서 직접 만들어서 제출하면 어떨까 라는 생각을 하게되어 개발하게 되었습니다. 프로그램 소개CentOS상에 서버를 실행시켰으며, 카카오톡 옐로아이디 페이지에서 세팅을 진행하였습니다. 각 과정을 거친 후 자신의 외박계를 하나 작성할 수 있는 프로그램입니다. 프로그램 동작화면 초기 채팅방에 진입하였을 경우 외박계를 작성할 것인지, 작성한 외박계를 확인할 것인지 선택합니다.외박계 작성을 선택하였을 경우 이름, 거주하는 동, 호수, 귀관일, 행선지를 입력하고전화번호 또한 입력 후 아무키나 입력하면 등록이 완료됩니다.[그림1]에서 확인버튼을 선택하였을 경우 [그림4]와 같이 입력한 내용을 확인할 수 있습니다. 작성된 외박계를 관리자가 확인하기 위해서는 채팅방에서 supervisorgj@를 입력합니다. 그 후 [그림5]와 같이 외박계를 조회할 수 있습니다. 소스코드 (Github Repository)-카카오톡 자동응답 서버 소스코드","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://KKimSangHeon.github.io/tags/Node-js/"},{"name":"Kakao talk open API","slug":"Kakao-talk-open-API","permalink":"http://KKimSangHeon.github.io/tags/Kakao-talk-open-API/"},{"name":"챗봇","slug":"챗봇","permalink":"http://KKimSangHeon.github.io/tags/챗봇/"},{"name":"MySQL","slug":"MySQL","permalink":"http://KKimSangHeon.github.io/tags/MySQL/"},{"name":"CentOS","slug":"CentOS","permalink":"http://KKimSangHeon.github.io/tags/CentOS/"}]},{"title":"Music Share","slug":"music-share","date":"2017-06-30T00:31:38.000Z","updated":"2017-06-30T03:32:36.202Z","comments":true,"path":"2017/06/30/music-share/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/music-share/","excerpt":"","text":"프로그램 개발배경-C 소켓프로그래밍에 대한 이해를 높이고자 진행한 프로젝트입니다. 프로그램 소개-본 프로그램은 회원가입기능, 로그인기능, 서버에 mp3파일을 올리는기능 등이 구현되어 있습니다. 회원가입을 하고 로그인 후 서버에 mp3파일을 올리거나 다운로드 받을 수 있습니다. 프로그램 개발환경은 우분투 14.04 LTS 입니다. 프로그램 기능 초기 서버에 접속하였을 경우 화면입니다. 서버에서는 클라이언트의 접속현황 및 상태를 확인할 수 있으며 클라이언트에서는 다음에 할 수 있는 일을 확인할 수 있습니다. 두 클라이언트가 회원가입을 진행하고 있고 이에 대한 내용이 서버측 화면에 출력됩니다. 클라이언트가 가입한 ID를 이용하여 로그인을 하였습니다. 로그인 후 에는 서버에 존재하는 mp3파일리스트를 조회하거나 mp3파일을 업로드, 다운로드 할 수있습니다. 클라이언트가 로그인을 한 후 mp3파일을 업로드하는 화면입니다. 클라이언트가 로그인을 한 후 서버에 존재하는 mp3파일을 조회하는 화면입니다. [그림4]에서 KSH클라이언트가 업로드한 hello.mp3 파일을 HRA클라이언트가 접속하여 다운로드 하는 화면입니다. 비밀번호를 찾기위해 ID, Email을 입력하였고 이 후 비밀번호가 화면에 출력되는 모습입니다.","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"C","slug":"C","permalink":"http://KKimSangHeon.github.io/tags/C/"},{"name":"Socket","slug":"Socket","permalink":"http://KKimSangHeon.github.io/tags/Socket/"},{"name":"Music Share","slug":"Music-Share","permalink":"http://KKimSangHeon.github.io/tags/Music-Share/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://KKimSangHeon.github.io/tags/Ubuntu/"}]},{"title":"다수 사용자의 실시간 위치추적 어플리케이션 구현","slug":"where-are-you","date":"2017-06-29T14:53:44.000Z","updated":"2017-06-30T03:57:10.134Z","comments":true,"path":"2017/06/29/where-are-you/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/29/where-are-you/","excerpt":"","text":"App 개발배경-한 인원이 다수의 인원을 통제해야 하는 상황은 다양한 상황에서 발생할 수 있습니다. 가령 한 초등학교에서 현장체험학습의 일환으로 박물관을 방문하였을 경우, 교사 한명이 통제해야할 학생수는 약 30명에 이릅니다. 이는 교사에게 부담스러운 수가 될 수 있을것이라 판단하여 어플리케이션을 통해 극복하고자 하였습니다. App 소개-본 어플리케이션은 BLE기반의 비콘을 이용하여 실내에서 다수 사용자의 위치를 파악하는 어플리케이션입니다. App을 사용하기 위해서는 User는 자신의 정보를 등록해야 하며 이때 입력하는 데이터는 이름, ClassID 입니다. Supervisor는 이름 혹은 (이름,ClassID)를 이용하여 User의 최근 위치를 파악할 수 있는데 ClassID로는 해당 ClassID를 갖는 모든 User가 조회되며, (이름,ClassID)으로는 해당 User의 이동경로를 파악할 수 있습니다. System Architecture -본 어플리케이션의 이용자는 크게 User, Supervisor로 나뉘는데 User의 경우 FingerPrintingServer로 자신이 인식한 비콘들의 값을 전송합니다. 이를 수신한 FingerPrintingServer 서버는 User의 위치를 FingerPrinting 알고리즘을 적용하여 계산한 후 DB에 업데이트합니다. 이용자가 Supervisor 일 경우에는 StudentLocationPage에 접근하여 User들의 위치를 읽어옵니다. FingerPrinting Algorithm-본 어플리케이션의 핵심 알고리즘은 FingerPrinting Algorithm 입니다. 이 알고리즘을 구현하기 위해 72개 지점에서 비콘인식 실험을 100번 간 진행하였습니다. 결과물을 토대로 평균, 분산, 표준편차 등을 곱하고 나누어서 가장 실제 위치와 근접한 값을 구할 수 있었으며 최종적으로 오차를 약 1.65m 까지 줄일 수 있었습니다. -다음은 간단한 FingerPrinting Algorithm 적용 방식입니다. (서버에서 사용하는 알고리즘과는 다릅니다.)핑거프린팅 기법은 사전에 측정된 각 좌표 별 비콘의 신호값을 토대로 현재 위치를 추측하는 기술입니다. 예를 들어 그림1과 같이 각 좌표 별 사전에 측정된 비콘의 신호값(RSSI)이 존재한다고 가정 해 보겠습니다.현재 위치에서 측정된 각 비콘의 RSSI 값이 B1: -86 B2: -91 B3: -100 일 때 Coordinate1에 대한 각 비콘 신호의 차이의 합을 구하면 (-86, -87과의 차이) + (-91, -90과의 차이) + (-100, -101과의 차이) 3입니다. 이 과정을 Coordinate2 또한 반복하면 결과값은 14이며 , Coordinate3 은 26입니다.이 중 오차가 가장 작은 즉 최소값을 갖는 좌표가 현재 위치라 판단할 수 있을 것 이므로 현재 위치는 Coordinate1이라 추측할 수 있겠습니다. Result ClassID로 조회하였을 경우 [그림1]과 같이 해당 User들이 최근에 위치한 좌표값을 확인할 수 있습니다. (이름,ClassID)로 조회하였을 경우 해당 User의 이동경로가 [그림2]와 같이 출력됩니다. User의 위치는 카카오톡 yelloID (ID:WhereAreYou)로도 확인이 가능한데 [그림3]과 같이 카카오톡을 이용하여 위치 조회가 가능합니다. 소스코드 (Github Repository)-안드로이드 어플리케이션 소스코드-카카오톡 자동응답 서버 소스코드-웹페이지 서버 소스코드","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://KKimSangHeon.github.io/tags/Android/"},{"name":"Reco Beacon","slug":"Reco-Beacon","permalink":"http://KKimSangHeon.github.io/tags/Reco-Beacon/"},{"name":"Beacon","slug":"Beacon","permalink":"http://KKimSangHeon.github.io/tags/Beacon/"}]},{"title":"안녕하세요!","slug":"about-me","date":"2017-06-29T09:58:22.000Z","updated":"2017-07-02T15:57:59.299Z","comments":true,"path":"2017/06/29/about-me/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/29/about-me/","excerpt":"","text":"Introduction안녕하세요. 항상 풀스택 개발자가 되고자 노력하는 취업준비생입니다. 이 블로그는 제가 개인적으로 공부한 내용, 진행했던 프로젝트를 업로드하고, 공유하고자 만들었습니다. 부족한 부분에 대한 태클은 언제든지 환영하며 빠르게 반영하도록 하겠습니다. 부족하지만 방문해주셔서 감사드리며 앞으로 더욱 완벽한 블로그를 만들기 위해 노력하겠습니다! Profile 부명고등학교 졸업 (2008.03~2011.02) 동국대학교 경주캠퍼스 컴퓨터공학과 졸업 (2011.03~2017.02) 아이티센 인턴수료 [공공2사업부문 개발2팀] (2016.12~2017.03) Project제가 진행했었던 프로젝트는 다음과 같습니다. 클릭하시면 자세한 설명을 볼 수 있는 페이지로 이동합니다. - 다수 사용자의 실시간 위치추적 어플리케이션(Android, Beacon, Socket) - 부모님을 부탁해(Android) - Music Share(C, Socket) - 기숙사 외박계(Node.js, kakao api) - 시각장애인을 위한 길안내 app제안(android) - 작성 논문","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"Introduction","slug":"About-Me/Introduction","permalink":"http://KKimSangHeon.github.io/categories/About-Me/Introduction/"}],"tags":[{"name":"Sang Heon Kim","slug":"Sang-Heon-Kim","permalink":"http://KKimSangHeon.github.io/tags/Sang-Heon-Kim/"}]},{"title":"부모님을 부탁해","slug":"request-parent","date":"2017-06-29T09:52:18.000Z","updated":"2017-06-29T16:11:45.718Z","comments":true,"path":"2017/06/29/request-parent/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/29/request-parent/","excerpt":"","text":"App 소개 및 개발배경-본 어플리케이션은 증가하는 고독사를 줄여보자는 취지에서 개발하게 된 어플리케이션입니다. 부재중 통화수가 사전에 등록해 놓은 n 개가 되었을 경우 사전에 등록해 놓은 지인에게 위치정보가 포함된 문자메세지가 송신되는 앱 입니다. 초기화면에서 문자메세지를 수신할 번호, 부재중통화의 개수n을 입력하고 동작하기 버튼을 누릅니다. 어플리케이션을 설치한 스마트폰 주인이 부재중통화를 n번 받지 않을 경우 스마트폰의 현재 위치가 등록한 번호로 전송됩니다. -시연영상 google play 방문","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://KKimSangHeon.github.io/tags/Android/"},{"name":"고독사 감소","slug":"고독사-감소","permalink":"http://KKimSangHeon.github.io/tags/고독사-감소/"}]},{"title":"거품정렬 (BubbleSort)","slug":"BubbleSort","date":"2017-06-29T05:36:52.000Z","updated":"2017-06-30T11:03:53.379Z","comments":true,"path":"2017/06/29/BubbleSort/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/29/BubbleSort/","excerpt":"","text":"거품정렬거품정렬의 코드는 다음과 같다.시간복잡도는 O(n^2) 이다. BubbleSort.c12345678910for(i=0;i&lt;n-1;i++)&#123; for(j=0;j&lt;(n-i)-1;j++) &#123; if(arr[j]&gt;arr[j+1]) &#123; swap; &#125; &#125;&#125; 참고 : 윤성우의 열혈 자료구조","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/categories/Data-Structure/"},{"name":"Sort","slug":"Data-Structure/Sort","permalink":"http://KKimSangHeon.github.io/categories/Data-Structure/Sort/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/tags/Data-Structure/"},{"name":"Sort","slug":"Sort","permalink":"http://KKimSangHeon.github.io/tags/Sort/"},{"name":"Bubble Sort","slug":"Bubble-Sort","permalink":"http://KKimSangHeon.github.io/tags/Bubble-Sort/"}]}]}