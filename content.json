{"meta":{"title":"Kim Sang Heon's Bolg","subtitle":null,"description":"Welcome to Sang Heon's Blog.","author":"Kim Sang Heon","url":"http://KKimSangHeon.github.io"},"pages":[],"posts":[{"title":"9. Data Dictionary, DCL, ROLE","slug":"database9","date":"2017-08-21T05:17:43.000Z","updated":"2017-08-21T06:55:26.184Z","comments":true,"path":"2017/08/21/database9/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/21/database9/","excerpt":"","text":"Data Dictionary란?모든 스키마 객체 정보, 스키마 객체의 공간 정보, 컬럼의 기본값, 제약조건 정보, 오라클 사용자 정보, 권한 및 롤 정보, 기타 데이터베이스 정보 … SELECT * FROM DICTIONARY;–데이터 딕셔너리 조회 SELECT * FROM USER_OBJECTS; SELECT * FROM USER_OBJECTS WHERE OBJECT_TYPE = ‘TABLE’; SELECT * FROM DICTIONARY;–데이터 딕셔너리 조회 SELECT * FROM USER_OBJECTS; SELECT * FROM USER_OBJECTS WHERE OBJECT_TYPE = ‘TABLE’; SELECT * FROM USER_USERS;–로그인한 유저만 보여줌 SELECT * FROM ALL_USERS;–전체 유저 보여줌 SELECT * FROM DBA_USERS;–CONN /AS SYSDBA로 로그인 후 가능 SELECT *FROM USER_CONSTRAINTSWHERE TABLE_NAME = ‘BOOK’;–제약조건 조회 SELECT * FROM USER_USERS; DCL–사용자 생성CREATE USER SHKIM IDENTIFIED BY “SHKIM”; –접속권한GRANT CREATE SESSION TO SHKIM; –SELECT 권한 부여 (DEV에 있는 BOOK테이블에 SELECT 할수있는..)GRANT SELECT ON DEV.BOOK TO SHKIM; –접속권한 없애기REVOKE CREATE SESSION FROM SHKIM; –롤 단위이렇게만 해도 접속 가능GRANT CONNECT, RESOURCE TO SHKIM; REVOKE CONNECT RESOURCE FROM SHKIM; ROLE 생성여러개의 권한을 묶어놓은것!CONN /AS SYSDBACREATE ROLE VIEWER;GRANT CREATE SESSION TO VIEWER;GRANT SELECT ON DEV.BOOK TO VIEWER;GRANT VIEWER TO SHKIM;CONN SHKIN/SHKIM;SELECT * FROM DEV.BOOK; CONN /AS SYSDBA;REVOKE VIWER FROM SHKIM; transaction트랜잭션은 DML의 집합으로 이루어진다. –DML–암시적(컬럼 지정X) 인 경우에는 순서와 , 개수 정확해야 함INSERT INTO AUTHOR VALUES(SEQ_AUTHOR.NEXTVAL, ‘둘리’,NULL); –명시적(컬럼 지정O)인 경우 지정한 순서와 개수 대로 입력해야 한다.INSERT INTO AUTHOR(NAME, NO) VALUES(‘둘리’,SEQ_AUTHOR.NEXTVAL); 트랜잭션은 다음과 같은 특징을 가져야 한다.Atomicity: all or nothing. 하나의 단위로 처리되어야 함. (중간까지만 처리됨은 불가)Consistency: 데이터베이스의 일관성(무결성)을 깨지 않아야 함Isolation: 다른 transaction과 동시에 수행되더라도 독립적으로 영향을 받지 않아야 함Durability: 한번 수행 완료(commit)되면 영원히 반영되어 있어야 함 (시스템 crash에서라도) DDL이나 DCL은 한 문장이 트랜잭션으로 처리됨","categories":[{"name":"빅데이터 전문가과정","slug":"빅데이터-전문가과정","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/"},{"name":"Data Base","slug":"빅데이터-전문가과정/Data-Base","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/Data-Base/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"8. Commit, Transaction, Delete, Update, CONSTRAINT","slug":"database8","date":"2017-08-21T00:23:06.000Z","updated":"2017-08-21T06:32:45.704Z","comments":true,"path":"2017/08/21/database8/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/21/database8/","excerpt":"","text":"Commit일련의 과정을 거친 후 커밋을 해줘야 데이터베이스에 반영이 된다.오라클의 경우 DDL은 자동으로 커밋이 되며 DML은 직접 커밋을 해줘야 한다.커밋의 과정중 에러가 나면 롤백시킨다. Transaction여러개의 job를 묶어 놓은것을 Transaction이라 한다. DELETEDELETEFROM BOOKWHERE NO = 1; COMMIT; // 커밋한다.ROLLBACK; //다시 롤백한다. UPDATEUPDATE BOOKSET TITLE = ‘토지2’WHERE NO = 1; Subquery를 이용한 테이블 생성백업용 테스트용으로 많이 쓰인다. Subquery의 결과와 동일한 테이블 생성됨질의 결과 레코드들이 포함됨NOT NULL 제약 조건 만 상속됨 CREATE TABLE EMPLOYEES_BAK01AS ( SELECT * FROM EMPLOYEES WHERE JOB_ID = ‘FI_ACCOUNT’); char, varcharchar - 10바이트를 만들고 ‘ab’를 입력하면 10바이트 할당됨varchar - 10바이트를 만들고 ‘ab’를 입력하면 2바이트 할당됨 모든 데이터가 고정크기일 때 (ex 주민번호, 학번) - char모든 데이터가 고정크기가 아닐 때 (ex 이메일) - varchar varchar, varchar2기능상의 다른점은 없지만 varchar2에서 성능개선이 이뤄짐.varchar는 곧 없어질 것이라 예고를 하고있다. NUMBER(x,y)y는 실수부분을 의미한다. varchar2(5), nvarchar2(5)varchar2(5)는 5바이트를 할당nvarchar2(5) 는 5글자를 할당한글은 UTF-8을 사용하기 떄문에 문제가 된다. –NVARCHAR2 , VARCHAR2와 비교 CREATE TABLE BOOK( NO NUMBER(10), TITLE VARCHAR2(120), AUTHOR VARCHAR2(5), –MAX 4000 BYTE TEST NVARCHAR2(2000), –MAX 2000자( 내부적으로 6000 BYTE ) PUB_DTAE DATE); INSERT INTO BOOK VALUES(1, ‘토지’, ‘가나’, SYSDATE);– 가나가 6바이트라 에러가 발생.. INSERT INTO BOOK VALUES(1, ‘토지’, ‘가’, SYSDATE);– 정상적으로 INSERT 가능 ALTERALTER TABLE BOOK ADD(PUBS VARCHAR(120));–컬럼추가ALTER TABLE BOOK MODIFY(PUBS VARCHAR(200));–컬럼 변경ALTER TABLE BOOK RENAME COLUMN PUBS TO PUBLISHINGS;–컬럼명 변경ALTER TABLE BOOK DROP(PUBLISHINGS);–컬럼 제거ALTER TABLE BOOK MODIFY(AUTHOR VARCHAR(300) NOT NULL);–컬럼 변경ALTER TABLE BOOK SET UNUSED(AUTHOR);–컬럼을 보이지 않게 만듦ALTER TABLE BOOK DROP UNUSED COLUMNS;–보이지 않게 만든 컬럼을 삭제함 SEQUENCE값이 1씩 증가한다CREATE TABLE BOOK( NO NUMBER(10), TITLE VARCHAR2(200) NOT NULL, AUTHOR VARCHAR2(50) NOT NULL, –MAX 4000 BYTE PUB_DATE DATE, PRIMARY KEY(NO) ); CREATE SEQUENCE SEQ_BOOKSTART WITH 1 –1부터 시작INCREMENT BY 1 –1씩 증가MAXVALUE 999999999 –MAX가 다차면 1로 돌아감–PRIMARY KEY 자동증가 SELECT SEQ_BOOK.NEXTVAL FROM DUAL; –증가SELECT SEQ_BOOK.CURRVAL FROM DUAL; –최근값 INSERT INTO BOOK VALUES( SEQ_BOOK.NEXTVAL, ‘토지2’, ‘박경리’, SYSDATE);–INSERT 문에서의 시퀀스 활용 CHECKCREATE TABLE BOOK( NO NUMBER(10), TITLE VARCHAR2(200) NOT NULL, AUTHOR VARCHAR2(50) NOT NULL, –MAX 4000 BYTE PUB_DATE DATE, STATE VARCHAR2(12) NOT NULL, PRIMARY KEY(NO), CONSTRAINT C_BOOK_CHECK CHECK(STATE IN (‘대여중’, ‘대여가능’))); INSERT INTO BOOK VALUES( SEQ_BOOK.NEXTVAL, ‘토지2’, ‘박경리’, SYSDATE, ‘대여가능’ –대여중, 대여가능만 들어갈 수 있다. ); 외부키CREATE SEQUENCE SEQ_AUTHORSTART WITH 1INCREMENT BY 1MAXVALUE 999999999–시퀀스 생성 CREATE TABLE AUTHOR( NO NUMBER(10), NAME VARCHAR2(200) NOT NULL, PROFILE VARCHAR2(2000), PRIMARY KEY(NO)) CREATE TABLE BOOK( NO NUMBER(10), TITLE VARCHAR2(200) NOT NULL, AUTHOR_NO NUMBER(10) , –MAX 4000 BYTE STATE VARCHAR2(12) NOT NULL, PUB_DATE DATE, PRIMARY KEY(NO), CONSTRAINT C_BOOK_FK FOREIGN KEY (AUTHOR_NO) REFERENCES AUTHOR(NO) ON DELETE CASCADE , –AUTHOR 테이블의 박경리 데이터가 삭제도면 BOOK테이블의 토지 데이터도 삭제된다. ON DELETE SET NULL, –AUTHOR 테이블의 박경리 데이터가 삭제도면 BOOK테이블의 AUTHOR_NO는 NULL이 된다.. CONSTRAINT C_BOOK_CHECK CHECK(STATE IN (‘대여중’, ‘대여가능’))); INSERT INTO AUTHOR VALUES(SEQ_AUTHOR.NEXTVAL,‘박경리’,NULL); INSERT INTO BOOK VALUES(SEQ_BOOK.NEXTVAL,‘토지’,1,‘대여가능’,SYSDATE); CONSTRAINT제약조건은 보통 ALTER테이블을 통해 모아서 준다.아래와 같이..CREATE TABLE AUTHOR( NO NUMBER(10), NAME VARCHAR2(200) NOT NULL, PROFILE VARCHAR2(2000)) ALTER TABLE AUTHORADD CONSTRAINT C_AUTHOR_PKPRIMARY KEY(NO); CREATE TABLE BOOK( NO NUMBER(10), TITLE VARCHAR2(200) NOT NULL, AUTHOR_NO NUMBER(10) NOT NULL, –MAX 4000 BYTE STATE VARCHAR2(12) NOT NULL, PUB_DATE DATE); ALTER TABLE BOOKADD CONSTRAINT C_BOOK_PKPRIMARY KEY(NO); ALTER TABLE BOOKADD CONSTRAINT C_BOOK_CHECKCHECK(STATE IN (‘대여중’, ‘대여가능’)); ALTER TABLE BOOKADD CONSTRAINT C_BOOK_FKFOREIGN KEY (AUTHOR_NO) REFERENCES AUTHOR(NO) ON DELETE CASCADE ;","categories":[{"name":"빅데이터 전문가과정","slug":"빅데이터-전문가과정","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/"},{"name":"Data Base","slug":"빅데이터-전문가과정/Data-Base","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/Data-Base/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"7. TOP - K","slug":"database7","date":"2017-08-18T04:04:24.000Z","updated":"2017-08-18T04:36:18.826Z","comments":true,"path":"2017/08/18/database7/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/18/database7/","excerpt":"","text":"– TOP -KSELECT ROWNUM,EMPLOYEE_ID, SALARY FROM EMPLOYEES WHERE HIRE_DATE LIKE ‘06%’ ORDER BY SALARY원하는대로 출력이 되지 않을 것이다. 이를 원하는대로 출력하기 위해서는 다음과 같이!SELECT ROWNUM, EMPLOYEE_ID, SALARYFROM ( SELECT EMPLOYEE_ID, SALARY FROM EMPLOYEES WHERE HIRE_DATE LIKE ‘06%’ ORDER BY SALARY ); SELECT ROWNUM, EMPLOYEE_ID, SALARYFROM ( SELECT EMPLOYEE_ID, SALARY FROM EMPLOYEES WHERE HIRE_DATE LIKE ‘06%’ ORDER BY SALARY ) WHERE ROWNUM &lt;= 3 ;–앞에서 3개 뽑는것 SELECT ROWNUM, EMPLOYEE_ID, SALARYFROM ( SELECT EMPLOYEE_ID, SALARY FROM EMPLOYEES WHERE HIRE_DATE LIKE ‘06%’ ORDER BY SALARY ) WHERE 6 &gt;= ROWNUM AND ROWNUM &lt;= 10;–이것은 원하는 결과가 나오지 않는다.1이 찍히지 않으므로 그렇다. 이로인해 ROWNUM이 증가하지 않음 SELECT * FROM ( SELECT ROWNUM AS RN, EMPLOYEE_ID, SALARY FROM ( SELECT EMPLOYEE_ID, SALARY FROM EMPLOYEES WHERE HIRE_DATE LIKE ‘06%’ ORDER BY SALARY ) ) WHERE RN &gt;=6 AND RN &lt;=10; – 위의 문제를 이렇게 해결함.","categories":[{"name":"빅데이터 전문가과정","slug":"빅데이터-전문가과정","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/"},{"name":"Data Base","slug":"빅데이터-전문가과정/Data-Base","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/Data-Base/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"6. SUBQUERY","slug":"database6","date":"2017-08-18T01:22:43.000Z","updated":"2017-08-18T04:04:17.946Z","comments":true,"path":"2017/08/18/database6/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/18/database6/","excerpt":"","text":"서브쿼리Lex보다 많이 받는 사원 구하기 SELECT FIRST_NAME, SALARYFROM EMPLOYEESWHERE SALARY &gt; (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = ‘Lex’); SELECT A.FIRST_NAME, B.SALARYFROM EMPLOYEES A, (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = ‘Lex’) BWHERE A.SALARY &gt; B.SALARY;– 조인으로도 처리 가능 SELECT FIRST_NAME, SALARYFROM EMPLOYEESWHERE SALARY &gt; (SELECT AVG(SALARY) FROM EMPLOYEES ); –SINGLE LOW SUB QUERY – 문_ JOB_ID가 ‘IT_PROG’인 직원이 받는 월급보다 많이 받고 있는 직원의 이름과 월급 SELECT FIRST_NAME, SALARYFROM EMPLOYEESWHERE SALARY &gt; ALL (SELECT SALARY FROM EMPLOYEES WHERE JOB_ID = ‘IT_PROG’) – MULTI ROW SUB QUERY –문) 각 부서별로 최고 월급을 받는 직원의 이름과 직원의 이름과 월급 출력 WHERE을 활용 SELECT FIRST_NAMEFROM EMPLOYEESWHERE (SALARY,DEPARTMENT_ID) IN ( SELECT MAX(SALARY),DEPARTMENT_ID FROM EMPLOYEES GROUP BY DEPARTMENT_ID ); FROM을 활용SELECT A.DEPARTMENT_ID, FIRST_NAME, SALARYFROM EMPLOYEES A, ( SELECT DEPARTMENT_ID, MAX(SALARY) AS MAX_SALARY FROM EMPLOYEES GROUP BY DEPARTMENT_ID ) BWHERE A.DEPARTMENT_ID = B.DEPARTMENT_IDAND A.SALARY = B.MAX_SALARY; CORELATED 활용SELECT DEPARTMENT_ID, FIRST_NAME, SALARYFROM EMPLOYEES AWHERE SALARY = ( SELECT MAX(SALARY) FROM EMPLOYEES WHERE A.DEPARTMENT_ID = DEPARTMENT_ID); – CORELATED SUBQUERY 자기 부서의 평균월급 보다 적은 월급을 받는 사원을 구하라","categories":[{"name":"빅데이터 전문가과정","slug":"빅데이터-전문가과정","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/"},{"name":"Data Base","slug":"빅데이터-전문가과정/Data-Base","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/Data-Base/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"5. ROLLUP, CUBE","slug":"database5","date":"2017-08-18T00:05:47.000Z","updated":"2017-08-18T01:22:37.148Z","comments":true,"path":"2017/08/18/database5/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/18/database5/","excerpt":"","text":"ROWNUMSELECT ROWNUM, EMPLOYEE_IDFROM EMPLOYEES; 트리 형태 구조를 추출하기 위한 질의– START WITH ~ CONNECT BY 절SELECT LEVEL MANAGER_ID, EMPLOYEE_IDFROM EMPLOYEESSTART WITH MANAGER_ID IS NULLCONNECT BY PRIOR EMPLOYEE_ID = MANAGER_IDORDER BY LEVEL, MANAGER_ID, EMPLOYEE_ID; ROLLUP부서별 직책별 평균월급, 사원수 평균월급을 출력하시오ROLLUP (A, B): group by (A, B) &amp; group by (A) &amp; ALL SELECT CASE GROUPING(DEPARTMENT_ID) WHEN 1 THEN ‘모든 부서’ ELSE NVL(TO_CHAR(DEPARTMENT_ID),’없음’) END AS “부서”, CASE GROUPING(JOB_ID) WHEN 1 THEN &apos;모든 직업&apos; ELSE NVL(TO_CHAR(JOB_ID),&apos;없음&apos;) END AS &quot;직업&quot; ,COUNT(*),ROUND(AVG(SALARY),0) FROM EMPLOYEESGROUP BY ROLLUP(DEPARTMENT_ID, JOB_ID)ORDER BY DEPARTMENT_ID, JOB_ID GROUPINGSELECT CASE GROUPING(DEPARTMENT_ID) WHEN 1 THEN ‘모든 부서’ ELSE NVL(TO_CHAR(DEPARTMENT_ID),’없음’) END AS “부서”, CASE GROUPING(JOB_ID) WHEN 1 THEN &apos;모든 직업&apos; ELSE NVL(TO_CHAR(JOB_ID),&apos;없음&apos;) END AS &quot;직업&quot; ,COUNT(*),ROUND(AVG(SALARY),0) FROM EMPLOYEESGROUP BY CUBE(DEPARTMENT_ID, JOB_ID)ORDER BY DEPARTMENT_ID, JOB_ID CUBEgroup by (A,B) &amp; group by (A) &amp; group by (B) &amp; ALLSELECT CASE GROUPING(DEPARTMENT_ID) WHEN 1 THEN ‘모든 부서’ ELSE NVL(TO_CHAR(DEPARTMENT_ID),’없음’) END AS “부서”, CASE GROUPING(JOB_ID) WHEN 1 THEN &apos;모든 직업&apos; ELSE NVL(TO_CHAR(JOB_ID),&apos;없음&apos;) END AS &quot;직업&quot; ,COUNT(*),ROUND(AVG(SALARY),0) FROM EMPLOYEESGROUP BY CUBE(DEPARTMENT_ID, JOB_ID)ORDER BY DEPARTMENT_ID, JOB_ID","categories":[{"name":"빅데이터 전문가과정","slug":"빅데이터-전문가과정","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/"},{"name":"Data Base","slug":"빅데이터-전문가과정/Data-Base","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/Data-Base/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"4. CASE, DECODE, GROUP BY","slug":"database4","date":"2017-08-17T01:59:31.000Z","updated":"2017-08-18T00:05:05.111Z","comments":true,"path":"2017/08/17/database4/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/17/database4/","excerpt":"","text":"CASESELECT EMPLOYEE_ID, SALARY, JOB_ID, CASE JOB_ID WHEN ‘AC_ACCOUNT’ THEN SALARY + SALARY 0.5 WHEN ‘AC_MGR’ THEN SALARY + SALARY 0.3 WHEN ‘AD_VP’ THEN SALARY + SALARY * 0.2 ELSE SALARY END AS SALARYFROM EMPLOYEES; DECODESELECT EMPLOYEE_ID, SALARY, JOB_ID, DECODE( JOB_ID , ‘AC_ACCOUNT’ , SALARY + SALARY 0.5 , ‘AC_MGR’ ,SALARY + SALARY 0.3 , ‘AD_VP’ , SALARY + SALARY * 0.2 , SALARY) AS “이번달 월급”FROM EMPLOYEES; SELECT EMPLOYEE_ID,AVG(SALARY) , MAX(SALARY)FROM EMPLOYEES;– ERROR– 집계함수 이외의 칼럼은 프로젝션 될 수 없다 GROUP BYSELECT JOB_ID,AVG(SALARY), MAX(SALARY)FROM EMPLOYEESWHERE MANAGER_ID IS NOT NULLGROUP BY JOB_ID;– GROUP BY 절에 참여하고 있는 컬럼은 프로젝션 할 수 있다.","categories":[{"name":"빅데이터 전문가과정","slug":"빅데이터-전문가과정","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/"},{"name":"Data Base","slug":"빅데이터-전문가과정/Data-Base","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/Data-Base/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"3. 함수 NVL,SYSDATE,IN,BETWEEN,IS NULL,LIKE,LOWER,INITCAP,LPAD,TRIM,REPLACE,CEIL,FLOOR,ROUND,TRUNC,MOD,POWER,SIGN,ADD_MONTHS,TO_CHAR","slug":"database3","date":"2017-08-16T04:19:24.000Z","updated":"2017-08-17T02:29:49.538Z","comments":true,"path":"2017/08/16/database3/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/16/database3/","excerpt":"","text":"SELECT FIRST_NAME || ‘ ‘ || LAST_NAME AS NAME FROM EMPLOYEES; ||은 CONCAT SELECT SALARY AS “본봉”, SALARY + SALARY * 0.3 AS “보너스”FROM EMPLOYEES; SELECT -SALARY FROM EMPLOYEES; NVL, NVL2SELECT EMPLOYEE_ID, NVL(MANAGER_ID,’0’)FROM EMPLOYEES; NVL함수 내의 두 형태는 같아야함 SELECT NVL(NULL, ‘0’) FROM DUAL; SELECT NVL2(NULL,10, 20) FROM DUAL;–NULL이면 10 SELECT NVL2(0, 10, 20) FROM DUAL;–NULL이 아니면 20 SELECT SALARY AS “본봉”, SALARY + SALARY * NVL(COMMISSION_PCT,0) AS “보너스”FROM EMPLOYEES; SELECT SALARY AS “본봉”, NVL2(COMMISSION_PCT,SALARY + SALARY * COMMISSION_PCT, SALARY) AS “보너스”FROM EMPLOYEES; NULLIFSELECT NULLIF( 10 , 5 + 5 ) FROM DUAL; COALESCESELECT COALESCE(NULL, NULL,1,2,3) FROM DUAL;– 1출력 SYSDATESELECT SYSDATE FROM DUAL; SELECT JOB_IDFROM EMPLOYEESWHERE JOB_ID = ‘AD_PRES’ OR JOB_ID = ‘AD_VP’; INSELECT JOB_IDFROM EMPLOYEESWHERE JOB_ID IN(‘AD_PRES’,’AD_VP’); BETWEENSELECT EMPLOYEE_ID, SALARYFROM EMPLOYEESWHERE SALARY BETWEEN 10000 AND SALARY ; IS NULLSELECT EMPLOYEE_ID, COMMISSION_PCTFROM EMPLOYEESWHERE COMMISSION_PCT IS NULL; LIKESELECT FIRST_NAMEFROM EMPLOYEESWHERE FIRST_NAME LIKE ‘A%’;–A로 시작하는 문자열에 대해서 SELECT FIRST_NAMEFROM EMPLOYEESWHERE FIRSTNAME LIKE ‘A‘;–A로시작하는 두글자 검색 SELECT EMPLOYEE_ID, FIRST_NAMEFROM EMPLOYEESORDER BY FIRST_NAME DESC; SELECT EMPLOYEE_ID, HIRE_DATEFROM EMPLOYEES; LOWERSELECT FIRST_NAMEFROM EMPLOYEESWHERE LOWER(FIRST_NAME) LIKE ‘al%’; INITCAPSELECT INITCAP(‘database managemaent system’) from dual;–맨앞만 대문자로 SELECT INSTR( ‘DATABASE MANAGEMENT SYSTEM’ , ‘BASE’ ) FROM DUAL;– BASE의 위치 찾기 (DB는 대부분 시작 인덱스가 1이다. )SELECT CEIL( 4.99) FROM DUAL;SELECT CEIL( 4.01) FROM DUAL;– 해당 수보다 큰 정수값 (5 출력됨) SELECT FLOOR( 4.99 ) FROM DUAL;SELECT FLOOR( 4.00001) FROM DUAL;– 해당 수보다 작은 정수값 SELECT ROUND(3.3364,3) FROM DUAL;– 넷째자리에서 반올림함(3.336 출력됨) SELECT MOD (9999,6) FROM DUAL;– 나머지SELECT POWER ( 2,10) FROM DUAL;–2의 10승 LPADSELECT EMPLOYEE_ID, LPAD(SALARY, 10 , ‘‘) FROM EMPLOYEES;– 10칸을만들되 왼쪽 나머지는 로 채울것 TRIMSELECT TRIM( ‘#’ FROM ‘####DATA#BASE####’) FROM DUAL;– 앞뒤 특정문자 제거 SELECT TRIM( ‘ ‘ FROM ‘ DATA BASE ‘) FROM DUAL;– 앞뒤 공백 제거 SELECT LTRIM(‘ DATA BASE ‘,’ ‘) FROM DUAL;– 왼쪽 공백 제거 REPLACESELECT REPLACE(‘ DATA BASE ‘, ‘ ‘ ,’’) FROM DUAL;– 공백 제거 CEILSELECT CEIL( 4.99) FROM DUAL;SELECT CEIL( 4.01) FROM DUAL;– 해당 수보다 큰 정수값 (5 출력됨) FLOORSELECT FLOOR( 4.99 ) FROM DUAL;SELECT FLOOR( 4.00001) FROM DUAL;– 해당 수보다 작은 정수값 ROUNDSELECT ROUND(3.3364,3) FROM DUAL;– 넷째자리에서 반올림함(3.336 출력됨) TRUNCSELECT TRUNC( 3.3864,1) FROM DUAL;– 1자리만 남기고 버림(3.3나옴) MODSELECT MOD (9999,6) FROM DUAL;– 나머지 POWERSELECT POWER ( 2,10) FROM DUAL;–2의 10승 SIGNSELECT SIGN(9999) FROM DUAL;– 1나옴 SELECT SIGN(-9999) FROM DUAL;– -1나옴 SELECT SIGN(0) FROM DUAL;– 0나옴 ADD_MONTHSSELECT ADD_MONTHS( SYSDATE, 3 ) FROM DUAL;SELECT ADD_MONTHS( ‘15/01/01’,3 ) FROM DUAL; SELECT LAST_DAY( SYSDATE ) FROM DUAL;–해당월에 마지막 일 SELECT MONTHS_BETWEEN( ADD_MONTHS(SYSDATE,3), SYSDATE) FROM DUAL; SELECT EMPLOYEE_ID, JOB_ID, ROUND(MONTHS_BETWEEN( END_DATE, START_DATE))FROM JOB_HISTORY; SELECT NEXT_DAY( SYSDATE, 7) FROM DUAL;– 1-&gt;SUN 7-&gt;SAT TO_CHARSELECT EMPLOYEE_ID, TO_CHAR(SALARY, ‘99999’ )FROM EMPLOYEES;– 숫자 &lt;-&gt; 문자– 5자리가 넘어가면 #####으로 표시된다. SELECT EMPLOYEE_ID, TO_CHAR(SALARY, ‘000099999’ )FROM EMPLOYEES;– 숫자 &lt;-&gt; 문자–앞에 0000으로 채운다. SELECT EMPLOYEE_ID, TO_CHAR(SALARY, ‘999,999’ )FROM EMPLOYEES;– 숫자 &lt;-&gt; 문자 SELECT TO_CHAR( 3.141592, ‘9.99’) FROM DUAL;– 3.14 나옴 SELECT TO_CHAR( 3.141592, ‘9999.9999’) FROM DUAL;– 3.1416 나옴 SELECT EMPLOYEE_ID, TO_CHAR(SALARY,’FM99999999’)FROM EMPLOYEES;– 왼쪽으로 다 땡겨준다 SELECT EMPLOYEE_ID, TO_CHAR(SALARY,’FM$99999999’)FROM EMPLOYEES;– 왼쪽으로 다 땡겨준다 SELECT EMPLOYEE_ID, TO_CHAR(SALARY,’FML99999999’)FROM EMPLOYEES;– 왼쪽으로 다 땡기고 원화를 넣어준다. SELECT TO_CHAR(-12345,’99999MI’) FROM DUAL;– 12345- SELECT TO_CHAR(-12345,’S99999’) FROM DUAL;– -12345 출력 SELECT TO_CHAR(12345,’S99999’) FROM DUAL;– +12345 출력 SELECT TO_CHAR(-12345,’99999PR’) FROM DUAL;– 출력 SELECT TO_CHAR(12345,’99999PR’) FROM DUAL; SELECT TO_CHAR( 1234, ‘RN’) FROM DUAL;–로마자로 표기 SELECT TO_CHAR( 1234, ‘XXXX’ ) FROM DUAL;–16진수 대문자로 표기 SELECT TO_CHAR( 1234, ‘xxxx’ ) FROM DUAL;–16진수 소문자로 표기 SELECT TO_NUMBER( ‘1234567’,’99999999’) FROM DUAL; SELECT EMPLOYEE_ID,TO_CHAR(HIRE_DATE, ‘yyyy-mm-dd’)FROM EMPLOYEES; SELECT EMPLOYEE_ID,TO_CHAR(HIRE_DATE, ‘yyyy”년”-mm”월”-dd”일”‘)FROM EMPLOYEES; SELECT EMPLOYEE_ID,TO_CHAR(HIRE_DATE, ‘yyyy”년”-mm”월”-dd”일” hh24”시”:mi:ss’)FROM EMPLOYEES; SELECT EMPLOYEE_ID,TO_CHAR(HIRE_DATE, ‘yyyy”년”-mm”월”-dd”일” day pm hh:mi:ss’)FROM EMPLOYEES; SELECTTO_CHAR(SYSDATE, ‘yyyy”년”-mm”월”-dd”일” ddd”일째 되는날”‘)FROM DUAL; SELECT TO_CHAR(SYSDATE, ‘RR’)FROM DUAL; SELECT TO_CHAR(TO_DATE(‘30’,’RR’), ‘YYYY’) FROM DUAL;– 현재 세기 SELECT TO_CHAR(TO_DATE(‘60’,’RR’), ‘YYYY’) FROM DUAL;– 이전 세기","categories":[{"name":"빅데이터 전문가과정","slug":"빅데이터-전문가과정","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/"},{"name":"Data Base","slug":"빅데이터-전문가과정/Data-Base","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/Data-Base/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"2. 데이터베이스 기본","slug":"database2","date":"2017-08-16T00:05:42.000Z","updated":"2017-08-16T04:19:06.546Z","comments":true,"path":"2017/08/16/database2/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/16/database2/","excerpt":"","text":"데이터베이스의 기본개념 (정의)-데이터의 집합 ( a Set of Data )-여러 응용 시스템(프로그램)들의 통합된 정보들을 저장하여 운영할 수 있는 공용(share) 데이터의 집합-효율적으로 저장, 검색, 갱신할 수 있도록 데이터 집합들끼리 연관시키고 조직화되어야 한다. DBMS가 하는일데이터 통합, 저장, 운영, 공유 기능 담당. 이를 위해 조직화 되어있어야 함. 데이터베이스의 특성-실시간 접근성(Real-time Accessability) 사용자의 요구를 즉시 처리할 수 있다.-계속적인 변화(Continuous Evolution) 정확한 값을 유지하려고 삽입·삭제·수정 작업 등을 이용해 데이터를 지속적으로 갱신할 수 있다.-동시 공유성(Concurrent Sharing) 사용자마다 서로 다른 목적으로 사용하므로 동시에 여러 사람이 동일한 데이터에 접근하고 이용할 수 있다.-내용 참조(Content Reference) 저장한 데이터 레코드의 위치나 주소가 아닌 사용자가 요구하는 데이터의 내용, 즉 데이터 값에 따라 참조할 수 있어야 한다. 데이터베이스 관리 시스템 장점데이터 중복이 최소화데이터의 일관성 및 무결성 유지데이터 보안 보장 데이터 베이스의 종류객체 관계형 데이터베이스 ( Object Relation DataBase = ORDB ) -관계형 데이터베이스에서 사용하는 데이터를 확장 -관계형 데이터베이스를 객체 지향 모델링과 데이터를 관리하는 기능을 갖도록 확장한 것NoSQL(Not Only SQL - SQL문 만을 이용하지 않아도 된다.) -대용량 데이터의 웹 서비스와 SNS, 클라우드 컴퓨팅의 확대 보급과 대중화로 최근 주목 받는 데이터베이스 기술 PK다른 행과 구분하기 위해 필요.PK를 설정할 땐 비즈니스와 상관없는 컬럼을 지정하는것이 좋다.(비즈니스 변경시 귀찮아 질 수 있다.)PK는 인덱싱이 자동으로 잡혀 빠르다.릴레이션에서 튜플(행)을 구분하기 위하여 사용하는 기본 키하나의 애트리뷰트, 또는 애트리뷰트의 집합(복합키) 가능관리자에 의해 릴레이션 생성시 정의됨 (자동으로 Index생성됨)동일한 PK를 지닌 레코드가 존재할 수 없음 기타Candidate Key (후보키): 튜플을 식별할 수 있는 최소한의 애트리뷰트 집합하나의 릴레이션에는 PK가 될 수 있는 키가 여러 개 있을 수 있음유일성과 최소성이 있으면 candidate key가 될 수 있음.Alternative Key (대체키): 후보키 중 기본키가 아닌것Composite key (복합키): 둘 이상의 애트리뷰트가 하나의 Key를 이루는 경우","categories":[{"name":"빅데이터 전문가과정","slug":"빅데이터-전문가과정","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/"},{"name":"Data Base","slug":"빅데이터-전문가과정/Data-Base","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/Data-Base/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"Whole in 밴드","slug":"wholin","date":"2017-08-11T06:55:24.000Z","updated":"2017-08-11T07:13:18.046Z","comments":true,"path":"2017/08/11/wholin/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/11/wholin/","excerpt":"","text":"App 소개 및 개발배경-GIF 2016 에 참가하면서 개발하였던 어플리케이션 입니다. 주제는 성공적인 개최를 위한 IOT 서비스 활용방안이였으며 저희팀은 NFC를 이용하여 국적별 다용도로 활용할 수 있는 팔찌(Wholin 밴드)를 제작하였습니다.프로토 타입 어플리케이션이므로 밴드를 통한 국적별 메뉴판 조회, 음식주문 기능을 구현하였습니다. 밴드소개 밴드 속에는 NFC칩이 존재하며 메뉴주문 및 결제, 사각지대 VR 생중계 등의 기능을 제공하며 프로토 타입이므로 국적별 메뉴판 조회기능만 제공합니다. 작동화면 처음 언어를 설정하고 자신의 기본정보를 입력하고 추가정보를 입력후 밴드를 스마트폰에 갖다대면 밴드 등록이 완료됩니다. -시연영상github Repository","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://KKimSangHeon.github.io/tags/Android/"},{"name":"NFC","slug":"NFC","permalink":"http://KKimSangHeon.github.io/tags/NFC/"}]},{"title":"동국대학교 경주캠퍼스 채팅봇","slug":"dg-chat-bot","date":"2017-08-11T06:20:24.000Z","updated":"2017-08-11T06:45:52.459Z","comments":true,"path":"2017/08/11/dg-chat-bot/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/11/dg-chat-bot/","excerpt":"","text":"프로그램 개발배경-기숙사 외박계가 서비스 되지 않은점이 아쉬웠으며 유용하게 쓰일 수 있는 프로그램을 만들어 보고싶어 학교 채팅봇을 만들어보게 되었습니다. 프로그램 소개플러스 친구 추가 후 통학버스 조회, 기숙사 식단조회, 도서관 좌석조회, 홈페이지 조회 기능을 사용할 수 있습니다.또한 AWS EC2인스턴스를 활용하여 서비스하며 동국대학교 경주캠퍼스 채팅봇을 검색 후 친구추가가 가능합니다. 프로그램 동작화면 플러스 친구 추가 후 통학버스 조회, 기숙사 식단조회, 도서관 좌석조회, 홈페이지 조회 기능을 사용할 수 있습니다. github Repository","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://KKimSangHeon.github.io/tags/Node-js/"},{"name":"Kakao talk open API","slug":"Kakao-talk-open-API","permalink":"http://KKimSangHeon.github.io/tags/Kakao-talk-open-API/"},{"name":"챗봇","slug":"챗봇","permalink":"http://KKimSangHeon.github.io/tags/챗봇/"},{"name":"MySQL","slug":"MySQL","permalink":"http://KKimSangHeon.github.io/tags/MySQL/"},{"name":"CentOS","slug":"CentOS","permalink":"http://KKimSangHeon.github.io/tags/CentOS/"}]},{"title":"데이터 프리 기프티콘","slug":"defcon","date":"2017-08-11T06:07:04.000Z","updated":"2017-08-11T06:15:14.135Z","comments":true,"path":"2017/08/11/defcon/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/11/defcon/","excerpt":"","text":"참가배경-두 번째 참가한 해커톤 입니다. 첫 해커톤에 흥미를 느껴 다시한번 참가하게 되었습니다. IdeaVPN을 이용하여 스마트폰 데이터 사용량을 감소시키는 어플리케이션입니다.데이터 사용량을 감소시키기 위해 서버에 데이터를 전송하기 전 압축하여 보내고 서버에서 클라이언트로 데이터를 보낼때도 압축을 진행하게 됩니다.서버, 클라이언트는 toyVPN이라는 오픈소스를 활용하였습니다. 동작화면 서버의 주소, 포트, 암호를 입력하고 데.프.콘 바로가기 버튼을 누르면 VPN서버에 접속하게됩니다. github Repository","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"ID 해커톤","slug":"ID-해커톤","permalink":"http://KKimSangHeon.github.io/tags/ID-해커톤/"}]},{"title":"엄마가 보고있다","slug":"Mother-Is-Looking","date":"2017-08-11T05:53:02.000Z","updated":"2017-08-11T06:06:16.469Z","comments":true,"path":"2017/08/11/Mother-Is-Looking/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/11/Mother-Is-Looking/","excerpt":"","text":"참가배경-해커톤을 통해 다양한 사람을 만나고 해커톤이라는 콘테스트에 한번쯤 참가 해 보고싶었습니다. Idea에너톡 플러그인을 사용하여 현재 문제가 되는 청소년 인터넷 중독문제를 해결하고자 하였습니다. 또한 실시간 전력량을 확인할 수 있는 기능또한 추가하였습니다. 동작화면 어플리케이션을 실행시켜면 다음과 같이 “우리 집 PC 확인”, “우리집 전력 확인”을 선택할 수 있습니다. 우리 집 PC 확인 버튼을 눌러 현재 PC의 사용유무를 확인할 수 있으며 전원버튼을 눌러 컴퓨터를 종료할 수 있습니다. 우리 집 전력 확인 버튼을 누르면 실시간 전력량을 확인할 수 있습니다. github Repository","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"에너지 해커톤","slug":"에너지-해커톤","permalink":"http://KKimSangHeon.github.io/tags/에너지-해커톤/"}]},{"title":"1. 오라클 설치","slug":"database1","date":"2017-08-11T04:39:31.000Z","updated":"2017-08-16T00:08:01.330Z","comments":true,"path":"2017/08/11/database1/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/11/database1/","excerpt":"","text":"run sql command line을 켜고 conn system/manager 입력 // manager가 비번 conn /as sysdba //관리자로 로그인 mysql은 데이터베이스를 각각 생성하지만오라클을 테이블 스페이스가 존재하며 자신의 테이블스페이스에 테이블 생성 alter user hr account unlock; //hr계정을 언락함(사용하기 위해)alter user hr identified by “hr”; //비번을 hr로함 conn hr/hr //hr 계정으로 로그인 이클립스 - help - market place - toad 설치 자바가 데이터베이스에 접근하기 위해서는 jdbc가 필요. Connections탭에가서 new connection선택 User에 hr입력비번에 hr입력 OK클릭","categories":[{"name":"빅데이터 전문가과정","slug":"빅데이터-전문가과정","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/"},{"name":"Data Base","slug":"빅데이터-전문가과정/Data-Base","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/Data-Base/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"12. UDP 소켓","slug":"bigdata13","date":"2017-08-11T00:08:02.000Z","updated":"2017-08-11T04:36:14.025Z","comments":true,"path":"2017/08/11/bigdata13/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/11/bigdata13/","excerpt":"","text":"UDP1.비 연결 지향 프로그래밍2.TCP와 달리 연결되지 않은 상태로 데이터 통신을 하기 때문에 패킷이 유실될 가능성이 있다3.속도 면에서는 큰 장점이 있다. ( 처음 반응속도가 빠르다 ) TCP 서버 포트 6000 / UDP 서버 포트 6000 일 때 충돌이 날까?나지않는다. 다른 프로토콜이라서 그렇다. UDP Echo ServerUDPEchoServer.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class UDPEchoServer &#123; private static final int PORT = 6000; private static final int BUFFER_SIZE = 1000; public static void main(String[] args) &#123; DatagramSocket socket = null; try &#123; //1. Socket 생성 socket = new DatagramSocket(PORT); //2. 데이터 수신 DatagramPacket receivePacket = new DatagramPacket(new byte[BUFFER_SIZE], BUFFER_SIZE); while( true ) &#123; //3. 데이터 수신 대기 socket.receive( receivePacket ); //block //4. 수신 String message = new String( receivePacket.getData(), 0, receivePacket.getLength(), \"UTF-8\"); System.out.println( message ); //5. 데이터 송신 byte[] sendData = message.getBytes( \"UTF-8\" ); DatagramPacket sendPacket = new DatagramPacket( sendData, sendData.length, receivePacket.getAddress(), receivePacket.getPort() ); socket.send( sendPacket ); &#125; &#125; catch (SocketException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if( socket != null &amp;&amp; socket.isClosed() == false) &#123; socket.close(); &#125; &#125; &#125;&#125;UDP Echo ClientUDPEchoClient.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class UDPEchoClient &#123; private static final String SERVER_IP = \"192.168.111.1\"; private static final int SERVER_PORT = 6000; private static final int BUFFER_SIZE = 1024; public static void main(String[] args) &#123; DatagramSocket socket = null; Scanner scanner = null; try &#123; // 0. 키보드 연결 scanner = new Scanner(System.in); // 1. 소켓생성 socket = new DatagramSocket(); while (true) &#123; System.out.print(\"&gt;&gt;\"); String message = scanner.nextLine(); if( \"\".equals(message)) &#123; continue; &#125; if( \"quit\".equals( message )) &#123; break; &#125; //2. 전송패킷 생성 byte[] sendData = message.getBytes(\"utf-8\"); DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, new InetSocketAddress(SERVER_IP, SERVER_PORT)); //3. 전송 socket.send(sendPacket); //4. 메세지 수신 DatagramPacket receivePacket = new DatagramPacket( new byte[ BUFFER_SIZE], BUFFER_SIZE); socket.receive(receivePacket); message = new String( receivePacket.getData(), 0, receivePacket.getLength(), \"UTF-8\") ; System.out.println(\"&lt;&lt;\"+message); &#125; &#125; catch (SocketException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (socket != null &amp;&amp; socket.isClosed() == false) &#123; socket.close(); &#125; scanner.close(); &#125; &#125;&#125;","categories":[{"name":"빅데이터 전문가과정","slug":"빅데이터-전문가과정","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/"},{"name":"Java","slug":"빅데이터-전문가과정/Java","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"11.소켓과 스레드의 결합","slug":"bigdata12","date":"2017-08-09T04:15:08.000Z","updated":"2017-08-09T04:41:54.150Z","comments":true,"path":"2017/08/09/bigdata12/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/09/bigdata12/","excerpt":"","text":"여러 클라이언트가 접속가능한 서버EchoServerReceiveThread.java123456789101112131415161718192021222324252627282930313233343536373839public class EchoServer &#123; private static final int SERVER_PORT = 5000; public static void main(String[] args) &#123; ServerSocket serverSocket = null; try &#123; // 1. 서버 소켓 생성 serverSocket = new ServerSocket(); // 2. 바인딩( Binding ) InetAddress inetAddress = InetAddress.getLocalHost(); String localhostAddress = inetAddress.getHostAddress(); serverSocket.bind(new InetSocketAddress(localhostAddress, SERVER_PORT)); System.out.println(\"[Server] binding \" + localhostAddress); while(true) &#123; // 3. 연결 요청 기다림( accept) Socket socket = serverSocket.accept(); // 반복문 내에서 blocking이 되기떄문에 CPU를 많이먹지 않는다. new EchoServerReceiveThread( socket ).start(); &#125; &#125; catch (IOException e) &#123; // 서버소켓과 관련된 캐치 e.printStackTrace(); &#125; finally &#123; try &#123; if (serverSocket != null &amp;&amp; serverSocket.isClosed() == false) &#123; serverSocket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private static void consoLog( String log ) &#123; System.out.println( \"[server:\" ); &#125;&#125; EchoServerReceiveThread.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class EchoServerReceiveThread extends Thread &#123; private Socket socket; public EchoServerReceiveThread( Socket socket ) &#123; this.socket = socket; &#125; @Override public void run() &#123; // 4. 연결성공 InetSocketAddress remoteSocketAddress = (InetSocketAddress) socket.getRemoteSocketAddress(); int remoteHostPort = remoteSocketAddress.getPort(); String remoteHostAddress = remoteSocketAddress.getAddress().getHostAddress(); consoleLog(\"connected from \"+ remoteHostAddress); try &#123; // 5. I/O Stream 받아오기 InputStream is = socket.getInputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(is, \"UTF-8\")); PrintWriter pw = new PrintWriter(socket.getOutputStream(), true); // auto flush를 true로 한다. true로 안하면 // 버퍼가 다찬다음 나가기 때문에 늦게나간다. while (true) &#123; // 6. 데이터 읽기 String message = br.readLine(); if (message == null) &#123; // 정상종료 consoleLog(\"disconnection by client\"); break; &#125; consoleLog(\" received : \" + message); // 7. 데이터 쓰기 pw.println(message); &#125; &#125; catch (SocketException e) &#123; // 상대편이 소켓을 정상적으로 닫지 않고 종료한 경우 consoleLog(\"sudden closed by client\"); &#125; catch (IOException e) &#123; // 소켓과 관련된 캐치 e.printStackTrace(); &#125; finally &#123; try &#123; if (socket != null &amp;&amp; socket.isClosed() == false) &#123; socket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private void consoleLog(String log) &#123; System.out.println(\"[Server: \"+getId() + \"]\" + log); &#125;&#125;","categories":[{"name":"빅데이터 전문가과정","slug":"빅데이터-전문가과정","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/"},{"name":"Java","slug":"빅데이터-전문가과정/Java","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"10.쓰레드","slug":"bigdata11","date":"2017-08-09T02:42:34.000Z","updated":"2017-08-09T04:14:24.003Z","comments":true,"path":"2017/08/09/bigdata11/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/09/bigdata11/","excerpt":"","text":"MultiThreadEx.java12345678910111213141516171819202122232425public class MultiThreadEx &#123; public static void main(String[] args) &#123; Thread thread1 = new AlphabetThread(); //쓰레드 생성방법1 Thread thread2 = new Thread( new DigitThread()); //쓰레드 생성방법2 //매개변수로 Runnable이 구현된 객체를 받음 new Thread( new Runnable() &#123; //쓰레드 생성방법3 @Override public void run() &#123; for( char c = 'A'; c&lt;= 'z'; c++) &#123; System.out.print( c ); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start();; thread1.start(); thread2.start(); &#125;&#125; DigitThread.java12345678910111213public class DigitThread implements Runnable&#123; public void run() &#123; for(int i = 0; i &lt; 10; i++) &#123; System.out.print( i ); try &#123; Thread.sleep( 1000 ); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; AlphabetThread.java1234567891011121314public class AlphabetThread extends Thread&#123; @Override public void run() &#123; for( char c = 'a'; c &lt;= 'z'; c++) &#123; System.out.print( c ); try &#123; Thread.sleep( 1000 ); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","categories":[{"name":"빅데이터 전문가과정","slug":"빅데이터-전문가과정","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/"},{"name":"Java","slug":"빅데이터-전문가과정/Java","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"9. TCP 소켓 프로그래밍1","slug":"bigdata10","date":"2017-08-09T00:05:06.000Z","updated":"2017-08-09T02:42:16.840Z","comments":true,"path":"2017/08/09/bigdata10/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/09/bigdata10/","excerpt":"","text":"TCPTCP : 스트림(stream) 통신 프로토콜양쪽의 소켓이 연결된 상태에서 통신이 가능하다. (연결지향 프로토콜)신뢰성 있는 데이터 통신한 번 연결이 되면 연결이 끊어 질 때까지 송신한 데이터는 차례대로 목적지의 소켓에 전달자바는 java.net 패키지에 TCP 소켓 프로그래밍을 쉽게 하도록 관련 클래스를 제공하고 있다.라이브러리의 사용법과 동작순서를 정확하게 이해하고 있어야 한다.ServerSocket과 Socket 클래스를 사용하게 된다. TCPServer.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class TCPSever &#123; private static final int SERVER_PORT = 5000; public static void main(String[] args) &#123; ServerSocket serverSocket = null; try &#123; // 1. 서버 소켓 생성 serverSocket = new ServerSocket(); // 2. 바인딩( Binding ) InetAddress inetAddress = InetAddress.getLocalHost(); String localhostAddress = inetAddress.getHostAddress(); serverSocket.bind(new InetSocketAddress(localhostAddress, SERVER_PORT)); System.out.println(\"[Server] binding \" + localhostAddress); // 3. 연결 요청 기다림( accept) Socket socket = serverSocket.accept(); // blocking // 4. 연결성공 InetSocketAddress remoteSocketAddress = (InetSocketAddress) socket.getRemoteSocketAddress(); int remoteHostPort = remoteSocketAddress.getPort(); String remoteHostAddress = remoteSocketAddress.getAddress().getHostAddress(); System.out.println(\"[server] connected from \" + remoteHostAddress + remoteHostPort); try &#123; // 5. I/O Stream 받아오기 InputStream is = socket.getInputStream(); OutputStream os = socket.getOutputStream(); while (true) &#123; // 6. 데이터 읽기 byte[] buffer = new byte[256]; int readByteCount = is.read(buffer); // block if (readByteCount &lt;= -1) &#123; //정상종료 System.out.println(\"[server] disconnection by client\"); break; &#125; String data = new String(buffer, 0, readByteCount, \"utf-8\"); System.out.println(\"[server] received : \" + data); // 7. 데이터 쓰기 os.write(data.getBytes(\"utf-8\")); &#125; &#125; catch(SocketException e) &#123; // 상대편이 소켓을 정상적으로 닫지 않고 종료한 경우 System.out.println(\"[server] sudden closed by client\"); &#125;catch (IOException e) &#123; // 소켓과 관련된 캐치 e.printStackTrace(); &#125; finally &#123; try &#123; if (socket != null &amp;&amp; socket.isClosed() == false) &#123; socket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; catch (IOException e) &#123; // 서버소켓과 관련된 캐치 e.printStackTrace(); &#125; finally &#123; try &#123; if (serverSocket != null &amp;&amp; serverSocket.isClosed() == false) &#123; serverSocket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; TCPClient.java123456789101112131415161718192021222324252627282930313233343536373839404142434445public class TCPClient &#123; private static final String SERVER_IP = \"192.168.111.1\"; private static final int SERVER_PORT = 5000; public static void main(String[] args) &#123; Socket socket = null; try &#123; // 1. Socket 생성 socket = new Socket(); // 2. 서버 연결 socket.connect(new InetSocketAddress(SERVER_IP, SERVER_PORT)); // 3. I/O 받아오기 InputStream is = socket.getInputStream(); OutputStream os = socket.getOutputStream(); // 4. 쓰기 / 읽기 String data = \"hello\"; os.write( data.getBytes( \"utf-8\" )); byte[] buffer = new byte[256]; int readByteCount = is.read( buffer ); if( readByteCount &lt;= -1) &#123; System.out.println( \"[client] disconnection by server\"); return; &#125; data = new String( buffer, 0, readByteCount, \"utf-8\"); System.out.println(\"[client] received:\"+ data); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (socket != null &amp;&amp; socket.isClosed() == false) &#123; socket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 에코서버, 클라이언트 만들기 EchoServer.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class EchoServer &#123; private static final int SERVER_PORT = 5000; public static void main(String[] args) &#123; ServerSocket serverSocket = null; try &#123; // 1. 서버 소켓 생성 serverSocket = new ServerSocket(); // 2. 바인딩( Binding ) InetAddress inetAddress = InetAddress.getLocalHost(); String localhostAddress = inetAddress.getHostAddress(); serverSocket.bind(new InetSocketAddress(localhostAddress, SERVER_PORT)); System.out.println(\"[Server] binding \" + localhostAddress); // 3. 연결 요청 기다림( accept) Socket socket = serverSocket.accept(); // blocking // 4. 연결성공 InetSocketAddress remoteSocketAddress = (InetSocketAddress) socket.getRemoteSocketAddress(); int remoteHostPort = remoteSocketAddress.getPort(); String remoteHostAddress = remoteSocketAddress.getAddress().getHostAddress(); System.out.println(\"[server] connected from \" + remoteHostAddress + remoteHostPort); try &#123; // 5. I/O Stream 받아오기 InputStream is = socket.getInputStream(); BufferedReader br = new BufferedReader( new InputStreamReader( is, \"UTF-8\" )); PrintWriter pw = new PrintWriter(socket.getOutputStream(), true); // auto flush를 true로 한다. true로 안하면 //버퍼가 다찬다음 나가기 때문에 늦게나간다. while (true) &#123; // 6. 데이터 읽기 String message = br.readLine(); if ( message == null ) &#123; //정상종료 System.out.println(\"[server] disconnection by client\"); break; &#125; System.out.println(\"[server] received : \" + message); // 7. 데이터 쓰기 pw.println(message); &#125; &#125; catch(SocketException e) &#123; // 상대편이 소켓을 정상적으로 닫지 않고 종료한 경우 System.out.println(\"[server] sudden closed by client\"); &#125;catch (IOException e) &#123; // 소켓과 관련된 캐치 e.printStackTrace(); &#125; finally &#123; try &#123; if (socket != null &amp;&amp; socket.isClosed() == false) &#123; socket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; catch (IOException e) &#123; // 서버소켓과 관련된 캐치 e.printStackTrace(); &#125; finally &#123; try &#123; if (serverSocket != null &amp;&amp; serverSocket.isClosed() == false) &#123; serverSocket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; EchoClient.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class EchoClient &#123; private static final String SERVER_IP = \"192.168.111.1\"; private static final int SERVER_PORT = 5000; static Scanner scanner; public static void main(String[] args) &#123; Socket socket = null; try &#123; // 1. Socket 생성 socket = new Socket(); // 2. 서버 연결 socket.connect(new InetSocketAddress(SERVER_IP, SERVER_PORT)); // 3. I/O 받아오기 BufferedReader br = new BufferedReader( new InputStreamReader(socket.getInputStream())); PrintWriter pw = new PrintWriter( new OutputStreamWriter(socket.getOutputStream(),\"UTF-8\"),true); // 4. 쓰기 / 읽기 scanner = new Scanner(System.in); while(true) &#123; System.out.print( \"&gt;&gt;\" ); String message = scanner.nextLine(); if(\"exit\".equals(message)) &#123; break; &#125; //메세지 보내기 pw.println( message ); //에코 메시지 받기 String echoMessage = br.readLine(); if( echoMessage == null) &#123; System.out.println(\"[client] Disconnection by Server\"); &#125; //출력 System.out.println( \"&lt;&lt;\" + echoMessage ); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (socket != null &amp;&amp; socket.isClosed() == false) &#123; socket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; scanner.close(); &#125; &#125;&#125;","categories":[{"name":"빅데이터 전문가과정","slug":"빅데이터-전문가과정","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/"},{"name":"Java","slug":"빅데이터-전문가과정/Java","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"8. 네트워크와 소켓의 이해","slug":"bigdata9","date":"2017-08-07T05:01:36.000Z","updated":"2017-08-08T07:09:50.450Z","comments":true,"path":"2017/08/07/bigdata9/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/07/bigdata9/","excerpt":"","text":"네트워크란?“유/무선 으로 연결되어 있는 Device들의 집합 ” 네트워킹?디바이스들 간에 미리 정의된 프로토콜을 사용하여 데이터를 교환 하는것.이를위해서는 프로토콜이 필요하다. 클라이언트 서버구조Client -&gt; Serverrequest Server -&gt; Clientresponse(ACK) 서버 : 서버프로그램이 돌고있는 장비 프로토콜디바이스간 데이터 통신을 위해 필요한 규약Hyper Text Transfer ProtocolFile Transfer ProtocolSMTP 등등. 패킷패킷은 Header, Body부분으로 나뉜다.Header은 Address, checksum 등 으로 구성되고Body는 Data로 구성된다. 소켓소켓?TCP / IP 프로토콜의 프로그래머 인터페이스를 의미네트워크 프로그래밍에서 개발자에게 네트워크에 접근할 수 있는 인터페이스 제공 포트?프로세스를 구분할 수 있는 주소16비트 정수를 사용한다. Address =&gt; IP Address Socket Address =&gt; IP Address + Port LocalHost.java123456789101112131415161718192021222324public class LocalHost &#123; public static void main(String[] args) &#123; try &#123; InetAddress inetAddress = InetAddress.getLocalHost(); String hostName = inetAddress.getHostName(); String hostAddress = inetAddress.getHostAddress(); byte[] addresses = inetAddress.getAddress(); //byte배열로 ip 받아오는 함수 System.out.println(hostName); //컴퓨터이름 System.out.println(hostAddress); //ipconfig의 결과와 같음 for( int i = 0 ; i &lt; addresses.length ; i++) &#123; System.out.print( addresses[i] &amp; 0x000000ff); //MSB로 인해 음수가 나와 마스킹을 해주는것. if( i &lt; 3 ) &#123; System.out.print(\".\"); &#125; &#125; &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; &#125;&#125; NSLookup기능을 구현해보자. NSLookup.java12345678910111213141516171819202122232425262728public class NSLookup &#123; public static void main(String[] args) &#123; String host = \"\"; Scanner sc = new Scanner(System.in); while (!(host.equals(\"exit\"))) &#123; try &#123; System.out.print(\"&gt;\"); host = sc.nextLine(); InetAddress[] inetAddresses = InetAddress.getAllByName(host); for (InetAddress inetAddress : inetAddresses) &#123; System.out.println(inetAddress.getHostAddress()); &#125; &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; System.out.println(); &#125; &#125;&#125;","categories":[{"name":"빅데이터 전문가과정","slug":"빅데이터-전문가과정","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/"},{"name":"Java","slug":"빅데이터-전문가과정/Java","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"7. 스트림","slug":"bigdata8","date":"2017-08-07T00:17:29.000Z","updated":"2017-08-08T02:11:38.343Z","comments":true,"path":"2017/08/07/bigdata8/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/07/bigdata8/","excerpt":"","text":"InputStream - 1 byte 단위로 읽는놈ByteInputStreamFileInputStream FilterInputStream(보조스트림) OutputStream - 1 byte 단위로 쓰는놈ByteOutputStreamFileOutputStream FilterOutputStream(보조스트림) Reader - char(2byte, 자바에서는 3byte(UTF-8)) 단위로 읽는놈FileReader(InputStreamReader을 상속)BufferedReader Writer - char(2byte, 자바에서는 3byte(UTF-8)) 단위로 쓰는놈FileWriterBufferedWriter 사용방법1.주 스트림을 소스에 꽂는다.2.보조스트림은 주 스트림에 꽂는다.3.프로그램에서 보조스트림을 사용해서 읽는다. IOExample.java12345678910111213141516171819202122232425public class IOExample &#123; public static void main(String[] args) &#123; byte[] src = &#123;0, 1, 2, 3&#125;; byte[] dest = null; try &#123; InputStream is = new ByteArrayInputStream( src ); OutputStream os = new ByteArrayOutputStream(); int data = -1; while( (data = is.read()) != -1 ) &#123; //data에 1바이트식 저장됨 os.write(data); &#125; dest = ((ByteArrayOutputStream)os).toByteArray(); System.out.println( Arrays.toString( src )); System.out.println( Arrays.toString( dest )); &#125; catch( IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; FileCopy.java1234567891011121314151617181920212223242526272829303132public class FileCopy &#123; public static void main(String[] args) &#123; InputStream is = null; OutputStream os = null; try &#123; is = new FileInputStream( \"./dooly.png\" ); os = new FileOutputStream( \"./dooly2.png \"); int data = 1; while( (data = is.read()) !=-1 ) &#123; os.write( data ); &#125; &#125; catch (FileNotFoundException e) &#123; System.out.println(\"파일없음\" + e); &#125; catch (IOException e) &#123; System.out.println(\"I/O 에러\" + e); &#125; finally &#123; try&#123; if( is != null) &#123; is.close(); &#125; if( os != null) os.close(); &#125;catch(IOException e) &#123; &#125; &#125; &#125;&#125; 123.txt를 UTF-8로 만들고(직접만들자)FileReader로 1바이트씩 읽어보고FileInputStream으로 3(UTF-8이므로..) 바이트씩 읽어보자 FileReaderTest.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class FileReaderTest &#123; public static void main(String[] args) &#123; Reader reader = null; InputStream is = null; try &#123; //비교를 위해서 두개를 만들었다. reader = new FileReader( \"./hello.txt\" ); //char 기반 is = new FileInputStream( \"./hello.txt \"); //바이트기반 int count = 0; int data = -1; while( (data = reader.read()) != -1 ) &#123; count++; System.out.println( (char)data ); &#125; System.out.println( \"\\n읽은 회수: \" + count ); System.out.println(\"=========\"); count = 0; data = -1; while( (data = is.read() )!= -1) &#123; count++; System.out.println( (char) data); &#125; &#125; catch (FileNotFoundException e) &#123; System.out.println( \"파일 없음 \" + e ); &#125; catch (IOException e) &#123; System.out.println(\"I/O 에러:\" + e); &#125; finally &#123; try &#123; if( reader != null) &#123; reader.close(); &#125; if( is != null) &#123; is.close(); &#125; &#125;catch(IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 보조스트림을 사용하여 보자 BufferedOutputStreamTest.java12345678910111213141516171819202122232425262728public class BufferedOutputStreamTest &#123; public static void main(String[] args) &#123; BufferedOutputStream bos = null; try &#123; bos = new BufferedOutputStream( new FileOutputStream( \"./123.txt\" ), 5 ); //버퍼가 5의 크기를 갖는다 5만큼 차면 flush(비우기)가 발생함 for(int i='1' ; i &lt;= '9' ; i++) &#123; bos.write( i ); //bos.flush(); //한번쓰고 플러시하고를 반복.(버퍼를 5로 설정한 의미가 없어짐..) &#125; &#125; catch (FileNotFoundException e) &#123; System.out.println(\"파일 없음: \" + e); &#125; catch (IOException e) &#123; System.out.println(\"I/O 에러\" + e); &#125; finally &#123; try &#123; if( bos!= null) &#123; bos.close(); &#125; &#125; catch( IOException e) &#123; &#125; &#125; &#125;&#125; 주스트림 FileReader을 꽂고보조스트림 BufferedReader을 꽂음. BufferedOutputStreamTest.java123456789101112131415161718192021222324252627282930public class BufferedReaderTest &#123; public static void main(String[] args) &#123; BufferedReader br = null; try &#123; br = new BufferedReader( new FileReader(\"./src/io/BufferedReaderTest.java\")); int index = 0; String line = null; while((line = br.readLine())!= null) &#123; System.out.println(++index + \" : \" + line); &#125; &#125; catch( FileNotFoundException e) &#123; System.out.println(\"파일없음: \" + e); &#125; catch( IOException e) &#123; System.out.println(\"I/O 에러\" + e); &#125; finally &#123; try &#123; if(br != null) &#123; br.close(); &#125; &#125;catch(IOException e) &#123; System.out.println(\"파일없음\"+e); &#125; &#125; &#125;&#125; MS 949로 텍스트 파일을 하나만들자.FileInputStream 주 스트림을 바이트단위로 꽂고 InputStreamReaderTest.java12345678910111213141516171819202122232425262728293031public class InputStreamReaderTest &#123; public static void main(String[] args) &#123; Reader reader = null; try &#123; reader = new InputStreamReader( new FileInputStream(\"./ms949.txt\"), \"MS949\" ); int data = -1; while( ( data = reader.read()) != -1 ) &#123; System.out.println( (char)data ); &#125; &#125; catch (UnsupportedEncodingException e) &#123; System.out.println(\"지원하지 않는 charset\"); &#125; catch (FileNotFoundException e) &#123; System.out.println(\"파일이 없음:\" + e); &#125; catch (IOException e) &#123; System.out.println(\"IOException:\"+e); &#125; finally &#123; try &#123; if( reader!=null) &#123; reader.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; System.in으로 부터 스트림을 생성해보자KeyboardTest.java12345678910111213141516171819202122232425262728293031323334353637383940public class KeyboardTest &#123; public static void main(String[] args) &#123; BufferedReader br = null; try &#123; br = new BufferedReader(new InputStreamReader(System.in, \"UTF-8\")); //키보드에서 라인 단위로 읽기 위해 br사용 //readLine() 메소드를 쓰기위해 while(true) &#123; System.out.print( \"&gt;&gt;\" ); String line = br.readLine(); if (line == null ) &#123; break; &#125; if( \"exit\".equals( line )) &#123; break; &#125; System.out.println(line); &#125; &#125; catch (UnsupportedEncodingException e) &#123; System.out.println(\"지원하지 않는 charset : \"+e); &#125; catch (IOException e) &#123; System.out.println(\"I/O 에러\" + e); &#125; finally &#123; try &#123; if(br != null) &#123; br.close(); &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 파일 객체사용해보자.tokenizer도 사용해보자PhoneList01.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class PhoneList01 &#123; public static void main(String[] args) &#123; BufferedReader br = null; try &#123; File file = new File( \"./phone.txt\" ); if( file.exists() == false ) &#123; System.out.println( \"파일이 존재하지 않습니다\" ); return; &#125; System.out.println( \"========== 파일정보 =========\" ); System.out.println( \"경로\" + file.getAbsolutePath() ); System.out.println( \"크기: \"+ file.length()+\"Bytes\" ); Date date = new Date( file.lastModified() ); SimpleDateFormat sdf = new SimpleDateFormat (\"yyyy-MM-dd hh:mm:ss\"); System.out.println( \"마지막 수정일:\" + sdf.format(date)); System.out.println( \"전화번호\"); br = new BufferedReader( new InputStreamReader( new FileInputStream(file),\"UTF-8\") ); String line = null; while((line = br.readLine())!=null) &#123; //System.out.println(line); StringTokenizer st = new StringTokenizer(line, \"\\t \"); int index = 0; while( st.hasMoreTokens() ) &#123; String s = st.nextToken(); if(index == 0 ) &#123; System.out.print( s + \":\"); &#125; else if( index ==1 ) &#123; System.out.print( s+ \"-\"); &#125; else if( index == 2) &#123; System.out.print( s+ \"-\"); &#125; else &#123; System.out.print( s); &#125; index++; &#125; System.out.print(\"\\n\"); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch ( UnsupportedEncodingException e) &#123; System.out.println(\"지원하지 않는 charset\"); &#125; catch(IOException e) &#123; &#125; finally &#123; if( br !=null) &#123; try &#123; br.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;위에서 했던 작업을 Scanner로 간편하게 해보자PhoneList02.java1234567891011121314151617181920212223242526272829303132333435363738394041424344public class PhoneList02 &#123; public static void main(String[] args) &#123; Scanner scanner = null; try &#123; File file = new File(\"./phone.txt\"); if (file.exists() == false) &#123; System.out.println(\"파일이 존재하지 않습니다\"); return; &#125; System.out.println(\"========== 파일정보 =========\"); System.out.println(\"경로\" + file.getAbsolutePath()); System.out.println(\"크기: \" + file.length() + \"Bytes\"); Date date = new Date(file.lastModified()); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\"); System.out.println(\"마지막 수정일:\" + sdf.format(date)); System.out.println(\"전화번호\"); // 여기까지는 PhoneList01과 같다 scanner = new Scanner(file); while( scanner.hasNext() ) &#123; String name = scanner.next(); String phone1 = scanner.next(); String phone2 = scanner.next(); String phone3 = scanner.next(); System.out.println(name + \":\" + phone1 + \"-\" + phone2 + \"-\" + phone3); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if ( scanner != null ) &#123; scanner.close(); &#125; &#125; &#125;&#125;","categories":[{"name":"빅데이터 전문가과정","slug":"빅데이터-전문가과정","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/"},{"name":"Java","slug":"빅데이터-전문가과정/Java","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"6. 제네릭, 가변변수, 익명클래스, Collection프레임워크","slug":"bigdata7","date":"2017-08-07T00:04:17.000Z","updated":"2017-08-07T06:04:14.976Z","comments":true,"path":"2017/08/07/bigdata7/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/07/bigdata7/","excerpt":"","text":"제네릭오버로딩을 대체할 수 있으며 유용하다. 메소드에 제네릭을 적용12345678public &lt;T,P,Q,R&gt; void println( T t ) &#123; System.out.println(t);&#125;public static void main(String args[]) &#123; println( 10 ); println( true );&#125; 메소드 반환형에 제네릭 적용1234567public &lt;T, P&gt; List&lt;P&gt; println( T t ) &#123; System.out.println( t ); List&lt;P&gt; list = new ArrayList&lt;P&gt;(); return list;&#125; 제네릭 배열을 어떻게 동적으로 생성하느냐12345678910111213public MyStack( E[] objects, int capacity ) &#123; //buffer = new E[ capacity ]; 오류발생 //방법1. buffer = ( E[] ) Array.newInstance(objects.getClass(), capacity); //방법2. 방법2가 더 선호된다. 객체를 생성하지 않아도 된다는점 때문에 buffer = ( E[] )Array.newInstance(Object.class, capacity); //방법3. 방법 2와 일치하는방식이다. buffer = ( E[] )new Object[capacity]; //방법 3을 제일 많이 쓴다. this.capacity = capacity; currentIndex = 0;&#125; 제네릭 호출 방식123456789101112131415public static void main(String[] args) &#123; MyStack&lt;String&gt; stack = new MyStack&lt;String&gt;(3); //String의 스택을 생성한다. MyStack&lt;?&gt; stack = new MyStack&lt;String&gt;(3); //모든 타입의 객체를 생성하겠다.&#125;public .... f(List&lt;? extends Shape&gt;)&#123; // Shape를 상속한 것들의 리스트를 파라미터로 받음 //와일드 카드를 사용해서 제네릭 타입 제한하기. ...&#125; 가변변수가변변수를 배우기 전에는 파라미터에 배열을 넣을 생각을 할 것이다. 하지만 이를 대체할 수 있는것이 가변변수이다. 1234567891011121314public static void main(String args[]) &#123; println2( \"둘리\" ); println2( \"둘리\", \"마이콜\" ); println2( \"둘리\", \"마이콜\", \"또치\"); //println3( new String[]&#123;\"둘리\", \"마이콜\", \"또치\"&#125;); 배열사용 &#125; public static void println2(String ... params) &#123; for( String s : params)&#123; System.out.println(s); &#125; &#125; 아래의 경우 Object를 파라미터로 주면 캐스팅을 계속 해줘야한다.1234567public &lt;T&gt; void println( T t) &#123; System.out.println(t);&#125;public void println(Object o ) &#123; System.out.println(o);&#125; 익명클래스파라미터를 전달하는 부분에서 객체를 생성하여 메소드를 호출.객체를 생성하지 않고 메소드 호출부분에서 객체를 생성함.123456789//anonymous class objectdraw( new Drawable() &#123; @Override public void draw() &#123; // TODO Auto-generated method stub System.out.println(\"한 번만 만들고 버릴 도형을 그렸습니다\"); &#125; &#125;); CollectionCollection인터페이스는 inteator() 메소드를 갖고 있다.List, Set 클래스는 Collection클래스를 구현하며 List는 중복허용, 순서를 갖는다. 그러나 Set는 중복을 허용하지 않으며 순서를 갖지 않는다.List인터페이스는 add, get, remove를 갖는다.LinkedList, ArrayList가 List 인터페이스를 구현한다. ArrayList는 빈번한 삽입,삭제가 일어나는 경우 사용하면 안된다. 그 과정이 길기 떄문에.LinkedList는 삽입삭제가 유용하나 10000번째 놈이면 10000번을 next해야한다. 멀티스레드에서 ArrayList, LinkedList의 add를 사용할 때는 동기화 처리를 해줘야한다. 하지만 Vector은 멀티스레드 환경에서 동기화를 해주지 않아도 된다. ArrayList , LinkedList, VectorTest21234567891011121314151617181920212223242526272829303132333435public class ArrayListTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); LinkedList&lt;String&gt;(); Vector&lt;String&gt;(); //삽입 list.add( \"둘리\" ); list.add( \"마이콜\" ); list.add( \"도우넛\" ); //순회1 int count = list.size(); for( int i = 0; i &lt; count ; i++) &#123; String s = list.get( i ); System.out.println(i); &#125; //제거 list.remove( 1 ); //순회2 Iterator&lt;String&gt; it = list.iterator(); while( it.hasNext() ) &#123; String s = it.next(); System.out.println( s ); &#125; //순회3 for( String s : list) &#123; System.out.println( s ); &#125; &#125;&#125; Vector1.2 시대의 Vector인터페이스는 addElement, elementAt, removeElement, elements메소드를 갖고 있다. 그 후 1.2이후에 생긴 List를 구현하여 List의 메소드를 갖는다. Vector를 사용하려면 Vector 메소드를 사용하거나 List 인터페이스 내부의 메소드만 사용하든가 해야 복잡해지지 않는다. 과거 Vector을 사용하는 방식. 호환성 때문에 존재할뿐.. 사용일 지양하자.VectorTest.java123456789101112131415161718192021222324252627public class VectorTest &#123; public static void main(String[] args) &#123; Vector&lt;String&gt; v = new Vector&lt;String&gt;(); v.addElement( \"둘리\" ); v.addElement( \"마이콜\" ); v.addElement( \"도우넛\" ); //순회1 Enumeration&lt;String&gt; e = v.elements(); while( e.hasMoreElements() ) &#123; String s = e.nextElement(); System.out.println( s ); &#125; //삭제 v.removeElementAt( 1 ); System.out.println(\"=====================\"); //순회2 int count = v.size(); for( int i=0; i&lt; count; i++) &#123; String s = v.elementAt( i ); System.out.println( s ); &#125; &#125;&#125; SetSet 인터페이스는 key, value로 구성된다. key를 통해 value에 접근할 수 있다.HashSet, TreeSet가 Map인터페이스를 구현한다.hashCode를 오버라이드 하여 사용하여야 한다. 123456789101112131415161718192021222324252627282930public class HashSetTest &#123; public static void main(String[] args) &#123; Set&lt;Value&gt; set = new HashSet&lt;Value&gt;(); Value v1 =new Value(10); Value v2 =new Value(5); Value v3 =new Value(10); Value v4 =new Value(20); set.add(v1); set.add(v2); set.add(v3); set.add(v4); //존재여부 확인 System.out.println(set.contains(new Value(10))); //삭제 set.remove( new Value(10) ); //순회 Iterator&lt;Value&gt; it = set.iterator(); while( it.hasNext() )&#123; Value v = it.next(); System.out.println(v); &#125; &#125;&#125; 성능향상을 위해 hash를 오버라이드 한다.12345678910111213141516171819202122232425262728293031323334public class Value &#123; private int value; public Value( int value ) &#123; this.value = value; &#125; @Override public String toString() &#123; return \"Value [value=\" + value + \"]\"; &#125; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + value; return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Value other = (Value) obj; if (value != other.value) return false; return true; &#125; Stack12345678910111213141516171819202122public class StackTest &#123; public static void main(String[] args) &#123; Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); stack.push(\"둘리\"); stack.push(\"마이콜\"); stack.push(\"도우넛\"); stack.push(\"길동\"); System.out.println( stack.isEmpty() ); System.out.println( stack.pop() ); System.out.println( stack.pop() ); System.out.println( stack.peek() ); //pop을 하지않고 확인만 System.out.println( stack.pop() ); System.out.println( stack.pop() ); //스택은 비어있는 경우 pop호출 시 예외가 발생한다. System.out.println( stack.pop() ); &#125;&#125; Queue123456789101112131415161718192021222324public class QueueTest &#123; public static void main(String[] args) &#123; Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); queue.offer(\"둘리\"); queue.offer(\"마이콜\"); queue.offer(\"도우너\"); queue.offer(\"길동\"); System.out.println( queue.isEmpty() ); System.out.println( queue.poll() ); System.out.println( queue.poll() ); System.out.println( queue.peek() ); System.out.println( queue.poll() ); System.out.println( queue.poll() ); System.out.println( queue.isEmpty() ); System.out.println( queue.poll() ); //스택은 예외가 발생했지만 큐는 null이 리턴된다. &#125;&#125; MapMap 인터페이스가 존재하는데 HashMap, HashTable가 이를 구현한다. 1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); map.put(\"둘리\", 100); map.put(\"마이콜\", 50); map.put(\"도우넛\", 80); map.put(\"길동\", 90); //중복 map.put( \"둘리\" , 0); //덮어쓴다. //auto unboxing int score = map.get( \"둘리\" ); System.out.println(score); map.remove( \"둘리\" ); //평균 ( 키를 모르는데 어떻게할까?) int sum = 0; Set&lt;String&gt; keySet = map.keySet(); Iterator&lt;String&gt; it = keySet.iterator(); while( it.hasNext() ) &#123; String key = it.next(); System.out.println( key ); int s = map.get( key ); sum += s; &#125; System.out.println( \"평균 : \"+ sum / keySet.size() );&#125;","categories":[{"name":"빅데이터 전문가과정","slug":"빅데이터-전문가과정","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/"},{"name":"Java","slug":"빅데이터-전문가과정/Java","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"5.자바기본API(유틸리티API)","slug":"bigdata6","date":"2017-08-04T05:10:31.000Z","updated":"2017-08-07T06:04:11.439Z","comments":true,"path":"2017/08/04/bigdata6/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/04/bigdata6/","excerpt":"","text":"날짜date 보다는 calendar을 쓰라고 권고한다. DateWrapperClassTest.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class DateTest &#123; public static void main(String[] args) &#123; Date now = new Date(); System.out.println( now ); printDate1(now); printDate2(now); // 특정시간 세팅(200/08/04) Date d1 = new Date(100, 7, 4, 14, 30, 30); printDate2( d1 ); //1970년 1월 1일 00:00:00 기준 //milliseconds 값을 세팅 Date d3 = new Date( 24L * 60 * 60 * 1000 * 365 * 30); printDate2(d3); &#125; private static void printDate1( Date date ) &#123; SimpleDateFormat sdf = new SimpleDateFormat( \"YYYY년 MM월 dd일 hh시 mm분 ss초\" ); System.out.println(sdf.format(date)); &#125; private static void printDate2( Date date) &#123; //년도 (+1900) int year = date.getYear(); //월(0~11) int month = date.getMonth(); //일 int day = date.getDay(); //시 int hour = date.getHours(); //분 int minutes = date.getMinutes(); //초 int seconds = date.getSeconds(); System.out.println( (year + 1900) + \"년 \" + (month + 1)+ \"월 \" + day + \"일 \" + hour + \"시 \" + minutes + \"분\" + seconds + \"초\" ); &#125;&#125; 싱글톤어플리케이션에서 객체 하나만 유지하고 싶을 떄 이 방법을 쓴다.Singleton.java123456789101112131415public class Singleton &#123; private static Singleton instance; public static Singleton getInstance() &#123; if(instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; private Singleton() &#123; //생성자를 private로 하여 객체 생성을 외부에서 불가능하도록 &#125;&#125;싱글톤 클래스를 활용해보자SingletonTest.java123456789101112public class SingletonTest &#123; public static void main(String[] args) &#123; Singleton s1 = Singleton.getInstance(); Singleton s2 = Singleton.getInstance(); Singleton s3 = Singleton.getInstance(); System.out.println(s1 == s2); System.out.println(s2 == s3); &#125;&#125; CalendarCalendar클래스는 추상클래스이다.(객체생성 불가능)WrapperClassTest.java12345678910111213141516171819202122232425262728293031323334public class CalendarTest &#123; public static void main(String[] args) &#123;// Calendar cal = new Calendar(); //추상클래스라 객체생성 불가능 Calendar cal = Calendar.getInstance(); //어플리케이션에서 이 객체 하나만 유지하고 싶을 떄 이 방법을 쓴다. 싱글톤 패턴이라함 printDate( cal ); &#125; public static void printDate( Calendar cal ) &#123; String[] days = &#123;\"일\",\"월\",\"화\",\"수\",\"목\",\"금\",\"토\"&#125;; int year = cal.get( Calendar.YEAR ); int month = cal.get( Calendar.MONTH ); int date = cal.get( Calendar.DATE ); //1(일요일) ~ 7(토요일) int day = cal.get( Calendar.DAY_OF_WEEK); int hour = cal.get( Calendar.HOUR ); int minute = cal.get( Calendar.MINUTE ); int seconds = cal.get( Calendar.SECOND ); System.out.println( (year) + \"년 \" + (month + 1)+ \"월 \" + date + \"일 \" + \"(\" + days[day-1] + \")\" + hour + \"시 \" + minute + \"분\" + seconds + \"초\" ); &#125;&#125; WrapperClassTest.java1","categories":[{"name":"빅데이터 전문가과정","slug":"빅데이터-전문가과정","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/"},{"name":"Java","slug":"빅데이터-전문가과정/Java","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"4. 자바기본 API(equals, wrapper클래스)","slug":"bigdata5","date":"2017-08-03T02:25:31.000Z","updated":"2017-08-07T06:04:11.018Z","comments":true,"path":"2017/08/03/bigdata5/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/03/bigdata5/","excerpt":"","text":"StringString 인스턴스 안에는 char 배열이 존재하는것이다.String은 toString를 오버라이딩 하여 안에 내용이 출력된다.toString를 오버라이딩 하여 인스턴스에 대한 정보를 확인할 수 있게 만드는 것은 좋은 습관이다. 디버깅할때 편하다는 장점이 있다. equals결과를 예측해보자12345678910111213141516171819202122232425262728293031public class EqualsTest &#123; public static void main(String[] args) &#123; Point point1 = new Point(10, 20); Point point2 = new Point(10, 20); Point point3 = point2; // ==연산자에서 두 개의 항이 객체 참조 변수 인 경우 // 두 개체의 동일 여부(동일성) System.out.println( point1 == point2 ); //false System.out.println( point2 == point3 ); //true //equals는 오버라이딩이 되지 않았을 경우 참조값 비교를 함.(동질성 비교) //해쉬코드를 갖고와서 비교를함(해쉬코드==참조값) System.out.println( point1.equals(point2) ); //false System.out.println( point2.equals(point3) ); //true System.out.println(\"================\"); //String 객체와 비교 //String는 equals가 오버라이딩 되어있다. String s1 = new String( \"hello\" ); String s2 = new String( \"hello\" ); String s3 = s2; System.out.println( s1 == s2 ); //false System.out.println( s2 == s3 ); //true System.out.println( s1.equals(s2) ); //true System.out.println( s2.equals(s3) ); //true &#125; equals를 오버라이딩 해보자hashCode()메소드도 오버라이딩이 필요하다.자바에서는 hashCode() equal() 메소드를 동시에 오버라이드 해야한다.equals 조건을 제곱으로 한다면 hashCode도 제곱으로 변경해주어야 한다.그렇지 않으면 해쉬맵 해쉬 셋을 쓸 때 어려워진다.Point.java123456789101112131415161718192021222324252627282930public class Point &#123; private int x; private int y;.. @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + x; result = prime * result + y; return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Point other = (Point) obj; if (x != other.x) return false; if (y != other.y) return false; return true; &#125; 결과를 예측해보자12345678910// String Literal // 문자열 상수 Pool에 있는것을 재사용함// 문자열 상수 Pool을 공유하기 때문에 문자열의 수정이 불가능하다.// str1의 변경은 가능하나 문자열 상수인 hello의 값이 변경 불가능하다는것.String str1 = \"hello\";String str2 = \"hello\";String str3 = str2;System.out.println( str1 == str2 ); //trueSystem.out.println( str2 == str3 ); //true new String(“문자열”) “문자열”의 차이는?위의 결과를 보고 잘 생각해 보자문자열은 변경되지 않는다는점을 잘 생각하자.변한다면 참고하고 있는 다른 참조변수들이 피해를 본다.. 잘생각해보자12345678910111213141516171819202122public static void main(String[] args) &#123; String str1 = \"abc\"; String str2 = \"cde\"; String str3 = str2; str2 = str3.toUpperCase(); System.out.println(str1); System.out.println(str2); System.out.println(str3); String str4 = str2.concat(\"??\"); System.out.println(str2); System.out.println(str4);// String s = \"!\";// String str5 = s.concat(str2);// Method chain String str5 = \"!\".concat(str2); //위의 코드와 별다른 차이가 없다. System.out.println(str5);&#125; String 메소드의 사용법 및 활용123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class StringTest03 &#123; public static void main(String[] args) &#123; String s= \"abcAbcabcABC\"; //charAt char c = s.charAt( 2 ); System.out.println( c ); //indexOf System.out.println( s.indexOf( \"Abc\" ) ); //3 System.out.println( s.indexOf(\"ab\") ); //0 System.out.println( s.lastIndexOf(\"ab\") ); //6 System.out.println( s.indexOf( \"XYZ\" )); //-1 반환 //replace System.out.println( s.replace(\"bc\", \"12\") ); //s가 바뀌지는 않음 System.out.println( s.replaceAll(\"bc\", \"12\") ); //s가 바뀌지는 않음 //substring System.out.println( s.substring( 3, 7) ); //3~6까지 나온다 //case System.out.println( s.toLowerCase() ); System.out.println( s.toUpperCase() ); //concat String str1 = \" ab cd \"; String str2 = \",efg\"; str1 = str1.concat(str2); //trim System.out.println( \"---\" + str1 + \"---\" ); //--- ab cd ,efg--- System.out.println( \"---\" + str1.trim() + \"---\" );//---ab cd ,efg--- //split String[] tokens = str1.split(\",\"); for( String token : tokens) &#123; // ab cd System.out.println( token ); // efg &#125; //split 예외 tokens = \"abcdefg\".split( \",\" ); for( String token : tokens) &#123; System.out.println( token ); //abcdefg &#125; tokens = \"\".split( \",\" ); System.out.println( tokens.length ); // 1 &#125;&#125; StringBufferStringBuffer는 가변크기의 버퍼를 가짐.“abc” + “cde” (String) 보다는 StringBuffer를 쓰는게 낫다.전자의 경우 런타임 때 “abc”를 스트링 버퍼로 만들고 append(“cde”)후 toString()를 통해 값을 반환한다.String를 사용해도 되지만 append의 작업이 많을 경우 StringBuffer사용하는것이 빠르다.123456789101112131415161718192021222324252627282930313233public static void main(String[] args) &#123;//생성StringBuffer sb = new StringBuffer( \"this\" );System.out.println(sb.length() + \":\" + sb.capacity()); //4:20//버퍼의 크기를 문자의 크기보다 크게 생성함(append를 염두)//문자열추가sb.append(\" is pencil\");System.out.println( sb );//삽입sb.insert(7, \" my\");System.out.println( sb ); //this is my pencil//치환sb.replace( 8, 10, \"your\" );System.out.println( sb );//버퍼 크기sb.setLength( 3 );System.out.println( sb );//문자열 + 연산은 내부적으로 StringBuffer 객체로 변환String s1 = \"Hello\" + \" World\" + 10 +true;System.out.println(s1); //Hello World10true//다음과 코드가 같은것.String s2 = new StringBuffer( \"Hello\" ).append( \" World\" ).append( 10 ).append( true ).toString();System.out.println(s1); //Hello World10trueSystem.out.println(s2); //Hello World10true&#125; Wrapper 클래스기본형 보다는 Wrapper 클래스를 쓰고자하는 움직임이 많이 발생하고 있다. WrapperClassTest.java1234567891011121314151617181920public class WrapperClassTest &#123; public static void main(String[] args) &#123; Integer i = new Integer(10); Character c = new Character( 'c' ); Float f = new Float ( 3.14 ); Boolean b = new Boolean( true ); //Auto Boxing Integer j = 10; //int k = 20 + j.intValue(); //Auto Unboxing int k = 20 + j; &#125; public static void swap( Integer a, Integer b ) &#123; // 상수풀 운영원칙 때문에 객체이지만 내부를 수정할 수 없다. &#125;&#125; 정규식을활용하여 정수인지 확인WrapperClassTest2.java12345678910111213141516171819202122public class WrapperClassTest2 &#123; public static void main(String[] args) &#123; System.out.println( Character.toLowerCase( 'a' )); System.out.println( Character.isDigit( '1' )); System.out.println( Character.isDigit( '@' )); //String는 isdigit가 존재하지 않는다. String s = \"1234\"; if(s.matches(\"-?\\\\d+\") == false ) &#123; System.out.println(\"숫자가 아닙니다\"); &#125; else &#123; int i = Integer.parseInt(s); &#125; // 프로그램 로직(변수 검증) 할 때는 // try - catch 문으로 하지 말것. // 비용이 많이든다. //정규식을 활용하자 &#125;&#125;","categories":[{"name":"빅데이터 전문가과정","slug":"빅데이터-전문가과정","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/"},{"name":"Java","slug":"빅데이터-전문가과정/Java","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"3. 패키지, 예외","slug":"bigdata4","date":"2017-08-03T01:41:54.000Z","updated":"2017-08-07T06:04:10.611Z","comments":true,"path":"2017/08/03/bigdata4/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/03/bigdata4/","excerpt":"","text":"LinkedList탐색의 경우 O(n) / 삽입 삭제의 경우 간단. ArrayList탐색의 경우 O(1) / 삽입 삭제의 경우 쭉~ 밀려남 패키지java.lang.* - 명시적으로 지정하지 않아도 자동으로 import 되는 패키지.자바 프로그램이 기본적으로 필요로 하는 클래스와 인터페이스 포함 java.io.* - 데이터를 입력받고 출력할 수 있도록 하는 클래스 포함 java.net.* - 네트워크를 통하여 통신할 수 있도록 해주는 클래스 포함 java.util.* - 날짜/시간 조작, 난수 발생 등 각종 유틸리티 클래스와 인터페이스 포함 예외처리예외프로그램이 실행되는 동안 발생할 수 있는 비정상적인 조건번역시의 에러가 아닌 실행시의 에러를 예외라 함 자바에서의 예외처리예외처리를 위한 Exception 클래스 정의기본적인 예외는 자바에 미리 정의된 예외를 통해 처리 가능사용자가 필요한 예외를 직접 정의할 수 있음예상되는 예외는 미리 처리해주면 무조건적인 프로그램의 종료를 피할 수 있음예외처리의 사용은 프로그램의 신뢰성을 높여줌 try catch 문catch문에서 예외가 발생하면 복구시키는게 목표이다. 하지만 그게 말이 쉽지 복구라는건 불가능한 경우가 많이있다.try catch는 가독성을 떨어뜨린다는 단점이 있다.ex) 상대방이 랜선을 뽑아서 캐치에 왔다면 어쩔래 finally는 옵션이다.주로 자원정리가 목적이다. 예외가 발생하던 안하던 들어감.심지어 try에서 return 을 해도 finally가 실행된다. 123456789101112int result=0;int a = 1;try &#123; result = 1000 / a; return;&#125;catch(ArithmeticException e) &#123; System.out.println(\"예외발생\"); return;&#125; finally &#123; System.out.println(\"자원정리\"); //실행된다.&#125; checked Exception메소드를 사용하기 위해서는 반드시 예외를 처리해 줘야함 (ex&gt; FileInputStream) 실습1.1234567891011121314public static void main(String[] args) &#123; FileInputStream fis = null; try &#123; fis = new FileInputStream( \"./hello.txt\" ); int data = fis.read(); &#125; catch(FileNotFoundException|NullPointerException e) &#123; /*여러개의 예외를 처리*/ &#125; catch (Exception e) &#123; /*모든예외를 처리하고 싶을 때*/ &#125; 실습2. 나의 Exception 정의MyException 정의MyException.java12345678910public class MyException extends Exception&#123; public MyException() &#123; super( \"MyException Occurs\" ); &#125; public MyException( String message ) &#123; super( message ); &#125;&#125; MyClass 정의 MyClass.java123456789101112131415public class MyClass &#123; public void danger() throws MyException &#123; System.out.println( \"some code1\" ); System.out.println( \"some code2\" ); if( 1==1 ) &#123; throw new MyException(\"MyClass Exception 발행\"); &#125; System.out.println( \"some code3\" ); System.out.println( \"some code4\" ); &#125;&#125; MyClassTest 정의MyClassTest.java1234567891011public class MyClassTest &#123; public static void main(String[] args) &#123; try &#123; MyClass myClass = new MyClass(); myClass.danger(); &#125; catch (MyException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"빅데이터 전문가과정","slug":"빅데이터-전문가과정","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/"},{"name":"Java","slug":"빅데이터-전문가과정/Java","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"2. 오버로드,오버로딩,추상클래스,인터페이스","slug":"bigdata3","date":"2017-08-03T00:27:12.000Z","updated":"2017-08-07T06:04:10.175Z","comments":true,"path":"2017/08/03/bigdata3/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/03/bigdata3/","excerpt":"","text":"오버로드아래는 다 다른 메소드이다.12345678void a (int a, int b)..void a (int a, float b)...void a (float a, int b)... 아규먼트 , 파라미터아규먼트는 int ,float 등 형을 의미파라미터는 실제적인 데이터 10, 0.5 등을 의미. 식별자클래스 이름, 변수이름, 메소드 이름을 식별자라 한다.대소문자 가능 숫자 가능 하지만 앞에는 안되고 특수문자는 $ _ 만 사용가능. 생성자기본으로 디폴트 생성자가 만들어지지만 생성자가 하나라도 정의되어 있으면 디폴트 생성자가 생성되지 않는다. 다형성외부에서 사용할 땐 일관되게 사용하는것.오버로딩, 오버라이딩을 통해 구현 thisthis 키워드는 메소드 호출을 받는 객체를 의미한다.현재 사용중인 객체 그 자체를 의미한다.this() 는 클래스의 한 생성자에서 다른 생성자를 호출 할 때 사용할 수 있다 오버로딩부모에있는 메소드와 시그니쳐가 동일(접근제어자 , 반환형, 메소드이름, 아규먼트) 생성자 관련 문제상속관계에서 자식 클래스의 인스턴스를 생성하면 부모 혹은 자식 생성자중 어떤것이 먼저 호출될까? 12345678910부모 생성자public Parent()&#123; syso(\"부모 호출됨\");&#125;자식 생성자public Child()&#123; syso(\"자식 호출됨\");&#125; 부모 생성자가 먼저 호출된다.즉 자식 메소드의 생성자 안에(8행) super(); (기본생성자 호출)가 자동으로 삽입된것이다. int형 매개변수가 존재하는 부모 생성자를 호출하려면 8행에 super(35); 를 넣어주면 된다. 캐스팅형은 높은데에서 낮은곳으로 가면 명시적으로 알려줘야 하지만 , 인스턴스는높은곳(부모) 낮은곳(자식) 으로 가려면 명시를 해줘야 한다.다운캐스팅의 예(Explicity Casting 명시적 캐스팅)123456//방법 1Person p = new Student();Student s1 = (Student)p;//방법 2((Student)p).set(); 업캐스팅의 예(Implicity Casting 암시적 캐스팅)1Person p2 = s1; 추상클래스추상화객체들이 가지고 있는 속성과 기능 중에 중요한 것들은 남기고 필요 없는 불필요한 것은 없애는것. 또는 공통된 것들을 그룹핑해서 한곳에다 모아놓는것. 추상클래스new를 통해 객체를 생성하지는 못한다.필드를 갖을 수 있고, 구현된 메소드를 갖을 수 있다.추상 클래스를 상속하는 클래스는 반드시 추상 클래스의 추상 메소드를 구현해야 함추상 클래스간의 상속에서는 추상클래스를 구현하지 않아도 됨추상 클래스의 활용여러 클래스들이 상당수 공통점을 가지고 있으나 부분적으로 그 처리 방식이 다를 경우 부모 클래스를 추상 클래스로 정의하여 자식 클래스들이 각각 해당 메소드를 구현 실습부모클래스Shape.java1234567891011abstract class Shape &#123; private String fillColor; private String lineColor;.. public abstract void draw(); public abstract int calcArea();&#125; Shape 클래스를 상속Rectangle.java12345678910111213141516public class Rectangle extends Shape &#123; private int x1; private int y1; private int x2; private int y2; @Override public void draw() &#123; System.out.println(\"사각형을 그렸습니다.\"); &#125; @Override public int calcArea() &#123; return ((x1+x2)*(y1+y2)); &#125;&#125; Shape 클래스를 상속Circle.java123456789101112131415161718192021222324public class Circle extends Shape&#123; private int x1; private int y1; private int radius; public Circle(int x1, int y1, int radius) &#123; this.x1 = x1; this.y1 = y1; this.radius = radius; &#125;.. @Override public void draw() &#123; System.out.println(\"원을 그렸습니다.\"); &#125; @Override public int calcArea() &#123; return (int)(Math.PI * radius * radius); &#125;&#125; main 메소드PaintApp.java1234567891011121314package paint;public class PaintApp &#123; public static void main(String[] args) &#123; drawShape( new Rectangle()); drawShape( new Circle(10, 20, 5)); &#125; private static void drawShape( Shape shape ) &#123; shape.draw(); &#125;&#125; 인터페이스객체를 사용할 수 있는 목록. 즉 메소드 목록이다.UML 에서는 &lt;&gt; 라고 하고 그림.기능의 명세이다. Drawable라는 인터페이스를 구현하여 draw 메소드를 오버라이딩하여 사용.Drawable 인터페이스를 구현하면 그릴수 있다는 것을 암시.서로 관계가 없는 물체들이 상호 작용을 하기 위해서 사용하는 장치나 시스템클래스 구조상의 관계와 상관 없이 클래스들에 의해 구현되어질 수 있는 규약인터페이스 안에서는 인터페이스 끼리 다중상속이 된다.public interface Drivable extends A,B{…..} 실습인터페이스 정의Drawable.java123public interface Drawable &#123; public void draw(); //자동으로 abstract가 됨&#125; Point클래스가 Drawable 인터페이스를 구현함Paint.java123456789101112131415public class Point implements Drawable&#123; private int x; private int y; public Point() &#123; &#125; public void show() &#123; System.out.println( \"점[x=\" + x + \",y=\" + y +\"]을 그렸습니다.\"); &#125; ... public void draw() &#123; show(); &#125;&#125; ColorPoint가 Point클래스를 상속하여 Drawable를 구현한 효과를 갖음ColorPoint.java1234567891011121314151617181920package paint;public class ColorPoint extends Point &#123; private String color; public ColorPoint(int x, int y, String color) &#123; super(x, y); this.color = color; &#125;.. @Override public void show() &#123; //완전 super.show(); System.out.println( \"color \" + color); &#125;&#125; 메인메소드PaintApp.java12345678910public class PaintApp &#123; public static void main(String[] args) &#123; draw(new ColorPoint(200,200,\"yellow\")); &#125; private static void draw( Drawable drawable ) &#123;//Drawable를 구현하고 있으면 draw를 해줄게 drawable.draw(); &#125;&#125; 인터페이스 추상클래스 차이인터페이스는서로 관계가 없는 물체들이 상호 작용을 하기 위해서 사용하는 장치나 시스템클래스 구조상의 관계와 상관 없이 클래스들에 의해 구현되어질 수 있는 규약하나 또는 그 이상의 클래스들에서 똑같이 구현되어질 법한 메소드를 선언하는 경우 추상클래스는객체들이 가지고 있는 속성과 기능 중에 중요한 것들은 남기고 필요 없는 불필요한 것은 없애는것. 또는 공통된 것들을 그룹핑해서 한곳에다 모아놓는것. 정리일반클래스 : 모두 완결한 메소드 / 필드를 가질 수 있음 / 객체화 가능 추상클래스 : 완결한 메소드, 추상메소드 / 필드 가질 수 있음 / 객체화 불가 인터페이스 : 모든 추상 메소드 / 필드 가질 수 없음 / 객체화 불가 instanceof1234567891011// 객체가 Circle 클래스의 인스턴스 인가?System.out.println( c instanceof Circle );// 객체가 Drawable 인터페이스를 구현하였는가?System.out.println( c instanceof Drawable );// 객체가 Rectangle 클래스의 인스턴스 인가?System.out.println( c instanceof Rectangle );// 객체가 Shape 클래스의 인스턴스 인가?System.out.println( c instanceof Shape );","categories":[{"name":"빅데이터 전문가과정","slug":"빅데이터-전문가과정","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/"},{"name":"Java","slug":"빅데이터-전문가과정/Java","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"깃허브 사용","slug":"bigdata2","date":"2017-08-01T04:04:28.000Z","updated":"2017-08-18T02:16:35.414Z","comments":true,"path":"2017/08/01/bigdata2/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/01/bigdata2/","excerpt":"","text":"깃허브란 형상관리 툴이다. A(팀장,a모듈담당) B(b모듈담당) C(c모듈담당) 개발자가 하나의 프로젝트를 개발중이다. A 가 프로젝트(모듈 a,b,c 포함)를 올린다. 그 후 B C 에게 그 사실을 알린다. B C 는 프로젝트를 내려받고 B,C가 자신의 모듈을 수정 후 커밋을 한다. A,B,C는 수정된 것을 내려 받은 후 테스트를 한다. git가 있으며 내부에는 Repository가 있다. git는 레파지토리가 2개 존재한다.하나는 로컬이고 하나는 원격이다. 로컬 레파지토리에 프로젝트를 올리는것을 commit 라고 하며 로컬 레파지토리를 원격 레파지토리에 맞추는 것을 push 라고 한다. 원격 레파지토리에서 프로젝트를 로컬레파지토리로 갖고오는것을 full 내 프로젝트로 반영하는것은 fetch라고 한다. 하지만 보통 로컬레파지토리와 프로젝트를 같이 놓는다.(편의상)1.내 프로젝트 올리기이클립스에서 실행1.이클립스 - show view - git Repository 선택2.프로젝트 우클릭 후 - team - share …-체크-create누름(로컬레파지토리 프로젝트를 같이하는것.) 깃허브에서 실행1.레파지토리 new - 프로젝트 이름이랑 동일하게 생성(굳이 안해도되나 편의상)2.깃 주소를 복사 이클립스에서 실행1.git Repository탭 - remote - Configure fetch 체크(push 체크하면 올리기만 되고 받기는 안된다.) - change 버튼 클릭 - save Fetch 클릭2.project explorer탭으로 - team - commit - Unsatage Changes에 있는 것들을 staged Changed로 내림. 커밋메세지는 추가할 수 있도록 하자. - commit and push 클릭 - next - finish 2.타 프로젝트 받기.방법1. 깃허브에서 다운받아서 임포트하기. 방법2. 프로젝트를 fork한다. 깃허브에서 실행원하는 프로젝트로 가서 fork를 누르고내 레파지토리로 가보자. 자신의 레파지토리에 생성되있는게 있을것임.이제 자기 레파지토리에 있는것을 잡아 땡겨보자clone or download 에서 url 복사 이클립스에서 실행git Repository탭으로 가서 컨트롤+vnext-next - browse 눌러서 자기 워크스페이스 선택 (로컬 레파지토리와 프로젝트저장소를 하나로 합치는것.)working tree 선택 후 오른쪽 누르고 import .. 클릭 후 finish Project explorer 탭으로 가서 보면 에러가 난다. (환경설정이 달라서 나는 에러이다.)프로젝트 우클릭 후 - properties - java build path 선택- Libraries 탭 선택 - 더블클릭 후 - alternate JRE 에서 선택 3.레파지토리 삭제해당레파지토리로 가서 - 세팅 - 레파지토리 이름 입력 이클립스에서 실행team - disconnect 후 delete Repository 클릭하나로 뭉쳐놨기 때문에 맨위 하나만 선택하면 된다.","categories":[{"name":"빅데이터 전문가과정","slug":"빅데이터-전문가과정","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/"},{"name":"기타","slug":"빅데이터-전문가과정/기타","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/기타/"}],"tags":[]},{"title":"1.자바프로그래밍 기본","slug":"bigdata1","date":"2017-08-01T00:05:28.000Z","updated":"2017-08-07T06:03:34.364Z","comments":true,"path":"2017/08/01/bigdata1/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/01/bigdata1/","excerpt":"","text":"특징많은 클래스, 파일로 프로그램이 구성된다. 클래스는 데이터를 갖고 있고 메소드는 데이터를 다루게 된다. 객체의 데이터를 다루기 위해서는 외부에서 메소드를 호출해야 한다. 하드웨어는 컴포넌트화로 인해 빠른 발전이 이루어졌다. 소프트웨어 또한 이에 따라 컴포넌트화로 발전하게 되었다. 객체지향은 설계분석이 가능하다. 요구사항 분석-&gt;추상화-&gt;객체관계 분석(상속,의존 등) 캡슐화, 상속, 다형성의 특징을 갖는다. 코드의 재사용성이 높다. 추상화 과정으로 인해 가능해지는것. 상속을 통해 부모에 존재하는 메소드 사용가능.잘못된 예: 홈쇼핑 프로젝트에서 만든 Person 클래스를 ERP를 만드는곳에서 Person을 만드는데 사용한다. 예외처리를 통해 신뢰성이 높아진다. java는 운영체제에 영향을 받지 않는다는 특징. JRE + API + javac + rt.jar = JDK 객체와 클래스객체는 정보를 효율적으로 관리하기 위하여 의미를 부여하고 분류하는 논리적 단위클래스를 사용자 데이터 타입 이라고도 한다. 객체의 구성요서는 속성(필드,인스턴스 변수)이 필요하다.클래스 내부에 있는 변수는 필드 혹은 속성이라 한다.!기능은 메소드라 한다. 컴파일 과정네비게이터로 bin 폴더를 보자.코들를 짜면 bin 폴더 내부에 클래스파일이 컴파일되어 생성된다. 메소드 영역필드정보(클래스에 대한 정보. getClass() 메소드를 통해 얻을 수 있다.), 메소드 코드, main메소드, static 변수, static 메소드 stack지역변수. 자바는 전역변수의 개념이 없으므로 모든 변수는 여기에 생성됨. heap객체 접근자public - 내부, 같은 패키지, 자식접근, 외부 가능. protected - 내부, 같은 패키지, 자식접근 가능. (default) - 쓰지않는것을 권고한다. 내부, 같은 패키지에서 접근가능. private - 내부에서만 접근 가능. 정보은닉데이터는 private를 넣고 접근할 때 메소드를 쓴다. 엔터프라이즈에서는 이러한 메소드를 빈이라고 부른다. finalfinal은 클래스 앞, 변수앞 , 필드 앞에도 정의할 수 있다.final은 여기가 마지막이라는 뜻.상수는 대문자로 만들라는 관례가 있다.!따지고 보면 변수와는 별 다른게 없지만 알아보기 편하게!123final int VALUE = 10;VALUE = 30; //에러발생 1234public final class Test&#123;.....&#125;이 경우 다른클래스가 Test클래스를 상속할 수 없음. 1234public final Sring getName() &#123; return name;&#125;오버라이딩 금지!! 생각해보자12345678910public void show() &#123; System.out.println( \"점[x=\" + x + \",y=\" + y +\"]을 그렸습니다.\"); &#125;public void show(boolean visible) &#123; //외부에서 매개변수를 통해 보이고 안보이고를 show메소드로만 통제 if(visible) &#123; show(); &#125;else &#123; System.out.println( \"점[x=\" + x + \",y=\" + y +\"]을 지움.\"); &#125; 코드를 위와 같이 구현 시 사용자는 show라는 메소드에 접근하고 boolean 값만을 통해 출력 미출력을 통제할 수 있다. 이 형태가 좋은 이유는 show , notShow 와 같은 메소드를 만들어서 사용자가 모든 메소드를 알고 있어야하는 상황을 없앨 수 있다.","categories":[{"name":"빅데이터 전문가과정","slug":"빅데이터-전문가과정","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/"},{"name":"Java","slug":"빅데이터-전문가과정/Java","permalink":"http://KKimSangHeon.github.io/categories/빅데이터-전문가과정/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"Chat-Bot","slug":"Chat-Bot","date":"2017-07-17T08:49:17.000Z","updated":"2017-08-11T06:28:37.858Z","comments":true,"path":"2017/07/17/Chat-Bot/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/17/Chat-Bot/","excerpt":"","text":"과정기본적인 틀 구축 1npm install --save cheerio node.js에서 제이쿼리의 선택자를 쓸 수 있게되어 설치.1npm install --save request url에 접속하여 html을 다운받을 수 있게된다. 1npm install --save async 비동기 방식을 사용할 수 있게 된다.1npm install --save node-cron 주기적인 작업을 실행시키기 위해 설치하였다.1npm install --save iconv html을 가져 왔을 때 한글 깨짐을 막을 수 있다.1npm install pm2 -g 서버가 문제가 생겼을 경우 재시작 시켜주며 성능향상에 기여한다.pm2의 명령어는 다음과 같다.12345678pm2 start 서버.js --name 별칭 //실행하면서 별칭을 붙여준다.pm2 list //실행되고 있는 pm2리스트를 조회pm2 stop 별칭 // pm2를 중지한다.pm2 restart 별칭 //pm2 재시작한다.pm2 delete 별칭 //pm2 종료pm2 show 별칭// 정보확인","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"관련정보","slug":"Linux/관련정보","permalink":"http://KKimSangHeon.github.io/categories/Linux/관련정보/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"}]},{"title":"19장. PXE 서버, 킥스타트","slug":"ThisIsLinux42","date":"2017-07-16T12:22:55.000Z","updated":"2017-07-16T14:03:03.582Z","comments":true,"path":"2017/07/16/ThisIsLinux42/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/16/ThisIsLinux42/","excerpt":"","text":"Centos를 100개 깔아야 하는 상황에는 여러가지 방법이 있겠지만 PXE 설치서버를 구성해놓는다면 쉽게 설치가 가능하다!1.DHCP 서버, TFTP 서버, syslinux부팅파일, FTP 또는 웹서버를 PXE 설치 서버에 구성해 놓는다. 즉 PXE는 하나의 프로그램이 아니라 여러개의 프로그램을 잘 조합해 놓은것을 의미2.Centos를 설치할 PC의 전원을 켠다.3.설치할 파일을 네트워크로 전송해서 자동으로 설치 PXE는 초기 설치화면 즉 언어설정 전 까지만 완료해 주지만 킥스타트는 초기설정까지 해준다. 1.PXE 설치1.1 서버에서 설정1# yum -y install syslinux dhcp tftp-server vsftpd //관련패키지 설치 1.1 DHCP 설정12345678910111213141516# systemctl stop firewalld# systemctl disable firewalld# vi /etc/dhcp/dhcpd.conf맨아래 다음 입력subnet 192.168.111.0 netmask 255.255.255.0 &#123; option routers 192.168.111.2; option subnet-mask 255.255.255.0; range dynamic-bootp 192.168.111.120 192.168.111.199; option domain-name-servers 192.168.111.2; allow booting; allow bootp; next-server 192.168.111.100; filename &quot;pxelinux.0&quot;;&#125;입력 후 종료 1.2 TFTP 설정123# vi /etc/xinetd.d/tftpdisable = no 로 변경저장후 종료 1.3 ftp로 iso이미지 접근가능하게오른쪽위 cd모양 우클릭 - 세팅 - Use ISO image… - Centos이미지 찾고 위에 Connected, Connect at power on 체크 - OK123# umount /dev/cdrom# mount /dev/cdrom /var/ftp/pub ftp를 접속할 경우 cd롬파일을 접근가능 1.4 부팅에 필요한 파일 준비tftp는 부팅파일을 전송하는 역할이다.123456789101112131415161718# cp /var/ftp/pub/images/pxeboot/vmlinuz /var/lib/tftpboot/# cp /var/ftp/pub/images/pxeboot/initrd.img /var/lib/tftpboot/# cp /usr/share/syslinux/pxelinux.0 /var/lib/tftpboot/# ls -l /var/lib/ftpboot# mkdir /var/lib/tftpboot/pxelinux.cfg# cd /var/lib/tftpboot/pxelinux.cfg# touch default //부팅에 관련된 파일 생성# vi default 다음을 입력DEFAULT CentOS7_Auto_InstallLABEL CentOS7_Auto_Install kernel vmlinuz APPEND initrd=initrd.img repo=ftp://192.168.111.100/pub# ps -ef | grep dnsmasq //충동하는 프로세스 kill위해# kill -9 1696# systemctl disable dnsmasq 1.5 관련 서비스 시작123456# systemctl restart dhcpd //서비스 시작# systemctl restart vsftpd# systemctl restart xinetd //tftp임# systemctl enable dhcpd //상시가동# systemctl enable vsftpd# systemctl enable xinetd 1.6 VMware에서 제공하는 DHCP를 끄자워크스테이션 키고 - Edit - Virtual Network Editor - change setting 누르고-VMnet8선택 - Use local DHCP .. 체크 해제 후 - OK이제 서버에서만 DHCP 서버를 제공한다. 1.7 새로운 PC를 만들자버츄어 머신에서 진행하자버츄어머신 네임을 TestCom으로로케이션을 Centos 폴더 내 TestCom으로 하자그 후 부팅하면 설치가 된다. 2.킥스타트 설치킥스타트는 교재를 참고하자.","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"18장. 방화벽 컴퓨터를 만들자","slug":"ThisIsLinux41","date":"2017-07-16T02:04:12.000Z","updated":"2017-07-16T04:31:45.506Z","comments":true,"path":"2017/07/16/ThisIsLinux41/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/16/ThisIsLinux41/","excerpt":"","text":"방화벽은 내부, 외부를 차단해주는 장비 또는 컴퓨터라고 생각하면 된다. 방화벽으로 인해 외부에서 내부 네트워크로 함부러 침입할 수 없다. 그 기법중 많이 쓰이는 것이 사설IP이다.방화벽 컴퓨터는 랜카드가 두개여야 된다. 내부와 결합되는(사설 IP) 랜카드 외부와 연결되는 랜카드(공인IP) 실습에서 192.168.xxx는 공인 ip10.1.xxx 는 내부ip로 사용한다책 737을 통해 네트워크 구성을 확인하자 1. 서버 B 설정(웹서버로 사용할것임)서버B의 네트워크 세팅에 들어가서 네트워크 어댑터 클릭 후 Bridged 클릭그러면 네트워크가 Bridged네트워크 안으로 들어옴(사설ip로 사용하기로 함)그 후 ip를 변경하자 123456789# nmtui edit ens32Address를 10.1.1.20/24로 변경Gateway를 10.1.1.1로 변경Dns 168.126.63.1로 변경 //kt에서 운영하는 dns 서버ok버튼# reboot# ip addr inet이 10.1.1.20 인지 확인 2. 클라이언트 설정(클라이언트에서 실행)클라이언트의 네트워크 세팅에 들어가서 네트워크 어댑터 클릭 후 Bridged 클릭 그러면 네트워크가 Bridged네트워크 안으로 들어옴123456789# nmtui edit ens33IPv4 CONFIGURATION을 Manual로 바꾸고 Show 엔터Address를 10.1.1.10/24Gateway는 10.1.1.1DNS Server는 168.126.63.1 OK 엔터# reboot# ip addr 3. 서버B,클라이언트 사설네트워크 테스트현재까지 구현한것(서버B,클라이언트)은 게이트웨이가 구현되어있지 않으므로 외부로 나갈 수 없다. 하지만 사설네트워크로 안에서는 연결되어 있으므로 ping이 왔다갔다 하는지 확인해보자 클라이언트에서 실행1# ping -c 3 10.1.1.20 4. 서버 구성(서버에서 실행)4.1 랜카드 하나가 외부로 연결 잘 되어있는지 확인해보자123# nmtui edit ens32게이트웨이, DNS Servers가 192.168.111.2로 잘 되어있다.# halt -p 서버에 랜카드를 하나 더 달자.vmware 워크스테이션에서 Edit virtual machins settings를 눌러 Add 후 Network Adapter 선택 다음 후 Bridged 선택하고 Finish 그 후 부팅추가한 장치가 ens32인지 확인해보자날짜 옆에 랜카드 모양을 누르면 ens34가 추가되어 있다. 네트워크설정 클릭 후 오른쪽 아래 톱니모양(유선연결1)을 누르고 신원을 누르자. 그 후 ens34로 입력하자다음 IPv4를 선택하여 자동을 수동으로 변경하자그 후 주소 10.1.1.1네트마스크 255.255.255.0게이트웨이 10.1.1.1네임서버 끄자IPv6로 가서 끄자이제 적용을 누르고 재부팅하자 12345# vi /etc/sysconfig/network-scripts/ifcfg-ens346,7행 지워버리기# systemctl restart network# ifconfigens32 는 192.168.111.100번으로 ens34는 10.1.1.1 이제 하드웨어 설정은 끝났다 5. 클라이언트에서 핑을 날려보자1# ping 10.1.1.1 6. 서버에 정책을 적용시켜보자1234567891011121314151617181920212223242526272829303132# vi /etc/sysctl.confnet.ipv4.ip_foward=1 맨아래 입력# echo 1 &gt; /proc/sys/net/ipv4/ip_forward //아무 메세지 안나오면 성공# cat /proc/sys/net/ipv4/ip_forward //1출력됨포워딩성공!# iptables --policy FORWARD DROP# iptables --policy INPUT DROP# iptables --policy OUTPUT DROPens34 장치를 설정해주자input 설정# iptables --append INPUT --in-interface ens34 --source 10.1.1.0/24 --match state --state NEW,ESTABLISHED --jump ACCEPToutput 설정# iptables --append OUTPUT --out-interface ens34 --destination 10.1.1.0/24 --match state --state NEW,ESTABLISHED --jump ACCEPT# iptables --append FORWARD --in-interface ens34 --source 10.1.1.0/24 --destination 0.0.0.0/0 --match state --state NEW,ESTABLISHED --jump ACCEPTens32 설정# iptables --append FORWARD --in-interface ens32 --destination 10.1.1.0/24 --match state --state ESTABLISHED --jump ACCEPT# iptables --table nat --append POSTROUTING --out-interface ens32 --jump MASQUERADE설정한것 저장# service iptables save# firewall-config영구적 - 마스커레이딩 - 마스커레이딩영역 체크 - 옵션 다시불러오기 7.클라이언트에서 인터넷 해보자이 경우 클라이언트는 자신의 ip(10.1.1.0)이 아닌 Server IP(192.168.111.100)으로 접속하게 된다. 이를 확인해보자 7.1 윈 클라이언트를 켜자파일질라서버를 카페에서 받자에딧 -유저- 오른쪽add -centos 입력- password centos -ok왼쪽 add 아무 디렉토리 선택- write/delete 선택 -okcmd 열고 netsh advfirewall firewall add rule name=”FTP서버” dir=in action=allow protocol=tcp localport=21방화벽 설정 입력ipconfig아이피를 기억하자 (지금은 192.168.111.128임) 7.2 클라이언트에서 FTP 접속해보자1234567# su# yum -y install ftp# ftp 192.168.111.128centoscentos&gt;pwd&gt;ls 7.3 윈도우 클라이언트에서 누가 접속했는지 확인해보자netstat /an찾다 보면 192.168.111.100이 들어온것을 확인할 수 있다.즉 사설네트워크 컴퓨터는 외부로 나갈 때 192.168.111.100으로 나간다! 8. 서버B를 웹서버로 만들고 윈 클라이언트로 접속해보자8.1 서버 B에서 실행12345678910# yum -y install httpd# firewall-cmd --add-service=http //포트열자# cd /var/www/html# touch index.html# vi index.htmlCentos7-Web Server 입력저장 후 종료# systemctl restart httpd# systemctl enable httpd 8.2 서버에서 80번 포트로 연결오면 서버 B로 연결해라를 설정서버에서 실행12# iptables --table nat --append PREROUTING --proto tcp --in-interface ens32 --dport 80 --jump DNAT --to-destination 10.1.1.20# service iptables save //저장 8.3 윈도우 클라이언트에서 접속해보자192.168.111.100 으로 접속하자","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"17장. 프록시 서버 설치와 운영","slug":"ThisIsLinux40","date":"2017-07-15T09:55:25.000Z","updated":"2017-07-15T11:04:12.590Z","comments":true,"path":"2017/07/15/ThisIsLinux40/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/15/ThisIsLinux40/","excerpt":"","text":"프록시서버?웹서핑을 할 경우 웹브라우저가 외부로 가서 파일을 가져와 읽게 되는것이다. 두 브라우져가 같은곳을 접속하면 따로 가져오게 되는 현상이 발생할 수 있다. 하지만 프록시 서버를 지정해놓으면 프록시 서버가 캐시에 a사이트 데이터를 저장 해놓고 다른 웹브라우져가 a서버를 요청하면 a 데이터를 보내준다. 프록시서버 구현(서버에서)123456789101112131415161718# yum -y install squid //설치# vi /etc/squid/squid.conf:set nu:26acl centos7 src 192.168.111.0/255.255.255.0 //c클래스 지정:54http_access allow centos7:62주석 제거 하고 100을 1000으로맨아래 다음추가visible_hostname centos7# firewall-config영구적 선택 - 포트 - 추가 3128 - 다시불러오기# systemctl stop firewalld //맘편하게 방화벽 끄는것# systemctl restart squid# systemctl enable squid# systemctl status squid 웹브라우저에서 프록시서버 지정(클라이언트)파이어폭스를 켜고 - 편집 - 환경설정 -고급 - 네트워크 - 설정 - 프록시 수동설정 192.168.111.100 포트 3128 입력 - 확인 윈도우클라이언트에서 지정(윈클라이언트)도구 -인터넷옵션 -LAN설정 프록시서버 192.168.111.100 3128 입력 1","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"16장. DHCP 서버 설치와 운영","slug":"ThisIsLinux39","date":"2017-07-15T07:09:22.000Z","updated":"2017-07-15T09:54:45.098Z","comments":true,"path":"2017/07/15/ThisIsLinux39/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/15/ThisIsLinux39/","excerpt":"","text":"DHCP(Dynamic Host Configuration Protocol) 서버는 자동으로 네트워크 정보(IP주소, 서브넷 마스크, 게이트웨이 주소,DNS 서버 주소)를 할당해 주는것이다. 일반 PC는 자신에게 고정IP가 할당되어있지 않아도 DHCP서버가 할당해준다. 그러므로 일반사용자는 IP에 대한 지식 없이도 인터넷 사용이 가능해진다. Vmware에서 제공하는 DHCP 서버의 기능은 중지시켜야 한다. 클라이언트 설정1234# ifconfigip를 DHCP로부터 할당받은것.# cat /etc/resolv.confnameserver 또한 DHCP로 부터 할당받은것. 1. DHCP 기능중지워크스테이션 - Edit - Virtual Network Editor - change setting 선택 - VMnet8선택 - DHCP Setting 선택128부터 254까지를 할당하는 것을 확인 Use local DHCP …. 클릭 해제Apply이제 IP를 자동으로 할당받지 못한다. 2. DHCP 서버 설정하자.12345678910111213141516171819202122232425262728293031323334353637# yum -y install dhcp# ps -ef | grep dnsmasq //dhcp와 충돌하므로 죽이자.nobody 1696 1 0 18:21 ? 00:00:00 /sbin/dnsmasq --conf-file=/var/lib/libvirt/dnsmasq/default.confroot 3514 2462 0 18:28 pts/0 00:00:00 grep --color=auto dnsmasq# kill -9 1696 //다를 수 있다.# systemctl disable dnsmasq //껏다켜도 실행 되지 않도록.# vi /etc/dhcp/dhcpd.conf //dhcp 설정파일아래를 추가하자. (엔터로 인한 공백이 존재하면 안된다)ddns-update-style interim;subnet 192.168.111.0 netmask 255.255.255.0 &#123; option routers 192.168.111.2; //라우터설정 option subnet-mask 255.255.255.0; //서브넷마스크설정 range dynamic-bootp 192.168.111.30 192.168.111.50; //ip범위 설정 30~50까지 20개 option domain-name-servers 192.126.63.1; //dns설정(kt에서 제공하는것) default-lease-time 10000; //디폴트 임대시간 max-lease-time 50000; //최대임대시간&#125; # ls /var/lib/dhcpddhcpd.leases에 ip를 임대해준것에 대한 기록이 있다.# systemctl restart dhcpd# systemctl enable dhcpd //상시가동# systemctl status dhcpd //잘 작동하는지 확인# systemctl stop firewalld# systemctl restart dhcpd 3. 클라이언트에서 IP 할당받아보자1234# su -c &apos;systemctl restart network&apos;password 입력# ifconfig //아이피 확인해보자192.168.111.30을 받았다. (아까 30~50을 지정해줌) 4. 윈도우 클라이언트에서 IP 할당받아보자네트워크 - 공유센터 - 어댑터 - 로컬 영역 연결을 사용안함으로 했다가 사용으로 변경 - cmd를 켜고 ipconfig 를 입력하면192.168.111.31을 받은것을 확인할 수 있다. 5. 서버에서 빌려간것들을 확인해보자12# cat /var/lib/dhcpd/dhcpd.leasesIP를 언제빌려갔고 누가 빌려갔고 맥어드레스 등을 확인할 수 있다. 6. 다시 워크스테이션의 DHCP를 켜자워크스테이션 - Edit - Virtual Network Editor - change setting 선택 - VMnet8선택 - DHCP Setting 선택 - Use local DHCP …선택","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"15장. Samba 서버 설치와 운영","slug":"ThisIsLinux38","date":"2017-07-15T05:37:36.000Z","updated":"2017-07-15T07:08:30.947Z","comments":true,"path":"2017/07/15/ThisIsLinux38/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/15/ThisIsLinux38/","excerpt":"","text":"NFS 유닉스와 유닉스 유닉스와 리눅스간 파일공유이고삼바는 유닉스(리눅스)와 윈도우즈간에 공유하는것. 1.윈도우가 삼바 서버1.1 윈도우 클라이언트를 삼바 서버로 만들자(윈클라이언트실행)C 드라이브에 smbShare 폴더만든다. 그 폴더 속성 들어가서 공유탭의 공유버튼 누르고 Everyone 선택하고 추가 그 후 Everyone은 읽기/쓰기로 선택 명령프롬프트 관리자 모드로 열고 net user root 1234 /add 입력. //윈도우즈 사용자 추가ipconfig192.168.11.131임을 기억하자 1.2 삼바 클라이언트로 접속해보자(서버에서 실행)123456789101112# rpm -qa | grep samba# smbclient -L 192.168.111.1311234입력# mkdir /sambaMount# mount -t cifs //192.168.111.131/smbShare /sambaMount //윈도우는 //로 해야함1234입력# ls -l /sambaMount# cp /boot/vmlinuz-* /sambaMount 2. 리눅스가 삼바 서버윈도우는 삼바 클라이언트라는 개념이 없다. 그래서 리눅스가 윈도우인척 폴더를 공유해 놓으면 윈도우 클라이언트는 해당폴더가 윈도우가 공유했는지 리눅스가 공유한지 모르고 그냥 쓰게 된다. 2.1 리눅스 서버를 삼바 서버로 만들자(서버에서 실행)12345678910111213141516171819202122232425262728# yum -y install samba관련파일 카페에서 받자# cd 다운로드# yum -y localinstall system-config-samba*여기서 에러날 경우 카페 자료실을 참고하자# systemctl restart smb# systemctl enable smb# ls /share / //share 폴더를 공유하자# chmod 707 /share# system-config-samba설정- 서버설정 - workgroup/centOS 7 입력- 보안탭가서 인증모드 공유로 하고 확인workgroup은 윈도우의 그룹이다.+를 누르고 폴더는 /share로 하고 쓰기가능,보이기 체크접근탭을 눌러서 모든사용자에게 접근부여 선택설정 - samba사용자 눌러서 사용자 추가.유닉스 사용자명은 centOS / winuser /1234 /1234 입력 후 확인# systemctl stop firewalld# firewall-config //삼바, 삼바 클라이언트 열기 //지금은 방화벽을 꺼둔상태라 하지 않아도 된다.# systemctl restart smb 2.2 윈도우에서 접속해보자컴퓨터 -&gt; 네트워크 드라이브 연결드라이브 Q로 선택폴더에 \\\\192.168.111.100\\share 입력centos1234 2.3 서버에 접속한 사용자를 보자(서버에서 실행)1# smbstatus","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"14장. NFS 서버 설치와 운영","slug":"ThisIsLinux37","date":"2017-07-15T03:11:36.000Z","updated":"2017-07-15T05:37:18.579Z","comments":true,"path":"2017/07/15/ThisIsLinux37/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/15/ThisIsLinux37/","excerpt":"","text":"NFS 서버리눅스 사이에 파일이나 폴더를 공유하는것NFS를 구현하면 다양한 클라이언트가 공유 디렉터리에 접근할 수 있다.서버에서는 서버를 구현하고 클라이언트는 그것을 마운트하여 사용한다. 서버를 NFS 서버로 구현(서버로 실행)1234567891011121314# rpm -qa nfs-utils //설치 확인(깔려있다.)# vi /etc/exports //공유할 폴더를 지정하는 파일/share 192.168.111.*(rw,sync) 입력 //리드 라이트, 싱크까지 시킴# mkdir /share# chmod 707 /share/# cp /boot/vmlinuz-3* /share/file1# ls -l /share/# systemctl restart nfs-server //서비스 시작# systemctl enable nfs-server //상시가동# exportfs -v //공개된 폴더 보임# systemctl stop firewalld //방화벽 끄기.. //관련된 것이 많아서 끄는게 낫다. 클라이언트로 NFS 접속(클라이언트로 실행)123456789101112131415# rpm -qa nfs-utils //패키지 설치여부 확인(깔려있다)# showmount -e 192.168.111.100 //서버에서 마운트한 폴더 조회# cd# mkdir myShare# su password 입력# cd /home/centos# mount -t nfs 192.168.111.100:/share myShare //마운트# ls -l myShare# cd myShare/# touch abc# touch bcd 클라이언트가 생성한게 서버에도 있나 확인1# ls -l /share //abc,bcd 파일이 존재한다 윈도우로 접속해보자일반적으로는 NFS는 제공을 안하지만 엔터프라이즈의 경우엔 제공해준다.제어판 - 프로그램 - 기능 사용/사용안함 클릭- nfs용 클라이언트 체크확인재부팅관리자로 cmd를 열자mount 192.168.111.100:/share *내컴퓨터를 누르면 접속 가능 NFS서버의 그래픽 설정도구를 사용해보자1234567페도라20에서 제공하므로 카페에서 다운받자# yum -y install# cd 다운로드# yum -y localinstall system-config-nfs-1.4.2-1.fc20.noarch.rpm# mkdir /share2# system-config-nfs","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"13장. FTP 서버 설치와 운영","slug":"ThisIsLinux36","date":"2017-07-15T02:04:42.000Z","updated":"2017-07-15T03:11:20.611Z","comments":true,"path":"2017/07/15/ThisIsLinux36/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/15/ThisIsLinux36/","excerpt":"","text":"네임서버, 이메일서버, 웹서버 보다는 훨신 간단하다.FTP 는 file transfer protocol의 약자로 파일을 전송하기 위한 서비스. 대용량 파일을 전송 할 때 FTP 서버는 성능이 좋다. ftp서버의 종류는 몇가지가 있는데 CentOS에서는 vsftpd를 제공한다. 페도라, 레드헷 엔터프라이즈 쪽에서 인기가 좋다.proftpd는 주로 대형 사이트에서 오래동안 인기가 많았다.pure-ftpd는 Troll-FTPd를 기반으로 프랭크 데니스가 2001년에 제작함.사실 사용자입장에서는 어떤 ftp이든 관계가 없다. 1.vsftpd실습1.1 vsftpd 설치 및 운영(서버실행)12345678910111213# yum -y install vsftpd //165kb 밖에 안되는데 성능이 좋다!# cd /var/ftp //vsftpd의 홈 디렉토리# ls -l //일반적으로 pub라는 디렉토리에 파일을 넣어놓는다. //우리회사가 A라는 파일을 배포해야하면 일반적으로 pub폴더에 넣음.# cd pub# ls# cp /boot/vmlinuz-3* file1# systemctl restart vsftpd //ftp 시작# systemctl enable vsftpd //상시가동# firewall-config //방화벽 열기영구적탭 . ftp 선택 . 옵션 firewalld다시불러오기 실습1.2 vsftpd 윈도우에서 접속해보자(윈클라이언트실행)알드라이브 설치192.168.111.100 입력포트 21익명로그인 체크연결파일 업로드가 안된다. 이유 : ftp는 기본적으로 다운로드만 가능하다. 아무나 업로드 가능하면 악성코드를 올릴 수 도 있다!하지만 허용할 수 있다. 실습1.3 vsftpd 업로드 가능하게 변경(서버에서 실행)12345678# vi /etc/vsftpd/vsftpd.conf29행 어나니머스가 업로드하는것을 허락한다. 주석해제33행 어나니머스가 디렉토리를 만드는것을 허락한다. 주석해제# chown ftp.ftp /var/ftp/pub //펍 소유주 변경# ls -l# systemctl restart vsftpd //서비스재시작 실습1.4 vsftpd 명령어로 파일을 올리고 받아보자(서버B에서 실행)123456789101112# yum -y install epel-release //레드헷에 접속해서 다운받을수 있도록 설치# yum -y install ncftp# ncftp 192.168.111.100&gt;cd pub&gt;get file1 //file1 다운로드&gt;put anaconda-ks.cfg //아나콘다파일 업로드&gt;ls -l &gt;bye //종료 2.proftpd실습2.1 proftpd 설치(서버실행)1234567891011121314151617# yum -y remove vsftpd //충돌 나니까 제거# yum -y install epel-release //proftpd도 레드헷에 있어서 해줘야함.# yum -y install proftpd //proftpd 설치# vi /etc/proftpd.conf //설정파일 열기:set nu :356 주석처리:425 주석처리 &lt;/IfDefine&gt;:383 DenyAll을 AllowAll로 변경//이제 어나니머스도 접속 가능# systemctl restart proftpd # systemctl enable proftpd 방화벽은 아까 열었으므로 안열어도 된다. 실습2.2 윈클라이언트에서 접속(윈클라이언트 실행)3. pure-ftpd실습3.1 pure-ftpd 설치(서버실행)123456789# yum -y remove proftpd# yum -y install pure-ftpd //레드햇에서 제공한다.# vi /etc/pure-ftpd/pure-ftpd.conf:set nu:77 익명사용자가 허용이 되어있다.:286 yes를 no로 변경# systemctl restart pure-ftpd# systemctl enable pure-ftpd","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"12장. 웹서버 설정파일,APM 컴파일 설치","slug":"ThisIsLinux35","date":"2017-07-14T09:45:57.000Z","updated":"2017-07-15T00:48:58.606Z","comments":true,"path":"2017/07/14/ThisIsLinux35/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/14/ThisIsLinux35/","excerpt":"","text":"x윈도를 통해 httpd.conf파일을 설정해보자httpd.conf는 웹서버 설정파일이다. 책을 통해 이 내용을 알아보자.1234카페에서 system-config-httpd 파일을 받자.# yum -y localinstall system-config-httpd-1.5.5-6.fc20.noarch.rpm# system-config-httpd 소스를 컴파일해서 APM을 설치최적화된 APM을 구성할 수 있는 장점. 아파치 설치12345678910111213141516171819202122232425262728293031323334353637383940# yum -y remove httpd //컴파일 한것을 쓰기위해 깔린것을 지움# yum -y install gcc gcc-c++ //컴파일러 설치# cd 다운로드/# tar xfj pcre* //압축풀기# cd pcre-8.36/# ./configure ; make; make install //세개의 명령어 한꺼번에# cd 다운로드/# tar xfj httpd-2.4.10.tar.bz2# tar xfj apr-1.5.1.tar.bz2# tar xfj apr-util-1.5.4.tar.bz2# mv apr-1.5.1 httpd-2.4.10/srclib/apr //파일이름을 apr로 srclib에저장# mv apr-util-1.5.4 httpd-2.4.10/srclib/apr-util //파일이름을 apr-util로 srclib에 저장# ls httpd-2.4.10/srclib# cd httpd-2.4.10/# ./configure --with-included-apr --with-pcre=/usr/local/bin/pcre-config --prefix=/web/httpd2/ ; make ; make install # vi /etc/ld.so.conf마지막에 다음 두줄 추가/web/httpd2/lib/web/httpd2/modules# ldconfig //방금 추가한 내용 적용# cp /web/httpd2/bin/apachectl /etc/init.d/httpd2 //아파치 시작스크립트 복사# vi /etc/init.d/httpd2맨 아래 다음 두줄 추가# chkconfig: -85 15# description: 아파치 웹서버 입니다.# chkconfig httpd2 on //부팅될때마다 시작되도록# systemctl restart httpd2# systemctl status httpd2localhost로 접속해보자APM 중 아파치 설치 완료! 마리아 db 설치12345678910111213141516171819202122232425262728293031323334353637두번째 마리아 db는 컴파일된 바이너리 코드를 설치하자(카페에서 미리 받아놓자)# cd /root/다운로드# tar xfz mariadb-10.0.15-linux-x86_64.tar.gz# mv mariadb-10.0.15-linux-x86_64 /web/mariadb# groupadd mysql //mysql 그룹 추가# adduser -M -d /web/mariadb -g mysql -s /bin/false -r mysql //실제 사용하지 않는 유저 생성# /web/mariadb/scripts/mysql_install_db --user=mysql --basedir=/web/mariadb --datadir=/web/mariadb/data//마리아 디비 초기화# cp -a /web/mariadb/support-files/my-huge.cnf /etc/my.cnfy# vi /etc/my.cnf29행에 다음 두줄 추가basedir = /web/mariadbdatadir = /web/mariadb/data# cp -a /web/mariadb/support-files/mysql.server /etc/init.d/mariadb //실행스크립트 복사# systemctl restart mariadb# chkconfig mariadb on //상시가동되도록# /web/mariadb/bin/mysqladmin -u root -p password엔터12341234//마리아 디비 관리자 암호 변경# PATH=$PATH:/web/mariadb/bin# mysql -u root -p1234 입력//정상작동하는지 접속 php 설치123456789101112131415161718192021222324252627282930# cd /root/다운로드# yum -y install libxml2-devel openssl-devel libjpeg-devel libpng-devel//관련 패키지 설치# tar xfj php-5.6.4.tar.bz2# cd php-5.6.4# ./configure --with-mysql=/web/mariadb --with-apxs2=/web/httpd2/bin/apxs --with-mysqli=/web/mariadb/bin/mysql_config --with-imap-ssl --disable-debug --with-iconv --with-gd --with-jpeg-dir --with-png-dir --with-libxml-dir --with-openssl ; make ; make install //컴파일 및 설치# ls -l /web/httpd2/modules/libphp5.so//제일 중요한 파일. 이파일을 위해 컴파일을 했다.# vi /web/httpd2/conf/httpd.conf147행에 모듈이 추가 된것을 확인376행에 AddType application/x-httpd-php .php .php3 .php4 .php5 .htm .html .inc아파치 웹서버가 376행의 타입까지 인식을 하도록 만듬# cp php.ini-production /etc/php.ini# systemctl stop httpd2# systemctl start httpd2# systemctl status httpd2# firewall-config영구적 . http 선택 옵션 firewalld 다시불러오기# cd /web/httpd2/htdocs/ //웹서버의 홈폴더# vi phpinfo.php //샘플파일 만들기다음 한줄 추가&lt;?php phpinfo(); ?&gt;http://192.168.111.100/phpinfo.php 접속해보자 과연 이 과정들을 거쳐 만들어진것들이 최고의 성능을 낼까?그것은 확실히 모른다. 현재 패키지들이 잘 만들어져 나오기 때문에 굳이 컴파일을 통해 진행된것들이 훨신 좋은 성능을 얻거나 하지는 않는다.학습차원에서 컴파일을 진행해 보았다. 12장은 활용도가 높으므로 익혀두자","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"12장. 클라우드 서비스 구축","slug":"ThisIsLinux34","date":"2017-07-14T08:04:41.000Z","updated":"2017-07-14T23:02:10.912Z","comments":true,"path":"2017/07/14/ThisIsLinux34/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/14/ThisIsLinux34/","excerpt":"","text":"클라우드 서비스를 구축해봅시다.클라우드 서비스는 서버에 파일이 있고 각각의 PC마다 폴더를 지정하여 동기화가 된다. 즉 웹하드는 업로드 다운로드를 하지만 클라우드는 자동으로 동기화가 되는점이 다르다. 카페에서 관련 서버 두개를 깔자.123456789# cd /root/다운로드# yum -y localinstall owncloud- *# ls -l /var/www/html // owncloud가 깔렸나 확인# systemctl restart httpd //서비스 재시작# firewall-config//영구적 선택 - http,https//방화벽 설정 열기클라이언트에서 192.168.111.100/owncloud 접속admin 1234 입력자세한 사용법은 책을 참고하자!","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"12장. 웹하드 설치와 운영","slug":"ThisIsLinux33","date":"2017-07-14T05:26:47.000Z","updated":"2017-07-14T06:21:43.408Z","comments":true,"path":"2017/07/14/ThisIsLinux33/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/14/ThisIsLinux33/","excerpt":"","text":"웹하드는 웹서버상에서 파일을 저장할 수 있는것. 웹하드에 파일을 저장해 놓으면 전세계 어디서든지 내려받고 수정할 수 있다. 설정하자1234567891011121314151617181920212223# cd /var/www/html# ls -l# mv /root/다운로드/pydio-core-6.0.2.tar.gz / .# tar xfz pydio-core-6.0.2.tar.gz# mv pydio-core-6.0.2 webhard //폴더명 변경# chmod 707 webhard/ //일반사용자가 접근할 수 있게 권한변경# chown -R apache.apache webhard/# ls -l# yum -y --skip-broken install php-* //php관련 패키지 설치 //--skip-broken 설치하다 에러나면 그냥 무시해라# yum -y install php-mcrypt //레드헷 엔터프라이즈에 존재 //지금은 설치 안될것이다.# yum -y install epel-release//레드헷 엔터프라이즈도 yum으로 깔 수 있게됨 # yum -y install php-mcrypt //이젠 설치가 된다.# vi /etc/httpd/conf/httpd.conf151 행 AllowOverride All로 변경# systemctl restart httpd 리눅스 클라이언트에서 접속해보자http://192.168.111.100/webhard/ 접속click here 클릭한국어 하고 start wizardadmin admin 12345678 12345678 global option 클릭default language만 한국어로 변경 configurations storage 클릭하고database system 선택database에 xeDB 입력User에 xeUser 입력Password에 1234 입력Try connecting…. 클릭 add some users 클릭centoscentos@hanbit.co.kr센토스사용자12341234Install pydi 클릭웹브라우져 껏다 켜서http://192.168.111.100/webhard/ 접속 centos1234 후 로그인업로드를 해보자! 업로드 용량 제한을 풀자서버에서 실행하자123456789101112131415161718vi /etc/php.ini //현재는 8m이상 업로드가 안되는데 제한을 풀자.:384 (384라인으로감!)30초가 넘어가면 종료되도록 설정되어있다 300초로 수정하자:6728M를 100M으로 수정:8002M 를 100M으로 수정:wq# cd /var/www/html/webhard/data/cache/ //캐쉬로 인해 제대로 작동하지 않을 수 있으므로 캐쉬를 지우자 //지금 캐쉬폴더가 없는데 실행을 안해서 그런가..?# rm -f plugin*# systemctl restart httpd 업로드를 다시 해보자리눅스 클라이언트에서.. 1","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"12장. APM 개념과 설치, XE 설치와 운영","slug":"ThisIsLinux32","date":"2017-07-14T02:14:09.000Z","updated":"2017-07-14T05:29:18.083Z","comments":true,"path":"2017/07/14/ThisIsLinux32/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/14/ThisIsLinux32/","excerpt":"","text":"리눅스에서 가장 많이 활용하는것중 하나가 웹서버이다.APM = Apache 웹서버 + 프로그래밍언어 PHP + 데이터베이스 MaraiaDB리눅스 환경에서 사용될 경우 LAPM(Linux Apache,PHP,MariaDB)라고도 부름.APM 이라는 소프트웨어는 존재하지 않으며 이 3가지가 서로 잘 연동되어 운영되도록 만든 환경을 APM이라 함 APM 설치설치를 해보자서버에서 진행12345# rpm -qa httpd php mariadb-serverhttpd만 깔려있으므로 나머지를 깔자# yum -y install mariadb-server mariadb php php-mysqlnd# rpm -qa httpd php mariadb-server //깔린버전 확인해보자# yum -y install php-gd 가동해보자12345678910111213# systemctl restart httpd# systemctl restart mariadb# systemctl restart php // php는 서비스가 아니라 httpd에 포함되는 기능이라 시작이 안된다.# systemctl enable httpd //상시가동# systemctl enable mariadb # firewall-config영구적 선택 - http,httpsmysql은 안열어도 됨. 어차피 안에서만 접근하고외부에서 접근하지 않을것이므로 옵션- 다시불러오기 접속해보자파이어폭스 키고 localhost php 하나를 만들어보자12345678# cd /var/www/html# pwd# ls# touch phpinfo.php# vi phpinfo.php아래 한줄 입력&lt;?php phpinfo(); ?&gt; 파이어 폭스 켜고 http://localhost/phpinfo.php 접속해보자 mariadb 확인해보자1# mysql XE 설치123456789101112# vi /etc/httpd/conf/httpd.conf //XE 외부에서 접근 가능하게:set number151 none 를 All로 변경# systemctl restart httpd# cd /var/www/html# mv /root/다운로드/xe.zip .# unzip xe*# chmod 707 xe //권한 변경# cd /var/www/html/xe/modules/# ls //board는 게시판임 XE 실습123456# mysql&gt;GRANT ALL PRIVILEGES ON xeDB.* TO xeUser@localhost IDENTIFIED BY &apos;1234&apos;;&gt;exit# mysql -u xeUser -p1234&gt; CREATE DATABASE xeDB; XE 설정외부에서 해도되고 내부에서 해도된다. 즉 관계 없다.윈 클라이언트로 하자.192.168.111.100/xe 접속한국어 . 다음동의. 다음다음mysql 선택 다음xeUser /1234 /xeDB 다음kora선택 다음aa@aa.com / 4321 /4321 관리자임. / admin 게시판 추가는 책을보자","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"11장. 쇼핑몰 데이터베이스 구축, Oracle 설치, Oracle에서 쇼핑몰 DB 구축","slug":"ThisIsLinux31","date":"2017-07-13T09:09:57.000Z","updated":"2017-07-13T12:22:00.473Z","comments":true,"path":"2017/07/13/ThisIsLinux31/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/13/ThisIsLinux31/","excerpt":"","text":"서버에서 실행해도 되고 윈 클라이언트에서 해도된다. 그러나 윈 클라이언트에서 해보자 윈도우에서 실행cmd 열기cd “c:\\Program Files (x86)”cd “MariaDB 10.0”cd MariaDB 10.0cd bin mysql -h 192.168.111.100 -u winuser -p4321 입력쿼리문은 책을 참조하자….. 오라클을 설치해보자서버에서 실행하자 카페에서 링크타고 오라클을 들어가서 깔자123456789101112131415161718192021222324252627# cd 다운로드/# ls -l# unzip oracle* //압축을 풀자# ls -l Disk1/# cd Disk1/오라클을 설치하기 위해서는 가상메모리 2기가가 필요함.그래서 추가적으로 2기가를 추가한다.# dd if=/dev/zero of=/swapfile bs=1024 count=4194304# mkswap /swapfile //스왑메모리로 만들자# swapon /swapfile //스왑을 키자# swapon -s //스왑 확인 총 (6기가 임을 확인)스왑을 껏다 켜도 유지되도록 하자# cd /etc/rc.d # chmod 755 rc.local# vi rc.local맨 밑에swapon /swapfile 추가# reboot# swapon -s //스왑 확인 총 (6기가 임을 확인)오라클을 본격적으로 설치하자# cd 다운로드/Disk1/# pwd# ls -l# yum -y localinstall oracle* 오라클을 설정하자123456# service oracle-xe configure엔터(8080은 외부로 접속하는 포트)엔터(1521은 sql+로 접속하는 포트)1234엔터1234엔터y 엔터(자동으로 실행할꺼냐) 오라클 서비스를 시작하자123456789101112131415# /etc/init.d/oracle-xe start //오라클 시작# vi /etc/bashrc //맨아래 다음을 입력.# . /u01/app//oracle/product/11.2.0/xe/bin/oracle_env.sh //오라클 환경설정하는 스크립트 실행하는것. //껏다켜면 이 한줄을 입력해야 하지만 //그 과정을 없애기 위해 /etc/bashrc에 추가# firewall-config영구적 선택.포트 탭 선택추가 8080 tcp추가 1521 tcp(오라클을 센토스에서 만든것이 아니라 등록이 되어있지 않다.)옵션 - Firewalld 다시불러오기 오라클에 접속해보자웹브라우저 실행192.168.111.100:8080/apexinternaladmin1234로그인123412341234applyreturn1234 로그인 마리아db에서 입력한 쿼리문을 오라클에서 실행해보자.123456# mkdir /oradata //데이터베이스가 생성될 디렉토리# chmod 777 /oradata# sqlplus //오라클에서 데이터베이스 시작system 입력 //오라클에서 가장 높은 관리자는 system1234 입력책보고 쿼리 입력","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"11장. MariaDB 설치/운영 , Windows에서 접속","slug":"ThisIsLinux30","date":"2017-07-12T09:21:35.000Z","updated":"2017-07-14T02:38:30.299Z","comments":true,"path":"2017/07/12/ThisIsLinux30/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/12/ThisIsLinux30/","excerpt":"","text":"마리아 DB 운영DBMS 설치12345678910111213141516171819카페에 올려놓은 마리아 db를 세개 다 받자.# yum -y remove mariadb-libs // 버전이 달라 새로 설치하면 충돌우려..# yum -y localinstall Maria*# systemctl restart mysql //mysql이 오라클로 들어가자 //개발자들이 마리아를 만들어냄.. # systemctl status mysql# checkconfig mysql on // systemctl enable mysql 과 동일 //상시가동하도록 설정# firewall-config //방화벽 열기영구적 탭 -&gt; 다시불러오기# mysql // 마리아디비 실행&gt; showdatabases; //그냥 확인차원칙은# mysql -u root -p 라고 입력 후 비번입력해야함지금은 비번을 설정 하지 않았으므로 엔터만 누르면 된다. 마리아 디비 암호 설정123456# mysqladmin -u root password &apos;1234&apos;마리아 디비 사용자인 root는 비번이 1234# mysql -u root -p //로그인1234 입력&gt;exit 윈도우 클라이언트에서 마리아DB 접속카페 접속해서 마리아디비 설치리눅스는 서버 클라이언트 따로지만 윈도우용은 하나다.다른건 설치하지 말고 클라이언트만 설치하자 서버에서 실행1234567# mysql -u root -p&gt; USE mysql&gt;SELECT user,host FROM user WHERE user NOT LIKE &apos;&apos;;루트 사용자는 외부에서 접속할 수 없다는 것을 확인.&gt;GRANT ALL PRIVILEGES ON *.* TO winuser@&apos;192.168.111.%&apos; IDENTIFIED BY &apos;4321&apos;; //192.168.111.XXX 는 허용하겠다.(윈도우 유저의 아이피의 마지막이 변동가능성이 있기 때문에 %로 처리) 윈도우에서 실행cmd 열기cd “c:\\Program Files (x86)”cd “MariaDB 10.0”cd MariaDB 10.0cd bin mysql -h 192.168.111.100 -u winuser -p4321 입력show databases;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"10장. 웹 메일의 설치 및 사용","slug":"ThisIsLinux29","date":"2017-07-11T18:40:05.000Z","updated":"2017-07-12T11:10:14.549Z","comments":true,"path":"2017/07/12/ThisIsLinux29/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/12/ThisIsLinux29/","excerpt":"","text":"웹 메일의 설치 및 사용10장의 지금까지의 구현내용은 문제가 있다. 일반사용자는 POP3, SMTP 등에 대한 설정하는것에 대한 지식이 없으며 원하지도 않는다.즉. 이메일 서버를 구축하려면 웹 메일까지 설정을 해주어야 한다.우리는 이를 위해 다람쥐 메일이라고 불리는 squirrelmail을 사용한다. 다람쥐 메일 설치(서버)센토스에서 다람쥐는 제공하지 않으므로 페도라것을 사용해야한다. (페도라의 거의 모든 패키지는 센토스에서 돌아간다.)1234567891011121314151617181920212223242526272829303132333435363738394041# wget http://download.hanbit.co.kr/centos/7/squirrelmail-1.4.22-13.fc20.noarch.rpm# yum -y localinstall squi* //로컬설치# chown apache.apache -R /usr/share/squirrelmail/ //웹사용자인 아파치로 소유주 변경# chown apache.apache -R /var/lib/squirrelmail/# chown apache.apache -R /var/spool/squirrelmail/# chown apache.apache /etc/squirrelmail/config.php# /usr/share/squirrelmail/config/conf.pl //설정할 수 있는 실행파일2입력1 (도메인 변경)naver.comA4mail.naver.com8othersr101ko_KR2euc-krsrsq간단하게 다람쥐 메일을 들어올 수 있게 설정# vi /etc/httpd/conf/httpd.conf 맨위에 다음 한줄 추가Alias /webmail/ /usr/share/squirrelmail/# systemctl restart httpd # systemctl enable httpd 포트를 추가해야하는데 방화벽을 아까 꺼놨기 때문에 따로 하지 않겠다.웹을 www로 들어가기 떄문에 웹주소도 네임서버에 추가# vi /var/named/naver.com.db 맨뒤에 다음 한줄 추가www IN A 192.168.111.100# systemctl restart named 클라이언트에서 테스트 해보자파이어폭스에서 www.naver.com/webmail/ 입력맨아래 예외 추가 -&gt; 보안예외 확인lee / lee 입력편지쓰기-&gt; kim@daum.net -&gt;전송윈도우 클라이언트에서 받기를 눌러보자, 그 후 답장을 눌러 보내보자","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"10장. 센드메일 서버의 구현","slug":"ThisIsLinux28","date":"2017-07-11T08:30:49.000Z","updated":"2017-07-11T18:19:07.383Z","comments":true,"path":"2017/07/11/ThisIsLinux28/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/11/ThisIsLinux28/","excerpt":"","text":"네임서버를 만들었으니 이메일을 보내는 메일서버를 만들어 보자. 1.서버 메일서버를 만들자(naver)1.1 서버에서 메일 서버를 만들자(서버에서 진행)123456789101112131415161718192021222324252627282930313233# yum -y install sendmail-cf dovecot //sendmail-cf 보내는메일서버 //devoct 받는 메일서버# vi /etc/mail/sendmail.cf :set number85를 Cwnaver.com 으로 수정264 Addr=127.0.0.1 를 지운다저장외부 호스트가 메일을 전달할 수 있도록 허가# vi /etc/mail/access 다음을 추가naver.com RELAYdaum.net RELAY192.168.111 RELAY# makemap hash /etc/mail/access &lt; /etc/mail/access //변경내용 적용사용자의 메일박스에서 메일을 꺼내 사용자에게 전달하는 도베캇 설정# vi /etc/dovecot/dovecot.conf:set number24행 30행 33행 주석제거저장# vi /etc/dovecot/conf.d/10-ssl.conf:set number8행 ssl=yes로 수정저장# vi /etc/dovecot/conf.d/10-mail.conf:set number25행 주석제거119행 mail_access_groups =mail 으로 수정159행 주석제거저장 1.2 서버에 사용자를 만들자(서버에서 진행)1234# adduser lee# passwd lee암호 lee 이 사용자는 lee@naver.com 1.3 서비스를 시작하자(서버에서 진행)12345# systemctl restart sendmail# systemctl enable sendmail# systemctl restart dovecot# systemctl enable dovecot 1.4 서버에서 만든 메일서버가 잘 작동하나 확인해보자(클라이언트에서 진행)이를 위해 클라이언트에서 메일을 보낸다.(클라이언트에서 실행)12345678910111213141516171819202122232425262728293031323334# su# vi /etc/resolv.confnameserver 192.168.111.100# yum -y install evolution //이메일 클라이언트 프로그램프로그램-&gt;오피스-&gt;에볼루션계속-&gt;계속 전체이름: 이네이버전자메일 주소: lee@naver.com계속서버종류 pop선택서버: mail.naver.com사용자이름: lee포트: 995암호화방식: SSL특정방식사용계속계속서버 mail.naver.com계속이름 : 네이버 메일계속적용계속 허용 //꼭 해야한다.암호: lee로그인 암호:centos새로만들기받는사람 lee@naver.com새로만들기를 눌러 lee@naver.com으로 메일을 하나 보내보자. 그러면 보낸편지함에 하나 들어있고 메일박스로 들어가있는상태. 그 후 보내기/받기를 누르면 받은편지함에 메일이 하나 생성된다. 2.서버B 메일서버를 만들자(daum)2.1 서버B에 메일 서버를 만들자(서버B에서 진행)123456789101112131415161718192021222324252627282930313233# yum -y install sendmail-cf dovecot //sendmail-cf 보내는메일서버 //devoct 받는 메일서버# vi /etc/mail/sendmail.cf :set number85를 Cwdaum.net 으로 수정264 Addr=127.0.0.1 를 지운다저장외부 호스트가 메일을 전달할 수 있도록 허가# vi /etc/mail/access 다음을 추가naver.com RELAYdaum.net RELAY192.168.111 RELAY# makemap hash /etc/mail/access &lt; /etc/mail/access //변경내용 적용사용자의 메일박스에서 메일을 꺼내 사용자에게 전달하는 도베캇 설정# vi /etc/dovecot/dovecot.conf:set number24행 30행 33행 주석제거저장# vi /etc/dovecot/conf.d/10-ssl.conf:set number8행 ssl=yes로 수정저장# vi /etc/dovecot/conf.d/10-mail.conf:set number25행 주석제거119행 mail_access_groups =mail 으로 수정159행 주석제거저장 2.2 서버B에 사용자를 만들자(서버B에서 진행)1234# adduser kim# passwd kim암호 kim 이 사용자는 kim@daum.net 2.3 서비스를 시작하자(서버B에서 진행)12345678# systemctl restart sendmail# systemctl enable sendmail# systemctl restart dovecot# systemctl enable dovecot# systemctl stop firewalld //방화벽 끄기# systemctl disable firewalld //방화벽 끄기 3. 최종테스트를 해보자3.1 윈도우 클라이언트에서 해보자썬더버드를 받자. 이때 네이버에 접속되지 않는데 아까 도메인 서버를 100으로 세팅해놔서 그렇다..이름 : 김다음메일주소 : kim@daum.net암호 : kimPOP3 선택하고 완료lee@naver.com 으로 메일을 보내보자클라이언트로 돌아와 보내기/받기를 눌러보자 그 후 회신을 눌러보자그 후 윈도우 클라이언트로 와서 받기를 눌러보자.","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"10장. 메일서버 개념, 메일서버를 위한 네임서버 구현","slug":"ThisIsLinux27","date":"2017-07-10T15:56:35.000Z","updated":"2017-07-11T17:41:52.193Z","comments":true,"path":"2017/07/11/ThisIsLinux27/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/11/ThisIsLinux27/","excerpt":"","text":"메일서버네임서버에 대한이해가 필수적이므로 이해하고 넘어올것.E-mail의 송수신에서 사용되는 프로토콜 다음, 네이버의 메일서버 계정을 갖고있다면 kim@daum.net / lee.naver.com 가 있다. kim@daum.net -&gt; lee.naver.com 메일전송smtp를 통해 kim 메일서버의 큐에 들어가고 여유가 있을 때 smtp 프로토콜을 이용해 lee의 메일서버로 보내놓는다. 메일서버는 메일 박스에 넣어놓고 lee는 pop3 imap프로토콜을 써서 자신의 컴퓨터로 확인한다.보내는 프로토콜 : smtp받는 프로토콜 : POP3 IMAP 실습계획Server : naver 메일서버, 네임서버 역할을 한다.Server(B) : daum 메일 서버WinClient : 메일 클라이언트Client : 메일 클라이언트 1. 메일서버를 구현하기 전에 네임서버를 구현하자1.1 다음을 서버에서 실행하자123456789101112131415# vi /etc/hostname 첫줄 지우고 mail.naver.com 입력# vi /etc/hosts 맨 뒤에 다음 입력 192.168.111.100 mail.naver.com# yum -y install sendmail //메일서버를 구현하려면 sendmail이 설치되어 있어야함# vi /etc/mail/local-host-names 아래 mail.naver.com 입력# vi /etc/sysconfig/network HOSTNAME=mail.naver.com 입력# reboot 1.2 다음을 서버 B에서 실행하자12345678910111213141516# yum -y install sendmail# vi /etc/hostname 첫줄 지우고 mail.daum.net 입력# vi /etc/hosts 맨 뒤에 다음 입력 192.168.111.200 mail.daum.net# vi /etc/mail/local-host-names 아래 mail.daum.net 입력# vi /etc/sysconfig/network HOSTNAME=mail.daum.net 입력# reboot 1.3 서버를 마스터네임 서버로 만들자 (서버에서 실행하자)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# yum -y install bind bind-chroot# vi /etc/named.conf:set number11행 127.0.0.1 지우고 any로12행 ::1 지우고 none로17행 localhost 지우고 any로여기까지만 하면 캐싱전용 네임서버이다.우리가 만들것은 마스터 네임서버이므로 맨아래 다음을 추가zone &quot;naver.com&quot; IN &#123; type master; file &quot;naver.com.db&quot;; allow-update &#123; none; &#125;;&#125;;zone 위에 커서 올리고 5yy 누르고 p(5줄 복사)zone &quot;daum.net&quot; IN &#123; type master; file &quot;daum.net.db&quot;; allow-update &#123; none; &#125;;&#125;;저장 후 종료# cd /var/named# touch naver.com.db# vi naver.com.db$TTL 3H@ SOA @ root. ( 2 1D 1H 1W 1H ) IN NS @ IN A 192.168.111.100 IN MX 10 mail.naver.com. //달라진부분; mail exchange 메일이 오면 mail.naver.com한테 메일처리를 하게해라mail IN A 192.168.111.100# cp naver.com.db daum.net.db //내용이 비슷하니까 복붙# vi daum.net.db$TTL 3H@ SOA @ root. ( 2 1D 1H 1W 1H ) IN NS @ IN A 192.168.111.200 IN MX 10 mail.daum.net.mail IN A 192.168.111.200으로 수정# named-checkconf //name.conf파일을 확인 //아무메세지가 없으면 문법문제 없음# named-checkzone naver.com naver.com.db# named-checkzone daum.net daum.net.db포트는 여러개 열어야 하는데 복잡하므로 아얘포트문제는 생기지 않도록 다 열어놓자. 즉 방화벽을 꺼놓자.# systemctl stop firewalld //방화벽 끄기# systemctl disable firewalld //재부팅해도 꺼지도록# systemctl restart named //네임서버 시작# systemctl enable named //재부팅해도 켜지도록# systemctl status named //잘 돌고있는지 확인# nslookup //실제 내부에서 잘동작하는지 확인&gt;server 192.168.111.100&gt;mail.naver.comAddress: 192.168.111.100 //성공&gt;mail.daum.netAddress: 192.168.111.200 //성공 2.각 컴퓨터의 로컬네임 서버를 생성한 네임서버로 지정하자2.1 서버의 네임서버를 지정123456# cd /etc/sysconfig/network-scripts/# ls //수정할 파일을 확인하자 ens....# # vi ifcfg-ens32 // 껏다 켜도 유지되도록 설정DNS1=192.168.111.100 으로 하자# systemctl restart network# cat /etc/resolv.conf //확인 서버 B의 네임서버를 지정123456# cd /etc/sysconfig/network-scripts/# ls //수정할 파일을 확인하자 ens....# # vi ifcfg-ens32 // 껏다 켜도 유지되도록 설정DNS1=192.168.111.100 으로 하자# systemctl restart network# cat /etc/resolv.conf //확인 2.2 클라이언트의 네임서버 지정클라이언트는 고정ip가 아니기 때문에 껏다 켜면 vmware가 제공하는 2번으로 바뀌기 때문에 클라이언트는 껏다 켜지 않겠다. 그러므로 conf파일만 수정하자123456789101112$ su -# vi /etc/resolv.confnameserver 192.168.111.100으로 수정# exit# nslookup&gt; mail.daum.netAddress: 192.168.111.200 //확인&gt; mail.naver.comAddress: 192.168.111.100 //확인 2.3 윈도우 클라이언트 설정12345678cmd 열기ipconfig //이더넷 어댑터 로컬 영역 연결netsh interface ip set dns &quot;로컬 영역 연결&quot; static 192.168.111.100ping mail.daum.net 1#","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"9장. 마스터 네임서버 구축, 라운드 로빈 방식 네임서버","slug":"ThisIsLinux26","date":"2017-07-09T05:49:08.000Z","updated":"2017-07-10T15:57:33.506Z","comments":true,"path":"2017/07/09/ThisIsLinux26/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/09/ThisIsLinux26/","excerpt":"","text":"앞에한건 캐싱전용이었다.캐싱전용네임서버 - 자기가 관리하는건 없고 무조건 밖에 나가서 알아다가 알려줌. 마스터 네임 서버 - 자기가 관리하는 것들이 있다. 마스터 네임 서버 구축1. 웹서버 하나 간단하게 만들자(서버)1234567# rpm -qa httpd //설치가 되어있다.# systemctl status httpd //시작되어있나 확인# systemctl restart httpd //시작# firewall-config영구적 - http 체크 - firewalld 다시불러오기# vi /var/www/html/index.html&lt;h1&gt; CentOS 7 홈피 입니다&lt;/h1&gt; //삽입 2. ftp서버 간단하게 만들자(서버B)서버 B를 켠다.123# yum -y install vsftpd# firewall-cmd --permanent --add-service=ftp //방화벽설정# firewall-cmd --reload 3. 환경설정을 해주자(서버)서버에서12345678910# vi /etc/named.conf:set number맨아래 가서zone &quot;centos.com&quot; IN &#123;type master; file &quot;centos.com.db&quot;; allow-update&#123;none;&#125;;&#125;;입력. 이 의미는 서버컴퓨터는 centos.com의 마스터 네임서버다. 그리고 상세정보는 centos.com.db(임의로 지은것)에 들어있다.# named-checkconf //방금작성한것 문법적으로 잘못된것 없나 확인 4. centos.com.db를 만들자(서버)123456789101112131415161718192021# cd /var/named# pwd# ls# touch centos.com.db# vi centos.com.db아래 추가$TTL 3H@ SOA @ root. (2 1D 1H 1W 1H) IN NS @ IN A 192.168.111.100www IN A 192.168.111.100ftp IN A 192.168.111.200위 세줄은 항상 써주는것.네번째는 자기 자신의 ip 입력나머지 아래 두줄은 알려줄것.# named-checkzone centos.com centos.com.db //오류있는지 확인# systemctl restart named방화벽 설정은 앞에서 해줬으니 안해도됨 5. 접속 테스트해보자클라이언트 켜자12345$ su -$ vi /etc/resolv.conf맨 아래 192.168.111.100 으로 수정www.centos.com 접속해보자ftp 접속해보자서버 B에서 다음을 실행하자(ftp서비스 시작)12# systemctl restart vsftpd# systemctl status vsftpd클라이언트에서 접속해보자123# ftp ftp.centos.com // anonymous //엔터 라운드 로빈 방식의 네임 서버이전에 실습한 방식은 여러명이 동시에 접속할 경우 서버 하나에 부하가 걸린다. 그래서 웹 서버를 여러개 만들어서 요청이 들어올 때마다 번갈아가면서 요청처리. 네이버가 이 방식을 쓴다.123# nslookupwww.naver.com두개가 넘어온다. 실습.www.john.com 으로 접속 했을 때 각각 다른 페이지를 뿌려주는실습.(라운드로빈 방식 확인가능) 1234# nslookup&gt; www.yes24.com //아이피 주소를 확인하기위해&gt; www.danawa.com //아이피 주소를 확인하기위해&gt; www.nate.com //아이피 주소를 확인하기위해 1234567891011121314151617# cd /var/named# vi centos.com.db아래 두줄 지우고 다음으로 대체www IN CNAME webserver.centos.com.webserver 100 IN A 61.111.13.51 200 IN A 119.205.194.11 300 IN A 120.50.131.112순차적으로 주소를 알려준다. 100,200,300 은 순차번호이다.# systemctl restart named# nslookup&gt;server 192.168.111.100&gt;www.centos.com결과가 세개가 온다. 클라이언트에서 접속해보자123# vi /etc/resolv.conf//192.168.111.100 이 맞나 확인//아니면 설정하기 웹 브라우져 닫고www.centos.com 들어가보자(여러번)","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"9장. 도메인 이름 체계 개념, 캐싱 전용 네임서버 구축","slug":"ThisIsLinux25","date":"2017-07-09T01:29:00.000Z","updated":"2017-07-10T15:51:05.334Z","comments":true,"path":"2017/07/09/ThisIsLinux25/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/09/ThisIsLinux25/","excerpt":"","text":"초창기 인터넷에서는 1대의 네임 서버만으로 충분히 IP주소와 이름의 관리가 가능했다. 하지만 인터넷이 확장되면서 그것이 도메인 이름 체계가 고안되었다. 원칙은 www.nate.com. 이다. 맨 뒤에 .을 붙여줘야 한다. 로컬 네임서버가 작동하는 순서www.nate.com. 접속과정1./etc/hosts 를 보고 없으면 /etc/resolv.conf 에 있는 로컬 네임서버를 참고한다.2.하지만 이 로컬네임서버도 많은것을 알지 못하므로 얘도 루트 네임서버한테 물어본다. 이렇게. “내가지금 www.nate.com으로 가려한다.”3.그러면 루트네임서버가 “그건 내가 모르지만 내가 관리하는 com의 네임서버 ip를 줄게”4.그러면 로컬네임서버는 다시 com네임서버에게 다시 물어본다5.그러면 com네임서버가 nate ip를 알려준다. 그러면 nate.com아이피는 www의 ip를 응답해준다. www.daum.net. 접속과정루트네임서버 -&gt; net 네임서버 -&gt;daum네임서버 -&gt;www네임서버 이제 우리가 할 실습!/etc/resolv.conf 에 있는 로컬네임서버를 만드는것.서버컴퓨터 : 캐싱전용 네임서버 (PC에서 URL로 IP주소를 얻고자 할 때 해당하는 URL의 IP주소를 알려주는 네임 서버를 말함) 클라이언트,서버B 에서 /etc/resolv.conf의 주소를 서버컴퓨터로 한다. 서버 설정1. 관련 패키지 설치1# yum -y install bind bind-chroot 2. 누가 서버컴퓨터로 물어보든 응답해주게 설정123456# vi /etc/named.conf //캐싱정보관련 설정파일:set number11행 보면 127.0.0.1 지우고 any로 변경 //누가 서비스를 요청하던 제공하겠다12행 ::1 지우고 none로 변경17행 localhost any로 변경named.conf 파일을 수정함으로서 누가 서버컴퓨터가 누가물어보든 응답을 해준다. 3. 서비스 재시작 및 환경설정123456789101112# systemctl restart named //네임서버의 서비스 이름은 named# systemctl status named //작동여부 확인disable 가 있다는건 껏다켜도 동작하지 않는다는것.# systemctl enable named //껏다켜도 작동하도록 설정# firewall-config영구적 선택 -&gt; dns 선택-&gt; 옵션/firewalld다시불러오기# nslookup //내부적으로 잘돌아가는지 테스트&gt;server 192.168.111.100&gt;www.daum.net&gt;exit 클라이언트 설정Client 켜고 실행123456# su -c &apos;vi /etc/resolv.conf&apos;password 입력192.168.111.100 으로 수정파이어폭스로 아무데나 접속해보자 Server B 켜고 실행123456789# vi /etc/resolv.confpassword 입력192.168.111.100 으로 수정# ping -c 3 www.yahoo.com# yum -y install elinks //텍스트모드의 웹브라우져# elinks //실행 윈도우에서 설정제어판 열기네트워크 상태 및 작업보기로컬영역 연결 클릭속성IPv4 속성다음 dns 서버 주소 사용기본 설정 DNS 서버에 192.168.111.100 입력 윈도우에서 원래대로 돌리기cmd 열고ipconfig 입력이더넷 어댑터 뒤에있는 글자 복사. netsh interface ip set dns “로컬 영역 연결” dhcp//로컬 영역 연결은 (이더넷 어댑터 뒤에있는 글자)","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"9장. 네임서버 개념, IP주소 획득 흐름","slug":"ThisIsLinux24","date":"2017-07-09T00:07:45.000Z","updated":"2017-07-10T15:51:04.205Z","comments":true,"path":"2017/07/09/ThisIsLinux24/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/09/ThisIsLinux24/","excerpt":"","text":"네임서배 개요네임서버=DNS(Domain Name System)서버도메인 이름을 IP주소로 변환시켜 주는 역할 = 이름해석12345678910# nslookup //컴퓨터에 연결된 네임서버를 조회&gt; server //도메인 이름을 칠 때 물어보는 주소 조회Default server: 192.168.111.2Address: 192.168.111.2#53&gt; www.nate.comServer: 192.168.111.2Address: 192.168.111.2#53exit 네임서버의 위치를 저장해 놓는곳은?123# cat /etc/resolv.confGenerated by NetworkManagernameserver 192.168.111.2 실습123456789101112131415# vi /etc/resolv.conf#을 넣어 두줄 다 주석처리.저장 후 종료www.nate.com 접속되지 않음# vi /etc/hosts211.234.241.205 www.nate.com 추가저장 후 종료www.nate.com 접속 가능네임서버가 죽어있는데 열린다. /etc/hosts에 먼저 접근 후resolv.conf파일에 접근한다.즉 수첩에 전화번호가 적혀있으면 114에 전화하지 않는것. nate.com 접속방식웹브라우저에서 www.nate.com을 치면 /etc/hosts에 접근하여 해당 ip가 있는지 확인을 한다. 존재 할 경우 그 ip로 접속하고 존재하지 않을 경우 /etc/resolv.conf 로 가서 네임서버를 확인하고 해당 ip주소를 알아온다.","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"8장. SSH서버, VNC서버","slug":"ThisIsLinux23","date":"2017-07-08T09:16:00.000Z","updated":"2017-07-10T15:51:06.159Z","comments":true,"path":"2017/07/08/ThisIsLinux23/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/08/ThisIsLinux23/","excerpt":"","text":"SSH서버텔넷과 용도는 동일하지만 보안이 강화되어있음명령문을 입력 시 암호화 되어서 날라간다. SSH서버를 쓰는것이 권장사항이다. CentOS에서 쓰는 SSH서느는 openSSH 서버라 함. 실습1.서버가 설치되었는지 확인12# rpm -qa | grep openssh설치되어있다. 2.가동되고 있는지 확인12345# systemctl status sshdLoaded: loaded (/usr/lib/systemd/system/sshd.service; enabled) //enable는 상시가동이라는 뜻Active: active (running) since 토 2017-07-08 17:43:06 KST; 1h 5min ago //돌고 있다.즉 ssh는 기본적으로 centos에서 깔려있고 가동되어 있다.기본적으로 쓰인다!!! 3.방화벽 열렸는지 여부 확인12# firewall-config쭉 내리면 ssh가 켜져있다. 4.새로운 리눅스(Client)에서 접속해보자클라이언트 켜자.1234# rpm -qa | grep openssh //깔려있나확인# ssh teluser@192.168.111.100 //telnet와 접속방법이 다름# ifconfig //서버컴퓨터의 아이피 확인 5.윈도우에서 접속해보자Putty 설치192.168.111.100 접속참고로 ssh는 포트 22 telnet는 23한글이 깨지면 오른쪽 누르고 유니코드로 전환abc.txt를 하나 만들고 gedit abc.txt를 실행하면 되질 않는다.왜냐하면 텔넷,SSH는 텍스트 모드로만 전송이 되기 때문에.즉 그래픽 명령어는 아얘 쓸 수 없다. 그럼 telnet ssh 다른점이 없는건가?그렇다. 기능은 같으나 ssh가 보안이 추가된 것이다. VNC 서버X 윈도우 환경으로 원격접속을 사용하고 싶을 때.telnet ,ssh 보다 많이 느리다. 그래픽이 왔다갔다하기 때문에! 1.VNC 설치 및 설정123# rpm -qa | grep tiger //설치유무 확인//미니멈 버전이 깔려있다. 다시깔자# yum -y install tigervnc-server VNC는 사용자한테 너 접속해, 너 화면번호 몇번 써 를 지정해야한다. 2.센토스 사용자 너 1번화면으로 접속해를 설정123456# cp /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@:1.service//1번화면을 쓰기위한 작업# vi /etc/systemd/system/vncserver@\\:1.service :set number40행,41행 의 &lt;USER&gt;을 지워버리고 centos로 고침 그리고 저장 후 종료 3.방화벽 열기1# firewall-config 설정에서 영구적 선택쭉 내려서 vnc-server체크옵션에서 firewalld 다시불러오기 클릭 4.centos사용자가 1번화면으로 들어올 때 전용 비밀번호를 생성즉 vnc 전용 비밀번호 생성123# su - centos# vncserver암호는 123456으로 설정 5.접속해보자리눅스 클라이언트에서 접속12345# rpm -qa | grep tiger //깔려있지 않은것을 확인# su -c &apos;yum -y install tigervnc&apos; //루트 권한으로 실행하는것.# vncviewer 192.168.111.100:1 //1은 디스플레이 번호 password 입력윈도우 클라이언트에서 접속카페이서 tigervnc 설치파일 깔기옵션해서 해상도를 낮추면 사용할만 함(color level)tigervnc vncviewer을 켜고192.168.111.100:1 입력하고 암호 123456","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"8장. 텔넷서버","slug":"ThisIsLinux22","date":"2017-07-08T08:32:45.000Z","updated":"2017-07-10T15:54:38.124Z","comments":true,"path":"2017/07/08/ThisIsLinux22/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/08/ThisIsLinux22/","excerpt":"","text":"이번장은 상당히 중요하다. 앞으로의 모든 장은 네트워크 서버를 구축하는데 8장이 첫 구축이다. 그러므로 8장을 잘 이해하면 큰 흐름을 이해 할 수 있다. 텔넷서버오랫동안 전통적으로 사용되어 온 원격 접속 방법이다.텔넷 서버에 접속하려면 텔넷 클라이언트를 쓰면 된다. 각 서버마다 해당되는 클라이언트가 존재한다. 텔넷 서버 구축 단계1.텔넷 서버 설치2.텔넷 서비스 시작3.텔넷 전용 사용자 생성4.방화벽 설정(포트 열기)5.텔넷 서비스 상시가동6.클라이언트에서 접속 실습모든 가상머신을 초기화하자! 1.텔넷 서버 설치12# rpm -qa | grep telnet //텔넷이 설치되었나 확인# yum -y install telnet-server //설치되어있지 않아 설치 2.텔넷 서버 서비스 시작12345# systemctl restart telnet.socket //restart는 시작이 안되어있으면 새로 시작하고 시작되어있으면 재시작함.# systemctl status telnet.socket //가동여부 확인 3.텔넷 전용 사용자 생성12# adduser teluser# passwd teluser //1234로 설정 4.방화벽 설정(포트 열기)외부에서 접속이 가능하기 위해서 여는 것이므로 일단 내부에서 잘 접속이 되는지 확인 후 에 방화벽을 열자1234567891011# yum -y install telnet //텔넷 클라이언트 프로그램 설치# telnet 127.0.0.1 //자기 자신으로 접속 teluser / 1234 입력# exit //종료 이제 방화벽 설정하자# firewall-config //설정차을 띄우자 설정 영구적 탭 선택 //서버는 한번 쓰는게 아니라 영원히 쓰기 때문에. 영역 탭의 public 선택 후 서비스에서 telnet 체크 옵션-&gt;Firewall 다시불러오기 이제 포트가 열렸다. 5.텔넷 서비스 상시가동포트가 열렸지만 컴퓨터가 껏다 켜면 제대로 작동안하기 때문에 다음을 입력1# systemctl enable telnet.socket //껏다 켜도 유지됨 6.클라이언트에서 접속이제 윈 클라이언트를 부팅하고 접속해보자.접속을 위해서는 서버의 IP주소가 필요하다. 서버에서 다음을 입력1# ifconfig //192.168.111.100IP주소 확인 했으니 윈 클라이언트로 가서 제어판-프로그램-프로그램 및기능Windows 기능 사용/사용안함 가서 맨아래 텔넷 클라이언트 기능 설치 윈도우 cmd를 열자그 후 telnet 192.168.111.100teluser /1234 입력 후 엔터접속이 된다.exit로 종료","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"7장. 셸 스크립트 프로그래밍","slug":"ThisIsLinux21","date":"2017-07-08T01:54:28.000Z","updated":"2017-07-08T05:39:45.800Z","comments":true,"path":"2017/07/08/ThisIsLinux21/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/08/ThisIsLinux21/","excerpt":"","text":"Centos의 기본 셸은 bash셸은 명령어를 해석 해 주는 것이다. -Alias, History, 연산 등의 기능을 갖는다. 환경변수12# echo $PATH //명령어를 실행하면 //명령어를 찾는 폴더들이 출력됨. 셸 스크립트 프로그래밍C언어와 유사하다.변수, 반복문,제어문 등의 사용이 가능vi, gedit으로 작성 가능 12345678910111213# vi name.sh //셸의 약자로 sh다음과 같이 입력#!/bin/sh //셸은 이것을 무조건 쓴다.echo &quot;사용자이름: &quot;$USERNAMEexit 0vi를 빠져나와서# sh name.sh //실행 방법 1# chmod u+x name.sh //실행방법2# ./name.sh //실행방법2 변수의 기본변수를 사용하기 전에 미리 선언하지 않으며, 변수에 처음 값이 할당되면서 자동으로 변수가 생성모든 변수는 ‘문자열(String)’로 취급변수 이름은 대소문자를 구분변수를 대입할 때 ‘=’ 좌우에는 공백이 없어야함 12345678910111213141516# testval = Hello //에러발생. 공백존재# testval=Hello# echo $testval //Hello 출력됨# testval=Yes Sir //에러발생# testval=&quot;Yes Sir&quot;# echo $testval //Yes Sir 출력# testval=7+5# echo testval //7+5 출력# testval=&apos;expr 7+5&apos;# echo testval //12 출력","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"6장 사용자별 공간 할당(쿼터)","slug":"ThisIsLinux20","date":"2017-07-07T14:55:51.000Z","updated":"2017-07-07T15:54:10.207Z","comments":true,"path":"2017/07/07/ThisIsLinux20/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/07/ThisIsLinux20/","excerpt":"","text":"쿼터사용자마다 용량 제한을 두는것이다.ex.클라우드 서비스를 가입하면 데이터 양이 한정되어있음. 쿼터 실습설치 직후로 초기화하자. 새로운 디스크를 추가해서 쿼터 전용 디스크로 하자사용자의 홈 디렉토리는 별도의 디스크로 하는것이 효과적이다. 그리고 사용자별 쿼터도 지정해보자 1. 20기가짜리 하나 디스크 달자1234567# fdisk /dev/sdb# mkfs.ext4 /dev/sdb1# mkdir /userHome //앞으로 추가되는 사용자는 userHome를 홈 디렉토리로 함# mount /dev/sdb1 /userHome/# vi /etc/fstab/dev/sdb1 /userHome ext4 defaults 1 2 추가 2. 유저 두명 추가하자12345678910# useradd -d /userHome/john john //홈디렉토리를 지정하면서 유저생성# useradd -d /userHome/bann bann //홈디렉토리를 지정하면서 유저생성 # ls -l /userHome //확인# passwd john //암호는 1234로 설정# passwd bann //암호는 1234로 설정 3. 아까 추가한 디스크를 쿼터용으로 설정하자1234567# vi /etc/fstabdefaults 를 아래와 같이 변경defaults,usrjquota=aquota.user,jqfmt=vfsv0리부트 해도 되지만 귀찮으니까# mount --options remount /userHome# mount //맨아래서 확인 4. 쿼터디비생성명령어들에 대해 관심있으면 책을보자1234567891011# cd /userHome/# quotaoff -avug# quotacheck -augmn# rm -rf aquota.*# quotacheck -augmn# touch aquota.user aquota.group# chmod 600 aquota.*# quotacheck -augmn# quotaon -avug# ls -l //aquota.group , user 생긴것 확인 5. 개인별 쿼터 설정블록(block)이 현재 사용하는 키로바이트 수 소프트제한(soft)- 넘어갈수 있지만 기간이 있음하드제한(hard) -완전히 못넘어감 소프트를 100으로 주고 하드를 150을 주었을 때130을 저장하면 몇일 이내에 30메가를 줄여야함. inodes- 파일의 개수를 제한하는것123456789101112131415161718192021222324# edquota -u john //유저 존에 대해 쿼터를 수정하겠다.소프트 10240(10메가) 하드 15360(15메가)를 주고 저장# su - john //존으로 로그인# cp /boot/vmlinuz-3.10.0-123.el7.x86_64 test1 // 파일 복사# cp /boot/vmlinuz-3.10.0-123.el7.x86_64 test2# cp /boot/vmlinuz-3.10.0-123.el7.x86_64 test3쿼터가 넘어갔다고 경고 뜸# ls -l //데이터가 잘 들어갔다.# cp /boot/vmlinuz-3.10.0-123.el7.x86_64 test4sdb1: write failed, user block limit reached.cp: `test4&apos;에 쓰는 도중 오류 발생: 디스크 할당량이 초과됨cp: failed to extend `test4&apos;: 디스크 할당량이 초과됨 오류뜬다.# ls -l//마지막 데이터는 용량이 다름 즉 짤려있음# quota // 내가 얼마나쓰고 있는지 확인block 현재 사용량grace가 6일동안 봐준다는것. 6. 존이 한것을 밴한테 그대로 적용하기1234# exit //존 로그아웃# repquota /userHome //쿼터확인# edquota -p john bann","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"6장. LVM 개념과 구현, RAID에 CentOS 설치","slug":"ThisIsLinux19","date":"2017-07-07T03:42:04.000Z","updated":"2017-07-07T06:58:12.212Z","comments":true,"path":"2017/07/07/ThisIsLinux19/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/07/ThisIsLinux19/","excerpt":"","text":"LVMLogical Volume Manage여러개의 하드디스크를 합쳐서 한 개의 파일 시스템으로 사용하는것으로 필요에 따라 다시 나눌 수 있다.예로 2테라 두개를 합친 후 1테라 3테라로 나눠서 사용한다. 물리 볼륨:sda1, sdb1 등의 파티션 볼륨 그룹:물리 볼륨을 합쳐서 1개의 물리그룹으로 만드는것. 논리 볼륨:볼륨 그룹을 1개 이상으로 나눠서 논리 그룹으로 나눈 것 실습3기가, 2기가를 볼륨 그룹으로 만들고3기가, 1기가, 1기가 논리 볼륨으로 만들어보자 1. 2기가, 3기가 디스크 추가버츄어머신 에딧에서.. 2. 파티션 설정12345678910111213141516171819# fdisk /dev/sdbnp1엔터엔터t8ew# fdisk /dev/sdcnp1엔터엔터t8ew 3. 피지컬 볼륨으로 만들기12# pvcreate /dev/sdb1# pvcreate /dev/sdc1 4. 볼륨 그룹으로 만들기123# vgcreate myVG /dev/sdb1 /dev/sdc1# vgdisplay //볼륨그룹 확인 5. 1기가 3기가 1기가로 나누자123456# lvcreate --size 1G --name myLG1 myVG# lvcreate --size 3G --name myLG2 myVG# lvcreate --extents 100%FREE --name myLG3 myVG //나머지 다써라# ls -l /dev/myVG //확인 6. 포멧하자123# mkfs.ext4 /dev/myVG/myLG1# mkfs.ext4 /dev/myVG/myLG2# mkfs.ext4 /dev/myVG/myLG3 7. 마운트하자123456# mkdir /lvm1 /lvm2 /lvm3# mount /dev/myVG/myLG1 /lvm1# mount /dev/myVG/myLG2 /lvm2# mount /dev/myVG/myLG3 /lvm3# df //확인 8. fstab에 등록하자123456# vi /etc/fstab팁 yy 한다음에 pp하면 복붙이된다./dev/myVG/myLG1 /lvm1 ext4 defaults 1 2/dev/myVG/myLG2 /lvm2 ext4 defaults 1 2/dev/myVG/myLG3 /lvm3 ext4 defaults 1 2 RAID 1 방식으로 디스크에 CentOS를 설치하자392p 보고 하자 1234# mdadm --detail -scan //확인해보자# mdadm --detail /dev/md/root //자세히보자","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"6장. RAID6 와 RAID 1+0","slug":"ThisIsLinux18","date":"2017-07-07T00:47:34.000Z","updated":"2017-07-07T02:18:58.856Z","comments":true,"path":"2017/07/07/ThisIsLinux18/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/07/ThisIsLinux18/","excerpt":"","text":"RAID6패리티가 2개이기 때문에 신뢰성이 높다 RAID 1+0RAID 0,1 쓰는것 실습디스크 10개 스냅샷으로 돌아온 후 2기가 짜리 하나를 지워버린다. RAID 6 생성123456789# mdadm --create /dev/md6 --level=6 --raid-devices=4 /dev/sdb1 /dev/sdc1 /dev/sdd1 /dev/sde1# mkfs.ext4 /dev/md6 //포멧# mkdir /raid6# mount /dev/md6 /raid6# df //2기가 확인 RAID 1+0 생성이는 RAID 1을 두개 먼저 생성해야한다. md2 ,md3를 RAID1으로 만들고 이 두개를 RAID 0으로 묶는다. 12345678910111213141516# mdadm --create /dev/md2 --level=1 --raid-devices=2 /dev/sdf1 /dev/sdg1 //raid1 md2로 생성# mdadm --create /dev/md3 --level=1 --raid-devices=2 /dev/sdh1 /dev/sdi1 //raid1 md3로 생성# mdadm --create /dev/md10 --level=0 --raid-devices=2 /dev/md2 /dev/md3 //md2, md3로 raid0 생성# mkfs.ext4 /dev/md10 //포멧# mkdir /raid10# mount /dev/md10 /raid10# df 잘동작하나 확인12345678# cp /boot/vmlinuz-3.10.0-123.el7.x86_64 /raid6/testFile# cp /boot/vmlinuz-3.10.0-123.el7.x86_64 /raid10/testFile# vi /etc/fstab/dev/md6 /raid6 ext4 defaults 1 2/dev/md10 /raid10 ext4 defaults 1 2//재부팅되도 마운트 유지하기 위해 추가 고장내보자SCSI 3, 5 ,8, 9 디스크 없애고 부트 RAID 6 확인12345# mdadm --run /dev/md6 //md6 실행# df //확인# ls -l /raid6 //데이터 확인# mdadm --detail /dev/md6 RAID 1+0 확인1234# mdadm --run /dev/md2# mdadm --run /dev/md3# mdadm --detail /dev/md10","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"RAID 0,1,5 의 고장과 원상 복구","slug":"ThisIsLinux17","date":"2017-07-06T03:33:07.000Z","updated":"2017-07-06T09:26:17.105Z","comments":true,"path":"2017/07/06/ThisIsLinux17/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/06/ThisIsLinux17/","excerpt":"","text":"SCSI 2,4,6,9를 고장내 놓고 잘동작하는 지 확인 해 보겠다. 잘 동작하나 확인하기 위해 고장내기 전에 파일을 옮긴다.123456# cp /boot/vmlinuz-3* /raidLinear/testFile# cp /boot/vmlinuz-3* /raid0/testFile# cp /boot/vmlinuz-3* /raid1/testFile# cp /boot/vmlinuz-3* /raid5/testFile# halt -pvmplayer을 켜고 SCSI 2,4,6,9 디스크를 제거쫌 지나면 응급복구모드로 실행이됨암호를 입력해주자 ls -l /dev/sd* 을 하니까 당겨져 있다. sdc가 sdb 이런식으로 RAID 1, 5 는 데이터가 살아있어야 한다. RAID 1 확인1234567# df //마운트가 다 끊겨있다.# mdadm --run /dev/md1 //강제로 가동시키는 것시작되었다.# df //raid1가 마운트 된것을 확인.# ls -l /raid1 //데이터가 잘 있는지 확인# mdadm --detail /dev/md1 //하나는 살아있고 하나는 removed인것을 확인 RAID 5 확인12345# mdadm --run /dev/md5 //강제로 가동시키는 것시작되었다.# df //raid5가 마운트 된것을 확인.# ls -l /raid5 //데이터가 잘 있는지 확인# mdadm --detail /dev/md5 //하나는 살아있고 하나는 removed인것을 확인 RAIDLinear 확인12# mdadm --run /dev/md9 //강제로 가동시키는 것실행할 수 없다. 결함을 허용하지 않음 RAID 0 확인12# mdadm --run /dev/md0 //강제로 가동시키는 것실행할 수 없다. 결함을 허용하지 않음 시스템이 재대로 실행되도록 해보자1234567891011# mdadm --stop /dev/md9 //종료# mdadm --stop /dev/md0 //종료# vi /etc/fstabmd9,md0 주석 하고# reboot리부트를 했는데 복구모드로 실행이 된다면 컨트롤 D를 누르고실행한 다음에 재 마운트를 해주면 된다.# df //마운트가 되어있는것 확인. 새로운 디스크를 장착하여 원상복구를 시켜보자Linear RAID, RAID 0 은 데이터를 살릴 순 없다.그러나 RAID 1, RAID 5는 데이터를 살릴 수 있다. vmplayer에서 디스크 4개를 1기가씩 주고 추가하자. 알아서 빈곳을 잘 찾아간다. 우리가 조금전 추가했던것은 sdc, sde, sdg, sdi 이다.2,4,6,9 로 들어갔으므로.. RAID 0, Linear Raid는 새로 만들어주어야 한다.12345678910111213141516# ls -l /dev/sd* //# fdisk /dev/sdc~sdi 까지 n 입력 p 입력 엔터 엔터 t 입력 fd 입력 w 입력# mdadm --stop /dev/md9 //다시만들기위해 stop# mdadm --create /dev/md9 --level=linear --raid-devices=2 /dev/sdb1 /dev/sdc1#mdadm --detail /dev/md9 //확인해보자# mdadm --stop /dev/md0 //다시만들기위해 stop# mdadm --create /dev/md0 --level=0 --raid-devices=2 /dev/sdd1 /dev/sde1# mdadm --detail /dev/md9 //확인해보자 RAID 1, RAID 5는 새로만들면 안되고 추가해주어야 한다.1234567891011121314# mdadm /dev/md1 --add /dev/sdg1# mdadm /dev/md5 --add /dev/sdi1# vi /etc/fstab/dev/md9 /raidLinear ext4 defaults 1 2/dev/md0 /raid0 ext4 defaults 1 2/dev/md1 /raid1 ext4 defaults 1 2/dev/md5 /raid5 ext4 defaults 1 2이렇게 바꿔준다.# reboot# df //마운트 확인. 데이터를 한번 확인해보자. 123456789101112131415# ls -l /raid0drwx------ 2 root root 16384 7월 6 17:26 lost+found-rwxr-xr-x 1 root root 4902656 7월 6 17:31 testFile# ls -l /raid1drwx------ 2 root root 16384 7월 6 17:27 lost+found-rwxr-xr-x 1 root root 4902656 7월 6 17:31 testFile# ls -l /raid5drwx------ 2 root root 16384 7월 6 17:29 lost+found-rwxr-xr-x 1 root root 4902656 7월 6 17:31 testFile# ls -l /raidLineardrwx------ 2 root root 16384 7월 6 17:25 lost+found-rwxr-xr-x 1 root root 4902656 7월 6 17:31 testFile raid 1그리고 raid5 는 데이터가 있을것이라 예상했지만 raid0 그리고 raidLinear도 데이터가 존재한다. 어떻게 된 것일까? 운이 좋게 지워지지않은 영역에 존재하는 것일 것이다. 그러므로 데이터를 신뢰 할 수 없으며 이는 포멧을 해주는 것이 좋다. 12345678# umount /dev/md0 //포멧하기전에 마운트를 끊음# umount /dev/md9# mkfs.ext4 /dev/md0 //포멧# mkfs.ext4 /dev/md9# reboot //리부트를 하지않고 바로 마운트를 해줘도됨. //어차피 리부트하면 마운트되어있으니까 아무거나 선택! raid 1, raid 5 의 고장난 디스크에 대해서 따로 작업을 해 줘야할줄 알았는데 –add만 하면 되어서 생각보다 간단하다고 생각했다.","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"6장. RAID 정의 및 개념,구현","slug":"ThisIsLinux16","date":"2017-07-06T00:13:09.000Z","updated":"2017-07-06T07:00:53.610Z","comments":true,"path":"2017/07/06/ThisIsLinux16/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/06/ThisIsLinux16/","excerpt":"","text":"RAIDRedundant Array of Inexpensive Disks여러개의 디스크를 하나처럼 사용하는 RAID를 알아보자비용절감 + 신뢰성 향상 + 성능 향상1테라 디스크 3개를 하나로 묶어서 3테라 디스크처럼 쓴다 하드웨어 RAID여러개의 하드디스크를 가지고 장비를 만들어서 사용. 장비업체에서 제공하기 떄문에 사용법이 다를 수 있다. 그리고 상당히 고가이다. 하드웨어RAID가 안정성이 높다. 소프트웨어 RAID디스크를 장착만하면 운영체제 레벨에서 하나로 묶을 수 있다. Linear RAID (339p 그림보기)최소 2개이상의 디스크를 하나로 묶음앞 디스크 부터 차례로 저장100TB 100TB 100TB 를 사용하면 총 300TB가 된다. 즉 공간효율성이 100%임. RAID 0 (339p 그림보기)모든 디스크에 동시에 저장되는 개념그러므로 하드디스크가 3개면 /3 시간으로 저장됨신뢰성이 낮다.빠르지만 전부 잃어버려도 큰 문제가 되지 않는 자료가 적당하다.3TB 100TB 100TB 를 사용하면 총 9TB가 된다. 즉 디스크 크기가 다르면 공간효율성이 100%가 되지 않음.그래서 RAID를 구성할 떈 같은회사 같은 용량의 디스크로 구성한다.디스크 세개중에 하나만 고장나도 디스크를 못쓴다. RAID 1미러링이라 부름1TB 1TB 를 사용하면 1TB 사용가능결함 허용을 제공= 신뢰성 높음. 즉 둘중에 하나가 고장나도 데이터가 보존된다.공간효율이 나쁘므로 비용이 비싸다는 단점이 있다. RAID 5RAID 2,3,4의 장점을 포용하기 때문에 2,3,4를 사용할 필요가 없다.RAID1의 데이터 안정성 +RAID0의 공간 효율성을 추구 디스크 개수 -1개의 공간을 사용. 즉 4개일 경우 3개를 사용(75%) 100개일 경우 99개를 사용(99%)즉 가격이 저렴하면서 안정적인것.최소한 3개 이상의 하드디스크가 필요하며 오류가 발생했을 때는 패리티(Parity)를 이용해서 데이터를 복구결함 허용을 제공 - 즉 디스크 하나가 고장나도 사용 복구 가능하지만 디스크가 하나가 고장났을 때는 복구가 가능하지만 디스크가 2개가 고장날 경우에는 복구 불가능.그래서 100개를 사용하였을 경우에는 불안하다.(2개 이상 고장날 확률이 높아지므로)즉 적은 디스크를 활용할 경우 공간효율은 낮아지지만 신뢰도는 높아진다.일반적으로 RAID 5는 7개에서 10개정도의 디스크로 구성 RAID 6패리트를 2개 쓴다. 즉 디스크가 2개가 고장나도 복구가능. 최소 4개이상의 디스크가 필요함.(패리티를 2개 쓰므로)패리티를 2개 쓰는 알고리즘의 효율성이 떨어져서 성능이 떨어지는 단점이 있어 많이 사용하지는 않음. RAID1 + 0 = RAID + RAID0신뢰성(안정성)과 성능(속도)이 동시에 뛰어난 방법RAID1로 구성된것을 RAID 0 으로 묶음. 그림참고 실습SCSI 0:1 부터 0:10 까지 진행. SCSI 0:1 SCSI 0:2 - Linear RAID SCSI 0:3 SCSI 0:4 - RAID 0 SCSI 0:5 SCSI 0:6 - RAID 1 SCSI 0:8 SCSI 0:9 SCSI 0:10 - RAID 5 SCSI 0:1 만 2GB로 구성하고 나머지는 다 1GB로 구성 에디트 쪽에서 디스크 2기가 1개 1기가 8개 추가. 1# ls -l /dev/sd* //장착이 잘 되었나 확인 9번 반복12345678# fdisk /dev/sdb ~sdj 까지 반복n p 엔터 엔터p //로 확인해보면 시스템이 리눅스인데 RAID로 변경해야한다.t 엔터L 누르면 도움말이 나온다.fd를 입력 후 엔터p를 눌러 확인w를 눌러 저장 1# ls -l /dev/sd* //장착이 잘 되었나 확인 과정 설명1.mdadm 명령어로 논리 볼륨 생성2.mkfs.ext4 명령어로 파일시스템 생성(포멧)3.mount 적용위 3가지 과정은 6장에서 하드디스크 1개추가 과정과 같다. Linear RAID 만들기sdb1 sdc1 이용mdadm RAID를 만들고 없애는 명령어 1234567891011121314151617181920212223# fdisk -l /dev/sdb /dev/sdc // 아까 한것이 잘 적용되었나 확인# mdadm --create /dev/md9 --level=linear --raid-devices=2 /dev/sdb1 /dev/sdc1 //RAID md9를 만드는데 리니어로 디바이스는 //개수 2개로 2개는 /dev/sdb1 /dev/sdc1 로# mdadm --detail --scan //돌고있는지 확인# mdadm --detail /dev/md9 //md9에 대해 자세히 보자# mkfs.ext4 /dev/md9 //포멧하자# mkdir /raidLinear //디렉토리 생성# mount /dev/md9 /raidLinear/ //마운트# df //마운트 확인# vi /etc/fstab //재부팅하면 마운트가 풀리므로 설정/dev/md9 /raidLinear ext4 defaults 0 0 맨 아래 추가# reboot# df //마운트 확인 RAID 0 만들기sdd sde로 한다1234567891011121314151617# mdadm --create /dev/md0 --level=0 --raid-devices=2 /dev/sdd1 /dev/sde1# mdadm --detail --scan //돌고있는지 확인# mdadm --detail /dev/md0 //md9에 대해 자세히 보자# mkfs.ext4 /dev/md0 //포멧하자# mkdir /raid0 //디렉토리 생성# mount /dev/md0 /raid0/ //마운트# df //마운트 확인# vi /etc/fstab //재부팅하면 마운트가 풀리므로 설정/dev/md0 /raid0 ext4 defaults 0 0 추가 RAID 1sdf sdg 사용12345678910111213141516# mdadm --create /dev/md1 --level=1 --raid-devices=2 /dev/sdf1 /dev/sdg1y입력 // raid1은 부트 디바이스로 사용 할 수 없는데 만들겠냐는 뜻# mdadm --detail /dev/md1 //확인해보자# mkfs.ext4 /dev/md1 //포멧하자# mkdir /raid1 //디렉토리 생성# mount /dev/md1 /raid1/ //마운트# df //마운트 확인# vi /etc/fstab //재부팅하면 마운트가 풀리므로 설정/dev/md1 /raid1 ext4 defaults 0 0 추가 RAID 5sdh sdi sdj 사용1234567891011121314151617# mdadm --create /dev/md5 --level=5 --raid-devices=3 /dev/sdh1 /dev/sdi1 /dev/sdj1망가졌다는 메세지 나오는데 무시하면된다. (컴퓨터가 착각함!)# mdadm --detail /dev/md5 //확인해보자# mkfs.ext4 /dev/md5 //포멧하자# mkdir /raid5 //디렉토리 생성# mount /dev/md5 /raid5/ //마운트# df //마운트 확인# vi /etc/fstab //재부팅하면 마운트가 풀리므로 설정/dev/md5 /raid5 ext4 defaults 0 0","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"6장. IDE/SCSI 장치 구성, 하드디스크 1개 추가","slug":"ThisIsLinux15","date":"2017-07-05T07:33:36.000Z","updated":"2017-07-05T11:05:49.132Z","comments":true,"path":"2017/07/05/ThisIsLinux15/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/05/ThisIsLinux15/","excerpt":"","text":"하드디스크 관리는 관리자 입장에서 기본적인것이다.디스크가 모자르면 디스크를 추가해야한다.. 이런걸 어떻게 할지 알아보자 IDE SCSI 장치에 대해IDE는 케이블을 2개 꽂을수가 있다. 여기에 하드디스크를 장착하거나 DVD롬을 장착할 수 있다. 즉 두개의 IDE가 있으면 4개를 장착할 수 있다. 0:0 , 0:1, 1:0 , 1:1 이렇게 구분된다(4개일 경우) SCSI는 총 16개의 SCSI 하드디스크를 꽂을 수 있는 케이블이 따져있다. 0,7번은 VMware가 사용하므로 사용할 수 없다.마찬가지로 SCSI 0:0 ,0:1 로 구분된다. 326p를 통해 그림으로 확인가능 우리가 80GB 의 하드디스크를 추가했는데 이를 sda라 그런다만일 하나더 추가하면 sdb라 그런다.정식이름은 /dev/sda 이다.여기서 파티션을 나누면 sda1,sda2로 나뉜다. 즉 sda는 하드디스크 자체를 의미하며 sda1은 파티션1 sda2는 파티션2를 의미한다. 땅 자체를 사는것을 하드디스크를 추가하는것으로 보면되고 축구장으로 사용하기 위해 특정부분에 선을 긋는것을 파티션을 나눈다고 보면된다. 또한 파티션은 특정디렉터리에 마운트를 해줘야함. 하드디스크 1개 장착과정1.SCSI 0:1에 물리적인 하드디스크 하나 장착 이는 /dev/sdb이다. 2.fdisk 명령어를 통해 파티션을 나눔(실습에서는 파티션1개로)./dev/sdb1 파티션이 생긴다. 3.파티션을 사용하기 위해서는 포멧을 해줘야한다.(mkfs.ext4를 사용) 4.그러면 완전히 준비된 하드디스크가 생기는데 이를 특정 폴더에 마운트해야한다. 5.마운트는 컴퓨터를 끄면 마운트가 끊어지므로 /etc/fstab 파일을 편집해 주어야 한다. 1.SCSI 0:1에 물리적인 하드디스크 하나 장착 이는 /dev/sdb이다.에디트에서 애드를 선택하고 다음스카시를 선택하고 다음맨위를 하고 다음1기가로 선택하고 싱글파일 선택하고 다음어드밴스드를 눌러 0:1로 되어있는것을 확인 123456789# ls -l /dev/sd*brw-rw---- 1 root disk 8, 0 7월 5 18:02 /dev/sdabrw-rw---- 1 root disk 8, 1 7월 5 18:02 /dev/sda1brw-rw---- 1 root disk 8, 2 7월 5 18:02 /dev/sda2brw-rw---- 1 root disk 8, 16 7월 5 18:02 /dev/sdbsda는 초기 설정때 설정한것. 파티션을 두개로 나눠서 sda1, sda2로 나뉜다.왜 sdb1은 없지? 파티션을 나누지 않았으므로! 2.fdisk 명령어를 통해 파티션을 나눔(실습에서는 파티션1개로)./dev/sdb1 파티션이 생긴다.파티션을 나눠보자1234567891011121314151617181920# fdisk /dev/sdbn //새로운 파티션 추가p // p(primary)는 주 파티션 e(extended)는 확장파티션을 의미 //p는 4개까지 나눌 수 있음 //4개 이상하고싶으면 3개는 p로하고 하나는 e로 잡아서 //e 파티션안을 나눠서 늘리면 된다. 이는 굉장히 드문경우 //일반적으로는 p를 쓰면 충분하다.1 //sdb1로 하겠다. 엔터 // 2047까지는 시스템 부분이므로 // 어디서 부터 시작할꺼냐. 엔터하면 2048부터엔터 //끝까지 쓰겠다. p //최종확인w //적용 # ls -l /dev/sd* //생성된 것 확인brw-rw---- 1 root disk 8, 0 7월 5 18:02 /dev/sdabrw-rw---- 1 root disk 8, 1 7월 5 18:02 /dev/sda1brw-rw---- 1 root disk 8, 2 7월 5 18:02 /dev/sda2brw-rw---- 1 root disk 8, 16 7월 5 18:11 /dev/sdbbrw-rw---- 1 root disk 8, 17 7월 5 18:11 /dev/sdb1파일 시스템을 생성하자. 3.파티션을 사용하기 위해서는 포멧을 해줘야한다.(mkfs.ext4를 사용)1# mkfs.ext4 /dev/sdb1 4.그러면 완전히 준비된 하드디스크가 생기는데 이를 특정 폴더에 마운트해야한다.12345678# mkdir /mydata# mount /dev/sdb1 /mydata# df // 마운트 된것을 확인# cp /boot/vmlinuz-3.10.0-123.el7.x86_64 /mydata/data1 // 새로운 디스크에 데이터 복사# df //확인 (용량 늘어난것 확인) 5.마운트는 컴퓨터를 끄면 마운트가 끊어지므로 /etc/fstab 파일을 편집해 주어야 한다.123# vi /etc/fstab /dev/sdb1 /mydata ext4 defaults 0 0 입력 후 vi종료 //dev/sdb1을 /mydata에 마운트하는것. ext4를 이용해 1","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"5장. 리눅스에 Windows 설치 KDE데스크톱 설치","slug":"ThisIsLinux14","date":"2017-07-05T06:37:05.000Z","updated":"2017-07-05T07:35:30.122Z","comments":true,"path":"2017/07/05/ThisIsLinux14/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/05/ThisIsLinux14/","excerpt":"","text":"리눅스 안에서 윈도우를 깔아보자CentOS에서 제공하는 가상머신을 이용하자즉 가상머신에서 가상머신을 만드는…램 올리고, 가상화 켜주고 311p참고 iso 파일을 받고 내폴더에 붙여넣기 해준다. 123# mkdir /iso# mv 600* /iso //파일이름이 600으로 시작함.# ls -l /iso 실습에서는 313p 의 2-0을 생략한다.프로그램 -시스템 도구 -가상머진 관리자로컬 선택 후 새가상머신 생성 왼쪽위 그림(노란색)Win2008 입력후 로컬설치매체 선택후 앞으로iso파일 선택하고 윈도우서버 2008 선택하고 앞으로그대로 두고 앞으로설치전에 사용자 설정 선택 후 완료디스플레이를 VNC로 하고 적용왼쪽 위 설치시작 KDE 데스크톱을 설치해보자센토스는 기본적으로 그놈데스크탑이 들어있다. 윈도우와 비슷한 KDE 데스크탑을 운영할 수 있다.123456$ yum grouplist | grep KDE //KDE 패키지그룹을 조회su -c &apos;yum -y groupinstall &quot;KDE Plasma Workspaces&quot;&apos; //조회됨$ su -c &apos;yum -y groupinstall &quot;KDE Plasma Workspaces&quot;&apos; //루트권한으로 &apos;&apos;안에 있는 명령어 실행(KDE 설치)자동로그인 해제 . 321p 참고1$ reboot톱니 누르고 KDE Plasma 작업공간 선택후 암호 입력 후 로그인","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"5장. 노틸러스, FireFox업그레이드, 기타 X윈도 유틸리티","slug":"ThisIsLinux13","date":"2017-07-05T04:47:34.000Z","updated":"2017-07-05T06:36:48.389Z","comments":true,"path":"2017/07/05/ThisIsLinux13/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/05/ThisIsLinux13/","excerpt":"","text":"노틸러스윈도우 탐색기와 비슷하다.실행법 : 프로그램-보조프로그램-파일 내폴더가 홈 디렉토리이다.컴퓨터가 / 폴더이다.rpm 파일도 설치 가능복붙도 가능 컨트롤 씨브이289p 참고 파이어폭스 업그레이드설치하고압축풀고 12345678910# mv firefox /usr/local //압축푼것 위치이동# chown -R root.root /usr/local/firefox/ 루트에게 권한줌# cd /usr/local/bin# ln -s /usr/local/firefox/firefox . //링크를 걸어줌파폭을 실행하면 에러가 나는데# cd /usr/local/firefox/browser/extensions/# rm -rf *해주고 리부트 어도비리더 설치123# wget http://download.hanbit.co.kr/centos/7/AdobeReader_kor-8.1.7-1.i486.rpm# su -c &apos;yum -y localinstall Adobe*&apos;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"5장. X윈도 테마, GRUB 배경화면","slug":"ThisIsLinux12","date":"2017-07-05T02:57:03.000Z","updated":"2017-07-05T04:38:22.934Z","comments":true,"path":"2017/07/05/ThisIsLinux12/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/05/ThisIsLinux12/","excerpt":"","text":"이 챕터는 책에서 중요도가 가장 떨어진다!서버관리자가 되었을 때 리눅스를 PC로 사용하는 사람에게 도움을 주기위해 알아둘 필요는 있다. 테마 설치하기12$ rpm -qa gnome-tweak-tool //설치되어있나 확인$ gnome-tweak-tool //툴 켜서 설정변경 GRUB 이미지 설정1234567891011121314$ su -c &apos;yum -y install grub2-starfield-theme&apos; //암호입력 //su -c는 슈퍼바이저 권한으로 실행하는것$ vi /etc/default/grubGRUB_TIMEOUT=5GRUB_DISTRIBUTOR=&quot;$(sed &apos;s, release .*$,,g&apos; /etc/system-release)&quot;GRUB_DEFAULT=savedGRUB_DISABLE_SUBMENU=true#GRUB_TERMINAL_OUTPUT=&quot;console&quot; //여기 주석처리GRUB_CMDLINE_LINUX=&quot;rd.lvm.lv=centos/swap vconsole.font=latarcyrheb-sun16 rd.lvm.lv=centos/root crashkernel=auto vconsole.keymap=us rhgb quiet&quot;GRUB_DISABLE_RECOVERY=&quot;true&quot;GRUB_THEME=&quot;/boot/grub2/themes/system/theme.txt&quot; //여기추가vi 저장후 종료 이미지 파일을 centos폴더에 저장 (ball.png)1mv /home/centos/ball.png /boot/grub2/themes/system실행하여 그림 이동 12345# vi /boot/grub2/themes/system/theme.txt //:set number34행가서 이미지 파일이름 변경# grub2-mkconfig -o /boot/grub2/grub.cfg //적용","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. 응급복구, GRUB, 커널 컴파일","slug":"ThisIsLinux11","date":"2017-07-04T07:09:17.000Z","updated":"2017-07-04T10:28:12.394Z","comments":true,"path":"2017/07/04/ThisIsLinux11/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/04/ThisIsLinux11/","excerpt":"","text":"응급복구261p 참고이게 문제가 될 소지가 있지않냐?그래서 처음 켤때 선택하는거에서 암호를 걸어야 한다. GRUB 부트로더/etc/default/grub 파일과 /etc/grup.d/ 디렉터리의 파일을 수정한 후 ‘grub2-mkconfig’ 명령어를 실행해 설정함 123456789101112131415161718# vi /etc/default/grubtimeout = 30 으로 변경distributor = &quot;Hello&quot; 로 변경# grub2-mkconfig -o /boot/grub2/grub.cfg // 변경사항 반영//여기서 부터 선택하는 곳에서 e 키 못누르게 비번 설정하는것# vi /etc/grub.d/00_header맨 아래 가서 다음코드 추가cat &lt;&lt; EOFset superusers=&quot;thisuser&quot;password thisuser 4321EOF여기까지!vi 빠져나와서# grub2-mkconfig -o /boot/grub2/grub.cfg // 변경사항 반영$ reboot선택하는곳에서 e 누르면 암호 누르도록 함 커널커널 : 하드웨어를 제어하는 기능모든 하드웨어를 제어하는 코드를 다 넣으면 커널이 너무 커지고 무거워진다. 그러므로 잘 안쓰는 하드웨어 코드는 모듈에 빼내서 필요할때마다 사용즉 모듈은 필요할때 쓸 수 있도록 커널의 코드를 밖으로 빼낸것이다! 1234567891011121314151617$ uname -r //커널버전확인$ wget &quot;https://kernel.org/pub/linux/kernel/v3.x/linux-3.17.4.tar.xz&quot; //교재와 동일한 커널 설치$ mv linux-3.17.4.tar.xz /usr/src$ cd /usr/src$ tar xfJ linux-3.17.4.tar.xz //압축을 풀자$ cd linux-3.17.4/커널은 c 코드이므로 설치를 위해 컴파일러를 깔자$ yum -y install gcc gcc-c++ qt qt-devel$ make mrproper // 커널설정 초기화$ make xconfig //커널의 환경설정 설정 후$ make clean$make ; make modules_install ; make install //순서대로 진행됨.","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. 파이프/필터, 프로세스, 서비스/소켓","slug":"ThisIsLinux10","date":"2017-07-04T05:52:52.000Z","updated":"2017-07-04T06:31:35.759Z","comments":true,"path":"2017/07/04/ThisIsLinux10/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/04/ThisIsLinux10/","excerpt":"","text":"파이프두개의 프로그램을 연결해주는 통로1$ ls -l /etc | more //앞에서 뒤로 넘김 필터필요한것만 걸러주는 명령어 123456$ ps -ef //현재 작동중인 프로세스 보여줌$ ps -ef | grep bash //bash와 관련된 프로세스만 //보여줌$ rpm -qa | grep gedit //gedit 관련된것만 보여줌 리다이렉션(보내는 것)123456789$ ls -l &gt; file.txt //결과를file.txt로 만드는것 //file.txt가 존재할 경우 덮어쓰고 //존재하지 않을경우 새로 만들고 작성$ ls -l &gt;&gt; file.txt //결과를file.txt로 만드는것 //file.txt가 존재할 경우 뒤에다 이어서 작성하고 //존재하지 않을경우 새로만들고 작성$ cat sort &lt; file.txt &gt; out.txt //file.txt를 정렬해서 out.txt에 넣어라 프로세스, 데몬프로세스는 하드디스크에 저장된 실행코드가 메모리에 로딩되어 활성화 된것. 포그라운드 프로세스실행하면 화면에 나타나서 사용자와 상호작용을 하는 프로세스 백그라운드 프로세스화면에 나타나지 않고 실행되는 프로세스백신 , 서버 데몬(=서비스,=서버 프로세스)등 프로세스번호각각의 프로세스는 할당된 번호가 있다.12345$ ps -ef | grep bash //bash관련된 프로세스만 보여줌root 693 1 0 13:43 ? 00:00:00 /bin/bash /usr/sbin/ksmtuned693은 자기 프로세스 번호고 1은 부모프로세스 번호이다. 작업 번호현재 실행되고 있는 백그라운드 프로세스의 순차번호 부모프로세스 ,자식프로세스모든 프로세스는 부모프로세스를 갖는다.부모 프로세스를 kill하면 자식프로세스도 자동으로 죽음. 프로세스 관련 명령ps 프로세스 보기1$ ps -ef | grep bash //bash 관련 프로세스 보여줌 kill 프로세스 종료파이어폭스 kill하기123456$ ps -ef | grep fire //파폭 관련 프로세스 보기root 2637 1934 0 13:49 ? 00:00:04 /usr/lib64/firefox/firefox//프로세스번호가 2637이다.$ kill 2637//가끔 킬 해도 죽지 않는 경우가 있는데 그경우 -9 옵션을 준다.$ kill -9 2637 pstree 프로세스 트리로 보기1$pstree //프로세스 구조를 트리로 보여줌 실습 (포그라운드-&gt;백그라운드-&gt;포그라운드)1234567$ yes &gt; /dev/null //y를 계속생성하는 프로세스 생성ctrl+ z 입력.$ bg //백그라운드 보는것. //처음에 했던 동작이 남아있다.[1]+ yes &gt; /dev/null &amp;$ fg 1 //1번작업을 다시 포그라운드로 갖고와라 실습 (포그라운드-&gt;백그라운드-&gt;포그라운드)1234567$ gedit &amp; //지에딧을 백그라운드로 돌려라. //콘솔을 계속 사용할 수 있게된다.$ vi &amp; //백그라운드로 돌아가긴 하는데 의미없다. //vi는 포그라운드로 돌려야 하므로 $ bg //vi의 백그라운드 번호를 알고$ fg 1 //vi를 포그라운드로 갖고옴 서비스와 소켓서비스웹 서버 = 웹 서비스FTP 서버 = FTP 서비스 서비스의 실행 스크립트 파일은 /usr/lib/systemd/system/ 디렉터리에 ‘서비스이름.service’라는 이름으로 확인할 수 있다. 예를들어 웹 서비스는 httpd.service라는 이름의 파일로 존재 소켓서비스는 항상 가동되지만 소켓은 필요할 떄만 구동된다. 외부에서 특정 서비스가 요청되었을 때. 그래서 약간 느리다./usr/lib/systemd/system/ 디렉터리에 소켓이름.socket 이름으로 존재","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. 네트워크 관련 개념과 명령어,SELinux","slug":"ThisIsLinux9","date":"2017-07-04T04:29:36.000Z","updated":"2017-07-04T05:09:11.039Z","comments":true,"path":"2017/07/04/ThisIsLinux9/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/04/ThisIsLinux9/","excerpt":"","text":"TCP/IP우리가 사용하는 인터넷은 tcp/ip 기반이다. 가장널리사용되는 프로토콜의 한 종류 호스트이름 도메인이름호스트이름 : 컴퓨터에 지정된 이름도메인 이름 : hanbit.co.kr rkxdms gudtlr IP 주소랜카드에 부여되는 중복되지 않는 유일한 주소 네트워크 주소같은 네트워크에 속해있는 공통된 주소 브로드캐스트 주소제일 뒤가 255인 주소내부 네트워크의 모든 컴퓨터가 듣게 되는 주소 게이트웨이, 라우터라우터=게이트웨이네트워크 간에 데이터를 전송하는 컴퓨터 또는 장비 넷마스크, 클래스넷마스크 : 네트워크의 규모를 결정ex(255.255.255.0) DNS 서버= 네임서버URL을 IP로 변환해주는 서버 12345678910111213141516$ nmtui //네트워크와 관련된 작업진행$ rdate -s time.bora.net //시간설정$ nmtui //설정 변경후 종료 네트워크매니저텍스트ui$ systemctl restart network //네트워크 재시작 (해줘야함)$ ifconfig //네트워크장치에 할당된 ip주소 확인$ ifdown ens32 //이거는 systemctl restart network //보다 강력하게 서버를 끄는것.$ ifup ens32 //서버 재시작 $ nslookup naver.com //DNS서버의 작동을 테스트$ ping www.yahoo.com //네트워크 응답 확인$ ping -3 www.yahoo.com //세번만 피을 때려라 주요 파일네트워크 기본적인 정보가 설정되어 있는 파일/etc/sysconfig/network /etc/sysconfig/network-scripts/ifcfg-ens32ens32 장치에 설정된 네트워크 정보가 모두 들어있는 파일ens32가 아니라 eno일수도 있다.BOOTPROTO = none 고정아이피를 쓰겠다.DNS1 DNS가 여러개 나올 수 있으므로 1이 필요ONBOOT =”yes” 네트워크를 쓰겠다 /etc/resolv.confDNS 서버의 정보와 호스트 이름이 들어있다.168.126.63.1 //kt에서 제공하는 네임서버이다 //네임서버가 없을 때 사용가능 SELinux보안에 취약한 리눅스를 보호하기 위해 탄생책에서는 실습을 위해 기능을 꺼두었다./etc/sysconfig/selinux를 편집하였다.SELINUX=disabled 이렇게..","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. 파일 압축과 묶기, CRON과 AT","slug":"ThisIsLinux8","date":"2017-07-04T00:26:28.000Z","updated":"2017-07-04T01:55:03.268Z","comments":true,"path":"2017/07/04/ThisIsLinux8/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/04/ThisIsLinux8/","excerpt":"","text":"파일 압축유닉스는 압축하는 파일이 여러개이다. 그래서 확장자도 여러개이다. 점점 개선이 되면서 여러개가 생긴것이다. 예전것도 쓰고 최신것도 쓰므로 모두 사용할줄 알아야함gzip-&gt;bzip2-&gt;xz 순으로 발전해옴 xz가 압축률도 제일좋다. 12345678910111213141516171819# cp glist.txt file1.txt //파일 복사# cp glist.txt file2.txt# cp glist.txt file3.txt# xz file1.txt# bzip2 file2.txt# gzip file3.txt# ls-l file*-rw-r--r-- 1 root root 1080 7월 4 09:31 file1.txt.xz-rw-r--r-- 1 root root 1072 7월 4 09:31 file2.txt.bz2-rw-r--r-- 1 root root 1053 7월 4 09:31 file3.txt.gz# xz -d file.txt.xz //압축해제# bzip2 -d file2.txt.bz2 //압축해제# gzip -d file3.txt.gz //압축해제# gunzip file3.txt.gz //위와 같음 gz로 압축한게 제일작은데? 파일마다 다르다!! 일반적으로는 gz가 효울이 제일 떨어진다. 그래서 일반적으로 커널파일을 xz로 배포한다.리눅스에서의 압축은 파일을 압축해서 원본파일이 사라진다는것을 주의하자. 파일 묶기리눅스는 압축, 묶기가 다르다묶기는 원본파일이 유지되며 하나로 묶은것이라 보면된다.12345678910# tar cvf bin.tar bin1 bin2 bin3 //bin1,2,3이 bin.tar로 묶임# rm -f bin? //bin1,2,3 제거# tar xvf bin.tar //풀기# ls -l-rw-r--r-- 1 root root 14714880 7월 4 09:41 bin.tar-rwxr-xr-x 1 root root 4902656 7월 4 09:40 bin1-rwxr-xr-x 1 root root 4902656 7월 4 09:40 bin2-rwxr-xr-x 1 root root 4902656 7월 4 09:40 bin3묶으면서 압축을 진행해보자12345678# rm -f bin.tar# tar cvfj bin.tar.bz2 bin1 bin2 bin3 //bz2형식으로 압축하면서 묶어줌# rm -f bin.tar.bz2# tar cvfJ bin.tar.xz bin1 bin2 bin3 //xz형식으로 압축하면서 묶어줌 //J가 대문자이다.# tar xvfJ bin.tar.xz /etc/sysconfig //xz압축해제 +tar 풀기 파일 위치 검색12345678910# find /etc -name &quot;*.conf&quot; //etc밑에 확장명이 conf 인것을 찾음# find /etc -name &quot;*.conf&quot; &gt; conf.txt //위 대상으로 conf.txt로 저장# find /home -user centos //centos 사용자의 파일들 검색# find /usr/bin -size +95k -size -100k //사이즈가 95kb 이상 //100kb 이하인것 검색# find /usr/bin -size +95k -size -100k -exec ls -l &#123;&#125; \\; // 윗줄의 결과가 중괄호 속에 들어가서 // ls -l 명령어 실행 시스템 설정123456# yum -y install system-config-date# system-config-date //날짜 설정 가능# nmtui //네트워크 설정# firewall-config CRON과 ATCRON : 주기적으로 반복되는 일을 자동적으로 실행될 수 있도록 실행 42 4 1 ** root run-parts /etc/cron.hourly42 : 42분4 : 4시1 : 1일* : 매 월* : 매 요일 01 * * * * root run-parts /etc/cron.daily맨 뒤는 요일이므로 제외하고매월매일매시1분마다. 02 4 * * * root run-parts /etc/cron.weekly매일 4시 2분마다 실행하라 03 4 * * 0 root run-parts /etc/cron.monthly일요일 4시 3분마다 실행해라 AT : 한번 실행되는것# at 3:00am tomorrow -&gt;내일 새벽 3시# at 11:00pm January 30 -&gt;1월 30일 오후 11시# at now + 1 hours -&gt;한시간 후그 후 예약 명령어 입력후 엔터완료되면 ctrl + d 쉘 스크립트 : 윈도우의 배치파일처럼 실행할 명령어가 쭉 나열되어있는것 CRON 실습123456789101112131415161718192021222324252627282930313233343536# systemctl status crond //크론이 돌고있는지 확인# vi /etc/crontab01 3 15 * * root run-parts /etc/cron.monthly //한줄 추가 매달 매 요일 15일마다 3시 1분에# cd /etc/cron.monthly/# vi myBackup.sh다음을 입력#!/bin/sh // 써줘야함set $(date) //날짜를 읽어옴fname=&quot;backup-$2$3.tar.xz&quot; //$2는 월 $3은 일tar cfJ /backup/$fname /home // /home폴더를 묶음vi 종료# chmod ugo+x myBackup.sh //쉘스크립트 파일 실행권한부여# mkdir /backup //백업파일 보관할 장소 생성# systemctl restart crond //예약하는 작업이 재시작된다.# date 011503002019 //테스트를 위해 시간을 변경 //월일시분년2019. 01. 15. (화) 03:00:00 KST 로 변경됨# systemctl restart crond // 시간적용을 위해 재시작1분이 지나고# ls-l /backup/ AT 실습12345678910111213# rdate -s time.bora.net //서버에 가서 정확한 시간을 세팅함# at 4:00 am tomorrow //내일 새벽 4시에 할 명령어 입력at&gt; yum -y updateat&gt; reboot입력 후 ctrl + d# at -l 예약된것 확인1 Wed Jul 5 04:00:00 2017 a root# atrm 1 //1번 목록 제거 1","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. RPM 사용법, YUM 사용법","slug":"ThisIsLinux7","date":"2017-07-03T09:58:51.000Z","updated":"2017-07-04T01:56:17.645Z","comments":true,"path":"2017/07/03/ThisIsLinux7/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/03/ThisIsLinux7/","excerpt":"","text":"RPM초창기 리눅스는 설치가 어려웠다 .소스코드를 갖고와서 적재적소에 컴파일을 해야했다. 그래서 일반사용자가 사용하기엔 거의 불가능했다. 이러한 이유로 외면을 받았었다. 결국 Redhat에서 RPM(Redhat Package Manager)을 내놓았다. 윈도우의 setup.exe 라고 생각하면 된다. gedit-3.8.3-6.el7.x86_64.rpm 패키지이름 : gedit -&gt; 패키지(프로그램)의 이름버전 : 3.8.3 -&gt; 대게 3자리수로 구성. 주버전, 부버전, 패치버전릴리즈번호 : 6 -&gt; 문제점을 개선할 때마다 붙여지는 번호 //noarch:모든CPUCentOS버전 : el7 -&gt; CentOS에서 배포할 경우에 붙여짐아키텍처 : x86_64 -&gt; 64비트 CPU를 의미 자주쓰는 RPM 명령어 옵션123456789101112131415$ rpm -Uvh 패키지파일이름.rpm // U -&gt; (대문자)패키지가 설치/업그레이드 // v -&gt; 설치진행과정의 확인 // h -&gt; 설치진행과정을 &quot;#&quot;마크로 화면에 출력$ rpm -e 패키지이름 //패키지 삭제$ rpm -qa 패키지이름 //패키지가 설치되었는지 확인$ rpm -qf 파일의 절대경로 // 파일이 어느 패키지에 포함된 것인지 확인$ rpm -qlp 패키지파일이름.rpm //패키지 파일에 어떤 파일들이 포함되었는지 확인$ rpm -qip 패키지파일이름.rpm //패키지 파일의 상세정보 실습12345678910111213$ rpm -qa mc //mc 패키지가 설치되었나 확인$ rpm -Uvh mc-4.8.7-8.el7.x86_64.rpm //설치$ rpm -qa mc //mc 패키지가 설치되었나 확인$ rpm -qi mc //mc 패키지 정보 출력$ rpm -e mc-4.8.7-8.el7.x86_64.rpm //삭제오류: mc-4.8.7-8.el7.x86_64.rpm 패키지가 설치되어 있지 않습니다//설치파일을 삭제하는것이다.!!!!$ rpm -e mc //패키지 이름만으로 삭제 YUM의 등장Yellowdog Updater Modified rpm의 경우 의존성 문제가 존재함. 이를 해결하기 위해 나온것이 YUM의존성 문제란? A를 설치하기 위해 B가 먼저 설치되어있어야 하는것.rpm은 B가 설치되어있지 않을 경우 A패키지 설치를 시도할 경우 B를 설치해야 한다고 알려주기는 하나 대략적으로 알려주고, B또한 다른 패키지에 의존성이 있을수도 있어 불편함을 유발한다. yum은 인터넷이 정상적으로 동작해야 작동함. yum은 의존성이 있는것을 모두 알아서 설치해준다!!! 즉 yum 명령어는 내부적으로 rpm명령을 실행하는것!! yum의 동작과정1.yum install을 입력한다2./etc/yum.repos.d/ 를 참고하여 URL을 확인하고3.전체 패키지 목록 파일을 요청한다(CentOS 7 패키지 저장소로)4.전체 패키지 목록 파일만 다운로드5.설치할 패키지와 관련된 패키지의 이름을 화면에 출력6.y를 입력하면 설치에 필요한 패키지 파일을 요청함7.설치할 패키지 파일을 다운로드해서 자동 설치12345678910111213141516$ yum install 패키지이름 //패키지 설치$ yum -y install 패키지이름 //패키지 설치(y안눌러도 됨)$ yum remove 패키지이름 //패키지 제거$ yum localinstall rpm파일이름.rpm //로컬에 존재하는 rpm으로 설치 // 만약 의존성이 있을경우 그 대상은 레파지토리에서 깐다.$ yum info mc //mc패키지에 관한 정보확인 $ yum groupinstall &quot;패키지 그룹이름&quot; //예로 자바를 깐다면 jdk //이클립스 등 한꺼번에 설치됭$ yum clean all //캐시를 지우는것. //yum이 이상할때 써보자 yum고급실습네트워크를 거치지 않고 마운트 시킨 dvd에서 받는다. 교재 221참고dvd에 없으면 네트워크에서 갖고온다. yum grouplist123456789101112$ yum grouplist //그룹리스트 조회$ yum grouplist hidden //숨겨진것까지 조회//영어로 그룹을 설치하는것이 좋다.. 그러므로$ chvt 2 //2번 가상터미널로 이동$ root password$ yum grouplist hidden &gt; glist.txt //glist.txt로 생성$ chvt 1 //x 윈도모드로 이동 226p 비타민퀴즈223p를 따라 설정 후 yum groupinstall “GNOME Desktop” 입력","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. 파일의 소유권/허가권, 링크","slug":"ThisIsLinux6","date":"2017-07-03T04:33:03.000Z","updated":"2017-07-03T05:45:36.399Z","comments":true,"path":"2017/07/03/ThisIsLinux6/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/03/ThisIsLinux6/","excerpt":"","text":"123# touch sample.txt //빈 파일생성# ls -l-rw-r--r-- 1 root root 0 7월 3 13:35 sample.txt 1.맨앞의 -는 파일의 유형을 의미. -: 일반파일 d: 디렉토리 l: 링크파일 2.rw-r–r–는 세개씩 끊어 읽으면 된다.2-1. 맨앞 세개는 소유자의 파일접근권한 (rw-)즉 소유자는 읽기, 쓰기 가능, 실행 불가 2-2. 두번째는 그룹의 파일접근권한읽기만 가능 2-3. 세번째는 그 외의 사용자의 파일접근권한이다.읽기만 가능또한 rw-r–r–는 3자리씩 끊어서 보면 644로 볼수 있다.rwxrwxrwx는? 666 3.1은 링크의 수 4.root는 파일 소유자 이름 5.root는 파일 소유 그룹이름 6.0은 파일의 크기 7.7월 3 13:35는 마지막 변경 날짜/시간 8.sample.txt는 파일이름 chmod 파일 허가권 변경1234567891011121314151617181920212223242526# chmod 655 sample.txt# ls -l sample.txt-rw-r-xr-x 1 root root 0 7월 3 13:35 sample.txt$ chmod o-x test //일반사용자(o : ordinary)는 -x (x:execute) 실행 못하도록$ ls -l test-rwxrwxrw- 1 centos centos 52 7월 3 13:52 test //마지막 x가 빠짐$ chmod ug-w test //소유주(u: user), 소유그룹(g: group) 쓰기권한 제거$ ls -l test-r-xr-xrw- 1 centos centos 52 7월 3 13:52 test //3번째 6번째 w가 빠짐$ chmod ugo-r test //전부다 읽기권한 제거$ ls -l test ---x--x-w- 1 centos centos 52 7월 3 13:52 test //r이 제거된것 확인$ chmod uo+rw test //소유주, 기타사용자에게 읽기,쓰기 허용$ ls -l test -rwx--xrw- 1 centos centos 52 7월 3 13:52 test//숫자를 넣지 않고 하는것을 심볼릭방법이라 하는데 이것이 더 편할 때가 있다.숫자로 할 경우 기존의 권한도 알아야 하기 때문에.. chown 파일 소유자 변경123# chown centos sample.txt //centos로 소유권을 넘김# ls -l sample.txt-rw-r-xr-x 1 centos root 0 7월 3 13:35 sample.txt //소유권 변경됨 chgrp 파일 소유 그룹 변경123# chgrp centos sample.txt# ls -l sample.txt-rw-r-xr-x 1 centos centos 0 7월 3 13:35 sample.txt chown 파일 소유자, 그룹 변경123# chown root.root sample.txt# ls -l sample.txt-rw-r-xr-x 1 root root 0 7월 3 13:35 sample.txt ./에 대한 이해파일을 실행하기 위해서는 아래의 명령어를 입력해야한다.1# ./파일명./는 왜 붙는것일까?그냥 파일명만 입력하면 찾지못하는데 그 이유는 현재 디렉토리가 경로에 없어서 그렇다.그래서 ./을 넣어주는 것이다. 앞에서 배웠듯이 . 은 현재 디렉토리를 의미하는것을 떠올려보자.즉 ./파일명 는 현재 디렉터리 아래에 있는 파일명을 실행하라는 것이다. su 해당사용자로 로그인1234# su - centos //centos계정으로 로그인 //루트계정일 경우 암호를 묻지않는다. //-를 붙이면 디렉토리가 centos디렉토리로 변경되가 //붙이지 않으면 변경되지 않는다. 실습해보자.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# touch test //test 파일 생성# vi test //이후 명령어(ex ls) 입력 그후 저장후 종료# ./test //test 파일 실행실행되지 않음. # chmod 755 test //실행권한을 모두 준다.# ./test //실행된다.현재 파일의 소유권은 root이다.# chown centos.centos test //소유자,그룹을 변경# su - centos //센토스 사용자로 접근 //이때 암호는 물어보지 않음. 루트에서 이동하는것이므로$ ls -l /root/test //허가 거부가 된다. //왜냐하면 /root 디렉토리가 일반사용자는 들어올수 없게 되어있음. //그러므로 파일을 이동시키거나, /root 디렉토리에 다른사용자가 들어 //올수 있게 허가해주어야 한다. 후자는 좋지 않은 방법이므로 전자를 //활용하자# exit //centos계정 로그아웃# mv test ~centos //centos 홈폴더로 test파일이동.# su - centos //다시 centos로 로그인$ chmod 777 test$ chown root.root test //소유권을 다시 root로 변경 //불가능하다. 어딜감히 root로 변경해 //악성코드를 심고 할 수도 있고..위험함.. //그래서 이 명령어는 루트사용자만 가능!!!$ chmod o-x test //일반사용자(o : ordinary)는 -x (x:execute) 실행 못하도록$ ls -l-rwxrwxrw- 1 centos centos 52 7월 3 13:52 test //마지막에 -가 들어간것을 확인$ chmod ug-w test //소유주(u: user), 소유그룹(g: group) 쓰기권한 제거$ ls -l test-r-xr-xrw- 1 centos centos 52 7월 3 13:52 test //3번째 6번째 w가 빠짐$ chmod ugo-r test //전부다 읽기권한 제거$ ls -l test ---x--x-w- 1 centos centos 52 7월 3 13:52 test //r이 제거된것 확인$ chmod uo+rw test //소유주, 기타사용자에게 읽기,쓰기 허용$ ls -l test -rwx--xrw- 1 centos centos 52 7월 3 13:52 test//숫자를 넣지 않고 하는것을 심볼릭방법이라 하는데 이것이 더 편할 때가 있다.숫자로 할 경우 기존의 권한도 알아야 하기 때문에.. 링크파일의 링크는 하드링크, 심볼릭 링크가 있다.윈도우의 바로가기처럼 연결되어있는것은 심볼릭링크 소프트 링크라 한다. 원본파일이 inode블록(실제 파일정보를 갖고있는것)을 가르키고 inode블록은 원본파일 데이터를 가르킨다. 하드링크파일은 inode를 직접 가르키며심볼링크파일은 새로운 inode를 만들고 새로운 inode는 원본파일 포인터를 하나 더만들고 그것을 가르킨다. 원본파일 포인터는 원본파일을 가르킨다. 교재 201p를 참고하자. 주로 하드링크보다는 심볼릭 링크를 생성한다. 실습해보기1234567891011121314151617181920212223242526272829# mkdir linktest# cd linktest/# vi basefile //아무거나 입력후 저장후 종료//원본파일이 생겼으므로 inode 블록이 생성되었을것이다.# ls -il basefile //inode 번호 확인405679049 -rw-r--r-- 1 root root 34 7월 3 14:36 basefile //405679049이 inode 번호# ln basefile hardlink //하드링크 생성# ln -s basefile softlink //소프트링크생성# ls -il405679049 -rw-r--r-- 2 root root 34 7월 3 14:36 basefile405679049 -rw-r--r-- 2 root root 34 7월 3 14:36 hardlink405679048 lrwxrwxrwx 1 root root 8 7월 3 14:40 softlink -&gt; basefile//basefile inode와 hardlink inode가 같다. softlink의 inode는 새로 만들어서 basefile을 가르킨다.# mv basefile ../ //원본파일을 앞 디렉토리로 이동시킴# ls -il# cat hardlink // 출력이 될까 안될까? //출력이 된다. 그 이유는 원본 inode를 가르키기 때문에!# cat softlink // 출력이 될까 안될까.? //안된다. 원본파일이 없어졌기 때문에.# mv ../basefile //다시 원상복구 시킴 (앞디렉토리로간 basefile 델꼬옴) 12","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. 사용자 및 그룹 관리","slug":"ThisIsLinux5","date":"2017-07-03T02:29:09.000Z","updated":"2017-07-03T04:32:32.265Z","comments":true,"path":"2017/07/03/ThisIsLinux5/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/03/ThisIsLinux5/","excerpt":"","text":"리눅스는 다중 사용자 시스템이다. 즉 서버 한대에 여러명이 접속한다. 그러므로 사용자를 관리하고 그룹을 관리하는게 중요한 이슈이다.기본적으로 rootㄹ는 슈퍼유저가 관리하며 모든 사용자는 하나 이상의 그룹에 소속되어야 한다.사용자는 /etc/passwd에 정의되어 있다.아래의 명령문을 실행시켜 vi 에디터로 확인해보자.1# vi /etc/passwd마지막 줄엔 다음과같은 코드가 존재한다.1centos:x:1000:1000:centos:/home/centos:/bin/bash이에 대해 자세히 알아보자. 1.centos = 사용자가 centos 이다. 2.x = 비밀번호 3.1000 = centos라는 사용자의 ID 4.1000 = centos사용자는 반드시 소속된 그룹이 있어야하는데 이는 소속된 그룹의 ID 즉 그룹번호이다.어떻게 그룹번호를 갖고 그룹명을 알까? /etc/group 파일에 정의되어 있다. 이 파일을 vi 에디터로 열면 그룹이름:그룹비밀번호:그룹의ID(그룹번호)의 형식을 갖는다.centos:x:1000:centos // 그룹이름:그룹비밀번호:그룹의ID(그룹번호)이게 무슨뜻일까? centos라는 사용자가 centos그룹에 속해 있다는 것이다. 마지막 centos 는 생략이 가능하며 신경쓰지 않아도 된다.예를 들면 홍길동이라는 부서에 홍길동 사원이 존재하는것이다. 회사에서는 부서를 만들고 사원을 뽑는다. 마찬가지로 centos도 새로운 사용자를 만들면 사용자 이름과 같은 그룹을 만들고 이 그룹에 해당시킨다.이것과 관련해 실습을 진행해보자.12345678# useradd myuser //유저 등록# tail -5 /etc/passwd //해당파일의 마지막 5줄만 보기myuser:x:1001:1001::/home/myuser:/bin/bash //그룹번호 1001을 기억# tail -5 /etc/group //해당파일의 마지막 5줄만 보기myuser:x:1001: //사용자 이름과 같은 그룹이 만들어졌고 그 그룹에 사용자가 속해있다. 5.centos = 전체이름이다. 생략이 가능하다 6./home/centos centos = 사용자의 홈 디렉토리 7./bin/bash = 사용할 기본 쉘 실습해보자디렉토리 설명/etc/passwd : 사용자 정보가 있음/etc/shadow : 사용자 비밀번호가 있음(비밀번호는 암호화되어서 저장됨)/etc/group : 그룹정보가 있음 실습 1유저 생성, 유저 그룹지정, 그룹생성1234567891011121314151617181920212223242526272829303132333435363738# useradd user1 //user1생성# tail -5 /etc/passwd //생성되었는지 확인user1:x:1001:1001::/home/user1:/bin/bash //잘생성됨# tail -5 /etc/shadow //사용자의 비밀번호를 확인해보자user1:!!:17350:0:99999:7::: //비밀번호를 설정하지 않았지만 암호화 되어있다.# tail -5 /etc/group //사용자의 그룹이 생성되었나 확인해보자user1:x:1001: //잘 생성되었다하지만 바람직하지 않다.! user1의 그룹이 user1이라니 말이되나!다시실습해보자 이번에는 그룹을 먼저 생성하고 사용자를 소속시키자# userdel -r user1 //보통 현업에선 -r옵션을 넣어 디렉토리까진 지우지 않는다. //하지만 실습이므로 과감하게 지운다.# groupadd centosGroup //그룹생성# tail -5 /etc/group //잘생성되었나 확인centosGroup:x:1001: //잘생성됨# useradd -g centosGroup user1 //centosGroup에 소속된 user1생성# useradd -g centosGroup user2 //centosGroup에 소속된 user2생성# tail -5 /etc/passwd //잘 생성되었나 확인.user1:x:1001:1001::/home/user1:/bin/bashuser2:x:1002:1001::/home/user2:/bin/bash //잘 생성되었고 사용자 ID는 다르지만 같은 그룹ID를 갖는다.# passwd user1 //암호지정. 이후 1234 1234입력 //일반사용자는 암호를 8자 미만으로 지정못하지만 //루트사용자는 8자 미만으로 지정해줄수 있다.# passwd user2 //암호지정. 이후 1234 1234입력# tail -5 /etc/shadow //user1,user2의 암호를 보자 //user1,user2의 암호를 1234로 지정하였지만 //암호화된 값이 다르다!! 실습 2x윈도에서 사용자권한관리 - x윈도가 없으면 안되므로 비추12# yum -y install system-config-users //system-config-users패키지 설치# system-config-users //x윈도우 상에서 사용자 관리가 가능하다! 관련 명령어189p 참고1234567891011121314151617181920212223242526-u : ID 지정-g : 그룹지정-d : 홈디렉터리지정-s : 쉘 지정# useradd shkim //새로운 사용자를 추가# passwd shkim //사용자의 비밀번호를 지정하거나 변경# usermod -g root shkim //사용자의 속성을 변경# userdel shkim //사용자는 지우나 디렉토리를 제거하지 않음. //-r 옵션이 존재. 이는 사용자가 사용하던 디렉토리까지 제거# change -m 2 shkim //사용자의 암호를 주기적으로 변경하도록 설정 //-m 2는 최소 이틀이상 써야한다.(189p 참고)# groups // 사용자가 속한 그룹을 보여줌# groupadd newgroup //새로운 그룹을 새성 # groupmod -n newgroup mygroup//그룹의 속성을 변경 newgroup을 mygroup로 변경# groupdel newgroup //그룹을 삭제# gpasswd newgroup //그룹의 암호설정","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. 리눅스 기본 명령어","slug":"ThisIsLinux4","date":"2017-07-02T06:25:50.000Z","updated":"2017-07-02T08:19:39.298Z","comments":true,"path":"2017/07/02/ThisIsLinux4/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/02/ThisIsLinux4/","excerpt":"","text":"기본명령어당연히 알고있어야 하는것들이다! 자연스럽게 사용할줄 알아야함! 폴더 == 디렉토리리눅스는 숨김파일일 경우 파일명 앞에 . 이 붙는다. (폴더도 마찬가지) $ ls -l 명령어를 실행하였을 때-로 시작하면 파일 d로 시작하면 디렉토리 ls 파일 목록보기123456789101112131415$ ls // 파일이나 폴더의 목록을 보는것 윈도우의 dir.$ ls /etc/sysconfig //특정 폴더내의 목록을 보는것$ ls -a //숨김파일까지 보는것.$ ls -l // 자세히 보는것 //-로 시작하면 파일 d로 시작하면 디렉토리$ ls *.cfg //확장자가 cfg인것$ ls ls my* // my로 시작하는것들 조회$ ls -al //숨김파일까지 자세히 조회 // -a, -l 의 결합 cd 디렉토리 이동x윈도가 있으면 편하겠지만 없으면 이동이 명령어로만 가능하기 때문에 익숙해지자. cd 명령어를 쓴 후에는 pwd 를 통해 현재 디렉토리를 보자. 리눅스의 디렉터리 구조를 이해 할 수 있게된다. 1234567891011121314151617181920212223$ cd /etc/sysconfig/$ pwd //현재 디렉터리 위치 출력$ cd / // 최상위폴더로 이동(루트 디렉토리라함) // $ cd / 명령어의 경우 다음 명령창이 아래와 같이 나온다. // [root@localhost /]#$ cd // &quot;/루트 디렉토리&quot;(현재 사용자의 홈폴더)로 이동 // $ cd 명령어의 경우 다음 명령창이 아래와 같이 나온다. // [root@localhost ~]$ cd /etc //루트 디렉토리의 etc로 이동(절대경로)$ cd etc //현재 디렉토리에서 etc로 이동 (상대경로)$ cd .. //현재 디렉토리의 바로 앞 디렉토리로 이동$ cd . //현재 디렉토리 반환$ cd ~centos //해당 사용자의 홈 디렉토리로 이동 //즉 $ cd~사용자 == $ cd 여기서 주의할점!우리가 서버에서 사용하는 계정은 root이라는 점을 잊지말자.$ cd / 명령어를 실행하면 루트 디렉토리 즉 최상위 폴더로 이동하는데 여기서 ls를 입력하면 root 폴더가 하나 있다. 이 두가지를 혼동하는 경우가 많은데 주의 하도록 하자. 루트 디렉토리 그리고 루트 디렉토리에 존재하는 root 폴더는 다르며 루트 디렉토리안의 root 폴더는 root계정이기 때문에 존재하는것이다. 강의에서는 루트 디렉토리 그리고 /root 디렉토리 로 구분한다. ..에 대한 이해다음을 이해해보자1234[root@localhost /]# cd /etc/sysconfig/network-scripts/[root@localhost network-scripts]# cd ../../../root[root@localhost ~]# pwd/root .에 대한 이해다음을 이해해보자이거를 어디다 쓸까 싶지만 현재 디렉토리의 어떤것을 실행하거나 어떤 것을 현재 디렉토리로 옮길 때 사용된다.123[root@localhost ~]# cd .[root@localhost ~]# pwd/root touch 비어있는 파일 생성1$ touch //비어있는 파일 생성 rm 파일 삭제123$ rm file1 // 삭제명령어 (삭제할것인지 재확인함)$ rm -f file1 // 삭제 명령어(삭제할것인지 확인하지 않고 삭제) cp 복사123$ cp file3 file4 //file3가 file4로 복사됨$ cp -r /etc/sysconfig . // /etc/sysconfig폴더를 현재 폴더에 복사한다. -r은 디렉토리 복사일 때 필요함 mv 이동 및 파일명 변경123$ mv myfile3.txt /root/sysconfig //myfile3.txt파일을 /root/sysconfig 로 이동$ mv file file3 //파일이름을 file에서 file3로 변경 mkdir 디렉토리 생성1234$ mkdir folder1 //folder1 디렉토리 생성$ mkdir -p dir1/dir2/dir3 // dir1/dir2/dir3 디렉토리를 생성 // 디렉토리가 3개가 만들어지는것이 아니라 dir1 안에 dir2 안에 dir3가 만들어진다. rmdir 디렉토리 제거1234567$ rmdir folder1 //디렉토리 제거 (폴더가 비어있을 경우 가능)$ rmdir -r folder1 //내부에 파일이 있는 디렉토리 제거 //(안에 들어있는 파일 하나하나 지울것인지 다물어본다.)$ rm -rf dir1 //묻지도 따지지도 않고 dir1 디렉토리 제거 //매우 위험하다!! 주의해서 사용 cat 파일 읽기사실 vi를 써도 되지만 그게 귀찮을 떄 사용1$ cat anaconda.ks.cfg head 파일 읽기맨 위의 10줄만 보기1$ head anaconda-ks.cfg tail 파일 읽기맨 밑의 10줄만 보기1$ tail anaconda-ks.cfg more,less 페이지 단위로 읽기페이지 단위로 끊어 읽기 스페이스는 다음페이지 B는 이전페이지 종료하려면 Q123$ more anaconda-ks.cfg$ less anaconda-ks.cfg //less more보다 몇가지 명령어가 더 존재함 file 파일이 어떤 파일인지 확인1$ file file1 //디렉터리인지, 링크인지, 비었는지 등을 알려준다. $ file /dev/cdrom 은 링크이다. 내 환경에서는 sr0을 가르키지만 다를 수 있다는 점을 알고있자. clear1$ clear //화면을 깨끗하게 해준다.","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. vi에디터, CD/DVD마운트","slug":"ThisIsLinux3","date":"2017-07-02T04:13:19.000Z","updated":"2017-07-02T06:19:38.179Z","comments":true,"path":"2017/07/02/ThisIsLinux3/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/02/ThisIsLinux3/","excerpt":"","text":"에디터gedit / vi 로 나뉜다. gedit는 윈도우의 메모장으로 생각하면 되며 단순하다. vi는 리눅스에서 자주 사용되므로 반드시 익혀야 한다. gedit1234$ gedit //gedit 실행 //윈도우 + 스페이스 : 한영전환$ gedit 파일명 // 파일열기 vi 에디터x윈도우가 설치되지 않은곳에서도 사용 가능하기에 공통적으로 사용가능하다!초기 실행시 vi에디터는 명령모드이다. 즉 입력이 불가능한 상태이다. 새파일 작성시 , 수정시 12345678$ vi 파일명 //vi 에디터가 실행된다.i 또는 a 입력 //이후 편집, 입력작업진행esc //작업이 끝난 후 명령모드로 변경:wq //저장하고 종료한다.:q! //수정사항 무시하고 종료.코드의 행 번호를 확인하고 싶을경우1$ :set number swp 파일?중간에 작업을 하다 터미널이 비정상적으로 종료될 경우 swp파일이 생성된다. vi를 실행하면 에러가 뜨는데 엔터를 누르면 작업이 가능하다. 이 파일을 확인하기 위해서는 다음명령어를 입력한다.1$ ls -a //숨김파일까지 조회 그 후 파일을 swp 파일을 지우려면 다음을 입력한다.1$ rm .myfile3.txt.swp 도움말기능도움말 사용방법1$ mas ls //ls에 대한 도움말을 확인 . 스페이스바로 페이지 이동가능 마운트물리적인 장치와 디렉터리를 연결시켜주는 과정무슨소리지? 윈도우는 CD를 넣으면 D 드라이드 등으로 연결시켜 주지만 리눅스는 이과정이 없어서 특정 디렉토리로 연결시켜 주는것이다. X윈도우에서 가능하며, 텍스트 모드에서 가능하다1.우선 vmware상으로 cd를 삽입해야 하므로 그 과정을 거친다. 좌측상단 Player을 누르고 Removable Decices -&gt; CD/DVD -&gt; Setting 을 들어간다.혹은 우측상단 CD 모양 누르고 Setting 2.CD/DVD 탭으로 가서 Connected 키고 Use ISO…. 에 iso 이미지 선택 3.자동으로 인식이 되는데???? 리눅스는 자동으로 안된다며…하지만 이게 되는 리눅스가 있고 안되는게 있다. 또한 텍스트 모드는 자동으로 인식이 되지 않으므로 수동으로 연습하는 것이 필요! 마운트 사용법사전지식 :dvd장치의 경로 : /dev/cdrom보통 /media/cdrom 디렉토리를 마운트 할 떄 많이씀 12345678910111213141516171819$ umount /dev/cdrom //마운트 된것을 끊는것. 연결이 되지 않았을 경우 오류메시지가 나온다. 하지만 상관없다.$ ls /media //마운트 대상 디렉터리를 생성하기 전에 존재유무 확인$ mkdir /media/cdrom //마운트 대상 디렉토리 생성$ mount /dev/cdrom /media/cdrom //마운트!$ cd /media/cdrom //디렉토리 이동$ ls //마운트가 잘 되었는지 확인$ umount /dev/cdrom //마운트 끊기 하지만 에러가 난다. 현재 cdrom 안에 존재하기 때문에.$ cd // 홈디렉토리로 이동$ umount /dev/cdrom //마운트 끊기 재시도$ ls /media/cdrom //정상적으로 끊어진것을 확인 ISO 파일 제작p180 보고 진행하세요~ 앞으로 사용할 일은 없지만 가볍게 실습해보세요ISO 파일을 생성하는 명령어는 genisoimage 이다. 또 iso 파일을 CD로 굽기 위한 명령어는 cdrecord이며 DVD로 굽는 명령어는 growisofs 이다. 먼저 아래의 명령어로 패키지가 설치되어있는지 확인해보자.1$ rpm -qa 패키지이름설치되어있지 않다면1$ yum -y install 패키지명 으로 설치를 한다. 그 후 아래와 같이 입력하자. /boot디렉토리의 모든 파일을 test1.iso파일로 만드는 것이다.-r -J 는 8글자 이상의 파일 이름 및 대소문자를 구분해서 인식하는 옵션이며 -o는 출력할 파일을 위한 옵션이다.1$ genisoimage -r -J -o test1.iso /boot 테스트 해보기 위해 디렉토리를 만들고 마운트 시킨다.1234$ mkdir /media/iso$ mount -o loop test1.iso /media/iso$ ls -l /media/iso$ ls -l /boot 테스트를 했으면 마운트를 취소시켜준다1$ umount /media/iso","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. 시작과종료, 가상콘솔, 런레벨, 자동완성","slug":"ThisIsLinux2","date":"2017-07-01T13:53:50.000Z","updated":"2017-07-02T04:12:47.584Z","comments":true,"path":"2017/07/01/ThisIsLinux2/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/01/ThisIsLinux2/","excerpt":"","text":"참고사항lrwxrwxrwx. 어쩌구가 있을경우 맨앞의 l은 링크파일임을 의미한다. 윈도우의 바로가기를 생각하자! 종료관련 명령어리눅스는 기본개념이 멀티유저 이므로 함부러 누군가 종료하거나 재시작하면 문제의 소지가 있다. ex) 네이버 서버를 누군가 종료시킨다면? 리눅스를 서버로 사용할 경우 리눅스는 종료가 아닌 로그아웃이 일반적인 개념이다! 12345678910111213141516171819202122$ shutdown -P now // 종료$ shutdown -P +10 //10분후에 종료$ shutdown -c //종료예약한것 취소$ shutdown -r 23:00 //23시에 재부팅$ shutdown -r +10 //10분후에 재부팅$ shutdown -c // 리부팅예약한것 취소$ shutdown -k +15 //20분 후에 종료된다는 메세지가 날라감 //루트를 제외한 모든 사용자에게.. //실제 종료는 안됨. //필요한 이유: 서버에 많은 사용자가 접속하였을 경우 사용자들의 로그아웃을 유도.$ init 0~6 // 0-종료모드 2-멀티유저모드 5-그래픽모드의 다중사용자모드 6-리부트모드$ startx //x윈도우 모드로 변경 주의) 예로 단순히 init4에서 init1로가는것과 다르다. //명령어 모드에서 x윈도우 모드로 변경되는것 가상콘솔 명령어CentOS는 6개의 가상콘솔을 제공하는데 ctrl+alt+F2~F6으로 이동이 가능하다. F1은 X윈도우 모드이다. 1$ chvt 1~6 입력 //가상콘솔 이동 자동완성일부만 입력하고 탭을 누르면 자동완성된다.12345678910$ /abcdef를 입력하고자 할 경우$ /abc만 입력하고 탭키를 누르면$ /abcdef 가 입력된다.먄약 abcde, abcdef 라는 디렉토리가 존재할 경우에는$ /abc입력 후 탭키를 누르면 자동완성이 되지않는다. 이 경우 탭키를 두번누르면 abcde, abcdef 라는 디렉토리가 있다는 사실을 알려준다. 히스토리123$ history //자신이 입력했던 명령어들이 출력된다.$ history //히스토리 리스트를 제거한다.","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"리눅스 명령어","slug":"Instruction","date":"2017-07-01T04:57:06.000Z","updated":"2017-07-16T13:09:20.251Z","comments":true,"path":"2017/07/01/Instruction/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/01/Instruction/","excerpt":"","text":"참고사항 $: 일반사용자 #: 루트사용자 명령어123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228$ halt -p // 종료$ gedit 파일명 //편집기 열기$ ifconfig //윈도우 ipconfig와 동일$ reboot //리부트 명령어$ su - //루트사용자의 권한을 얻음(폴더가 이동됨)$ su //루트사용자의 권한을 얻음(폴더 이동되지 않고)$ setfont sun12x22 //글자크기 변경$ vi 파일명 //vi 에디터 열기$ ip addr //ip 확인$ clear //콘솔창 초기화$ yum 프로그램 //프로그램 설치$ cd //홈디렉터리로 이동$ shutdown -P now // 종료$ shutdown -P +10 //10분후에 종료$ shutdown -c //종료예약한것 취소$ shutdown -r 23:00 //23시에 재부팅$ shutdown -r +10 //10분후에 재부팅$ shutdown -c // 리부팅예약한것 취소$ shutdown -k +15 //20분 후에 종료된다는 메세지가 날라감 //루트를 제외한 모든 사용자에게.. //실제 종료는 안됨. //필요한 이유: 서버에 많은 사용자가 접속하였을 경우 사용자들의 로그아웃을 유도.$ init 0~6 // 0-종료모드 2-멀티유저모드 5-그래픽모드의 다중사용자모드 6-리부트모드$ startx //x윈도우 모드로 변경 주의) 예로 단순히 init4에서 init1로가는것과 다르다. //명령어 모드에서 x윈도우 모드로 변경되는것$ chvt 1~6 입력 //가상콘솔 이동$ gedit //gedit 실행 //윈도우 + 스페이스 : 한영전환$ gedit 파일명 // 파일열기$ vi 파일명 //vi 에디터가 실행된다.i 또는 a 입력 //이후 편집, 입력작업진행esc //작업이 끝난 후 명령모드로 변경:wq //저장하고 종료한다.:q! //수정사항 무시하고 종료$ :set number //코드의 행번호 확인$ ls -a //숨김파일까지 조회$ rm .myfile3.txt.swp //파일삭제$ mas ls //ls에 대한 도움말을 확인 . 스페이스바로 페이지 이동가능$ umount /dev/cdrom //마운트 된것을 끊는것. 연결이 되지 않았을 경우 오류메시지가 나온다.$ mount /dev/cdrom /media/cdrom //마운트!$ rpm -qa 패키지이름 //패키지 설치여부 확인$ yum -y install 패키지명 으로 설치를 한다.$ ls // 파일이나 폴더의 목록을 보는것 윈도우의 dir.$ ls /etc/sysconfig //특정 폴더내의 목록을 보는것$ ls -a //숨김파일까지 보는것.$ ls -l // 자세히 보는것 //-로 시작하면 파일 d로 시작하면 디렉토리$ ls *.cfg //확장자가 cfg인것$ ls ls my* // my로 시작하는것들 조회$ ls -al //숨김파일까지 자세히 조회 // -a, -l 의 결합$ cd /etc/sysconfig/$ pwd //현재 디렉터리 위치 출력$ cd / // 최상위폴더로 이동(루트 디렉토리라함) // $ cd / 명령어의 경우 다음 명령창이 아래와 같이 나온다. // [root@localhost /]#$ cd // &quot;/루트 디렉토리&quot;(현재 사용자의 홈폴더)로 이동 // $ cd 명령어의 경우 다음 명령창이 아래와 같이 나온다. // [root@localhost ~]$ cd /etc //루트 디렉토리의 etc로 이동(절대경로)$ cd etc //현재 디렉토리에서 etc로 이동 (상대경로)$ cd .. //현재 디렉토리의 바로 앞 디렉토리로 이동$ cd . //현재 디렉토리 반환$ cd ~centos //해당 사용자의 홈 디렉토리로 이동 //즉 $ cd~사용자 == $ cd $ touch //비어있는 파일 생성$ rm file1 // 삭제명령어 (삭제할것인지 재확인함)$ rm -f file1 // 삭제 명령어(삭제할것인지 확인하지 않고 삭제)$ cp file3 file4 //file3가 file4로 복사됨$ cp -r /etc/sysconfig . // /etc/sysconfig폴더를 현재 폴더에 복사한다. -r은 디렉토리 복사일$ mv myfile3.txt /root/sysconfig //myfile3.txt파일을 /root/sysconfig 로 이동$ mv file file3 //파일이름을 file에서 file3로 변경$ mkdir folder1 //folder1 디렉토리 생성$ mkdir -p dir1/dir2/dir3 // dir1/dir2/dir3 디렉토리를 생성 // 디렉토리가 3개가 만들어지는것이 아니라 dir1 안에 dir2 안에 dir3가 만들어진다.$ rmdir folder1 //디렉토리 제거 (폴더가 비어있을 경우 가능)$ rmdir -r folder1 //내부에 파일이 있는 디렉토리 제거 //(안에 들어있는 파일 하나하나 지울것인지 다물어본다.)$ rm -rf dir1 //묻지도 따지지도 않고 dir1 디렉토리 제거 //매우 위험하다!! 주의해서 사용$ cat anaconda.ks.cfg // 파일을 읽기$ head anaconda-ks.cfg //위에 10줄만 읽기$ head -5 anaconda-ks.cfg //위에 5줄만 읽기$ tail anaconda-ks.cfg //아래 10줄만 읽기$ more anaconda-ks.cfg //페이지 단위로 끊어읽기$ less anaconda-ks.cfg //페이지 단위로 끊어읽기 less가 more보다 몇가지 명령어가 더 존재함$ file file1 //디렉터리인지, 링크인지, 비었는지 등을 알려준다.# userdel -r user1 //보통 현업에선 -r옵션을 넣어 디렉토리까진 지우지 않는다. //하지만 실습이므로 과감하게 지운다.# groupadd centosGroup //그룹생성# useradd user1 //user1생성# useradd -g centosGroup user1 //centosGroup에 소속된 user1생성# useradd -g centosGroup user2 //centosGroup에 소속된 user2생성# passwd shkim //사용자의 비밀번호를 지정하거나 변경# usermod -g root shkim //사용자의 속성을 변경# userdel shkim //사용자는 지우나 디렉토리를 제거하지 않음. //-r 옵션이 존재. 이는 사용자가 사용하던 디렉토리까지 제거# change -m 2 shkim //사용자의 암호를 주기적으로 변경하도록 설정 //-m 2는 최소 이틀이상 써야한다.(189p 참고)# groups // 사용자가 속한 그룹을 보여줌# groupadd newgroup //새로운 그룹을 새성 # groupmod -n newgroup mygroup//그룹의 속성을 변경 newgroup을 mygroup로 변경# groupdel newgroup //그룹을 삭제# gpasswd newgroup //그룹의 암호설정$ chmod o-x test //일반사용자(o : ordinary)는 -x (x:execute) 실행 못하도록$ ls -l test-rwxrwxrw- 1 centos centos 52 7월 3 13:52 test //마지막 x가 빠짐$ chmod ug-w test //소유주(u: user), 소유그룹(g: group) 쓰기권한 제거$ ls -l test-r-xr-xrw- 1 centos centos 52 7월 3 13:52 test //3번째 6번째 w가 빠짐$ chmod ugo-r test //전부다 읽기권한 제거$ ls -l test ---x--x-w- 1 centos centos 52 7월 3 13:52 test //r이 제거된것 확인$ chmod uo+rw test //소유주, 기타사용자에게 읽기,쓰기 허용$ ls -l test -rwx--xrw- 1 centos centos 52 7월 3 13:52 test//숫자를 넣지 않고 하는것을 심볼릭방법이라 하는데 이것이 더 편할 때가 있다.숫자로 할 경우 기존의 권한도 알아야 하기 때문에..# chown centos sample.txt //centos로 소유권을 넘김# ls -l sample.txt-rw-r-xr-x 1 centos root 0 7월 3 13:35 sample.txt //소유권 변경됨# chgrp centos sample.txt //파일소유그룹 변경# ls -l sample.txt-rw-r-xr-x 1 centos centos 0 7월 3 13:35 sample.txt# chown root.root sample.txt //파일 소유자, 그룹 변경# ls -l sample.txt-rw-r-xr-x 1 root root 0 7월 3 13:35 sample.txt# su - centos //centos계정으로 로그인 //루트계정일 경우 암호를 묻지않는다. //-를 붙이면 디렉토리가 centos디렉토리로 변경되가 //붙이지 않으면 변경되지 않는다.# ps -ef | grep dnsmasq //dnsmasq 프로세스 번호 확인# kill -9 xxxx //xxxx프로세스 kill","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"관련정보","slug":"Linux/관련정보","permalink":"http://KKimSangHeon.github.io/categories/Linux/관련정보/"}],"tags":[{"name":"리눅스 명령어","slug":"리눅스-명령어","permalink":"http://KKimSangHeon.github.io/tags/리눅스-명령어/"}]},{"title":"리눅스 에러","slug":"LinuxError","date":"2017-07-01T04:45:37.000Z","updated":"2017-07-21T05:56:56.452Z","comments":true,"path":"2017/07/01/LinuxError/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/01/LinuxError/","excerpt":"","text":"증상:Virtualized performance counters are not supported on the host CPU type. Module VPMC power on failed. Failed to start the virtual machine 이라는 에러메세지 출력. 해결법:.vmx 파일을 열고 vpmc.enable 부분을 “FALSE”로 수정. 증상:quotaoff: command not found , 쿼터에 대한 명령어가 실행이 안됨. 해결법:1# yum install quota 증상:ifconfig가 먹히질 않는다. 해결법1# yum install net-tools 방화벽 설정dns 방화벽 설정을 허용한다고 가정. 해결법12# firewall-cmd --permanent --add-service=dns //방화벽 설정 허용# firewall-cmd --reload //설정내용 적용 증상:받고싶은 패키지가 있는데 레드헷전용이다. 해결법1# yum -y install epel-release //레드헷에 접속해서 다운받을수 있도록 설치 증상: vsftpd를 사용하는데 너무 느리다. 해결법123456# vi /etc/vsftpd/vsftpd.conf# local_max_rate=0# systemctl restart vsftpd","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"관련정보","slug":"Linux/관련정보","permalink":"http://KKimSangHeon.github.io/categories/Linux/관련정보/"}],"tags":[{"name":"Linux Error","slug":"Linux-Error","permalink":"http://KKimSangHeon.github.io/tags/Linux-Error/"}]},{"title":"BinarySearch","slug":"BinarySearch","date":"2017-06-30T10:38:20.000Z","updated":"2017-06-30T11:01:37.840Z","comments":true,"path":"2017/06/30/BinarySearch/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/BinarySearch/","excerpt":"","text":"이진탐색데이터의 정렬이 선행되어야 한다. 시간복잡도는 O(log2n) 이다.BinarySearch.c 재귀적인 방법12345678910111213141516int ISearch(int ar[], int first, int last, int target)&#123; int mid; if(first &gt; last) return -1; // -1의 반환은 탐색의 실패를 의미 mid=(first+last) / 2 ; if(ar[mid] == target) return mid; // 탐색된 타겟의 인덱스 값 반환 else if(target &lt; ar[mid]) return ISearch(ar, first, mid-1, target); else return ISearch(ar, mid+1, last, target);&#125; BinarySearch.c 반복문 이용123456789101112131415161718BinarySearch(int DataSet[], int Size, int target)&#123; int Left,Right,Mid; Left=0; Right=Size-1; while(Left&lt;=Right)&#123; Mid=(Left+Rigth) / 2 ; if( Target==DataSet[Mid]) return DataSet[Mid]; else if(Target&gt;DataSet[Mid]) Left=Mid+1; else Right=Mid-1; &#125; return NULL;&#125; 이진탐색의 경우 비교대상이 되는 mid값을 단순히 (first+last)/2로 설정한다.그러나 보간 탐색의 경우 mid 값 설정방식이 다르며 이진탐색보다 우수한 성능을 보인다. 보간탐색탐색대상이 앞쪽에 위치 할 경우 앞쪽에서 탐색을 시작하고 뒤쪽에 위치할 경우 뒤쪽에서 탐색을 시작한다.이진탐색보다 우수하다.ISearch.c12345678910111213141516int ISearch(int ar[], int first, int last, int target)&#123; int mid; if(ar[first]&gt;target || ar[last]&lt;target) return -1; // 이진 탐색과의 차이점을 반영한 문장 mid = ((double)(target-ar[first]) / (ar[last]-ar[first]) *(last-first)) + first; if(ar[mid] == target) return mid; // 탐색된 타겟의 인덱스 값 반환 else if(target &lt; ar[mid]) return ISearch(ar, first, mid-1, target); else return ISearch(ar, mid+1, last, target);&#125; 보간탐색의 mid값 계산 방법 그림[1]에서 arr[s]는 찾는값을 의미함. 참고 : 윤성우의 열혈 자료구조","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/categories/Data-Structure/"},{"name":"Search","slug":"Data-Structure/Search","permalink":"http://KKimSangHeon.github.io/categories/Data-Structure/Search/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/tags/Data-Structure/"},{"name":"Search","slug":"Search","permalink":"http://KKimSangHeon.github.io/tags/Search/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"http://KKimSangHeon.github.io/tags/BinarySearch/"}]},{"title":"2장. CentOS 리눅스 소개","slug":"ThisIsLinux1","date":"2017-06-30T09:55:52.000Z","updated":"2017-07-01T05:14:51.441Z","comments":true,"path":"2017/06/30/ThisIsLinux1/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/ThisIsLinux1/","excerpt":"","text":"리눅스 리눅스란?리눅스 = 무료 유닉스 라 생각하면 된다.1991 ‘리누스 토르발스’가 버전 0.01을 최초로 완성. 리누스 토르발스는 커널(kernel)만 개발함(여기서 커널은 자동차 엔진이라고 보면된다.)모든 배포판은 리누스 토르발스가 개발한 커널을 갖고 사람들이 만들어진것이다. CentOS 또한 마찬가지..자동차로 비유하자면 A,B,C 회사가 하나의 엔진을 사용하여 각기 다른 자동차를 만들어내놓음.우리가 공부할 CentOS의 커널버전은 3.17.4인데 변경이 가능하다.!자동차로 비교하면 자동차를 그대로 두고 엔진만 변경하는것.이를 커널 업그레이드 라고 한다. GNU 프로젝트?GNU 프로젝트 - GPL(General Public License[자유 소프트웨어의 수정과 공유의 자유를 보장하는것.]) 에 따라 소스를 배포하여 공개하고 그것을 더 개선하여 배포하고 의 반복.. 리눅스 또한 마찬가지. 그래서 현재는 유닉스 보다 더 좋다고 말하는 사람들이 많다. 여기서 재미있는점 하나. 소스코드를 무료로 얻어서 기능개선 후 판매는 가능하다. 그러나 GPL에 의해 소스코드는 공유해야한다는점. 레드햇 리눅스와 CentOS 리눅스?전 세계적으로 유명하며 기업에서 많이쓴다. 무료버전은 없으며 상용버전만 존재한다. 하지만 GPL에 의해 소스코드는 공개되어 있어 레드햇 엔터프라이즈 리눅스의 소스코드를 그대로 가져와 로고만 바꾼것이 CentOS!!결국 레드햇 리눅스 == CentOS 리눅스","categories":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/categories/Linux/"},{"name":"이것이 리눅스다","slug":"Linux/이것이-리눅스다","permalink":"http://KKimSangHeon.github.io/categories/Linux/이것이-리눅스다/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"기수정렬 (RadixSort)","slug":"RadixSort","date":"2017-06-30T05:36:34.000Z","updated":"2017-06-30T11:02:17.317Z","comments":true,"path":"2017/06/30/RadixSort/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/RadixSort/","excerpt":"","text":"기수정렬버켓에 데이터를 작은 수 부터 넣고 빼내어 정렬하는 방식이다.기수정렬의 시간복잡도는 O(ln)이며 l은 버켓의 크기를 의미한다. red, why, few 정렬가능 - 버킷 3개 필요10,161,18,1 가능 - 버킷 3개 필요proffesor , red , why 불가능125 , -101, 167, -505 불가능 ##참고사항 1의자리 수 구하기-num/1%1010의자리 수 구하기 -num/10%10100의 자리 수 구하기 -num/100%10 InsertionSort.c123456789101112131415161718192021222324252627282930313233343536373839void RadixSort(int arr[], int num, int maxLen) // maxLen은 가장 긴 데이터의 길이&#123; Queue buckets[BUCKET_NUM]; int bi; int pos; int di; int divfac = 1; int radix; // 총 10개의 버킷 초기화 for(bi=0; bi&lt;BUCKET_NUM; bi++) QueueInit(&amp;buckets[bi]); // 가장 긴 데이터의 길이만큼 반복 for(pos=0; pos&lt;maxLen; pos++) &#123; // 정렬 대상의 수만큼 반복 for(di=0; di&lt;num; di++) &#123; // N번째 자리의 숫자 추출 radix = (arr[di] / divfac) % 10; // 추출한 숫자를 근거로 데이터 버킷에 저장 Enqueue(&amp;buckets[radix], arr[di]); &#125; // 버킷 수만큼 반복 for(bi=0, di=0; bi&lt;BUCKET_NUM; bi++) &#123; // 버킷에 저장된 것 순서대로 다 꺼내서 다시 arr에 저장 while(!QIsEmpty(&amp;buckets[bi])) arr[di++] = Dequeue(&amp;buckets[bi]); &#125; // N번째 자리의 숫자 추출을 위한 피제수의 증가 divfac *= 10; &#125;&#125; 참고 : 윤성우의 열혈 자료구조","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/categories/Data-Structure/"},{"name":"Sort","slug":"Data-Structure/Sort","permalink":"http://KKimSangHeon.github.io/categories/Data-Structure/Sort/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/tags/Data-Structure/"},{"name":"Sort","slug":"Sort","permalink":"http://KKimSangHeon.github.io/tags/Sort/"},{"name":"Radix Sort","slug":"Radix-Sort","permalink":"http://KKimSangHeon.github.io/tags/Radix-Sort/"}]},{"title":"퀵정렬 (QuickSort)","slug":"QuickSort","date":"2017-06-30T05:36:18.000Z","updated":"2017-06-30T11:02:24.397Z","comments":true,"path":"2017/06/30/QuickSort/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/QuickSort/","excerpt":"","text":"퀵정렬퀵 정렬 O(nlog2n)- 피벗을 정하여 분할하여 정복.. 피벗을 선택 할때 3개를 선택하여 평균치를 구하여 구하면 더 효율적으로 피벗을 정할 수 있다.피벗이 잘 선택될 경우 시간복잡도가 줄어든다. 최악의 경우 O(n^2)이 될 수 있다 (피벗값이 많이 안좋을 경우) O(nlog2n)의 시간복잡도를 갖는 다른 정렬 알고리즘 보다 평균적으로 빠르다.why ? 데이터 이동이 상대적으로 작고 병합정렬과 같이 별도의 메모리 공간을 요구하지 않기 때문에.. 나만의 요약! : 피벗값을 기준으로 처음지점부터 시작한 반복문은 피벗보다 작은값을 찾고 뒤에서 시작한 반복문은 피벗보다 큰값을 찾아 서로 바꾼다. ( 단 피벗을 지나치치 않음) QuickSort.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void Swap(int arr[], int idx1, int idx2)&#123; int temp = arr[idx1]; arr[idx1] = arr[idx2]; arr[idx2] = temp;&#125;int Partition(int arr[], int left, int right)&#123; int pivot = arr[left]; // 피벗의 위치는 가장 왼쪽! int low = left+1; int high = right; while(low &lt;= high) // 교차되지 않을 때까지 반복 &#123; while(pivot &gt; arr[low]) low++; while(pivot &lt; arr[high]) high--; /* while(pivot &gt;= arr[low] &amp;&amp; low &lt;= right) low++; while(pivot &lt;= arr[high] &amp;&amp; high &gt;= (left+1)) high--; */ if(low &lt;= high) // 교차되지 않은 상태라면 Swap 실행 Swap(arr, low, high); // low와 high가 가리키는 대상 교환 &#125; Swap(arr, left, high); // 피벗과 high가 가리키는 대상 교환 return high; // 옮겨진 피벗의 위치 정보 반환&#125;void QuickSort(int arr[], int left, int right)&#123; if(left &lt;= right) &#123; int pivot = Partition(arr, left, right); // 둘로 나눠서 QuickSort(arr, left, pivot-1); // 왼쪽 영역을 정렬 QuickSort(arr, pivot+1, right); // 오른쪽 영역을 정렬 &#125;&#125; 참고 : 윤성우의 열혈 자료구조","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/categories/Data-Structure/"},{"name":"Sort","slug":"Data-Structure/Sort","permalink":"http://KKimSangHeon.github.io/categories/Data-Structure/Sort/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/tags/Data-Structure/"},{"name":"Sort","slug":"Sort","permalink":"http://KKimSangHeon.github.io/tags/Sort/"},{"name":"Quick Sort","slug":"Quick-Sort","permalink":"http://KKimSangHeon.github.io/tags/Quick-Sort/"}]},{"title":"병합정렬 (MergeSort)","slug":"MergeSort","date":"2017-06-30T05:36:10.000Z","updated":"2017-06-30T11:02:44.760Z","comments":true,"path":"2017/06/30/MergeSort/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/MergeSort/","excerpt":"","text":"병합정렬재귀적으로 분할하여 병합하는 방식으로 재귀적으로 모든 요소들을 쪼갠 후 합쳐나간다. 시간복잡도는 O(nlog2n))이다. MergeSort.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void MergeTwoArea(int arr[], int left, int mid, int right)&#123; int fIdx = left; int rIdx = mid+1; int i; int * sortArr = (int*)malloc(sizeof(int)*(right+1)); int sIdx = left; while(fIdx&lt;=mid &amp;&amp; rIdx&lt;=right) &#123; if(arr[fIdx] &lt;= arr[rIdx]) sortArr[sIdx] = arr[fIdx++]; else sortArr[sIdx] = arr[rIdx++]; sIdx++; &#125; if(fIdx &gt; mid) &#123; for(i=rIdx; i&lt;=right; i++, sIdx++) sortArr[sIdx] = arr[i]; &#125; else &#123; for(i=fIdx; i&lt;=mid; i++, sIdx++) sortArr[sIdx] = arr[i]; &#125; for(i=left; i&lt;=right; i++) arr[i] = sortArr[i]; free(sortArr);&#125;void MergeSort(int arr[], int left, int right)&#123; int mid; if(left &lt; right) &#123; // 중간 지점을 계산한다. mid = (left+right) / 2; // 둘로 나눠서 각각을 정렬한다. MergeSort(arr, left, mid); MergeSort(arr, mid+1, right); // 정렬된 두 배열을 병합한다. MergeTwoArea(arr, left, mid, right); &#125;&#125; 참고 : 윤성우의 열혈 자료구조","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/categories/Data-Structure/"},{"name":"Sort","slug":"Data-Structure/Sort","permalink":"http://KKimSangHeon.github.io/categories/Data-Structure/Sort/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/tags/Data-Structure/"},{"name":"Sort","slug":"Sort","permalink":"http://KKimSangHeon.github.io/tags/Sort/"},{"name":"Merge Sort","slug":"Merge-Sort","permalink":"http://KKimSangHeon.github.io/tags/Merge-Sort/"}]},{"title":"힙정렬 (HeapSort)","slug":"HeapSort","date":"2017-06-30T05:35:38.000Z","updated":"2017-06-30T11:02:55.505Z","comments":true,"path":"2017/06/30/HeapSort/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/HeapSort/","excerpt":"","text":"힙 정렬힙을 만들어서 힙에 넣고 빼는것으로서 시간복잡도는 O(nlog2n) 이다. BubbleSort.c12345for(i=0;i&lt;n;i++) HInsert(&amp;heap,arr[i]);for(i=0;i&lt;n;i++) arr[i]=HDelete(&amp;heap); 참고 : 윤성우의 열혈 자료구조","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/categories/Data-Structure/"},{"name":"Sort","slug":"Data-Structure/Sort","permalink":"http://KKimSangHeon.github.io/categories/Data-Structure/Sort/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/tags/Data-Structure/"},{"name":"Sort","slug":"Sort","permalink":"http://KKimSangHeon.github.io/tags/Sort/"},{"name":"Heap Sort","slug":"Heap-Sort","permalink":"http://KKimSangHeon.github.io/tags/Heap-Sort/"}]},{"title":"삽입정렬 (InsertionSort)","slug":"InsertionSort","date":"2017-06-30T05:35:28.000Z","updated":"2017-06-30T11:03:11.884Z","comments":true,"path":"2017/06/30/InsertionSort/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/InsertionSort/","excerpt":"","text":"삽입정렬1~n까지 정렬해 나감 1~2 정렬 12묶음 3정렬 13묶음 4정렬첫 번째 데이터는 정렬이 되어있다고 봄. 그래서 i=0이아닌 1부터 시작.시간복잡도는 O(n^2) 이다. InsertionSort.c123456789101112for(i=1;i&lt;n;i++)&#123; insData=arr[i]; //정렬대상을 insData에 저장 for(j=i-1;i&gt;=0;j--) &#123; if(arr[j]&gt;insData) arr[j+1]=arr[j]; else break; &#125; arr[j+1]=insData;&#125; 참고 : 윤성우의 열혈 자료구조","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/categories/Data-Structure/"},{"name":"Sort","slug":"Data-Structure/Sort","permalink":"http://KKimSangHeon.github.io/categories/Data-Structure/Sort/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/tags/Data-Structure/"},{"name":"Sort","slug":"Sort","permalink":"http://KKimSangHeon.github.io/tags/Sort/"},{"name":"Insertion Sort","slug":"Insertion-Sort","permalink":"http://KKimSangHeon.github.io/tags/Insertion-Sort/"}]},{"title":"선택정렬 (SelectionSort)","slug":"SelectionSort","date":"2017-06-30T04:59:38.000Z","updated":"2017-06-30T11:03:24.859Z","comments":true,"path":"2017/06/30/SelectionSort/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/SelectionSort/","excerpt":"","text":"선택정렬오름차순일 경우 작은걸 맨앞에 넣고 그 다음 작은걸 두 번째 넣고 ..이 과정을 계속 반복한다. 시간복잡도는 O(n^2) 이다. SelectionSort.c12345678910for(i=0;i&lt;n-1;i++)&#123; maxIdx=i; for(j=i+1;j&lt;n;j++) //최소값 탐색 &#123; if(arr[i]&lt;arr[maxIdx]) maxIdx=j; &#125; swap;&#125; 참고 : 윤성우의 열혈 자료구조","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/categories/Data-Structure/"},{"name":"Sort","slug":"Data-Structure/Sort","permalink":"http://KKimSangHeon.github.io/categories/Data-Structure/Sort/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/tags/Data-Structure/"},{"name":"Sort","slug":"Sort","permalink":"http://KKimSangHeon.github.io/tags/Sort/"},{"name":"Selection Sort","slug":"Selection-Sort","permalink":"http://KKimSangHeon.github.io/tags/Selection-Sort/"}]},{"title":"작성논문","slug":"paper","date":"2017-06-30T04:40:14.000Z","updated":"2017-07-07T00:51:51.519Z","comments":true,"path":"2017/06/30/paper/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/paper/","excerpt":"","text":"A Survey of Fingerprint Indoor Positioning TechniquesintroductionThe location based service (LBS) industry is so flourishing that enumerating all LBSs available now is almost impossible. In the marketing field, LBSs may recognize the current location of tenta-tive customers and push advertisement messages and coupons to them when they enter a predefined area. When a person makes a call to 911, the location of the person is identified by the emergency response agency so that help can be provided quickly. The location-based information service deliv-ers information of points of interests located near to the user. The navigation service is another well-known type of location-based services.Location-based service cannot be realized unless the positioning problem is solved. The Global Positioning System (GPS) can be used as a general solution for outdoor positioning. However, posi-tioning for indoor area is still under development. We are especially interested in wireless local area network (WLAN)-based indoor positioning techniques because it is available in almost all huge man made constructions. Most of WLAN-based indoor positioning techniques use either the signal propa-gation model or fingerprints.Implementation of the signal propagation model based indoor positioning method can be done quickly whereas implementation of the fingerprint method takes a long time. However, the finger-print method is more accurate than the signal propagation model based method. This paper surveys recently published fingerprint indoor positioning techniques. 자세히 보기 Review of the Techniques for Smart Learning SystemsintroductionFlipped learning is said to be one of the most efficient teaching and learning methods. In flipped learning, students watch lecture videos at home. In the class, they solve interesting problems under the teacher’s guide. Nowadays, students watch videos through smart devices while they are on the way home. Therefore, schools should provide a smart learning system.A database of lecture videos, smart applications, content management systems, and streaming servers are essential parts of smart learning systems. There are many database management system (DBMS) with which we can develop database of lecture videos. Among them, this paper reviews techniques to use MySQL DBMS. 자세히 보기 Techniques for Group Management Application DevelopmentintroductionA group management system provides many types of valuable services. For example, a teacher can be aware of current locations of all the students in real time during a field trip using a group management mobile application. In the early stage of location based service, fleet management was one of the hottest research topics. This paper reviews group management related research results.Positioning, handling maps, handling a database and mobile programming are indispensable technologies for the development of fleet management systems. Usages of these technologies in fleet management system development are discussed.자세히 보기 Survey of Techniques for Location-Based Mobile Campus Guide SystemsintroductionLocation-based service provides useful information based on the place where the user is located. Smart phones are ideal devices that provide location-based services because they are equipped with various sensors with which we can determine the location of smart phones.As an example of location-based service, the authors of [1] introduced a campus guide mobile app. This paper surveys techniques needed in development of location-based mobile campus guide systems. Campus guide systems prints out texts and images. It also plays audios and videos. Therefore, video on demand (VOD) techniques will be discussed. Techniques to identify the context of user will also be discussed. Finally, this paper will propose a design of a campus guide 자세히 보기","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"작성 논문","slug":"작성-논문","permalink":"http://KKimSangHeon.github.io/tags/작성-논문/"}]},{"title":"시각장애인을 위한 길안내 app","slug":"For-blind","date":"2017-06-30T03:42:08.000Z","updated":"2017-06-30T04:32:05.752Z","comments":true,"path":"2017/06/30/For-blind/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/For-blind/","excerpt":"","text":"참가배경-교내 창업경진대회가 진행 중이라는 소식을 듣고 참가하게 되었습니다. 비콘과 관련된 프로젝트를 진행중이던 상황이라 비콘을 이용해서 창업아이템을 고안하게 되었습니다. Idea를 떠올린 계기 -지하철을 이용하던 어느 날 시각장애인이 길을 찾는데 어려움을 겪는 것을 보았습니다. 시각장애인이 길을 찾는데 어려움을 겪은 이유는 점형블록에 대한 인식이 부족한 상인이 올려둔 짐 때문이었고 결국 시각 장애인은 주변 사람들의 도움을 통해 올바른 길을 찾아 갈 수 있었습니다. 저는 그 이후 지하철 내 점형블록을 눈여겨보게 되었습니다. [그림1]의 좌측 사진과 같이 깨진 점형블록이 보수되지 않은 채 존재하며, 우측 사진과 같이 매트가 깔려있기도 했습니다. -또한 그들을 위한 시설인 음성유도기 또한 고장나있는경우가 많으며 가격이 비싸다는 단점이 존재하였습니다.(개당 약 270만원) Idea 소개역사에 10m^2당 비콘을 하나씩 설치하여 핑거프린팅 알고리즘을 적용한 후 현재위치를 파악합니다. (FingerPrinting Algorithm(참고)) 그 후 [그림3]과 같이 이동방향을 파악 후 이동방향에 따른 음성안내를 실시합니다.음성안내를 실시하기 위해서는 다음의 Newtone API 혹은 Naver의 음성합성 기능을 사용하면 가능합니다. 결과 운이 좋게도 장려상과 30만원의 장학금을 지급받았습니다 !","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://KKimSangHeon.github.io/tags/Android/"},{"name":"Beacon","slug":"Beacon","permalink":"http://KKimSangHeon.github.io/tags/Beacon/"},{"name":"창업경진대회","slug":"창업경진대회","permalink":"http://KKimSangHeon.github.io/tags/창업경진대회/"}]},{"title":"기숙사 외박계","slug":"Dormitory-Sleep-Out","date":"2017-06-30T01:22:14.000Z","updated":"2017-06-30T03:37:41.143Z","comments":true,"path":"2017/06/30/Dormitory-Sleep-Out/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/Dormitory-Sleep-Out/","excerpt":"","text":"프로그램 개발배경-교내 기숙사의 외박계 프로그램이 존재하지 않으며, 업체에 의뢰하여 제작하려했으나 비용상의 문제로 거절된것을 알게되었습니다. 그래서 직접 만들어서 제출하면 어떨까 라는 생각을 하게되어 개발하게 되었습니다. 프로그램 소개CentOS상에 서버를 실행시켰으며, 카카오톡 옐로아이디 페이지에서 세팅을 진행하였습니다. 각 과정을 거친 후 자신의 외박계를 하나 작성할 수 있는 프로그램입니다. 프로그램 동작화면 초기 채팅방에 진입하였을 경우 외박계를 작성할 것인지, 작성한 외박계를 확인할 것인지 선택합니다.외박계 작성을 선택하였을 경우 이름, 거주하는 동, 호수, 귀관일, 행선지를 입력하고전화번호 또한 입력 후 아무키나 입력하면 등록이 완료됩니다.[그림1]에서 확인버튼을 선택하였을 경우 [그림4]와 같이 입력한 내용을 확인할 수 있습니다. 작성된 외박계를 관리자가 확인하기 위해서는 채팅방에서 supervisorgj@를 입력합니다. 그 후 [그림5]와 같이 외박계를 조회할 수 있습니다. 소스코드 (Github Repository)-카카오톡 자동응답 서버 소스코드","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://KKimSangHeon.github.io/tags/Node-js/"},{"name":"Kakao talk open API","slug":"Kakao-talk-open-API","permalink":"http://KKimSangHeon.github.io/tags/Kakao-talk-open-API/"},{"name":"챗봇","slug":"챗봇","permalink":"http://KKimSangHeon.github.io/tags/챗봇/"},{"name":"MySQL","slug":"MySQL","permalink":"http://KKimSangHeon.github.io/tags/MySQL/"},{"name":"CentOS","slug":"CentOS","permalink":"http://KKimSangHeon.github.io/tags/CentOS/"}]},{"title":"Music Share","slug":"music-share","date":"2017-06-30T00:31:38.000Z","updated":"2017-08-11T06:17:27.853Z","comments":true,"path":"2017/06/30/music-share/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/music-share/","excerpt":"","text":"프로그램 개발배경-C 소켓프로그래밍에 대한 이해를 높이고자 진행한 프로젝트입니다. 프로그램 소개-본 프로그램은 회원가입기능, 로그인기능, 서버에 mp3파일을 올리는기능 등이 구현되어 있습니다. 회원가입을 하고 로그인 후 서버에 mp3파일을 올리거나 다운로드 받을 수 있습니다. 프로그램 개발환경은 우분투 14.04 LTS 입니다. 프로그램 기능 초기 서버에 접속하였을 경우 화면입니다. 서버에서는 클라이언트의 접속현황 및 상태를 확인할 수 있으며 클라이언트에서는 다음에 할 수 있는 일을 확인할 수 있습니다. 두 클라이언트가 회원가입을 진행하고 있고 이에 대한 내용이 서버측 화면에 출력됩니다. 클라이언트가 가입한 ID를 이용하여 로그인을 하였습니다. 로그인 후 에는 서버에 존재하는 mp3파일리스트를 조회하거나 mp3파일을 업로드, 다운로드 할 수있습니다. 클라이언트가 로그인을 한 후 mp3파일을 업로드하는 화면입니다. 클라이언트가 로그인을 한 후 서버에 존재하는 mp3파일을 조회하는 화면입니다. [그림4]에서 KSH클라이언트가 업로드한 hello.mp3 파일을 HRA클라이언트가 접속하여 다운로드 하는 화면입니다. 비밀번호를 찾기위해 ID, Email을 입력하였고 이 후 비밀번호가 화면에 출력되는 모습입니다. github Repository","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"C","slug":"C","permalink":"http://KKimSangHeon.github.io/tags/C/"},{"name":"Socket","slug":"Socket","permalink":"http://KKimSangHeon.github.io/tags/Socket/"},{"name":"Music Share","slug":"Music-Share","permalink":"http://KKimSangHeon.github.io/tags/Music-Share/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://KKimSangHeon.github.io/tags/Ubuntu/"}]},{"title":"다수 사용자의 실시간 위치추적 어플리케이션 구현","slug":"where-are-you","date":"2017-06-29T14:53:44.000Z","updated":"2017-08-09T09:28:08.513Z","comments":true,"path":"2017/06/29/where-are-you/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/29/where-are-you/","excerpt":"","text":"App 개발배경-한 인원이 다수의 인원을 통제해야 하는 상황은 다양한 상황에서 발생할 수 있습니다. 가령 한 초등학교에서 현장체험학습의 일환으로 박물관을 방문하였을 경우, 교사 한명이 통제해야할 학생수는 약 30명에 이릅니다. 이는 교사에게 부담스러운 수가 될 수 있을것이라 판단하여 어플리케이션을 통해 극복하고자 하였습니다. App 소개-본 어플리케이션은 BLE기반의 비콘을 이용하여 실내에서 다수 사용자의 위치를 파악하는 어플리케이션입니다. App을 사용하기 위해서는 User는 자신의 정보를 등록해야 하며 이때 입력하는 데이터는 이름, ClassID 입니다. Supervisor는 이름 혹은 (이름,ClassID)를 이용하여 User의 최근 위치를 파악할 수 있는데 ClassID로는 해당 ClassID를 갖는 모든 User가 조회되며, (이름,ClassID)으로는 해당 User의 이동경로를 파악할 수 있습니다. System Architecture -본 어플리케이션의 이용자는 크게 User, Supervisor로 나뉘는데 User의 경우 FingerPrintingServer로 자신이 인식한 비콘들의 값을 전송합니다. 이를 수신한 FingerPrintingServer 서버는 User의 위치를 FingerPrinting 알고리즘을 적용하여 계산한 후 DB에 업데이트합니다. 이용자가 Supervisor 일 경우에는 StudentLocationPage에 접근하여 User들의 위치를 읽어옵니다. FingerPrinting Algorithm-본 어플리케이션의 핵심 알고리즘은 FingerPrinting Algorithm 입니다. 이 알고리즘을 구현하기 위해 72개 지점에서 비콘인식 실험을 100번 간 진행하였습니다. 결과물을 토대로 평균, 분산, 표준편차 등을 곱하고 나누어서 가장 실제 위치와 근접한 값을 구할 수 있었으며 최종적으로 오차를 약 1.65m 까지 줄일 수 있었습니다. -다음은 간단한 FingerPrinting Algorithm 적용 방식입니다. (서버에서 사용하는 알고리즘과는 다릅니다.)핑거프린팅 기법은 사전에 측정된 각 좌표 별 비콘의 신호값을 토대로 현재 위치를 추측하는 기술입니다. 예를 들어 그림1과 같이 각 좌표 별 사전에 측정된 비콘의 신호값(RSSI)이 존재한다고 가정 해 보겠습니다.현재 위치에서 측정된 각 비콘의 RSSI 값이 B1: -86 B2: -91 B3: -100 일 때 Coordinate1에 대한 각 비콘 신호의 차이의 합을 구하면 (-86, -87과의 차이) + (-91, -90과의 차이) + (-100, -101과의 차이) 3입니다. 이 과정을 Coordinate2 또한 반복하면 결과값은 14이며 , Coordinate3 은 26입니다.이 중 오차가 가장 작은 즉 최소값을 갖는 좌표가 현재 위치라 판단할 수 있을 것 이므로 현재 위치는 Coordinate1이라 추측할 수 있겠습니다. Result ClassID로 조회하였을 경우 [그림1]과 같이 해당 User들이 최근에 위치한 좌표값을 확인할 수 있습니다. (이름,ClassID)로 조회하였을 경우 해당 User의 이동경로가 [그림2]와 같이 출력됩니다. User의 위치는 카카오톡 yelloID (ID:WhereAreYou)로도 확인이 가능한데 [그림3]과 같이 카카오톡을 이용하여 위치 조회가 가능합니다. 소스코드 (Github Repository)-안드로이드 어플리케이션 소스코드-카카오톡 자동응답 서버 소스코드-웹페이지 서버 소스코드-소켓 서버 소스코드","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://KKimSangHeon.github.io/tags/Android/"},{"name":"Reco Beacon","slug":"Reco-Beacon","permalink":"http://KKimSangHeon.github.io/tags/Reco-Beacon/"},{"name":"Beacon","slug":"Beacon","permalink":"http://KKimSangHeon.github.io/tags/Beacon/"}]},{"title":"안녕하세요!","slug":"about-me","date":"2017-06-29T09:58:22.000Z","updated":"2017-08-11T13:11:59.886Z","comments":true,"path":"2017/06/29/about-me/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/29/about-me/","excerpt":"","text":"Introduction안녕하세요. 항상 풀스택 개발자가 되고자 노력하는 취업준비생입니다. 이 블로그는 제가 개인적으로 공부한 내용, 진행했던 프로젝트를 업로드하고, 공유하고자 만들었습니다. 부족한 부분에 대한 태클은 언제든지 환영하며 빠르게 반영하도록 하겠습니다. 부족하지만 방문해주셔서 감사드리며 앞으로 더욱 완벽한 블로그를 만들기 위해 노력하겠습니다! Profile 부명고등학교 졸업 (2008.03~2011.02) 동국대학교 경주캠퍼스 컴퓨터공학과 졸업 (2011.03~2017.02) 아이티센 인턴수료 [공공2사업부문 개발2팀] (2016.12~2017.03) Project제가 진행했었던 프로젝트는 다음과 같습니다. 클릭하시면 자세한 설명을 볼 수 있는 페이지로 이동합니다. - 다수 사용자의 실시간 위치추적 어플리케이션(Android, Beacon, Socket) - 부모님을 부탁해(Android) - Music Share(C, Socket) - 기숙사 외박계(Node.js, Kakao API) - 시각장애인을 위한 길안내 app제안(android) - 작성 논문 - 엄마가 보고있다(android) - 데이터 프리 기프티콘(android) - 동국대 경주캠퍼스 채팅봇(Node.js, Kakao API, AWS) - Wholin 밴드(android)","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"Introduction","slug":"About-Me/Introduction","permalink":"http://KKimSangHeon.github.io/categories/About-Me/Introduction/"}],"tags":[{"name":"Sang Heon Kim","slug":"Sang-Heon-Kim","permalink":"http://KKimSangHeon.github.io/tags/Sang-Heon-Kim/"}]},{"title":"부모님을 부탁해","slug":"request-parent","date":"2017-06-29T09:52:18.000Z","updated":"2017-08-11T06:19:57.080Z","comments":true,"path":"2017/06/29/request-parent/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/29/request-parent/","excerpt":"","text":"App 소개 및 개발배경-본 어플리케이션은 증가하는 고독사를 줄여보자는 취지에서 개발하게 된 어플리케이션입니다. 부재중 통화수가 사전에 등록해 놓은 n 개가 되었을 경우 사전에 등록해 놓은 지인에게 위치정보가 포함된 문자메세지가 송신되는 앱 입니다. 초기화면에서 문자메세지를 수신할 번호, 부재중통화의 개수n을 입력하고 동작하기 버튼을 누릅니다. 어플리케이션을 설치한 스마트폰 주인이 부재중통화를 n번 받지 않을 경우 스마트폰의 현재 위치가 등록한 번호로 전송됩니다. -시연영상github Repositorygoogle play 방문","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://KKimSangHeon.github.io/tags/Android/"},{"name":"고독사 감소","slug":"고독사-감소","permalink":"http://KKimSangHeon.github.io/tags/고독사-감소/"}]},{"title":"거품정렬 (BubbleSort)","slug":"BubbleSort","date":"2017-06-29T05:36:52.000Z","updated":"2017-06-30T11:03:53.379Z","comments":true,"path":"2017/06/29/BubbleSort/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/29/BubbleSort/","excerpt":"","text":"거품정렬거품정렬의 코드는 다음과 같다.시간복잡도는 O(n^2) 이다. BubbleSort.c12345678910for(i=0;i&lt;n-1;i++)&#123; for(j=0;j&lt;(n-i)-1;j++) &#123; if(arr[j]&gt;arr[j+1]) &#123; swap; &#125; &#125;&#125; 참고 : 윤성우의 열혈 자료구조","categories":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/categories/Data-Structure/"},{"name":"Sort","slug":"Data-Structure/Sort","permalink":"http://KKimSangHeon.github.io/categories/Data-Structure/Sort/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/tags/Data-Structure/"},{"name":"Sort","slug":"Sort","permalink":"http://KKimSangHeon.github.io/tags/Sort/"},{"name":"Bubble Sort","slug":"Bubble-Sort","permalink":"http://KKimSangHeon.github.io/tags/Bubble-Sort/"}]}]}