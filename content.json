{"meta":{"title":"Kim Sang Heon's Bolg","subtitle":null,"description":"Welcome to Sang Heon's Blog.","author":"Kim Sang Heon","url":"http://KKimSangHeon.github.io"},"pages":[{"title":"","date":"2019-03-06T13:45:53.067Z","updated":"2019-03-05T13:05:59.701Z","comments":true,"path":"images/adsense.html","permalink":"http://KKimSangHeon.github.io/images/adsense.html","excerpt":"","text":"(adsbygoogle = window.adsbygoogle || []).push({});"}],"posts":[{"title":"AWS VPC 전반 기초 요약","slug":"aws","date":"2020-01-14T00:29:38.000Z","updated":"2020-01-14T10:11:12.789Z","comments":true,"path":"2020/01/14/aws/","link":"","permalink":"http://KKimSangHeon.github.io/2020/01/14/aws/","excerpt":"","text":"AWS전세계에서 가장 많이 쓰는 퍼블릭 서버IAAS로 시작함 가용성 존(AZ)가장 기본적인 단위는 Region 이다.한국의 경우 서울 하나만 있다.Region는 논리적인 단위이고 가용성 존(AZ)이 물리적인 단위이다.한 Region은 여러개의 가용성 존을 갖고 있다.가용성 존이 오늘 다룰 단위이다. AZ 하나는 CIDC(클라우드 IDC)로서 하나의 단위이다. VPC(Virtual Private Cloud) - AZ를 포함하는 단위. 리전마다 만들 수 있다.자기 자신만의 가상 IDC를 만들어서 활용하는것. 가상서버의 인스턴스는 VPC안에 생성된다. IDC는 게이트웨이, 방화벽, 서버, 서브넷 등이 필요한데 이들은 VPC안에 정의 가능하다. Bastion Host / VPN 으로 접속하는 방법이 있다. Bastion Host의 경우 SSH을 열은 EC2 로 접근하여 다른 서브넷에 접근하는 방식이다.둘 다 그림으론 IGW를 안거치는것 처럼 보이지만 거치는 형태이다. ELB 는 로드벨런서이다. 실습vpc 검색 VPC 생성대부분의 오브젝트 이름이 태그로 관리된다. 논리적인 이름이다. 이름태그퍼블릭 클라우드는 네이밍이 중요하기 떄문에 신중해야 함. 왜?VPC를 여러개 만드는 경우가 생기게 되는데 (ex. 개발, 프로덕트, 스테이징 등등 생성하고자 할 때 / 부서별로 생성하는 경우) 네이밍 방법vpc-opne2-dev-{서비스 약칭} opne2 - 한국지역dev - 개발용 (dev,prod,stg 중 선택)서비스 약칭 IPv4 CIDR 블록10.1.0.0/16 을 하면 156xx개를 사용할 수 있다 IPv6 CIDR 블록IPv6를 지원하면 켜줘야함 이제 생성클릭 VPC 목록 화면VPC ID가 식별자이다. DNS 호스트 이름 : 도메인네임도 내부 룰에 맞춰서 생성해서 붙여줄까?라우팅 테이블 : VPC안에서 서브넷간 통신을 어떻게 할지어디서 어디까지 흘러가는건 막고 등… 내부흐름 조절DHCP 옵션 세트:내부적으로 붙는 인스턴스가 AWS가 내부 IP로 붙인다. 네트워크 ACL : 서브넷 단위의 firewall 주로 ACL보다는 시큐리티 그룹을 즐겨쓴다. DNS 호스트 이름 활성화좌측 위 작업 - DNS 호스트 이름 편집- 활성화 체크 인터넷 게이트웨이VPC를 생성한 이후에 가장먼저해야할게 외부와 통신하기 위해 게이트웨이를 만들어야한다. 좌측에서 인터넷 게이트웨이 생성 클릭네이밍 규칙igw-opne2-dev 우즉 위 작업 - VPC에 연결클릭 후 연결시켜준다. ACLfirewall로서 서브넷 단위로 통신흐름을 제어하는데 인바운드 아웃바운드 제어가 가능. 서브넷 처럼 뭐는 되고 뭐는 안되는 세밀한 조정은 안됨 ACL은 서브넷 단위로 트래픽을 제어하고 RT를 통해 어느서브넷에서 나온것은 어디로 흘러갈지 정의한다. ACL은 디폴트로 생성된다. 좌측에 네트워크 ACL 클릭 후 선택 후 인바운드, 아웃바운드 보면 다열려있다, 서브넷 연결탭은 아무것도 없는데 조금 뒤 서브넷을 만들고 설정하도록 하겠다. 서브넷 생성VPC에 저복하기 위해서는 VPN을 사용하지만 이는 비용이 든다. 그래서 VPC 내 여러개의 서브넷 중 하나에 EC2를 생성하고 SSH로 접속하여 다른곳에 붙는다. 이를 Bastion Host라 함. 좌측 서브넷 선택네이밍 규칙subnet-opne2-dev-ssh VPC 선택가용영역: 서울리전에는 AZ가 3개가 있다고 했었따. 가용영역서브넷은 가용영역이 있으므로 이름태그를 subnet-apne2a-dev-ssh로 수정한다. a는 가용영역 3개중 비교를 위해 붙임. AZ를 여러개로 구성하여 다중화를 통해 장애에 유연하게 대처할 수 있도록 하는것이 좋다 CIDRVPC가 갖고있는 범위안에서 CIDR을 만들어야 한다.(아까 만든 10.1.0.0/16)10.1.1.0/24 관례적으로 3번째 숫자가 낮아질 수록 은밀성이 높아진다.내부적으로 10번대는 웹서버, 20번대는 디비 …. 이런식으로 정한다. VPC의 CIDR 블록값이 다른값과 겹치면 안된다.블록값이 겹치면 VPC간 페어링을 해야할 때 동일한 CIDR 블록을 갖는것들은 페어링이 안된다. 과금팁 EC2 는 메모리,CPU 를 점유하므로 그냥 있어도 과금이 된다. 같은 AZ안에서의 통신은 과금이 되지않는다(조금씩 다르긴하다) 인바운드는 보통 과금이 되지만 아웃바운드는 과금이 되지 않는 경우도 존재 다시 ACL가서 생성한 서브넷 연결확인좌측에 네트워크 ACL 선택 후 서브넷 하나 선택하고 서브넷 연결탭에서 등록되어있따 확인. 라우트 테이블VPC 왼쪽메뉴 보면 라우팅 테이블이있다. 네이밍규칙rt-apne-dev-ssh 생성되어있는것의 이름을 네이밍 규칙에 맞게 설정 그 후 서브넷 연결 편 탭에서 서브넷 연결편집 클릭 - 하나 선택후 저장 EC2 생성ec2 검색인스턴스 키페어 생성키페어 생성버튼 클릭 네이밍keypair-apne2-dev-public 을 입력하고 파일을 내려받게된다. 키페어만 있으면 ACL, 시큐리티 그룹에서 막히지 않았을 때 어디서든 들어올 수 있다. 인스턴스 생성왼쪽인스턴스 선택 - 인스턴스 생성 클릭 - Amazon Linux 2 AMI (HVM), SSD Volume Type - ami-0bea7fd38fabe821a 선택 t2.micro 는 Bastion Host로 사용하기에 널널하다General Purpose의 유형중 t로 시작하는것은 개발/테스트 용도로 사용하기 적당m으로 시작하는것은 메모리가 많다.t 뒤에 위치한 숫자는 세대(Generation)라고 보면 된다. t2.micro 선택 후 다음 클릭 네트워크에서 내가 만든것 선택서브넷은 하나뿐일것임퍼플릭 IP 자동할당 - 활성화 (외부와 통신이 필요할 때 활성화를 한다. 리스타트하면 ip가 바뀌므로 해당 ip로 통신하도록 박아놓으면 안된다.)종료방식 - 중지(종료로 되어있으면 종료했을 때 인스턴스가 종료된다.) 네트워크 인터페이스 고급세부정보인스턴스를 기동할 때 특정 행위를 하도록 할 수 있는데 여기에 집어넣는것. 다음 스토리지 추가 클릭 다음 태그추가 클릭키가 : name값이 : ec2-apne2a-dev-ssh 다음 보안그룹 클릭 보안그룹 이름 : sg-apne-dev-ssh으로 해야되지만시큐리티 그룹은 특수문자를 허용하지 않기 때문에 sgapnedevssh로 하자 유형 : SSH소스 : 내 IP설명 : xxx(꼭 넣어주는것이 좋다. 어딘지 알 수 있도록) 검토및 시작 클릭 후 시작하기 클릭 기존 키 페어 선택 클릭 후 인스턴스 시작 퍼블릭 IP는 다시시작하면 바뀌므로 접속정보로 사용하지 말것. 라우트 테이블에 연결왼쪽탭의 라우팅테이블라우팅 추가 - 0.0.0.0/0(잘 선택해서 추가해라… 잘못해서 해멨다..) EC2에 접속해보면 잘될것이다. 1차 정리해보자가상의 IDC이다. 외부와 통신하기 위해 게이트웨이를 붙이고 VPC에 게이트웨이 바인딩하고 서브넷을 만들었다. 서브넷은 퍼블릿/프라이빗을 구분하기 위해 라우팅테이블에 포함되어 있는지 판단한다. 라우팅테이블에 존재하면 퍼블릭 ACL은 서브넷 단위까지밖에 관리 못함 실제로 인터넷 서비스를 이용하기 위해 게이트웨이, 라우터 등이 필요한데 집에있는 모뎀은 라우터 , 게이트웨이가 합쳐져있는것이다. 1sudo yum update 서브넷 새로 하나 추가서브넷 (CIDR 추가), 라우팅테이블 추가 서브넷 추가서브넷 탭에서 서브넷 생성subnet-apne2a-dev-webCIDR 블록10.1.2.0/24추가 라우팅테이블서브넷 연결 설정rt-apne2-dev-webweb에 0.0.0.0/0 / Internet gateway 추가 보안그룹 생성sgapne2devweb와ssh / http 생성 EC2생성ec2-apne2a-dev-web 생성한 서브넷에 접속하여 아래 입력1234sudo yum updatesudo yum install httpdsudo systemctl start httpdcurl localhost 지금까지 환경 구성했ㅆ던것들을 템플릿화 하여 코드로 관리할 수 도 있다CloudFormation 활용하여…. 로드벨런서서브넷에 붙기전에 로드벨런서에 붙는다.이는 로컬 로드벨런서임. elb를 거치도록 하는것이 좋다. elb는 다른서브넷에도 접근이 가능하다. 즉 서브넷이 죽었을 때 다른곳으로 보내줄 수 있다 elb에는 인스턴스를 식별할 수 있는것이 주어져야함 최근에는 DNS또한 로드벨런싱을 어느정도 해주긴 함.DNS가 위치 등의 정보에 따라 적절한 elb에 연결해줌 로드벨런서 생성 실습EC2의 좌측 로드밸런서 탭 로드밸런서 생성 클릭 Classic Load Balancer 생성이름 : elb-apne2-deb-web내부 로드 밸런서 생성 : 체크 다음보안설정구성 그냥 다음 4단계: 상태 검사 구성은 헬스체크를 어디로 얼마 주기로 할 것인지.다음 NAT프라이빗으로 구성하여 yum update를 할 경우 외부로 나갈 수 없게되는데 이를 해결하기 위해 NAT를 쓴다. 기본적인가 BastionHost Public로 두고 ELB public로 하고NAT, Web on premese 등을 private로 많이쓴다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"오픈소스,기술","slug":"CS/오픈소스-기술","permalink":"http://KKimSangHeon.github.io/categories/CS/오픈소스-기술/"}],"tags":[{"name":"Streamset","slug":"Streamset","permalink":"http://KKimSangHeon.github.io/tags/Streamset/"}]},{"title":"5.빈의 스코프","slug":"spring","date":"2020-01-13T12:27:57.000Z","updated":"2020-01-13T13:17:57.374Z","comments":true,"path":"2020/01/13/spring/","link":"","permalink":"http://KKimSangHeon.github.io/2020/01/13/spring/","excerpt":"","text":"앞에까지는 아무 설정도 하지 않은 싱글톤 스코프의 빈을 사용하였다.(강사님은 싱글톤 스코프 외에는 사용할 일이 거의 없을거라 하심.) 싱글톤 스코프싱글톤 스코프 : 어플리케이션에 걸쳐 인스턴스가 하나뿐!어플리케이션 콘텍스트를 만들 때 만들어진다. 즉 어플리케이션 구동 시 시간이 길어질 수 있다. 12345678910111213141516@Componentpublic class Proto &#123; @Autowired Single single;&#125;@Componentpublic class Single &#123; @Autowired Proto proto; public Proto getProto() &#123; return proto; &#125; &#125; 프로토타입 스코프프로토타입 스코프 : 매번 새로운 인스턴스를 만드는 스코프@Scope(“prototype”) 를 붙여주면 된다. 12345@Component @Scope(&quot;prototype&quot;)public class Proto &#123; @Autowired Single single;&#125; 위 처럼 프로토 타입 빈이 싱글톤 빈을 참조하면 문제가 없다(프로토타입의 빈은 매번 새롭겠지만 프로토타입의 빈은 동일 한 것) 하지만 싱글톤 빈이 프로토 타입 빈을 참조하면??12345678910111213141516@Componentpublic class Single &#123; @Autowired private Proto proto; public Proto getProto() &#123; return proto; &#125;&#125;....getBean(Single.class).getProto() ....getBean(Single.class).getProto()....getBean(Single.class).getProto() 마지막 3줄의 Proto 는 모두 동일의도한 바가 아님! 해결방법은?해결방법 1. scoped-proxy1234@Component @Scope(&quot;prototype&quot;, proxyMode = ScopedProxyMode.TARGET_CLASS)public class Proto &#123;&#125; Proto 빈을 클래스기반 프록시로 감싸라프록시로 감싸는 이유 : 다른 빈들이 프로토 빈을 직접 참조하면 안되기 때문에… 직접 쓰면 바궈줄 여지가 없다. cg라이브러리를 활용해 클래스 기반 프록시를 만들어준다. Single 내 Proto의 참조변수는 Proto 클래스를 상속한 Proxy가 주입되게 되는것이다. 해결방법 2.ObjectProvider1번이 어렵고 성능에도 영향을 줄것같다면 이 방법을 쓰자. 하지만 ObjectProvider라는 스프링 코드가 들어가기 때문에 조금 그렇다…. 1234567891011121314@Component @Scope(&quot;prototype&quot;)public class Proto &#123;&#125;@Componentpublic class Single &#123; @Autowired private ObjectProvider&lt;Proto&gt; proto; public Proto getProto() &#123; return proto.getIfAvailable(); &#125;&#125; 싱글톤 객체를 사용할 때 주의해야 할 점123456789@Componentpublic class Single &#123; int counter; ... counter++; //Thread Safe하지 않다.&#125; 참고할것https://en.wikipedia.org/wiki/Proxy_pattern","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Spring","slug":"Web-App/Spring","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://KKimSangHeon.github.io/tags/Spring/"}]},{"title":"Thingsboard","slug":"thingsboard","date":"2020-01-13T11:24:26.000Z","updated":"2020-01-13T12:03:45.548Z","comments":true,"path":"2020/01/13/thingsboard/","link":"","permalink":"http://KKimSangHeon.github.io/2020/01/13/thingsboard/","excerpt":"","text":"Thingsboard 오픈소스 IoT 플랫폼으로서 데이터 수집, 처리, 시각화, 디바이스 관리 기능 등을 제공 클라우드, on-premise 환경에서 손쉬운 설치를 제공하며 데이터 유실이 없음 (한 노드가 죽었을 때 downtime 없이 대체 가능) Multi-tenancy 구조 Downtime 없는 Scale Out 가능 SQL / NoSQL / SQL + NoSQL 사용 가능 가격정책 사용 환경에 따른 다양한 가격정책이 존재. 영구사용의 경우 2999$ Use Case 제공 설치환경 다양한 플랫폼에서 설치를 지원하므로 on premise 혹은 cloud 환경에 손쉽게 설치 가능. Multi-tenancyThingsBoard의 유저 구분 System Administrator Tenant Administrator Customer Asset 논리적 구성단위인 Asset Asset과 Device를 계층 형태(Contain, Manage), 즉 상위/하위 개념으로 구성가능 Device, Asset에 속성 정보 지정가능 속성정보 활용예 Device의 속성정보에 위경도를 지정해 지도상에 표시 가능 Multi-tenancy &amp; Asset의 활용예 System Administrator의 역할 IoT 플랫폼을 사용할 Tenant 관리 위젯관리 보안설정 Security Setting 내 항목 최대 로그인 시도횟수, 계정이 잠기게 될 경우 메일을 수신할 주소 설정 최소 패스워드 길이 설정 최소 소문자/대문자/숫자/특수문자 의 수 설정 패스워드 유지 기간 설정 Tenant Administrator의 역할 디바이스, 룰, 대시보드, 위젯 등을 관리하며 Customer 가 각종 정보를 확인할 수 있도록 권한을 부여 함. 기능 정리","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"오픈소스,기술","slug":"CS/오픈소스-기술","permalink":"http://KKimSangHeon.github.io/categories/CS/오픈소스-기술/"}],"tags":[{"name":"Streamset","slug":"Streamset","permalink":"http://KKimSangHeon.github.io/tags/Streamset/"}]},{"title":"20200112 돈의문마을","slug":"photography","date":"2020-01-12T13:51:39.000Z","updated":"2020-01-12T14:01:45.382Z","comments":true,"path":"2020/01/12/photography/","link":"","permalink":"http://KKimSangHeon.github.io/2020/01/12/photography/","excerpt":"","text":"출사 소모임 두번째 활동","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"Photograph","slug":"About-Me/Photograph","permalink":"http://KKimSangHeon.github.io/categories/About-Me/Photograph/"}],"tags":[{"name":"Photograph","slug":"Photograph","permalink":"http://KKimSangHeon.github.io/tags/Photograph/"}]},{"title":"4.@Component와 컴포넌트스캔","slug":"spring","date":"2020-01-10T10:02:18.000Z","updated":"2020-01-10T11:00:14.702Z","comments":true,"path":"2020/01/10/spring/","link":"","permalink":"http://KKimSangHeon.github.io/2020/01/10/spring/","excerpt":"","text":"@Component와 컴포넌트스캔@ComponentScanSpringBootApplication이 @ComponentScan을 갖고있는데 @ComponentScan으로 인해 @Service @Repository @Controller @Configuration를 붙이면 빈으로 등록되게 해준것이다.(@Service/ @Repository/ @Controller/ @Configuration 은 내부적으로 @Component 를 갖고있다) ComponentScan은 basePackagesClasses로 값을 주면 스캔을 해서 빈을 생성하게 된다. 즉 @SpringBootApplication이 어플리케이션 클래스에 붙어있을 경우 해당패키지에 대해 컴포넌트 스캔을 하게된다.(타 패키지는 스캔을 하지않음) 컴포넌트 스캔을 한다고 해서 모든것을 빈으로 생성해주진 않는다. @Filter 으로 원하지 않는것에 대해 거를 수 있다. 빈 주입이 잘안될땐 컴포넌트 스캔의 범위를 잘 생각해보자 요약하면 @Component스캔은 basePackagesClasses / @Filter 만 기억하자! 빈이 많을경우 어플리케이션을 실행할 때 구동시간이 오래걸릴 수 있다. 구동시간이 오래걸려서 싫을 때는 펑션을 사용한 빈 등록을 고려해보자(Spring 5부터 지원) 펑션을 사용한 빈 등록12345678MyBean 클래스는 @ComponentScan의 basePackagesClasses 범위 밖이다. MyBean은 @Service 없어도 됨.public static void main(String[] args) &#123; new SpringApplicationBuilder().sources(Demospring51Application.class) .initializers((ApplicationContextInitializer&lt;GenericApplicationContext&gt;)applicationContext -&gt; &#123; applicationContext.registerBean(MyBean.class); &#125;).run(args);&#125; 위를 할경우 빈을 생성할 때 자신의 코드를 추가할 수 있고 구동시간의 이점이 있다. ComponentScan의 동작 원리BeanPostProcessor이 아닌 BeanFactoryPostProcessor를 구현한 ConfigurationClassPostProcessor와 연결되어 있다.BeanFactoryPostProcessor은 BeanPostProcessor와 비슷한데 실행되는 시점이 다름. 다른 모든 빈들이 만들어지기 전에 적용해준다.다른빈들이 모두 등록되기전에 컴포넌트 스캔을 해서 빈을 등록해준다.여기서 다른빈이란 펑션을 사용한 빈 등록 등등… 참고사항펑션을 사용한 빈등록, @Bean 을 통해 빈을 등록하는 방법은 @ComponentScan을 나오게한 원인(많은 빈을 수동으로 등록하는 불편함)을 다시 야기하므로@ComponentScan외의 것들을 사용하여 빈을 등록할 때는 잘생각해보자.","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Spring","slug":"Web-App/Spring","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://KKimSangHeon.github.io/tags/Spring/"}]},{"title":"StreamSets의 에러처리","slug":"streamset","date":"2020-01-09T12:59:00.000Z","updated":"2020-01-09T13:03:39.876Z","comments":true,"path":"2020/01/09/streamset/","link":"","permalink":"http://KKimSangHeon.github.io/2020/01/09/streamset/","excerpt":"","text":"에러 처리는 Stage(Origin, Processor, Destination, Executor) 관점, 파이프라인 관점에서 처리방법이 존재 Stage(Origin, Processor, Destination, Executor) 관점Discard , Send to Error, Stop Pipeline 파이프라인 관점Discard, Send Response to Origin, Write to Another Pipeline, Write to Elasticsearch/File/Kafka … 위 그림은 파이프라인을 총 2개 생성한 상황이다. 카프카 컨슘 파이프라인에서 에러가 발생할 경우 SDC RPC를 통해 다른 파이프라인으로 에러내용을 전달하도록 하였고 에러처리 파이프라인에서는 RPC로 받은 에러데이터를 Email로 보내고 Local 파일로 저장하는 상황이다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"오픈소스,기술","slug":"CS/오픈소스-기술","permalink":"http://KKimSangHeon.github.io/categories/CS/오픈소스-기술/"}],"tags":[{"name":"Streamset","slug":"Streamset","permalink":"http://KKimSangHeon.github.io/tags/Streamset/"}]},{"title":"object","slug":"object","date":"2020-01-09T12:57:06.000Z","updated":"2020-01-13T11:17:45.725Z","comments":true,"path":"2020/01/09/object/","link":"","permalink":"http://KKimSangHeon.github.io/2020/01/09/object/","excerpt":"","text":"오브젝트 9장OCP - 추상화에 의존하여 컴파일 타임의존성은 유지하면서 런타임 의존성의 가능성을 확장하고 수정할 수 있는 구조. 객체 생성,사용자 분리 - 동일 클래스 안에서 객체 생성과 사용이라는 두가지 이질적인 목적을 가진 코드가 공존할 경우 부적절.(Movie에게 금액할인정책을 적용할지, 비율할인 정책을 적용할지 알고 있는것은 그 시점에 Movie와 협력할 클라이언트이므로 클라이언트가 할인정책을 생성하고 Movie는 추상화된 메소드를 사용하여 구현) FACTORY - 생성과 사용을 분리하기 위해 객체생성에 특화된 객체 표현적 분해 - 도메인에 존재하는 사물 또는 개념을 표현하는 객체들을 이용해 시스템 분해 PURE FABRICATION - 특정 책임을 할당하기 위해 Information expert를 찾아봤는데 없을 경우 도메인 모델에 속하지 않는 Factory를 활용. 보통 행위적 분해로 인해 생성되는것이 대부분 의존성주입 - 생성자 주입, setter주입, 메서드 주입(주입인가에 대한 논란이 있다) SERVICE LOCATOR 패턴 - 저장소(Storage.AmountDiscountPolicy)를 통해 의존성 해결하는 패턴 (가장널리 쓰임 - 그렇지만 비추함) 의존성역전원칙 - 상위 모듈, 하위모듈 둘 다 추상화에 의존하라(과거 패러다임은 상위가 하위에 의존) SEPARATED INTERFACE 패턴 - 추상화(인터페이스 등)를 별도의 패키지가 아닌 클라이언트가 속한 패키지에 포함시켜라 오브젝트 10장ㅇ상속을 위한 경고- 자식 클래스의 메소드 아넹서 super 참조를 이용해 부모클래스의 메소드를 호출할 경우 두 클래스는 강하게 결합된다. super호출을 제거 할 수읶는 방법을 찾아라 경고2 상속받은 부모 클래스의 메소드가 자식 클래스의 내부 구조에 대한 규칙을 깨뜨릴수있다ex 스택 add(0,”data”) 으로 맨앞에 넣는것… 경고3 자식 클래스가 부모 클래스의 메소드를 오버라이딩 할 경우 부모클래스가 자신의 메소드를 사용하는 방법에 클래스가 결합될 수 있다 경고4 클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수 밖에 없다 취약한 기반 클래스문제- 자식클래스가 부모 클래스의 뱐경에 취약해지는 현상","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"OOP","slug":"CS/OOP","permalink":"http://KKimSangHeon.github.io/categories/CS/OOP/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://KKimSangHeon.github.io/tags/OOP/"}]},{"title":"3.@Autowired","slug":"spring","date":"2020-01-08T12:48:13.000Z","updated":"2020-01-10T10:03:25.470Z","comments":true,"path":"2020/01/08/spring/","link":"","permalink":"http://KKimSangHeon.github.io/2020/01/08/spring/","excerpt":"","text":"@Autowired필요한 의존 객체의 “타입”에 해당하는 빈을 찾아 주입한다. 생성자, 세터, 필드에 사용가능하다 아래 예시를 참고하자. BookService의 생성자에 Autowired를 달았다. 잘동작할것이다.1234567891011121314@Servicepublic class BookService &#123; BookRepository bookRepository; @Autowired public BookService(BookRepository bookRepository) &#123; this.bookRepository = bookRepository; &#125; &#125;///////////////////////////////////@Repositorypublic class BookRepository&#123;&#125; 이번에는 세터에다 Autowired를 달아주고 @Repository를 지워보자. 1234567891011121314@Servicepublic class BookService &#123; BookRepository bookRepository; @Autowired public void setBookRepository(BookRepository bookRepository) &#123; this.bookRepository = bookRepository; &#125; &#125;///////////////////////////////////public class BookRepository&#123;&#125; 위는 실패하는데 왜 실패할까단순 세터에 Autowired만 붙였으므로 인스턴스 생성은 되어야 하는거아녀? Autowired가 있기때문에 의존성 주입을 시도하게되고 이로 인해 실패한다. 실패를 벗어나기 위해서는 @Autowired(require = false)로 해결할 수 있다. 즉 생성자가 아닌곳에 붙은 @Autowird는 require = false 옵션을 적절히 활용할 수 있다.(생성자에 Autowired(required = false) 가 붙어있으면 객체 자체 생성이 불가능하므로 생성자에는 부적절) 해당 타입의 빈이 여러개인 경우1234567891011121314151617181920interface A &#123; ..&#125;@Repositoryclass BRepository implements ARepository &#123; ..&#125;@Repositoryclass CRepository implements ARepository &#123; ..&#125;@servicepublic class AService &#123; @Autowired ARepository aRepository;&#125; AService의 aRepository에는 누가 주입될까?내가 어떤걸 원하는지 스프링은 모르기 때문에 에러가 발생한다. 해결방법은? @Primary 어노테이션 붙이기 (추천)1234@Repository @Primaryclass CRepository implements ARepository &#123; ..&#125; 위처럼 할경우 CRepository가 주입된다. Qualifier 활용12345@servicepublic class AService &#123; @Autowired @Qualifier(&quot;cRepository&quot;) ARepository aRepository;&#125; 위처럼 할경우 CRepository가 주입된다. 해당 타입의 빈 모두 주입받기12345@servicepublic class AService &#123; @Autowired List&lt;ARepository&gt; aRepository;&#125; 리스트에 BRepository , CRepository가 들어간다. 추천하진 않지만 알고만 있어라12345@servicepublic class AService &#123; @Autowired ARepository cRepository;&#125; Autowired는 타입만 보는것이 아니라 이름도 한번 보기때문에 위처럼 할 경우 cRepository를 주입받을 수 있다. 동작원리는?BeanPostProcessor새로 만든 빈 인스턴스를 수정할 수 있도록 도와주는 인터페이스이다. AutowiredAnnotationBeanPostProcessor​ extends BeanPostProcessor위에 보다시피 AutowiredAnnotationBeanPostProcessor​가 BeanPostProcessor을 상속하여 사용하는데 초기화 이전에 @Autowired같은 어노테이션을 찾아 주입을 해준다. 이제 동작원리 설명ApplicationContext (BeanFactory)가 BeanPostProcessor을 구현한 빈을 찾고 AutowiredAnnotationBeanPostProcessor를 찾아 일반적인 빈들에게 해당 로직을 적용하는것이다.(결국 AutowiredAnnotationBeanPostProcessor​도 빈으로 등록되어있다는것)(ApplicationContext는 빈 들을 갖고있다)","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Spring","slug":"Web-App/Spring","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://KKimSangHeon.github.io/tags/Spring/"}]},{"title":"2.스프링  ApplicationContext와 다양한 빈 설정 방법","slug":"spring","date":"2020-01-07T12:26:10.000Z","updated":"2020-01-08T12:51:34.926Z","comments":true,"path":"2020/01/07/spring/","link":"","permalink":"http://KKimSangHeon.github.io/2020/01/07/spring/","excerpt":"","text":"고전적인 빈 생성방법application.xml의 등장리소스에 application.xml을 생성하고 안에 을 생성한다1234567&lt;beans .....&gt; &lt;bean id=&quot;bookService&quot; class=&quot;xxxxxx&quot; &gt; &lt;property name=&quot;bookRepository&quot; ref=&quot;bookRepository&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;bookRepository&quot; class=&quot;bookRepository&quot;/&gt;&lt;/beans&gt; 해당 방법은 번거롭다! 그래서 등장한것이 바로 컴포넌트 스캔 component-scan의 등장1234&lt;beans ...&gt; &lt;context:component-scan base-package=&quot;xxxxxxxx&quot;/&gt;&lt;/beans&gt; 이 경우 @Componet라는 어노테이션을 클래스 위에 붙여줌으로써 빈을 생성할 수 있다. 위의 두 경우(xml로 빈생성) ClassPathXmlApplicationContext 클래스를 통해 ApplicationContext 인스턴스를 생성한다. 빈을 xml말고 자바로 빈을생성 할 수 없을까? 있다 ApplicationConfig 자바로 빈생성 할래 . ApplicationConfig1234567891011121314151617181920212223242526272829@Configurationpublic class ApplicationConfig&#123; @Bean public BookRepository bookRepository() &#123; return new BookRepository(); &#125; @Bean public BookService bookService()&#123; BookService bookService = new BookService(); bookService.setBookRepository(bookRepository()); return bookService; &#125; 위 메소드는 아래 메소드와 동일 @Bean public BookService bookService(BookRepository bookRepository)&#123; BookService bookService = new BookService(); bookService.setBookRepository(bookRepository); return bookService; &#125; 두번째 것을 아래 메소드로 할 경우 BookService내 bookRepository에 Autowired를 넣어주면 주입이 된다. //생성자로 주입받아야 할 경우에는 Autowired로 어떻게 할 수 가 없다. @Bean public BookService bookService()&#123; return new BookService(); &#125;&#125; 자바로 할 땐 오히려 xml보다 불편한다 다른 편한방법없나? 있다ComponentScan 어노테이션 좀더 편하게 자바로 빈생성할래 @ComponentScan123456@Configuration@ComponentScan(basePackageClasses = XXX.class)//XXX 클래스가 위치한 곳부터 스캐닝을 함public class ApplicationConfig&#123;&#125; @SpringBootApplication위의 과정을 하나의 어노테이션으로 해결해주는 어노테이션이 바로 @SpringBootApplication 이다. 위의 두 경우(java로 빈생성) AnnotationConfigApplicationContext 클래스를 통해 ApplicationContext 인스턴스를 생성한다.","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Spring","slug":"Web-App/Spring","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://KKimSangHeon.github.io/tags/Spring/"}]},{"title":"StreamSets 이란","slug":"streamsets4","date":"2020-01-07T11:25:56.000Z","updated":"2020-01-07T12:09:34.525Z","comments":true,"path":"2020/01/07/streamsets4/","link":"","permalink":"http://KKimSangHeon.github.io/2020/01/07/streamsets4/","excerpt":"","text":"StreamSets란?데이터 흐름을 관리할 수 있으며 Data drift에 유연하게 대처가능한 솔루션 StreamSets 활용 및 장점 요약글로벌 社에서 StreamSets을 Data Lakes, Big Data/Hadoop Ingestion, Event Streaming, IoT/edge device integration 등 용도로 사용중. 데이터센터, AWS, GCP 등에 배포 가능하며 YARN, MESOS, Kubernetes을 활용한 스케일링 가능. 처리량, 지연, 에러율 등을 UI로 확인할 수 있음. 민감한 데이터를 보호할 수 있음. StreamSets의 개발, 운영, Agility 측면의 장점개발자 생산성 측면 코드작성의 최소화, 자동 인스턴스 관리, 파이프라인 로직의 재활용 가능 운영효율 측면 파이프라인 시각화, 파이프라인 성능 모니터링, 이벤트에 대한 동작설정 가능 Agility 측면 Downtime 없는 파이프라인 내 데이터 시스템 업데이트, 데이터 변경 시 자동탐지 및 동기화, 버전 별 파이프라인의 성능 비교 가능 StreamSets Data Collector 위의 화면에서 드래그앤드롭 방식으로 데이터 flow를 파이프라인으로 생성 및 관리 가능 파이프라인은 Origin/Processor/Destination/Executor 로 구성된다. Origin 파이프라인의 시작점을 의미하며 파이프라인 내 하나만 생성할 수 있다. Kafka / Redis / GCP / TCP / UDP 를 포함한 약 60여개를 data 근원지로 활용가능 Processor 데이터 처리, 가공 Stream Selector / JSON Parser / Jython Evaluator / Field Masker 를 포함한 약 50여개 기능 제공 Destination 파이프라인의 목적지 Hbase / Local file / Redis / DB 를 포함한 50여개를 data 목적지로 활용가능 Executor 이벤트를 수신했을 때 동작 정의 Email Executor / Shell Executor / JDBC Query Executor 를 포함한 약 10여개 기능 제공 세부지원 요소 확인하기https://streamsets.com/documentation/datacollector/latest/help/datacollector/UserGuide/Processors/Processors_overview.html#concept_hpr_twm_jqhttps://streamsets.com/documentation/datacollector/latest/help/datacollector/UserGuide/Executors/Executors-title.html","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"오픈소스,기술","slug":"CS/오픈소스-기술","permalink":"http://KKimSangHeon.github.io/categories/CS/오픈소스-기술/"}],"tags":[{"name":"Streamset","slug":"Streamset","permalink":"http://KKimSangHeon.github.io/tags/Streamset/"}]},{"title":"StreamSets Data Collector의 클러스터링 방법","slug":"streamsets3","date":"2020-01-07T11:22:41.000Z","updated":"2020-01-07T11:25:11.110Z","comments":true,"path":"2020/01/07/streamsets3/","link":"","permalink":"http://KKimSangHeon.github.io/2020/01/07/streamsets3/","excerpt":"","text":"https://streamsets.com/blog/five-ways-scale-kafka-streamsets/ 1.Vertical Scaling – Deploy a Bigger Box가장 간단한 방법으로 여러개의 컨슈머 스레드를 생성하는 방법컨슈머 스레드를 병렬로 실행하게 됨서버가 죽으면 당연히 데이터 flow 또한 죽게됨. 카프카 관련지식으로 스레드는 카프카의 파티션의 수 보다 작아도 된다. Horizontal Scaling – Deploy More Boxes2.Manually Run Multiple Data Collectors수동으로 여러 인스턴스를 생성 후 각 인스턴스에서 파이프라인을 돌리는것이다.이방법의 경우 간단한 방법이지만 수동으로 각 인스턴스의 파이프라인을 제어해야 하기 때문에 운영자가 번거로울 수 있다. 장점하나의 인스턴스가 죽게될 경우 카프카는 해당 파티션을 나머지 인스턴스에 할당하기 때문에 데이터 흐름을 유지할 수 있다. 1.Vertical Scaling – Deploy a Bigger Box 와의 차이는 인스턴스의 수 3. Run the Pipeline in Cluster Streaming Mode분산 컴퓨팅 환경을 제공하는 YARN(Yet Another Resource Negotiator) 혹은 아파치 Mesos cluster 를 사용했다면 Data Collector’s Cluster Streaming mode를 사용하는것이 좋다.파이프라인의 실행모드를 ‘Cluster YARN Streaming’ or ‘Cluster Mesos Streaming’로 설정하고 카프카 consumer을 생성하면 카프카 토픽에 부여된 파티션만큼의 노드를 요청하게 된다. 장점운영자가 파이프라인을 수동으로 여러개 생성할 필요가 없으며 클러스터 플랫폼(YARN or Mesos )이 스케일링을 관장한다파티션 수가 변경되면 파이프라인을 재시작 하면된다.또한 YARN의 경우 노드장애가 발생할경우 클러스터 플랫폼이 알아서 다시시작해준다. 4.Use StreamSets Control Hub to Start Multiple Pipeline Instances ( 유료 )YARN이나 Mesos를 사용하지 않지만 Data Collector의 인스턴스를 자동으로 관리하고 싶을 때 StreamSets Control Hub를 사용할 수 있다.StreamSets Control Hub를 사용하면 UI에서 Data Collector의 인스턴스, 파이프라인을 관리할 수 있다. 장점인스턴스 관리 설정만 해두면 알아서 해줌한 인스턴스가 오프라인이 되면 다른 인스턴스로 스스로 대체한다. 5.Use StreamSets Control Hub with Kubernetes to Start Multiple Data Collector Containers On Demand (유료)쿠버네티스 클러스터를 사용한다면 Control Hub’s Kubernetes Control Agent를 사용할 수 있다.Google Kubernetes Engine 또는 Azure Kubernetes Service 에서도 사용 가능하며 데이터 센터에도 배포가 가능하다.YARN or Mesos 보다 유연한 클러스터링 환경을 제공한다. 장점Control Agent는 Control Hub와 통신하여 실행중인 Kubernetes 클러스터에서 Data Collector 컨테이너를 자동으로 프로비저닝합니다.프로비저닝(deploying, registering, starting, scaling, and stopping the Data Collector containers) Cluster Streaming Mode vs StreamSets Control HubYARN이나 Mesos를 사용하지 않지만 Data Collector의 인스턴스를 수동으로 관리하고 싶지 않을 때 StreamSets Control Hub를 사용할 수 있다. Control Hub는 Cluster Streaming Mode와 유사한 자동화 기능을 제공하지만 파이프 라인을 실행할 할 수 있는 Data Collector 인스턴스가 요구됨 Control Hub는 Data Collector 인스턴스의 모니터링, 하나의 인스턴스가 죽었을 때 대체하는 기능등을 제공한다.Control Hub는 자체적인 통계기능을 제공함, 파이프라인 커밋 히스토리를 볼 수 있다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"오픈소스,기술","slug":"CS/오픈소스-기술","permalink":"http://KKimSangHeon.github.io/categories/CS/오픈소스-기술/"}],"tags":[{"name":"Streamset","slug":"Streamset","permalink":"http://KKimSangHeon.github.io/tags/Streamset/"}]},{"title":"StreamSets 과거 라이브러리 추가하기","slug":"streamset2","date":"2020-01-07T11:19:02.000Z","updated":"2020-01-08T12:09:17.794Z","comments":true,"path":"2020/01/07/streamset2/","link":"","permalink":"http://KKimSangHeon.github.io/2020/01/07/streamset2/","excerpt":"","text":"StreamSet 과거 라이브러리 추가하기Origin, Destination의 과거버전 지원하도록 라이브러리 추가 상황카프카 0.8버전을 사용해야 하는데 스트림셋에서는 0.10 부터 지원하는 상황이었다. 찾아보니 해결방법은 있다. 해결방법123456789101112131415161718192021222324252627https://archives.streamsets.com/index.html 에 접속하여 LegacyLibs를 검색 후 자신의 스트림셋에 맞는 것을 찾아 들어가자그 후 자신이 받을 라이브러리의 링크복사.# wget https://archives.streamsets.com/datacollector/3.12.0/legacy/streamsets-datacollector-apache-kafka_0_8_2-lib-3.12.0.tgz스트림셋 경로 혹은 추가 라이브러리를 저장할 디렉토리에 들어간 후 wget 명령어를 통해 해당 파일을 다운받고# tar -xvzf streamsets-datacollector-apache-kafka_0_8_2-lib-3.12.0.tgz해당 라이브러리가 저장된 디렉토리를 복사# cd streamsets-datacollector-3.11.0/libexec스트림셋이 설치된 디렉토리 내 libexec디렉토리# vi sdc-env.sh맨아래 다음을 추가export USER_LIBRARIES_DIR=&quot;아까 설치한 라이브러리가 저장된 경로 복붙&quot;# vi $SDC_CONF/sdc-security.policy나의경우 SDC_CONF는 /etc/sdc이다.맨아래 다음을 추가하자 &quot;file:/&quot; 뒤에는 라이브러리가 설치된 경로grant codebase &quot;file:///home/tkdgjs1501/streamsets-datacollector-3.11.0/user-libs/-&quot; &#123; permission java.security.AllPermission;&#125;;스트림셋 리스타트 참고https://streamsets.com/documentation/datacollector/3.4.2/help/datacollector/UserGuide/Installation/AddtionalStageLibs.htmlhttps://streamsets.com/documentation/datacollector/3.4.2/help/datacollector/UserGuide/Configuration/CustomStageLibraries.html#concept_pmc_jk1_1x","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"오픈소스,기술","slug":"CS/오픈소스-기술","permalink":"http://KKimSangHeon.github.io/categories/CS/오픈소스-기술/"}],"tags":[{"name":"Streamset","slug":"Streamset","permalink":"http://KKimSangHeon.github.io/tags/Streamset/"}]},{"title":"Aggregation vs Composition","slug":"aggregationvscomposition","date":"2020-01-07T10:58:19.000Z","updated":"2020-01-07T11:17:42.120Z","comments":true,"path":"2020/01/07/aggregationvscomposition/","link":"","permalink":"http://KKimSangHeon.github.io/2020/01/07/aggregationvscomposition/","excerpt":"","text":"다양한 책에서 볼 수 있는 Aggregation, Composition.같은듯 다른 두개의 차이를 공부해봤다. Composition123456789101112public class Car &#123; //final will make sure engine is initialized private final Engine engine; public Car()&#123; engine = new Engine(); &#125;&#125;class Engine &#123; private String type;&#125; 위와같이 차는 엔진을 갖고있는 것이기 때문에 변수로 엔진을 갖고있다. Aggregation12345678public class Organization &#123; private List employees;&#125;public class Person &#123; private String name; &#125; 조직은 Employees 들의 리스트를 갖고(Composition)있다. 해당 Epmloyees들은 Person들이다. 회사가 없어지더라도 Person 들은 그대로 유지된다. 핵심은 다음 두줄이다!A “owns” B = Composition : B has no meaning or purpose in the system without AA “uses” B = Aggregation : B exists independently (conceptually) from A 연관해서 생각해보면 좋을 주제 (오브젝트 8장)new 키워드를 사용할 경우 생성자의 모든 인자와 순서를 알아야 하고 인자로 사용되는 구체 클래스에 대해서도 의존성을 늘리게 된다,그러므로 new 키워드를 사용하기 보다는 setter, 생성자 를 통해 주입받는것이 좋다. (좋은 방법은 생성자로 주입받고 setter로 변경가능토록 하는것)new를 생성해도 좋을때는 해당클래스가 변경될 확률이 거의 없을 때 이다(ex. ArrayList, Data 클래스 등) 참고 : https://javarevisited.blogspot.com/2014/02/ifference-between-association-vs-composition-vs-aggregation.html오브젝트 도서","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"OOP","slug":"CS/OOP","permalink":"http://KKimSangHeon.github.io/categories/CS/OOP/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://KKimSangHeon.github.io/tags/OOP/"}]},{"title":"1.스프링 IoC 컨테이너와 빈","slug":"spring1","date":"2020-01-06T12:50:41.000Z","updated":"2020-01-08T12:51:34.030Z","comments":true,"path":"2020/01/06/spring1/","link":"","permalink":"http://KKimSangHeon.github.io/2020/01/06/spring1/","excerpt":"","text":"스프링 부트를 통해 학습하면서 스프링을 공부해 보겠다 스프링의 역사 스프링은 2003년에 등장하였다. 자바EE와 싸우는 경쟁관계처럼 보이지만 실상은 자바 EE를 많이 호환한다. 스프링 5부터 리액티브 프로그래밍을 지원함 스프링의 디자인 철학 다양한 관점 지향 하위호환성 준수 API 설계의 신중성 높은 수준의 코드 스프링 IoC(Inversion of Control)컨테이너의존 객체를 객체를 직접 직접 만들어 만들어 사용하는게 사용하는게 아니라 아니라, 주입 주입 받아 받아 사용하는 사용하는 방법​ 방법​을 말 함. Service, Autowired, Repository 스프링 초기에는 xml 로 빈을 설정하였지만 이후에는 어노테이션 기반으로 인젝션을 지원한다. 빈으로 등록되어있는것들을 Autowired같은 것들로 인젝션 받을 수 있다. 스프링 IoC 컨테이너의 최상위 인터페이스는 BeanFacotry인데 이것이 IoC의 핵심이다. 스프링 빈스프링 IoC컨테이너가 관리하는 객체 Service, Repository 등의 어노테이션이 붙어있는 클래스 등이며 의존성 주입(Autowired)을 받기위해서는 이는 빈으로 등록되어있어야 함. 싱글톤으로 관리하고 싶을 때 IoC컨테이너로 만들면 된다.장점 싱글톤이기 때문에 비용이 절약된다. 라이프사이클 인터페이스를 지원한다. ex(PostConstruct 어노테이션을 활용해 부가적인 작업 가능)싱글톤 : 하나만 만들어서 사용프로토타입 : 매번 다른객체 when(bookRepository.save(book)).theReturn(book)save라는 메소드를 호출할 때 book이 들어오면 book를 리턴하라. ApplicationContext 또한 빈 팩토리의 하위이다. 메시지 소스처리(i18n 이라 하며 다국어 기능이라 보면 된다.) 리소스 로딩등","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Spring","slug":"Web-App/Spring","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://KKimSangHeon.github.io/tags/Spring/"}]},{"title":"20200101 양재천","slug":"photography","date":"2020-01-01T12:29:33.000Z","updated":"2020-01-12T13:53:29.617Z","comments":true,"path":"2020/01/01/photography/","link":"","permalink":"http://KKimSangHeon.github.io/2020/01/01/photography/","excerpt":"","text":"집 앞 양재천 산책","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"Photograph","slug":"About-Me/Photograph","permalink":"http://KKimSangHeon.github.io/categories/About-Me/Photograph/"}],"tags":[{"name":"Photograph","slug":"Photograph","permalink":"http://KKimSangHeon.github.io/tags/Photograph/"}]},{"title":"20191229 판교","slug":"photography","date":"2019-12-29T04:42:02.000Z","updated":"2020-01-12T13:53:26.568Z","comments":true,"path":"2019/12/29/photography/","link":"","permalink":"http://KKimSangHeon.github.io/2019/12/29/photography/","excerpt":"","text":"오후 반차쓴 날 현석이형 집들이 가기전에 판교에서","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"Photograph","slug":"About-Me/Photograph","permalink":"http://KKimSangHeon.github.io/categories/About-Me/Photograph/"}],"tags":[{"name":"Photograph","slug":"Photograph","permalink":"http://KKimSangHeon.github.io/tags/Photograph/"}]},{"title":"Centos에서 kafka 설치 및 테스트","slug":"kafka","date":"2019-12-26T12:11:45.000Z","updated":"2019-12-26T12:19:44.590Z","comments":true,"path":"2019/12/26/kafka/","link":"","permalink":"http://KKimSangHeon.github.io/2019/12/26/kafka/","excerpt":"","text":"카프카 설치법12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# yum install java-1.8.0-openjdk.x86_64# vi /etc/profile profile 파일 안에 아래의 내용을 추가export JAVA_HOME=/usr/lib/jvm/jre-1.8.0-openjdkexport JRE_HOME=/usr/lib/jvm/jresource 명령어를 이용해서 변경된 내용 적용# source /etc/profile# yum install -y wget# wget http://www-us.apache.org/dist/kafka/2.3.0/kafka_2.11-2.3.0.tgz# tar xvf kafka_2.11-2.3.0.tgz# mv kafka_2.11-2.3.0 /opt# cd /opt/kafka_2.11-2.3.0/# vi conifg/server.properties아래 두줄 추가port = 9092advertised.host.name = localhost (서버주소를 입력하는것인데 vm상에서 띄울때는 서버가 될 주소 입력)서버 시작# ./bin/zookeeper-server-start.sh -daemon config/zookeeper.properties# ./bin/kafka-server-start.sh -daemon config/server.properties토픽 생성./bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test토픽 조회# ./bin/kafka-topics.sh --list --zookeeper localhost:2181Producer# ./bin/kafka-console-producer.sh --broker-list localhost:9092 --topic testConsumer# ./bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning# ./bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic test --from-beginning컨슈머 그룹 확인./kafka-consumer-groups.sh --all-groups --list --bootstrap-server localhost:9092실시간 변화 확인$ watch -d -n 1 &apos;./kafka-consumer-groups.sh --bootstrap-server localhost:9092 --group console-consumer-33229 --describe&apos;","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"오픈소스,기술","slug":"Etc/오픈소스-기술","permalink":"http://KKimSangHeon.github.io/categories/Etc/오픈소스-기술/"}],"tags":[{"name":"Kafka","slug":"Kafka","permalink":"http://KKimSangHeon.github.io/tags/Kafka/"}]},{"title":"Centos에서 Streamset 설치하기","slug":"streamset","date":"2019-12-26T12:11:21.000Z","updated":"2020-01-08T13:43:44.612Z","comments":true,"path":"2019/12/26/streamset/","link":"","permalink":"http://KKimSangHeon.github.io/2019/12/26/streamset/","excerpt":"","text":"StreamSet 설치스트림셋오픈소스 데이터 콜렉터 : ETL 도구라함 (추출, 변환, 적재)동일기종 또는 타기종으로 부터 추출하고, 이를 변환하고 적재하는 과정을 의미NIFI / KNIME도 유명하다 12345678910111213141516171819202122232425262728293031323334353637383940# wget https://archives.streamsets.com/datacollector/3.11.0/tarball/streamsets-datacollector-all-3.11.0.tgz# tar xvf &#123;datacollector&#125;.tar# cd streamsets-datacollector-all-3.11.0// 설정# cp ./etc /tc/sdc -r# cd libexec // 환경변수 세팅하는 디렉# vi sdc-env.sh // 아래 네개항목 주석 해제export SDC_DATA=/var/lib/sdcexport SDC_LOG=/var/log/sdcexport SDC_CONF=/etc/sdcexport SDC_RESOURCES=/var/lib/sdc-resources# cd ..# cd bin# ulimit -n 32768 // 최대 열 수 있는 갯수를 늘려줌# ./streamsets dc# firewall-cmd --zone=public --add-port=18630/tcp --permanent# service sshd startxxx:18630 접속admin/ admin# cd ..# mkdir data# cd data# mkdir BasicTutorial# cd BasicTutorial# mkdir error# mkdir origin // 원천데이터# mkdir destination //최종적으로 변환된 것이 저장된 공간# ./streamsets dc 만약 경로관련 문제로 실행이 안될경우스트림셋 실행하기 전에 아래를 입력하고 ./streamsets dc 해볼것1234export SDC_CONF=/etc/sdcexport SDC_DATA=/var/lib/sdcexport SDC_LOG=/var/log/sdcexport SDC_HOME=/opt/streamsets-datacollector 백그라운드로 돌리기 위해선 아래를 입력nohup ./streamset dc &amp;","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"오픈소스,기술","slug":"CS/오픈소스-기술","permalink":"http://KKimSangHeon.github.io/categories/CS/오픈소스-기술/"}],"tags":[{"name":"Streamset","slug":"Streamset","permalink":"http://KKimSangHeon.github.io/tags/Streamset/"}]},{"title":"VirtualBox에 Centos Minimal 설치","slug":"centosminimal","date":"2019-12-26T12:10:51.000Z","updated":"2019-12-26T12:20:24.044Z","comments":true,"path":"2019/12/26/centosminimal/","link":"","permalink":"http://KKimSangHeon.github.io/2019/12/26/centosminimal/","excerpt":"","text":"Centos minimal 설치 및 기본 세팅Virtual Box 이용 12345678910111213141516171819202122$ vi /etc/sysconfig/network-scripts/ifcfg-enp0s3네트워크 설정 파일을 열어 필요한 부분을 수정한다. 단, ifcfg-enp0s3 부분은 장비에 따라 다르게 나올 수 있다.기본적으로 dhcp를 사용하도록 되어 있을텐데 dhcp를 그대로 사용한다면 ONBOOT=no 부분을 ONBOOT=yes으로 바꿔주기만 하면된다. dhcp를 사용하지 않는다면 사용할 IP를 지정한다# service network restart# ip addr# yum install -y openssh-server net-tools# service sshd startRedirecting to /bin/systemctl restart sshd.service# chkconfig sshd on# firewall-cmd --zone=public --add-port=22/tcp --permanent# service sshd start","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"centos","slug":"centos","permalink":"http://KKimSangHeon.github.io/tags/centos/"}]},{"title":"20191222 부산 UFC 관람","slug":"photography6","date":"2019-12-25T14:01:35.000Z","updated":"2020-01-12T13:53:16.064Z","comments":true,"path":"2019/12/25/photography6/","link":"","permalink":"http://KKimSangHeon.github.io/2019/12/25/photography6/","excerpt":"","text":"웅형과 부산 UFC 관람","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"Photograph","slug":"About-Me/Photograph","permalink":"http://KKimSangHeon.github.io/categories/About-Me/Photograph/"}],"tags":[{"name":"Photograph","slug":"Photograph","permalink":"http://KKimSangHeon.github.io/tags/Photograph/"}]},{"title":"20191214 우면산","slug":"photography5","date":"2019-12-25T14:01:30.000Z","updated":"2020-01-12T13:53:19.325Z","comments":true,"path":"2019/12/25/photography5/","link":"","permalink":"http://KKimSangHeon.github.io/2019/12/25/photography5/","excerpt":"","text":"주말에 등산하며","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"Photograph","slug":"About-Me/Photograph","permalink":"http://KKimSangHeon.github.io/categories/About-Me/Photograph/"}],"tags":[{"name":"Photograph","slug":"Photograph","permalink":"http://KKimSangHeon.github.io/tags/Photograph/"}]},{"title":"20191209 우면동 거리","slug":"photography4","date":"2019-12-25T14:01:19.000Z","updated":"2020-01-12T13:53:12.259Z","comments":true,"path":"2019/12/25/photography4/","link":"","permalink":"http://KKimSangHeon.github.io/2019/12/25/photography4/","excerpt":"","text":"야근하는 동기를 기다리며 첫 패닝샷","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"Photograph","slug":"About-Me/Photograph","permalink":"http://KKimSangHeon.github.io/categories/About-Me/Photograph/"}],"tags":[{"name":"Photograph","slug":"Photograph","permalink":"http://KKimSangHeon.github.io/tags/Photograph/"}]},{"title":"20191208 이화마을 낙상공원","slug":"photography3","date":"2019-12-25T13:55:08.000Z","updated":"2020-01-12T13:53:09.395Z","comments":true,"path":"2019/12/25/photography3/","link":"","permalink":"http://KKimSangHeon.github.io/2019/12/25/photography3/","excerpt":"","text":"소모임 가입 후 첫 활동","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"Photograph","slug":"About-Me/Photograph","permalink":"http://KKimSangHeon.github.io/categories/About-Me/Photograph/"}],"tags":[{"name":"Photograph","slug":"Photograph","permalink":"http://KKimSangHeon.github.io/tags/Photograph/"}]},{"title":"20191123 춘천 산토리니","slug":"photography2","date":"2019-12-25T13:55:03.000Z","updated":"2020-01-12T13:53:05.991Z","comments":true,"path":"2019/12/25/photography2/","link":"","permalink":"http://KKimSangHeon.github.io/2019/12/25/photography2/","excerpt":"","text":"갑작스럽게 가게된 춘천","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"Photograph","slug":"About-Me/Photograph","permalink":"http://KKimSangHeon.github.io/categories/About-Me/Photograph/"}],"tags":[{"name":"Photograph","slug":"Photograph","permalink":"http://KKimSangHeon.github.io/tags/Photograph/"}]},{"title":"20191122 양재공원","slug":"photography1","date":"2019-12-25T13:46:14.000Z","updated":"2020-01-12T13:53:02.245Z","comments":true,"path":"2019/12/25/photography1/","link":"","permalink":"http://KKimSangHeon.github.io/2019/12/25/photography1/","excerpt":"","text":"점심시간에 날이 좋아서","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"Photograph","slug":"About-Me/Photograph","permalink":"http://KKimSangHeon.github.io/categories/About-Me/Photograph/"}],"tags":[{"name":"Photograph","slug":"Photograph","permalink":"http://KKimSangHeon.github.io/tags/Photograph/"}]},{"title":"DevGround Junior 2019 내용 요약","slug":"devground1","date":"2019-12-13T00:31:45.000Z","updated":"2019-12-25T13:52:06.581Z","comments":true,"path":"2019/12/13/devground1/","link":"","permalink":"http://KKimSangHeon.github.io/2019/12/13/devground1/","excerpt":"","text":"9 Skill for Developers박종천 상무님 Hard Skills Basic Knowledge(C++, OS) 제품에 대한 이해(제품 분석) 개발 사이클(요구사항/분석, 디자인 모델링, Implementation, Test/Release, Feedback/Update) 계속 잘 해야함 Soft Skills Project Management : 비용(Resources), 시간(Schedule), Scope(Quallity) Team Management : Forming, Storming, Norming, Performing 모든 조직은 해당 네가지를 거치게 된다. Process(Agile, Zero-Bug) : 어떤일을 잘하기 위한것이 아니라 실패하지 않기 위한것. PMMM(Project Management Maturit Model) Business Skills HR System : 잘하는 사람보다 못하는 사람을 안뽑는것 Business Management Vision/Goals/Culture 세상은 배우는 사람, 배우지 않는 사람으로 나뉜다.벤자민 자기관리는 시간관리이다.필요한데 써라낭비 - 최소한으로invest - 극한으로 올려라많은사람을 만나기 위해 이메일을 많이 돌리셨다고 함. AI:막막해하는 당신에게임태규 Motion2AI AI에서 갖가야할 7가지 프로그래밍 언어남의 코드를 얼마나 이해할 수 있는지. 최소한 80%는 이해할 수 있어야 해당 언어를 안다고 할 수 있다. 스킬업을 위해 코드리뷰를 자주해라하나를 깊게 파봐라 Pytorch , 텐서플로우 한번씩 봐두면 좋다 데이터 구조데이터를 어떻게 뽑아쓰고 저장하는지 알아둬야함. 메모리가 적다는 상황이라 가정하고 효율적으로 하는것을 익혀라 전략1알고리즘알고리즘은 외우기 보다는 어떻게 동작하는지 이해를 해라또한 이를 잘 사용할 줄 알아야 한다. 자신만의 라이브러리를 만들어서 활용하는것도 좋다 전략2수학을 공부해라.Linear Algebra, Probability, Geometry는 알아야 한다. Insight를 가져라특정 프로젝트를 했다면 장점,단점,가치를 말할 수 있어야한다. 특정 프로젝트를 했는데 펑션 X에서 문제가 있어서 개선하고 해결했다 프로젝트를 했으면 얻은게 무엇이고 보완할것이 무엇인지 시간, 일아침에 출근하면 30분 단위로 할일을 정한다고 함 일을 할 때 3가지로 분리함해야할 것, 할 수 있는것, 하지말아야 할 것 통찰력을 기르기 위해 책을 많이 읽어라 사소한것에 목숨걸지 말것.자신감은 없어도 자존감은 가득내 자신에게 한 약속은 반드시 지킬 것 개발 분야와 상관없이 알아야 하는 기술 10가지수아랩 이기곤 리드 엔지니어 문자열 인코딩컴퓨터가 문자를 이해할 수 있게 만든 규칙인코딩마다 지원하는 문자의 종류와 문자를 구분하는 체계가 다르다. 아스키 코드 1byteEUC-KR : 한글 숫자 영어 지원UTF-8 : 표준이 된 문자열 인코딩 1~4byteUTF-16 : 자바 윈도우 API에서 UTF-8보다 많이 사용되지 않지만 멀티바이트라고도 부름 고정2byteUTF-32 : 고정된 4byte Base64바이너리 데이터를 아스키코드 기반 문자열로 인코딩하는 방법. (이미지, 텍스트, 동영상 등) 이메일, HTTPbody 등에서 많이 사용된다. OTP가 랜덤하게 생성되는게 바이너리로 나오는데 이를 HTTP로 전달하기 위해서는 Base64로 인코딩 해야한다. 인코딩을 할경우 바이너리에 비해 33% 늘어난다.Base64는 암호화 기법이 아니므로 암호화를 위해 해싱을 해야함 JSON여러 형태의 데이터를 구조화 할 때 사용하는 텍스트 기반 데이터 규격 여러 정보를 하나의 구조체처럼 묶어서 사용하고 싶을 때 사용 json의 장점 : map, list자료구조와 비슷해 다루기 쉽고 텍스트 기반이어서 디버깅하기 쉽다. json의 단점 : 바이너리 기반 규격보다 용량이 더 필요하고, 처리 비용도 크다. 게임, 금융 분야처럼 초당 메시지 처리가 중요한곳에서는 크리티컬할 수 있다. 데이터 규격이 바뀌어도 프로그램에 직접적으로 반영되지 않는다. - 직렬화를 통해 개선 가능 모든 데이터를 직접 가공해야 한다. 알아두면 좋은 내용GraphQL, 직렬화, XML, YAML, Pbu(프로토콜 버퍼) 다국어 처리프로그램을 수정하지 않고 여러 언어를 동시에 지원하는 기술다국어 처리는 1. 리소스파일 2. 언어설정, 3.프로그램 으로 구성된다. 파이썬의 gettext 함수안드로이드에서 프레임웍상에서 제공한다.다국어처리는 프레임워크마다 다르나 i18n이라는 표준이 있다. 언어마다 글자수가 달라 레이아웃이 언어에 따라 꺠질 수 있다. 알아두면 좋은내용i18n, gettext, resx (C#에서 사용됨) 날짜와 시간국가별로 사용하는 표준 시가 다르다. 그래서 사용됨. 이로인해 발생할 수 있는 문제 예방 시간은 단조시간 실제시간으로 구분된다. 타임존- 타임존은 나라마다 다르며 한국가에서 여러 타임 존을 사용하기도 한다.한 시스템을 구성하는 여러 서버간 타임존이 달라지면 문제가 생길 수 있다. 단조시간- 운영체제나 CPU에서 직접 계산하는 시간이다. 실제 시간과는 단위는 같지만 다른 값을 사용한다. 점진적으로 증가한다. 운영체제가 시작하고 종료될때 까지 절대 바뀌지 않는다. 실제시간- 벽시계 시간으로도 부른다. 단조시간과는 다르게 동기로 인해 언제든지 바뀔 수 있다. 컴퓨터의 1초와 실제시간의 1차는 약간의 오차가 있다. 한달이상 걸리는 작업은 실제시간을 사용해야 한다.왜? 한달이라는 기준은 모호하다.(ex 윤년계산 등) 단조시간은짧은시간의 주기로 수행해야 할 때, 특정 작업의 실행 시간을 계산할 때 사용 실제 시간을 사용하는곳어떤 작업을 특정 날짜, 또는 한달 이상 걸리는 주기로 실행해야 할 때단순히 실제 시간을 표시해야 할 떄 날짜를 다룰 때 항상 UTC를 사용하거나 동일한 타임존을 사용해야 한다. 정규표현식주어진 문자열 속에서 특정 패턴을 가진 문자열을 찾을때 사용한다.https://regex101.com 에서 도움받을 수 있다. UUID소프트웨어는 여러 식별자가 필요하다. (유저, 작업, 세션, 아이템 등)식별자를 만들 때 사용되는것으로 4개의 하이픈과 32개의 16진수 문자들로 구성되어있다.v4가 많이 사용되며 v5는 해시 함수와 유사해 대체되었다고 봐도 무관 UUID만으로 정확한 내용을 파악하기 어려우므로 요청ip,주소 메서드 등을 같이출력해야 어떤정보인지 알 수 있다.확률은 낮지만 같은 UUID가 만들어져 충돌이 발생할 때를 염두해 둬야함 난수무작위로 생성된 값을 뜻한다. 많이들 완벽한 난수를 생성할수 없다고 하지만 가능하다고 함 UUID와 비슷하게 사용되기도 함. 유사난수:난수표, 난수 알고리즘, 시드를 합쳐 난수를 생성한다유명한 알고리즘은 mt19937(메르센 트위스터)유사난수는 암호학적으로 안전하지 않다.알고리즘, 시드값을 알고 있다면 동일한 난수를 획득할 수 있다.타임스탬프를 시드로 사용하면 안된다.(예측이 가능하므로) 암호학적으로 안전한 난수하드웨어 난수 생성기로 난수를 만든다. 3배에서 4배정도 유사난수에 비해 느리다.이는 열 잡음, 광 전자 등의 노이즈를 이용해 예측이 불가능하다.인증키 생성, 게임 아이템 및 재화 생성에 사용된다. 해시함수임의의 입력값을 고정된 길이의 값으로 변환하는 함수입력값이 동일하면 해시값도 동일길이는 입력값과 관계없이 동일하다. (알고리즘마다 길이는 다르겠지만 보통 64비트)서로다른 입력값이 같은 해시 값을 만들 확률이 낮다. 해시함수는 해시맵을 만드는데 사용한다.해시맵은 데이터 접근 비용이 O(1)이다. 입력값이 동일하면 해시값도 동일하다. 이를 통해 민감한 데이터의 변조를 막을 수 있다.비밀번호 검증시에 사용할 수 있다. 비밀번호를 해시를 해서 저장한다. 입력값이 동일하면 해시값도 동일하기 떄문에…비밀번호 저장은 암호학적으로 안전한 해시 함수를 사용해야 한다. 해시충돌이 불가능하고 원복이 불가능하도록 실무에서는 비밀번호에 salt값을 넣어 해시를 생성한다. 해시함수의 종류는 MD5, SHA-1은 더이상 사용되지 않으며 SHA-256이상 사용할것을 권장한다. 알아두면 좋은내용SHA-1, SHA-2 HashMap, O(1) HTTP(S)텍스트 기반 통신에 사용하며 오늘날 웹의 기초가 되는 프로토콜이다.상태가 없는 프로토콜로서 요청을 보내기 직전까지 서버가 살아있는지 알 수 없다.요청을 보낼 때 연결을 맺고 응답을 받으면 연결을 끊는다.대부분 1.1버전을 사용하는데 2.0도 꽤 사용된다. 요청하나당 소켓을 열고 닫기때문에 Websocket,HTTP/2기술을 사용해 이를 개선하여 한번열고 계속 사용할 수 있다, 응답성공 200서버이동:300 너는 이서버로 올게 아니라 다른쪽으로 가야해인자실패 400서버내부실패 500 HTTPSHTTP에 TLS암호화 기법을 적용한것.주고받는것을 타인이 볼 수 없다.암호화 수준은 TLS에 따라 달라진다.HTTPS통신을 하려면 서버는 반드시 인증된 제3자가 발급한 인증서가 필요하다. 프론트엔드 개발자라면 Sticky Session(한번 요청으로 계속 보내는것), CORS(도메인이 다를때 브라우저에서 요청 막는것) SSL 랩스에서 도메인에 대한 암호화 등급을 확인할 수 있다. letsencrypt, godaddy,codomo등에서 인증서를 받을 수 있다. 성장을 바라는 웹프로트엔드 개발자를 위한 제언우아한 형제들 김민태님 성장바라보는 두가지 시선내가 생각하는 성장내가 상상하는 성장 열심히 하는것만 중요하지 않다, 전략을 잘 짜는것이 중요하다. 성장을 바라보는 두 가지 시선타인이 바라보는성장타인이 평가하는 성장 성장을 위한 결심만으로 부족하고 객관화를 위한 측정 지표를 만들자 결심한 목표와 형태가 적절한가달성 기준은 무엇인가성장 목적은 무엇인가 왜 특정기술을 선택했고 유사기술은 무엇이있을까요즉 why에 대한고민을 많이해라 나의 부족함을 알고있어야 한다 성장은 환경에 대한 적응이므로 성장해야만 한다. 그러기 위해 어떻게 성장할지 끊임없이 질문하자. 오픈소스속에서 성장하기강대명님 유데미 ARCUS 깃헙 github.com/naver/arcus 오픈소스레디스 github.com/antirez/redis 레디스를 선택한 이유Arcus처럼 Collection 기능을 제공C로 개발됨실제로 코드를 볼 생각이었따. Centos 5.3버전에서는 레디스가 잘 안돌아갔다. 빌드문제를 고치기 위한 접근 방법1.먼저 재현하기 안되는 방법 찾기2.해결방법 찾기 해당방법이 해결이 되는지, 더 좋은 방법이 없는지3.수정후 테스트 해당 주제에만 집중.주제와 상관없는 다른것들은 굳이 고치지 말자 큰프로젝트는 알아야 할것도 많다. 내가 많이쓰는 오픈소스를 고르자. 내가 많이 쓰는 오픈소스의 장점.1.좀 더 장애를 겪어볼 수 있다.2.계속 쓰고 있다.3.오픈소스의 학습이 업무지식에도 도움이 된다. 오픈소스를 고를 떄? 언어가 익숙한 언어로 구현되어있는지??카프카를 한다면 Scala/Java쿠버네티스 같은것을 한다면 Go로 기반지식을 충분히 이해하고 있는가 전체 모든 지식이 아니라 필요한것에 대한 지식이 필요함PR을 했는데 타이밍 어택에 취약하다 한다.그러면 타이밍 어택에 대해 공부해야 한다.. 커뮤니티가 활발한가?사람이 많으면 공헌하기 어렵고 적으면 공헌해도 배울게 얼마없다. 오픈소스를 통한 세속적인 장점업무에 필요한 툴에 대한 이해도가 더 높아진다.내가 이 부분을 이해하고 있다는 근거가 되어준다. 결론오픈소스를 통해 여러가지 지식습득, 선행학습이 가능하다.오픈 소스에 참여하면서 생기는 이점도 많다. 내가 미리 알았으면 좋았을 개발 생활 팁강윤신 - 라인 파이낸셜 플러스 어떻게 물어봐야 할까요 왜 내말을 알아듣지 못할까요 프로그래머 - 해결하려는 문제를 정의하고 코드로 해결하는 사람 질문하기전에 준비해야 할것내문제를 이해하자 내가 정의한 문제가 무엇인지. 이 문제를 이 사람에게 물어보는게 맞을까 상대방은 내가 정의한 문제를 이해 했나 나는 상대방의 대답을 이해 했나 low context인지 high context인지 상호 정하는것이 중요하다. 개발자의 세가지 덕목나태 / 조바심 / 자만심 홀로 성장하는 시대는 끝났다한국마이크로소프트 이소영님 커뮤니티 공부 =’~하기’공부내향적 - 전문서적 번역하기/ 블로그에 올릴 글이나 컬럼 작성하기/ 도서 집필하기/ 지식인 기술 포럼 답변하기/ 트위터 페이스북 등의 소셜 활동하기 외향적 - 페이스북/ 카페 밋업 등의 그룹 활동하기/ 유튜브 방송하기/ 컨퍼런스 발표하기/ 스터디 활동하기/ 앱개발,메이크 활동하기 마이크로스프트의 직원평가다른사람 성공에 어떻게 기여하는지 평가한다. 계속배우려하고 모험이나 도전이 오면 자신감있고 뒤##AI/Data 시대를 위한 개발자 생존 가이드상성리서치 임백준님 Programming 2.0 선사시대초기엔 책에 주로 의존했다. 르네상스이 후 스택오버플로우가 생겨났는데 시스템을 게임화 하여 개발을 재밌게 만들었다 Programming 2.0풀고자 하는 문제의 목적을 설정컴퓨터가 탐색할 공간을 지정하는 코드의 얼개 작성가능한 모든 자원을 동원해서 컴퓨터가 탐색을 수행하는 환경 제공ML 등 Programming 1.0 개발자전통적인 코딩을 통해 SW2.0 개발자가 사용할 수 있는 툴,인프라 등을 제공 Software 1.0컴퓨터에게 파이썬, 자바, C++ 같은 언어를 써서 명시적으로 전달하는것 Software 2.0뉴럴 네트워크 웨이트 처럼 사람이 읽을 수 없는 숫자로 컴퓨터에게 할일을 전해주는 방식 빠르게 쏟아지는 신기술과 개념을 어떻게 공부할 것인가모든것을 직접 경험하여 익히는 것은 불가능DevOps나 Full Stack 개발자는 모든 것을 다 경험한 사람이 아니라, 어떤 일도 잘 할것같은 사람하나의 경험을 통해 다른 일도 잘 할 수 있는 역량을 키워야함일ㅈ시적으로 유행하는 프레임워크나 API가 아니라 10년 20년 유지되는 기본적인 것을 공부해라 Fundamental을 공부해라프레임워크 API는 길어야 3년객체지향, 함수형, TDD, 리팩토링 등 원리와 패러다임은 10년 이상학력, 경력, 직책, …등 인간 자체의 문제해결 능력은 평생 Clean Code, Code Complete, Programming Pearl, Design Patterns, The Mythical Manmonth 는 반드시 읽어봐라 Survival Guide올바른 습관과 올바른 태도 Fake it till you make itJob vs Career : Job에서 생각하지말고 커리어 측면에서 생각해라.People skills :기술은 종교가 아니다 : 자기에 기술에만 국한되지 말고 열린태도를 갖자Add value to othersDon’t be afraid to look like an idiot : 환경이나 타인을 탓하지 않는 대범함, 실패에 좌절하지 않는 집요함, 흥분하지 않는 침착성, 자신을 사랑할 줄 아는 자존감 전자레인지로 음식을 데우기 위해서는 전자공학을 공부할 필요가 없다.문제를 해결하기 위한것을 공부하는것이 좋다. /","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"강연","slug":"Etc/강연","permalink":"http://KKimSangHeon.github.io/categories/Etc/강연/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"effective","slug":"effective","date":"2019-07-23T12:22:02.000Z","updated":"2019-07-23T12:22:03.000Z","comments":true,"path":"2019/07/23/effective/","link":"","permalink":"http://KKimSangHeon.github.io/2019/07/23/effective/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"규칙20. 태그달린 클래스 대신 클래스 계층을 활용하라.","slug":"effective2","date":"2019-07-02T12:08:50.000Z","updated":"2019-07-02T12:13:48.710Z","comments":true,"path":"2019/07/02/effective2/","link":"","permalink":"http://KKimSangHeon.github.io/2019/07/02/effective2/","excerpt":"","text":"두 가지 이상의 기능을 가지고 있으며, 그 중 어떤 기능을 제공하는지 표시하는 태그가 달린 클래스를 만날 수 있다. 12345678910111213141516171819class Figure &#123; enum Shape &#123; RECTANGLE, CIRCLR &#125;; // 어떤 모양인지 나타내는 태그 필드. final Shape shape; //사각형일때만 생성되는 필드 double length; double width; //원일때만 사용되는 필드 double radius; double area()&#123; ... &#125; ...&#125; 위의 클래스는 원을 표현할 수도 있고 사각형을 표현할 수 도 있다. 위 처럼 태그달린 클래스는 다양한 문제가 있다.enum선언, 태그필드, switch문 등의 상투적 코드가 반복되는 클래스가 만들어지며, 서로 다른 기능을 위한 코드가 한 클래스가 모여있어 가독성도 떨어진다. 또한 객체를 만들때 불필요한 필드도 함께 생성되어 메모리 요구량도 늘어난다. final을 초기화 하기 위한 상투적인 코드도 늘어나기도 한다. 마지막으로 그 객체가 무슨 기능을 제공하는지 알 수 없다.한줄로 정리하자면 태그기반(tagged class) 클래스는 너저분하고 오류발생가능성이 높고 비 효율적이다. 태그기반 클래스 대신 하위 자료형 정의(subtyping)를 사용하자. 다양한 기능의 객체들을 하나로 표현하기 위해 태그달린 클래스 대신 하위 자료형 정의(subtyping)를 사용하자. 태그 기반 클래스를 클래스 계층으로 변환하려면 먼저 태그 값에 따라 달리 동작하는 메서드를 추상 메서드로 선언하는 추상클래스를 정의해야 한다. 그리고 추상 클래스를 클래스 계층 맨꼭대기에 둔다. 그리고 태그 값에 좌우되지 않는 메서드는 전부 그 클래스에 넣는다. 모든 기능에 공통되는 데이터 필드도 전부 그 클래스에 넣는다. 태그 기반 클래스가 제공하던 각각의 기능을 방금 만든 최상위 클래스의 객체 생성 가능 하위클래스로 정의한다. 123456789101112131415161718192021abstract class Figure &#123; abstract double area(); &#125;class Circle extends Figure &#123; final double radius; double area()&#123; ... &#125;&#125;class Rectangle extends Figure &#123; final double length; final double width; double area()&#123; ... &#125;&#125; 위 코드가 하위자료형 정의한것이다. 단순하고명료하며 원래 클래스에 있던 단점들이 없다. 또한 최상위 클래스의 소스코드를 보지 않고도 독립적으로 일하면서 협력할 수 있게 된다. 기능마다 별도의 자료형이 있기 때문에 변수가 가진 기능이 무엇인지 명시적으로 표현 가능하며, 특정한 기능을 갖춘 자료형의 객체만이 변수나 인자에 할당되도록 할 수 있다. 요약하자면 태그 기반 클래스 사용은 피하고 클래스 안에 태그 필드를 명시적으로 두고 싶다면 클래스 계층을 통해 태그를 제거할 방법이 없는지 생각해 봐라. /","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"규칙 18.인터페이스는 자료형을 정의할 때만 사용하라","slug":"effective1","date":"2019-07-02T12:08:33.000Z","updated":"2019-07-13T12:18:41.751Z","comments":true,"path":"2019/07/02/effective1/","link":"","permalink":"http://KKimSangHeon.github.io/2019/07/02/effective1/","excerpt":"","text":"인터페이스를 구현하는 클래스를 만들게 되면 그 인터페이스는 해당 클래스의 객체를 참조할 수 있는 자료형(type)역할을 하게된다. 인터페이스를 구혆 클래스를 만든다는 것은, 해당 클래스의 객체로 어떤 일을 할 수 있는지 클라이언트에게 알리는 행위다. 다른 목적으로 인터페이스를 정의하고 사용하는것은 적절치 못하다.적절하지 못한예: 상수 인터페이스(메서드가 없고 static final 필드만 있음)가 있다. 상수 정의를 인터페이스에 포함시키면 구현 세부사항이 클래스의 공개 API에 스며들게 된다. 다음번 릴리스에서 더 이상 그런 상수를 사용하지 않도록 변경할 것이라 해보자. 그렇다 해도 호환성을 보장하려면 그인터페이스를 계속 구현해야 한다.상수를 API일부로 공개하고 싶을때는 더 좋은 방법이 있다. 상수가 존재하는 클래스나 인터페이스에 강하게 연결되어있을 때는 그 상수들을 해당 클래스나 인터페이스에 추가해야 한다. 그렇지 않을 경우에는 상수들을 객체 생성이 불가능한 유틸리티 클래스에 넣어서 공개해야 한다. 123456public class PC&#123; private PC()&#123;&#125; public static final double HI = 10.0; public static final double BYE = 20.0;&#125; 위와같은 PC 클래스를 사용할 일이 많다면 JDK 1.5부터 도입된 저억 임포트 기능을 사용하면 클래스이름을 제거할 수 있다.1234567import static com.sh.PC.*;public class Test&#123; double getHi() &#123; return HI; &#125;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"3. IP주소","slug":"network3","date":"2019-06-28T13:28:19.000Z","updated":"2019-06-30T08:10:28.923Z","comments":true,"path":"2019/06/28/network3/","link":"","permalink":"http://KKimSangHeon.github.io/2019/06/28/network3/","excerpt":"","text":"IP주소이야기TCP/IP 라는 프로토콜을 사용하는 모든 장비들을 구분해 주기 위해 만들어낸것이다.이진수 8개마다 점을 찍는데 이를 묶어서 옥테트(octet)라고 부른다. IP주소는 32비트이며 즉 IP주소는 4개의 옥테트로 나누어진다. 라우터에서의 IP주소라우토가 IP의 라우팅(경로배정)만 담당하는 것은 아니다.pc여러대 - 스위치 - 라우터 - 인터넷의 구성을 생각해보자.내부 네트워크에 연결되는 라우터의 포트를 이더넷 인터페이스라 생각하고(즉 스위치-라우터 사이) 외부 즉 인터넷쪽으로 연결되는 인터페이스를 시리얼 인터페이스라고 생각하자.그러므로 라우터에 부여해야하는 IP주소는 두 개가 된다. 하나는 이더넷 인터페이스에 부여할 것이고 하나는 시리얼 인터페이스에 부여할 주소이다.이더넷 인터페이스의 주소:이더넷용 IP주소는 우리가 내부에서 사용하기 위해 부여 받은 IP주소 중 하나를 배정해야 한다.(라우터의 이더넷쪽은 내부 네트워크에 접속되기 때문에..) 보통은 부여받은 주소중 맨 앞의 주소를 쓴다.시리얼 인터페이스의 주소 : 시리얼의 주소는 마음대로 부여할 수 있는게 아니다. 라우터가 접속하는 상대편(ISP 업체) 라우터의 시리얼 인터페이스와 IP 주소를 서로 맞추어야 하기 때문이다.(라우터에서 인터페이스가 달라지면 네트워크가 달라진다는 것을 의미. 즉 상대편 라우터의 시리얼과는 같은 네트워크가 되어야 한다.)예를 들어 상대편 라우터의 시리얼이 203.150.150.5에 서브넷 마스크가 255.255.255.252라면 우리 라우터의 시리얼은 203.150.150.6에 서브넷 마스크는 255.255.255.252가 된다.(왜 시리얼이 다를까?? 아직은 이해가 되질 않는다. 같아야 할 것이라 생각하는데… 잘못이해 했구나. 상대편 라우터의 시리얼 인터페이스와 IP 주소를 서로 맞추어야 한다는 뜻은 그것을 똑같이 일치시켜야 한다는 뜻이 아니라 mapping 해야 한다는 뜻으로 이해하자! ) 네트워크 부분, 호스트 부분네트워크 부분:네트워크란 하나의 브로드 캐스트 영역이라고 생각하면 된다. 즉 하나의 PC가 데이터를 뿌렸을 때 그 데이터를 라우터를 거치지 않고도 바로 받을 수 있는 영역을 의미. 한 브로드캐스트 영역 안에 있는 두 PC는 라우터 없이 통신이 가능하지만 그렇지 않은 경우에는 라우터를 꼭 거쳐야 한다.호스트 부분: 각각의 PC 또는 장비를 의미한다. IP주소는 네트워크 부분 ,호스트 부분으로 나누어진다. 따라서 어떤 네트워크에서든지 하나의 네트워크에서는 네트워크 부분은 모두 같아야 되고 호스트 부분은 달라야 정상적인 통신이 일어난다. 한 라우터의 있는 한 인터페이스로 50대의 PC가 연결되어 있다면 이들은 모두 같은 네트워크상에 있다하고 IP주소 중 네트워크 부분이 같아야 한다. 하지만 호스트 부분은 서로 다른것을 확인할 수 있다. 같은 네트워크에 있는 다른 PC를 찾아갈때는 라우터가 필요없고 라우터는 다른 네트워크로 갈 때만 필요하다. ClassIP 주소는 5개의 Class로 구분된다. 2개는 별로 쓰이지 않는다.(하나는 멀티캐스트용, 하나는 연구용)클래스는 A,B,C,D,E로 구분된다. 클래스에 따라 어디까지가 네트워크 부분이고 어디까지가 호스트 부분인지 나누어진다. 이를 이렇게 나눈건 네트워크 크기에 따른 구분이다. 하나의 네트워크가 호스트의 수를 몇 개 까지 가질수 있는가에 따라 클래스가 나누어진다. 클래스A: 하나의 네트워크가 가질 수 있는 호스트 수가 가장 많은 클래스이다. 32개의 이진수 중에서 맨 앞쪽 하나가 항상 0으로 시작되는 것들이다. 클래스 A의 경우는 앞의 8비트가 네트워크 부분을 나타내고 나머지 24비트가 호스트 부분을 나타낸다는 약속이 있다. 즉 클래스 A는 가장 작은 네트워크는 1.0.0.0(0.0.0.0 제외)이고 가장 큰네트워크는 126.0.0.0(127제외. 이건 약속) 으로 규정된다.하나의 클래스가 가질 수 있는 호스트의 수는 2^24-2(모두 0인경우 네트워크 자체를 나타내기 때문에 , 모두 1인경우 브로드캐스트 주소이기 때문에 ) 클래스B : 맨 앞이 반드시 10(이진수)으로 시작된다. 뒤에는 어떤 숫자가 와도 상관없다. 즉 10xx xxxx. xxxx xxxx. xxxx xxxx. xxxx xxxx형태를 띤다. 제일 작은 수는 128.0.0.0 이고 제일 큰 수는 191(1011 1111).255.255.255 이다. 클래스 B의 경우 앞의 16비트가 네트워크부분을 나타내고 나머지 16비트가 호스트 부분을 나타낸다. 정리하자면 128 부터 191로 시작하는 네트워크는 클래스 B이고 클래스 B 네트워크가 가질 수 있는 호스트의 수는 2^16 -2개(모두 0인경우 네트워크 자체를 나타내기 때문에 , 모두 1인경우 브로드캐스트 주소이기 때문에)이다. 클래스C : 맨 앞이 110(이진수)으로 시작된다. 죽 110x xxxx. ….의 형태이다. 따라서 맨 앞에는 110이 반드시 나와야 한다. 192.0.0.0이 가장 작은 숫자고 가장 큰 부분이 233.255.255.255 이다. 클래스 C의 경우 앞의 24비트가 네트워크 부분을 나타내고 나머지 8비트가 호스트 부분을 나타낸다. 클래스 C가 가질 수 있는 호스트의 수는 2^8-2 즉 254개이다. 이렇게 나눈 이유는 IP주소를 적정하고 효율적으로 배분하기 위한것으로서 IP 앞주소분만 보면 클래스를 알 수 있다. 요약 :시작하는비트/네트워크비트/호스트비트클래스A: 0/7/24클래스B: 10/14/16클래스C: 110/21/8 서브넷마스크메인이 아닌 어떤 가공을 통한 네트워크를 만들기 위해서 씌우는 마스크이다. 다시 말해 우리가 어떤 IP주소를 받게되면 이 주소를 그대로 사용하지 않고 입맛에 맞게 가공하여쓴다. 클래스 B 주소를 받았을 때 하나의 네트워크가 65000여개의 호스트를 가지는데 이렇게 큰 네트워크를 구성하면 브로드 캐스트 영향이 많아 아무것도 할 수 없다. 부여받은 IP주소에 서브넷 마스크를 씌워 네트워크를 나눈다. 또한 각각의 서브넷간의 통신은 라우터를 통해서만 가능해진다.즉 서브넷 마스크는 주어진 IP주소를 네트워크 환경에 맞게 나누어 주기 위해 씌워지는 이진수의 조합이다. 서브넷 마스크는 주소를 나누지 않더라도 항상 IP 옆에 붙어다닌다. 그래야 그 주소를 나눈 건지 아닌지 알 수 있기 때문이다. 디폴트 서브넷 마스크 : 주어진 클래스를 나누어 쓰지 않고 몽땅 쓰는경우에도 서브넷 마스크는 따라다니는데 그게 바로 디폴트 서브넷 마스크, 즉 기본 서브넷 마스크이다.클래스 C의 경우 디폴트 서브넷 마스크는 255.255.255.0이다. 클래스 B의 경우는 255.255.0.0이고 클래스 A는 255.0.0.0 이다. 그러므로 주어진 네트워크를 하나도 나누지 않고 그대로 다 쓰는 경우에는 디폴트 서브넷 마스크를 쓰면 된다. 하지만 주어진 네트워크를 나누어서, 즉 가공해서 쓰는 경우는 디폴트 서브넷 마스크를 쓰지 않고 약간 고쳐서 쓴다 네트워크를 나누는 경우 활용법 : 서브넷 마스크란 IP주소를 가지고 어디까지가 네트워크 부분이고 또 어디까지가 호스트 부분인가를 나타내는 역할을 한다. 따라서 서브넷 마스크를 보면 그 IP 주소의 네트워크 부분과 호스트 부분을 알 수 있다. 네트워크 부분은 서브넷 마스크가 이진수로 1인부분이고 호스트 부분은 0인 부분이다. 150.150.100.1(B클래스)이라는 IP주소에 디폴트 서브넷 마스크를 사용했을 때 네트워크 부분은 150.150이 된다. 하지만 서브넷마스크를 255.255.255.0을 씌우게 되면 네트워크 부분은 150.150.100이 되고 호스트 부분이 줄어들게 된다. 즉 클래스 B 주소를 마치 클래스C처럼 사용한다는 의미이다. 이렇게 서브넷 마스크를 씌워서 작은 네트워크로 만드는 것을 서브네팅이라 한다. 정리하자면 서브넷 마스크는 커다란 네트워크를 작은 네트워크 여러 개로 나누어서 쓰기 위함이며 서브넷 마스킹은 기존 IP주소의 호스트 부분의일부를 네트워크 부분으로 바꾸는 작업이다. 서브넷 마스크의 성질:서브넷 마스크로 만들어진 네트워크, 즉 서브넷은 이제 하나의 네트워크이기 때문에 서로 나뉘어진 서브넷끼리는 라우터를 통해서만 통신이 가능하다.서브넷 마스크는 이진수로 썼을 때 1이 연속적으로 나와야 한다. 즉 255.255.255.15(1111 1111.1111 1111.1111 1111.0000 1111)는 불가능하고 255.255.255.252(1111 1111.1111 1111.1111 1111.1111 1100)은 가능하다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Network","slug":"CS/Network","permalink":"http://KKimSangHeon.github.io/categories/CS/Network/"}],"tags":[]},{"title":"2.TCP/IP와의 만남","slug":"network2","date":"2019-06-25T11:46:10.000Z","updated":"2019-06-27T13:12:31.690Z","comments":true,"path":"2019/06/25/network2/","link":"","permalink":"http://KKimSangHeon.github.io/2019/06/25/network2/","excerpt":"","text":"오늘날 가장 많이 사용되는 프로토콜은 TCP/IP 이다.(인터넷 때문..)Transmission Control Protocol/Internet Protocol의 약자로서 ARPANET에 의해 처음 개발되었다. 각각의 네트워크에 접속되는 호스트는 다른 네트워크에 연결되어 있는 호스트까지도 서로 데이터를 주고받을 수 있다. 이 때 사용하는 호스트들의 고유 주소인 IP주소는 Internet Network Information Center(InterNIC)이란 단체에서 관리 분배되고 있다. IP의 한정으로 인해 내부 네트워크에서는 공인되지 않은 IP주소를 사용하고 인터넷으로 나갈 때만 공인주소(유일한 IPwnth)를 가지고 나가는 방식인 NAT(Network Address Translation)나 동일한 IP 주소를 가지고 여러 명이 인터넷에 접속하면서 포트 넘버만을 바꾸는 PAT 등이 사용되고 있다. IP주소는 2진수 32개로 만들어졌다. 즉 만들 수 있는 주소는 2^32만큼이다. 이를 IPv4라 하고 고갈 대책으로 나온것이 IPv6인데 2^128개의 주소를 표현할 수 있다. DHCPIP주소를 자동으로 배정해준다. DHCP 서버가 따로 존재하며 DHCP클라이언트들이 주소를 요청하면 DHCP 서버는 갖고있는 주소중에서 하나를 자동으로 할당해준다. NIC(Network Interface Card) 즉 랜카드유저의 데이터를 케이블에실어서 허브나 스위치 혹은 라우터 등으로 전달해주고 자신에게 온 데이터를 CPU에게 전달해주는 역할대부분(90% 이상) 이더넷용 랜카드이다. UTP타입을 많이쓴다고만 알아두자. 허브직사각형 상자에 구멍이 뚫려있는 모양으로 구멍에 따라 몇 포트 허브다라고 한다. 구멍의 숫자가 몇대의 장비를 연결할수 있는지 결정한다. 또한 같은 허브에 연결된 PC끼리는 서로 통신이 가능하다. 허브는 멀티포트 리피터라고 말 할 수 있다. 즉 포트가 많고 들어온 데이터를 그대로 재전송한다는것. 쉽게말하면 한 포트로 들어온 데이터를 나머지 모든 포트로 뿌려준다는 것(이 때 받은 데이터를 수신한 랜카드들은 목적지 맥 어드레스를 보고 버릴지 CPU로 올릴지 판단한다.). 한 허브에 연결된 모든 PC는 같은 콜리전 도메인 안에 있다. 리피터두 장비를 UTP로 통신할 때 100m 이상인경우 권장되지 않는다. (완전한 통신보장x) 이 경우 중간에 리피터를 두어 들어온 데이터를 다른 쪽으로 전달해 주는 역할을 한다. 허브가 리피터의 역할을 대신하게 되어 만나기가 쉽지 않다. 허브의 한계허브의 수를 늘리기 위해 다른 허브에 물리게 된다면 collistion domain이 커지게 된다. 이로 인해 콜리전이 자주 발생하게 되는 결과를 낳는다. 허브의 종류허브는 보통 인텔리전트 허브, 더미허브, SemiIntelligent 허브로 나뉜다. 인텔리전트 허브 : NMS(네트워크 관리시스템)를 통해서 관리가 되는가로 인텔리전트 허브와 더미 허브로 나눈다. 즉 인텔리전트 허브는 NMS상에서 모든 데이터를 분석, 제어가 가능하다. 특정 PC가 자꾸 데이터를 보내 컬리전이 발생킨다면 네트워크에서 분리시킴으로써 해결할 수있는 기능도 갖고있다. 또한 분리된 포트는 허브에서 램프로 표시되기 때문에 바로 조치가 가능하고 이를 Auto Partition이라고 한다. Semi 더미 허브 : 더미 허브이지만 인텔리전트 허브와 연결하면 자기도 인텔리전트 허브가 된다. 즉 혼자 있을때는 더미허브, 인텔리전트 허브랑 같이 있으면 인텔리전트 허브가 된다. Stackable 허브: 스택이 가능한 허브, 즉 쌓을 수 있는 허브, 학교 전산실에 허브 여러개 쌓아둔거 생각해보자. 허브의 끝 스위치의 시작(허브보다 두 수 높은 스위치!)콜리전 도메인을 낮춘 브리지 또는 스위치!스위치가 나오기 전까지는 브릿지가 다 해주었지만 이제 브릿지보다 빠른 스위치가 나와 브릿지는 물러나고 있다.스위치는 1번 포트에 연결된 PC가 2번 포트에 연결된 PC와 데이터를 주고받는 동안에도 3번 포트에 연결된 PC와 4번 포트에 연결된 PC가 서로 데이터를 주고 받을수 있게 해주는 장비.유식하게 포트별로 콜리전 도메인이 나뉘어져 있다고 한다.허브는 한 순간에 한대의 차만달릴 수 있다면 스위치는 포트 수별로 차선이 존재하여 여러대가 달릴 수 있는구조이다. 그렇지만 스위치 또한 서버와의 통신은 한순간에 하나의 PC만이 가능하다. 허브보다 한 수 높은 브릿지말그대로 다리이다. 스위치와 사촌지간이며 하는일이 서로 비슷하다.브릿지는 허브로 만들어진 콜리전 도메인 사이를 반으로 나누고 중간에 다리를 놓는다. 이로 인해 다리 남단은 남단끼리 북단은 북단끼리 동시에 통신이 가능해진다.정리하자면 브릿지는 허브보다 한 수 위 장비인데 콜리전 도메인을 나누어 준다.(중간에 브릿지를 만들어서) 브릿지/스위치의 기능 Learning. 배운다 Flooding. 모르면 들어온 포트를 제외한 다른 모든 포트로 뿌린다. Forwarding. 해당 포트로 건네준다. Filtering. 다른 포트로는 못건너가게 막는다 Aging. 나이를 먹는다. Learning : 브릿지나 스위치는 자신의포트에 연결된 A라는 PC가 통신을 위해 프레임을 내보내면 그때 이 PC의 맥 어드레스를 읽어서 자신의 맥 어드레스 테이블(브리지 테이블이라함)에 저장해 놓는다. 그리고 나주에 어떤 PC가 A에게 통신할 경우에 자신의 브릿지 테이블을 참고해서 다리를 건너게 할지 못건너게 할지 결정한다. Flooding : 들어온 포트를 제외한 나머지 모든 포트로 뿌리는 것을 의미. 들어온 프레임이 찾아가는 주소를 보니 브릿지 테이블에 없는 주소 일경우 다리를 건너야 할지 건너지 말아야할지 모르는 경우가 생기는데 이 경우 Flooding이 사용된다. Flooding는 브로드 캐스팅이나 멀티캐스트의 경우에도 발생한다. Forwarding : 브리지가 목적지의 맥어드레스를 자신의 브릿지 테이블에 갖고 있고 다리를 건너야 할 경우 Forwarding이 발생한다. 이는 모든 포트로 프레임을 뿌리는 Flooding과 다르게 해당 포트쪽으로만 프레임을 뿌린다. Filtering : 브리지를 못넘어가게 막는다는 것. 브릿지가 목적지의 맥 어드레스를 알고 있고 (브릿지 테이블에 맥어드레스가 존재하는 경우) 출발지와 목적지가 같은 세그먼트 상에 있는경우. 즉 브릿지를 건너가지 않아도 되는경우 다리를 막는 필터링을 실시한다. 브릿지의 필터링 기능 때문에 허브와 다르게 콜리전 도메인을 나눌 수 있다. 프레임이 목적지와, 브릿지 둘다 날라 가지만 브릿지에서는 브릿지 테이블을 보고 다리를 막는다. Aging : 브릿지 테이블에 맥 어드레스를 저장은 무한정 할 수 없다. 그러므로 나이를 맥여 (디폴트로 5분. 조정 가능) 일정 나이가 되면 브릿지 테이블에서 삭제시킨다. 하지만 타이머 만료 전에 다시 들어오게 된다면 타이머를 Refresh하여 다시 카운트 한다. 브릿지와 스위치의 차이둘다 데이터 링크 레이어지만 차이점이 존재한다. 스위치는 처리방식이 하드웨어로 이뤄지기 때문에 소프트웨어적으로 프레임을 처리하는 브릿지에 비해 빠르다.(스위치는 처리 절차를 미리 칩에 구워서 하드웨어 방식으로 만드는 ASIC방식) 브릿지는 포트들이 같은속도를 지원하지만, 스위치는 서로 다른 속도를 연결해 줄 수 있다. 스위치는 브릿지에 비해 제공하는 포트 수가 훨씬 많다. (브릿지는 2~3개정도 포트/스위치는 몇십 몇백개) 스위치의 경우 cut-through, 또는 store-and-forward 방식을 사용하는데 브릿지는 store-and-forward 방법만을 사용한다. Store-and-forwarding: 스위치나 브릿지가 일단 들어오는 프레임을 전부 받아들인 다음 처리를 시작.(에러가 날 경우 버리고 다시 요청) Cut-through: 스위치가 들어오는 프레임의 목적지 주소(처음 48bit)만을 본 다음 바로 전송 처리를 시작하는 방식(Store-and-forwarding처럼 프레임이 다 들어오기를 기다리지 않음). 이전 방식에 비해 빠르지만 가끔씩 발생한 에러를 찾아내기가 어렵기때문에 에러 복구능력이 약점이다. Fragment-Free: 앞의 두가지 방식의 장점을 결합한 방식으로 전체 프레임을 다 기다리지 않고 처음 512비트만 보게 된다. 에러 감지능력이 Cut-through보다 좋다.`` Looping은 왜 생길까루핑을 브릿지나 스위치에서 자주 발생하는 현상이다. 이는 프레임이 네트워크 상에서 무한정으로 뱅뱅 돌기 때문에 이더넷의 특성상 네트워크가 조용해야 데이터를 전송할 수 있는 다른녀석들이 계속 네트워크가 조용해지기를 기다리기만 할 뿐 데이터 전송이 불가능한 상태를 말한다. 브릿지, 스위치 디자인에서 주의해야 한다. 두 호스트 사이에 스위치 또는 브릿지가 두 개 있다고 가정해보자. 즉 하나의 호스트에서 다른 호스트로 가는 경로가 두 개 이상 만들어진다는 것이다. 이렇게 구성하는 이유는 보통 하나가 끊어지면 다른 하나로 통신하기 위해 구성한다. 하지만 아무 생각없이 이렇게 구성하게 될 경우 루핑이 발생하게 된다. 스 스위ㅡㅡㅡㅡㅡ위치ㅡㅡㅡㅡㅡ치ㅣ ㅣA pc B pc A가 브로드 캐스트 패킷을 보내면 양쪽 스위치(혹은 브릿지)로 전달되게 된다. 그 다음 두 개의 스위치(혹은 브릿지)는 이 패킷을 분석하고 브로드캐스트 패킷이란것을 알아낸다. 그 후 Flooding을 하게된다. (스위치(혹은 브릿지)는 목적지 주소를 보고 그 주소가 자신의 브릿지 테이블에 없거나, 멀티캐스트 주소이거나, 브로드 캐스트 주소인 경우에는 들어온 포트를 제외한 나머지 모든 포트로 뿌려주는 Flooding를 하게된다.) 그럼 상대방쪽 세그먼트로 브로드캐스트 패킷이 보내지게된다. 즉 양쪽 브릿지에서 모두 패킷이 다리를 건너게 된다. 그 다음엔 반대쪽으로 건너간 브로드캐스트 패킷을 다시 양쪽 브릿지의 아래쪽 트로 전달되고 이 패킷 역시 브릿지의 특성에 따라 다시 위로 전달된다.( 즉 다시 다리를 건너오게 된다.)이를 해결할 수 있는것이 바로 스패닝 트리알고리즘! 폴트 톨러런트(Fault tolerant) : 네트워크상에 어떤 문제가 발생할 때를 대비해서 미리 장애 대비를 해놓는 것을 의미한다.(장애 대비책으로 대부분 이중 구조를 의미하고 전체 네트워크가 하나의 지점에서 발생한 장애로 인해 영향을 받는것을 방지하기 위한 대책)로드 밸런싱(Load balancing) : 로드를 분산하는것. 회선 하나를 이용한 인터넷 접속대신 인터넷 회선을 두 개 사용하는것. 스패닝 트리되지 않는 스위치는 팥 없는 찐빵스패닝 트리는 자동으로 루핑을 검색해서 루핑이 발생할 수 있는 상황을 미리 막아주는 역할을 한다. 이를 가능케하는 이유는 스위치간 두개의 링크중 하나를 끊어서 실제 링크는 두 개지만 데이터는 한쪽으로만 다니게 한다. 이를 통해 루핑을 예방할 수 있다.그럼 스위치를 두 개의 링크로 연결한 이유가 무엇일까? 이는 바로 하나의 링크가 끊어졌을때를 대비하는것이다.정리하자면 스패닝 트리알고리즘은 스위치나 브릿지에서 발생할 수 있는 루핑을 미리 막기 위해 두개 이상의 경로가 발생하면 하나를 제외하고 나머지 경로를 막아두었다가 기존의 경로에 문제가 생기면 막아놓은 경로를 풀어 데이터를 전송하는 알고리즘이다.모든 스위치는 스패닝 트리 알고리즘을 지원한다. 라우팅 or 스위칭?라우팅 or 스위칭 비교가격 : 라우터가 스위치보다 비싸다.속도 : 스위치가 우세. 라우터는 내부에서 처리하는 일이 많음.구성의 편리함: 스위치가 훨씬 구성이 쉽다. 라우터는 라우팅프로토콜, 네트워크 설정 필요 브로드캐스트 영역(도메인)을 나눠주기 위해서는 라우터가 꼭 필요하다. 스위치가 그런 기능을 하는 경우가 있지만 (스위치가 라우터의 역할까지를 수행하는 경우 이런 스위치를 레이어3 스위치라고 한다) 역시 내부를 들여다보면 스위치에 라우터를 붙여놓은 형태이다. 브로드 캐스트 영역을 나눌때는 IP일때 약 500노드가 권고사항이라 한다. 실질적으로는 반 정도만 사용해야 네트워크를 제대로 사용할 수 있다. (노드는 네트워크에 접속되는 장비) 또한 라우터는 스위치가 보장못하는 보안기능, 즉 패킷 필터링을 제공하고 네트워크 주소에 따라 전송을 막았다 푸는 필터 기능도 제공한다. 또 하나 바로 로드 분배기능을 제공한다. 즉 여러 개의 경로를 가지고 있기 때문에 데이터가 여로 경로를 타고 날아갈 수 있다. 스위치도 로드 분배가 가능하지만 굉장히 제한적이다. 라우터는 이 외에도 프로토콜이나 데이터의 크기, 중요도 등 여러 상황에 따라 트래픽의 전송 순서를 조정해주는 QoS(Quality of Service) 기능도 제공한다. 결론은 스위치와 라우팅을 적당히 사용하자 /","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Network","slug":"CS/Network","permalink":"http://KKimSangHeon.github.io/categories/CS/Network/"}],"tags":[]},{"title":"16. 장애대책","slug":"kube20","date":"2019-06-23T08:30:27.000Z","updated":"2019-06-23T10:21:05.006Z","comments":true,"path":"2019/06/23/kube20/","link":"","permalink":"http://KKimSangHeon.github.io/2019/06/23/kube20/","excerpt":"","text":"도커 운영 시의 장애 대책주로 dockerd 자체보다는 운영하는 사람의 실수나 부주의에서 비롯되거나 서버 리소스에 의한것이많다. 장애를 막기 위한 이미지 운영의도하지 않은 컨테이너가 실행되는 경우 운영 환경에서 latest버전의 이미지를 실행하거나 컨테이너 오케스트레이션 과정에서 최신 이미지를 실행한 상황 latest 외의 버전 이미지를 덮어쓴 상황 example/aaa:latest 태그로 빌드해야될 이미지를 example/bbb:latest 태그로 빌드한 상황(다른 이미지와 바뀜) 이미지 테스트실행단계에서 이미지가 잘못되었는지 판단하면 늦다. 이전에 이미지 테스트를 거치는것이 좋은데 이를 위해 container-structure-test가 많이 사용된다. container-structure-test는 구글에서 오픈 소스로 공개한 테스트 프레임워크로 도커이미지를 테스트 대상으로 한다. 컨테이너안에 특정 파일의 존재여부, 파일 내용확인등을 진행할 수 있다. 디스크 용량 부족 도커 호스트 역시 디스크 용량 부족을 주의해야 한다. 용량이 가득차면 새로운 컨테이너를 만들수도 없고 기존 컨테이너의 실행에도 지장이 생긴다. 서드파티 모니터링 도구를 사용한 호스트 디스크 용량 모니터링은 필수이며 도커에서도 디스크 용량을 낭비하지 않도록 해야한다. 이를 위해 불필요한 이미지나 컨테이너는 디스크에서 삭제하는것이 좋다. 이럴경우 docker prune 명령어(사용하지 않는 이미지나 컨테이너 일괄 삭제)를 cron을 통해 야간에 실행하면 좋다 쿠버네티스 운영 시의 장애 대책쿠버네티스는 장애에 강한 컨테이너 오케스트레이션 시스템이지만, 노드 다운등 장애를 일으킬 수 있는 몇 가지 요인이 있다. 노드가 장애를 일으켰을 때 쿠버네티스의 동작?노드가 장애를 일으켜 다운됐을 때 노드에 배포된 파드가 어떻게 되는지 알아봐야한다. 한 노드가 다운되면 정지된 파드들은 다른 노드로 배치된다. 이는 파드를 생성하는 레플리카 세트가 지정된 수의 파드를 유지하려고 하기 때문이다. 이를 오토힐링이라 한다. 레플리카세트가 관리하는 파드를 노드에서 의도적으로 삭제한 경우에도 같은 일이 일어난다. 즉 쿠버네티스에서는 레플리카세트를 관리하는 디플로이먼트나 스테이트풀세트, 데몬세트를 이용해 파드를 생성하는것이 가장 좋은 대책이다. 파드 안티 어피니티를 이용해 장애에 강한 파드 배치 전략 수립하기레플리카세트의 오토힐링은 강력하지만 다른 노드로 파드가 재배치되는 동안에는 다운타임을 피할 수 없다.(replicas=1일때 치명적.) 그러므로 이러한 문제점의 피해를 최소화 하기위해 파드가 여러 노드에 나눠 배치되어야 한다. 이를 위해 replicas 값을 적절히 조절하는 방법을 사용한다. 파드가 여러 노드에 걸쳐 배치돼 있는 만큼 다운타임 없이 파드가 재배치 될 수 있을것이다. 하지만 파드 여러개가 한노드에 배치되어있는경우 해당 노드가 죽을경우 모두 정지되므로 파드가 여러개라도 다운타임이 생기게 된다. 쿠버네티스는 시스템 리소스가 여유 있는 노드를 골라 파드를 배치하기 때문에 앞서말한 가능성을 배제할 수 없다. 이를 해결하는 기능이 바로 파드 안티 어피니티(pod antiaffinity)이다. 이것은 파드간 상성을 고려한 배치전략을 규칙으로 정의한다. 이를 통해 C파드가 정의된 노드에는 D파드를 배치하지 말것과 같은 규칙을 정의할 수 있다. 디플로이먼트 정의에서 spec.affinity.podAntiAffinity설정에 이를 정의할 수 있다.만약 replicas=3으로 했을 때 존재하는 노드가 2개 뿐이라면 하나의 파드는 펜딩상태가 되고 노드가 클러스터에 추가된 시점에 배치된다. 파드 어피니티라는 기능도 있는데 이는 파드 A는 파드 B와 자주 통신하므로 같은 노드에 배치한다 와 같은 경우에 활용할 수 있다. CPU 부하가 큰 파드를 노드 어피니티로 격리하기어플리케이션에 따라 CPU 부하가 큰 특성을 갖기도 한다. 배치잡처럼 CPU 부하가 클 경우 같은 노드 내 다른 파드의 성능을 떨어뜨린다. 이 경우 배치잡 파드를 전용 노드로 격리해야할 필요가 있다. 이를 위해 노드에 용도별로 구분짓는 레이블을 부여하고 파드 배치 규칙에 해당 레이블을 갖는 노드에만 파드를 배치하면 된다. 특정 레이블이 부여된 노드에만 파드를 배치하는 규칙을 정의하는 것이 노드 어피니티 이다.노드에 레이블을 부여하기 위해 instancegroup 값을 설정하고 웹 어플리케이션이나 API파드만을 배치할 노드에는 webapi, 배치 잡만을 처리할 노드에는 batch라는 레이블을 붙여 용도를 구분한다. 정의된 규칙에 부합하는 노드가 없는경우 파드는 배치되지 않고 Pending 상태로 남는다. HPA를 이용한 파드 오토 스케일링HPA(Horizontal pod autoscaler)는 시스템 리소스 사용률에 따라 파드 수를 자동으로 조정하는 쿠버네티스 리소스이다. HPA는 파드의 오토 스케일링 조건을 디플로이먼트나 레플리카세트에 부여하기 위한 리소스다. 노드에 대한 파드의 CPU 사용률이 40퍼센트를 넘었을 때 파드에 오토 스케일링을 적용하고 싶을 때 사용하면 된다. 설정된 CPU 사용률 기준을 초과하면 자동으로 새로운 파드를 만들고 maxReplicas에 설정된 개수 이상의 파드는 생성하지 않는다.HPA는 Cluster Autoscaler와 함께 사용할 때 효과가 극대화 된다. Cluster Autoscaler를 이용한 노드 오토 스케일링HPA가 파드의 오토 스케일링을 제공한다고 해도 파드를 배치할 노드 리소스가 충분하지 못할 수 있다. 이경우 Cluster Autoscaler을 사용한다. Cluster Autoscaler는 쿠버네티스 클러스터의 노드 수를 자동 조정한는 역할을 한다. 이는 쿠버네티스 리소스가 아니라 노드 오토 스케일링 기능을 제공하는 별도의 도구이다. 헬름의 릴리스 히스토리 제한헬름으로 어플리케이션을 배포하는 경우 릴리즈 히스토리로 인한 문제가 발생할 수 있다. kubectl -n kube-system get configmap을 입력하면 어플리케이션명, 버전명이 붙은 컨피그 맵이 생성되어 있다. 헬름을 통해 설치, 업데이트를 반복하면 그만큼 컨피그 맵이 생기게 된다. 이를 피하기 위해 helm init 명령으로 틸러를 배포할 때 –history-max 옵션으로 히스토리 저장 최대 건수를 정한늑서이 좋다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://KKimSangHeon.github.io/tags/kubernetes/"}]},{"title":"15-1. 로그 관리방법(구글스택드라이버, stern)","slug":"kube19","date":"2019-06-23T06:45:10.000Z","updated":"2019-06-23T08:30:01.300Z","comments":true,"path":"2019/06/23/kube19/","link":"","permalink":"http://KKimSangHeon.github.io/2019/06/23/kube19/","excerpt":"","text":"구글 구글스택드라이버구글 스택드라이버는 GCP나 AWS에서 로깅 및 모니터링에 사용되는 매니지드 서비스이다. https://app.google.stackdriver.com/ 으로 접속하거나 콘솔메뉴(왼쪽메뉴바)에서 모니터링을 선택하자. 그 후 Logging 탭을 선택하자.스택드라이버에서는 로그를 Cloud HTTP 로드 밸런서나 GKE 컨테이너와 같은 카테고리 별로 나눠 볼 수 있다. 또한 컨테이너에서 JSON포맷 등으로 구조를 가진 로그를 출력한다면 jsonPayload.속성:값 형식으로 검색 결과를 좁힐 수 있다. 또한 입력 시에 가능한 속성명에 자동완성 기능을 제공해 더욱 편리하다. 이는 GKE 쿠버네티스 클러스터 노드에 배치된 fluentd-gcp리소스에서 제공한다. 개발자가 이를 관리할 필요가 없으며 컨테이너에서 로그를 json형태로 출력만 하면 로그를 확인할 수 있다. 스택드라이버는 어플리케이션 병목 검출(스택드라이버 트레이스), 어플리케이션 오류 탐지 기능(스택드라이버 에러 리포팅) 등의 기능을 제공한다. GKE에서는 필수적인 도구이다. stern키바나, 스택드라이버는 좋긴하지만 조금 거창한느낌이 있다. 이보다 가볍개 보는 방법으로 kubectl logs -f 파드ID라는 방법이 있지만 파드 ID를 매번 확인해야 하는것이 불편하다. 쿠버네티스 로그 열람을 돕는 도구로서 stern이 있는데 이는 레이블만 지정하면 로그확인이 가능하다. stern -l app=echo 라는 명령어를 통해 특정 파드가 삭제되거나 다시 생성되어도 로그를 볼 수 있다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://KKimSangHeon.github.io/tags/kubernetes/"}]},{"title":"1.네트워크 세상에 들어서며","slug":"network1","date":"2019-06-19T14:00:51.000Z","updated":"2019-06-25T11:46:52.012Z","comments":true,"path":"2019/06/19/network1/","link":"","permalink":"http://KKimSangHeon.github.io/2019/06/19/network1/","excerpt":"","text":"인터넷여러개의 네트워크를 묶었다는 의미.인터넷의 특징1.TCP/IP라는 하나의 프로토콜만 사용2.웹브라우저를 통해 인터넷을 탐험한다.3.없는정보가 없다. 인트라넷내부의 네트워크를 의미. 사내업무도 웹 브라우저만으로 할 수 있다. TCP/IP 프로토콜을 사용함. 엑스트라넷인트라넷과 유사하지만 인트라넷을 기업의 종업원이외에도 협력회사나 고객에게 사용할 수 있도록 한것. LAN?Local Area Network의 약자로 한정된 공간에서 네트워크를 구성한다는것.(ex.한 사무실 내에 구축) WAN멀리 떨어진 지역을 서로 연결하는 경우. 요즘은 LAN,WAN이 공존하는 형태이다. 이더넷네트워킹의 한 방식으로 CSMA/CD라는 프로토콜을 사용해 통신한다. 우리나라의 90%이상이 이더넷 방식을 사용함.네트워킹방식의 경우 다양한 방식이 존재한다.(토큰링,FDDI,ATM) 그러므로 이에 맞게 랜카드부터 네트워크 장비를 다르게 구입해야한다. 즉 자신의 네트워킹 방식을 모르고 랜카드 한장도 함부로 살수 없으므로 내용을 잘 알아두자. CSMA/CD는 Carrier Sense Multiple Access/Collision Detection을 줄여서 대충 알아서 눈치로 통신하자라는 뜻이다. 이더넷 환경에서 통신을 하고싶은 PC나 서버는 네트워크상에 통신이 일어나고 있는지 확인(네트워크 자원을 쓰고있는 PC나 서버가 있는지 확인) 즉 캐리어가 있는지를 감지한다. 이를 Carrier Sense라고 한다. 캐리어가 감지되면 감지되지 않을때까지 기다렸다(눈치보다가) 자기 데이터를 네트워크에 실어 보낸다. 만약 동시에 여러 컴퓨터가 데이터를 보낼 경우 이를 Multiple Access라고 하며 Collision이 발생했다고 한다. 따라서 이더넷에서는 Collision Detection을 잘해야하며 발생했을 경우 랜덤한 시간동안 기다린 다음 다시 데이터를 전송하게 된다. 토큰링?한 네트워크에 토큰이 하나뿐이라(아닌경우도 있음) 한 네트워크에서 오직 한 PC, 즉 토큰을 가진 PC만이 네트워크에 데이터를 실어 보낼 수 있다.보내고 난 후에는 옆 PC에게 토큰을 건네주게 되고 전송할 데이터가 없다면 다시 옆PC에게 전달한다. 이러한 방식으로 통신이 발생하여 충돌이 발생하지 않고 성능을 예측하기도 쉽다.이더넷의 발전으로 역사의 뒤안길로 사라졌다..단점: 바로 보내야할 데이터가 있고 다른 PC들은 보낼 데이터가 하나도 없더라도 차례가 올때까지 기다려야 한다. 이더넷 &amp; 토큰링데이터 네트워크의 두 가지 형태로서 이더넷을 많이쓰며 이더넷의 일반적인 속도는 100/1000Mbps이다. 토큰링은 100/1000Mbps이다. UTP 케이블장비와 장비의 연결에는 어떤 종류의 케이블이든 반드시 케이블이 들어가게 된다. 이러한 케이블의 종류에는 광케이블, UTP 케이블, 동축케이블등 다양하다. 이중에 가장 많이 사용되는 것은 UTP케이블이다. TP 케이블? : Twisted-pair의 약어로써 즉 꼬인녀석이라는 의미이다. TP에는 UTP와 STP가 존재하며 UTP는 Unshielded(감싸지 않은) UP를 의미하는데 우리가 주로 사용하는 케이블이다. STP는 Shielded로 케이블 주위를 어떤 절연체로 감싸서 만든것을 말한다. STP가 좀더 비싸고 성능이 좋다.기존 UTP가 많았기에 UTP가 주를 이루게 되었고 STP는 주로 토큰링 쪽에서 많이 쓰이고 있다. 케이블10 Base T에서 10은 속도를 나타낸다. 즉 10Mbps의 속도를 지원하는 케이블을 의미한다.Base란 말은 케이블이 Baseband용 케이블이라는 것을 의미한다. 케이블의 종류에는 Baseband와 Broadband가 있는데 Baseband는 디지털 방식이고 Broadband는 아날로그 방식이라고 볼 수 있다.T가 있는 자리에는 케이블의 종류 또는 이 케이블이 전송할 수 있는 최대거리가 나온다. 여기서는 케이블의 종류가 나온것으로 T란 TP(Twisted Pair)케이블이라는 것을 나타낸다. 이것이 바로 UTP 케이블을 나타낸다.가령 T 대신 숫자가 나왔을 땐 최대 통신거리를 의미하는데 10 Base 5 일경우 최대 500m까지 통신이 가능함을 의미한다. 즉 10 Base T는 10M의 속도로 최대 500미터까지 전송이 가능한 케이블을 의미한다. 맥어드레스MAC는 Media Access Control의 약어로서 네트워크 상에서 어떻게 서로를 구분해서 인식할지에 대한것이다. 통신을 위해서는 서로를 구분할 일종의 주소가 필요한데 이를 MAC주소라 한다. 6옥테트(48bit) 의 주소를 갖게 되는데 이 주소는 랜카드 또는 네트워크 장비에 고정되어 있는 주소이고 유일하다. 6개의 16진수로 표현되는데 앞의 6개는 OUI(Organizational Unique Identifier) 즉 생산자를 나타내고 뒤의 6개는 시리얼 넘버로 볼 수 있다. ARP:Address Resolution Protocol:IP주소를 다시 MAC로 바꾸는 절차를 의미.iconfig/all을 입력했을 때 Physical address를 맥 어드레스라 한다. 같은 네트워크에서의 통신PC Y는 자기가 속한 네트워크에 있는 모든 PC에게 메시지를 보내는데 이때 메시지의 의미는 “여기 네트워크안에 Z있으면 통신하고싶으니 맥어드레스좀 알려줘라”라는 것이다. PC Z는 Y에게 자신의 맥 어드레스를 알려주게 되고 통신을 시작하게 된다. 다른 네트워크간 통신호스트 Z가 다른네트워크에 있을 때 즉 라우터를 통해 가야하는 경우라 생각해보자.이경우 Y가 브로드 캐스트를 보내도 Z는 메세지를 받아볼 수 없다(라우터는 브로드 캐스팅을 통과시켜 주지 않는다.). 이 경우 라우터는 Y가 브로드캐스트를 보내도 Z가 대답하지 못할것을 알게된다. 그 후 라우터는 Y에게 자신 즉 라우터의 맥 어드레스를 보내면서 “나한테 전달해주면 내가 Z에게 전달해준다고 메세지를 보냅니다.” 따라서 PC Y는 PC Z에게 정보를 보낼 때 받는 맥 어드레스를 라우터의 맥 어드레스로 해서 보내게 된다. 그 다음 라우터가 Z가 있는 네트워크로 넘겨준다. 그럼 그곳에 살고있는 라우터는 Z의 맥 어드레스를 알아내고 해당 목적지로 데이터를 전송해준다. 이번에는 네트워크 통신방식에 대해 알아보자. 유니캐스트네트워크상에서 가장 많이 사용되고 있는 트래픽이다. 출발지와 목적지의 주소 즉 맥어드레스를 프레임 안에 세팅하고 통신하는 방식을 의미한다. (받는 PC의 주소를 프레임 안에 하나 넣음)특정 PC가 유니캐스트 프레임을 뿌리면 로컬 이더넷의 기본 성격이 붙어있는 모든 PC들을 일단 이프레임을 받아들여서 랜카드에서 자신의 맥 어드레스와 비교하게 된다. 자신이 받아야할것이라고 판단되면 받아서 처리하지만 자신이 받지말아야할 프레임일경우 프레임을 버리게 된다. 이 때는 PC의 CPU까지는 영향을 주지 않기 때문에 PC의 성능이 저하되는 일은 발생하지 않는다. 즉 자신의 것이 아니면 랜카드가 해당 프레임을 버리고 자신의 것이면 CPU로 올려보내준다. 브로드캐스트로컬 랜 상에 붙어있는 모든 네트워크 장비들에게 보내는 통신. 로컬랜이란 라우터에 의해 구분지어진 공간, 즉 브로드 캐스트 도메인이라고 하는공간을 뜻한다. 브로드캐스트는 통신의 대상이 특정한 어떤 한 네트워크 장비가 아니고 내가 살고 있는 네트워크 안의 모든 네트워크 장비들에게 통신할 때 쓰기위한 방식이다. 브로드 캐스트의 주소는 FFFF.FFFF.FFFF이며 이 주소를 받은 랜카드는 해당 패킷을 CPU로 올려 보내게 되고 CPU는 이를 처리하게 된다. 이로인해 유니캐스트에 비해 CPU에 부담에 많아지는 방식이다. (해당 패킷을 받으면 CPU는 하던일을 중지하고 브로드캐스트 받은 것을 처리한다.) 브로드캐스트가 발생하는 경우 : ARP - 우리동네 사는 모든 사람들에게 이 IP주소 가진사람 누구야 라고 브로드캐스팅을 보내고 응답을 통해 알아낸다. 멀티캐스트200명중 150명에게만 데이터를 보내야 할경우 150명에게 유니캐스트를 보내는것은 150번을 반복해야 하므로 트래픽을 가중시키는 행위이다. 200명 모두에게 전송하는 브로드 캐스팅 또한 불합리한 방식이다.이중 적합한 방법은 멀티캐스트이다. 멀티캐스트는 보내고자 하는 그룹 멤버들에게만 한번에 보낼 수 있으며 특정 그룹에 속해있는 사람들에게만 선택적으로, 한번에 보낼 수 있다. 만약 라우터나 스위치가 멀티캐스트를 지원하지 않는경우 이를 브로드캐스트처럼 취급해서 다 막아버리는 경우가 생길 수 있다.(라우터는 브로드 캐스트를 막는다) OSI7계층통신에 관한 국제적인 표준기구인 International Organization for Standardization(ISO)라는 곳에서 만든 OSI7레이어는 통신이 일어나는 단계를 7단게로 나눔.장점 데이터의 흐름이 한눈에 보인다. 문제 해결이 편리하다.(작은 문제들로 나누어져있음.)메일이 안보내지면 ping를 통해 연결되었나 확인하고 되어있을경우 네트워크 영역까지는 잘 동작하는것이라 판단가능(피지컬.데이터링크,네트워크) 층별로 표준화를 하므로 여러 회사 장비를 써도 이상없이 돌아간다.(케이블 국산, 랜카드 인텔, 스위치나 허브는 시스코) 피지컬 계층전기,기계,기능적인 특성을 이용해서 통신 케이블로 데이터를 전송한다. 단지 데이터를 전달만 할뿐 에러, 통신의 효율등에는 관여하지 않음. 장비로는 통신케이블,리피터, 허브등이 있다. 데이터 링크 계층정보의 오류와 흐름을 관리하여 안전한 정보의 전달 수행. 통신의 오류도 찾아주고 재전송도 하는 기능을 갖고있을 뿐 아니라 맥어드레스를 가지고 통신할 수 있게 해줌. 여기서 전송되는 단위를 프레임이라 함. 브릿지, 스위치 등이 있다. 네트워크 계층데이터를 목적지까지 빠르고 안전하게 전달하는 라우팅을 한다. 라우터가 이 계층에 속하며 스위치 중에서도 라우팅 기능을 하는것들이 있기에 스위치를 보통 Layer3 스위치라 한다. 프로토콜규약 협약이란 뜻으로 인터넷을 사용하기 위해서는 모든 PC가 TCP/IP라는 프로토콜을 사용해야 한다. 즉 프로토콜이란 컴퓨터끼리 서로 통신하기 위해서 꼭 필요한 서로간의 통신규약 또는 통신방식에 대한 약속이다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Network","slug":"CS/Network","permalink":"http://KKimSangHeon.github.io/categories/CS/Network/"}],"tags":[]},{"title":"15. 로그 관리방법(Fluentd, Elasticsearch 활용)","slug":"kube18","date":"2019-06-16T11:50:45.000Z","updated":"2019-06-23T07:37:39.594Z","comments":true,"path":"2019/06/16/kube18/","link":"","permalink":"http://KKimSangHeon.github.io/2019/06/16/kube18/","excerpt":"","text":"도커에서는 로그 라이브러리를 사용한다 해도 로그를 파일이 아닌 표준 출력으로 출력하고 이를 Fluentd 같은 로그 컬렉터로 수집하는 경우가 많다. 이를 활용할 경우 어플리케이션 쪽에서 로그 로테이션을 할 필요가 없으며 로그 전송을 돕는 로깅 드라이버 기능도 갖추고 있으므로 로그 수집이 편리하다.로그 로테이션 : 로그로테이션이란 일정시간 주기로 원본 로그 파일을 다른 이름으로 복사하고, 로그 파일을 truncate 해서 새로 로그를 쌓게 하는 일련의 과정을 말한다. 일정 시간이 지난 로그파일은 알아서 삭제를 해주기 때문에 로그파일이 계속 커지는 것을 막을 수 있다. 참고:https://www.joinc.co.kr/w/man/12/logrotate 도커의 로깅 드라이버도커 컨테이너의로그는 JSON 포멧으로 출력되는데 이는 도커에 json-file이라는 기본 로깅 드라이버가 있기 때문이다. json-file 외에도 다양한 것들을 사용할 수 있다. 도커 로그는 fluentd를 사용하는것이 정석이며 퍼블릭 클라우드에서 도커를 사용하는 경우에는 awslogs나 gcplogs를 많이 사용한다. Syslog : syslog로 로그를 관리Journald : systemd로 로그 관리Awslogs : AWS CloudWatch Logs로 로그를 전송Gcplogs : Google Cloud Logging으로 로그 전송Fluentd : fluentd로 로그를 관리. 컨테이너에서 로그 관리컨테이너가 아닐 때 어플리케이션을 당연히 로그를 파일에 출력한다. 이 방법은 컨테이너에 적용하기에는 어려움이 있다. 장애로 인해 컨테이너가 날라갈경우 로그까지 날라가는 경우가 생길 수 있다. 도커처럼 로그를 표준 출력으로 남기면 로그가 호스트에 위치한 파일에 남는다. 물론 컨테이너에 공유한 볼륨에 파일로 로그를 남기는것도 가능하지만 로그는 표준 출력으로 남기고 이 내용을 호스트에서 파일에 수집하는것이 더 간단하며 이것이 도커에서는 정석으로 여겨진다. 쿠버네티스에서 로그 관리컨테이너에서는 표준 출력으로만 로그를 내보내면 되고 이에 대한 처리는 컨테이너 외부에서 이뤄진다. 로컬 쿠버네티스 환경에 Elashticsearch와 kibana를 구축한 다음 로그를 전송할 fluentd와 DaemonSet을 구축해보자. Kibana: 로그 열람기능 활용.Fluentd: 로그 수집기. Elasticsearch로 전송하는 기능을 할 용도Elasticsearch : JVM에서 동작하는 풀텍스트 검색 엔진. fluentd로 수집한 로그를 검색하는 용도로도 사용할 수 있다. fluentd+Elasticsearch는 로그 관리에서 단골로 사용된다. 로컬에서 Elashticsearch와 Kibana 구축하기kube-system 네임스페이스에 Elashticsearch를 구축해보자.해당 네임스페이스는 쿠버네티스 클러스터의 기본 네임스페이스로 코어 컴포넌트가 배치된다. 로그는 네임스페이스를 뛰어넘어 Elashticsearch에 모여야 로그 검색에 편리하므로 Elashticsearch를 kube-system 네임스페이스에 배치한다. 1.엘라스틱서치 설치PVC, 서비스, 디플로이먼트, 컨피그맵 등의 매니페스트를 포함한 다음 파일을 생성한다.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107kind: PersistentVolumeClaimapiVersion: v1metadata: name: elasticsearch-pvc namespace: kube-system labels: kubernetes.io/cluster-service: &quot;true&quot;spec: accessModes: - ReadWriteOnce resources: requests: storage: 2G---apiVersion: v1kind: Servicemetadata: name: elasticsearch namespace: kube-systemspec: selector: app: elasticsearch ports: - protocol: TCP port: 9200 targetPort: http---apiVersion: apps/v1kind: Deploymentmetadata: name: elasticsearch namespace: kube-system labels: app: elasticsearchspec: replicas: 1 selector: matchLabels: app: elasticsearch template: metadata: labels: app: elasticsearch spec: containers: - name: elasticsearch image: elasticsearch:5.6-alpine ports: - containerPort: 9200 name: http volumeMounts: - mountPath: /data name: elasticsearch-pvc - mountPath: /usr/share/elasticsearch/config name: elasticsearch-config volumes: - name: elasticsearch-pvc persistentVolumeClaim: claimName: elasticsearch-pvc - name: elasticsearch-config configMap: name: elasticsearch-config---kind: ConfigMapapiVersion: v1metadata: name: elasticsearch-config namespace: kube-systemdata: elasticsearch.yml: |- http.host: 0.0.0.0 path.scripts: /tmp/scripts log4j2.properties: |- status = error appender.console.type = Console appender.console.name = console appender.console.layout.type = PatternLayout appender.console.layout.pattern = [%d&#123;ISO8601&#125;][%-5p][%-25c&#123;1.&#125;] %marker%m%n rootLogger.level = info rootLogger.appenderRef.console.ref = console jvm.options: |- -Xms128m -Xmx256m -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly -XX:+AlwaysPreTouch -server -Xss1m -Djava.awt.headless=true -Dfile.encoding=UTF-8 -Djna.nosys=true -Djdk.io.permissionsUseCanonicalPath=true -Dio.netty.noUnsafe=true -Dio.netty.noKeySetOptimization=true -Dio.netty.recycler.maxCapacityPerThread=0 -Dlog4j.shutdownHookEnabled=false -Dlog4j2.disable.jmx=true -Dlog4j.skipJansi=true -XX:+HeapDumpOnOutOfMemoryError 2.키바나 설치 123456789101112131415161718192021222324252627282930313233343536373839404142apiVersion: v1kind: Servicemetadata: name: kibana namespace: kube-systemspec: selector: app: kibana ports: - protocol: TCP port: 5601 targetPort: http nodePort: 30050 type: NodePort---apiVersion: apps/v1kind: Deploymentmetadata: name: kibana namespace: kube-system labels: app: kibanaspec: replicas: 1 selector: matchLabels: app: kibana template: metadata: labels: app: kibana spec: containers: - name: kibana image: kibana:5.6 ports: - containerPort: 5601 name: http env: - name: ELASTICSEARCH_URL value: &quot;http://elasticsearch:9200&quot; kubectl get pod -n kube-system 으로 파드들이 잘 돌고있나 확인해보자 localhost:30050으로 접속하여 키바나가 제대로 동작하고 있는지 보자.나의경우 localhost:30050 으로 접속이 되질 않아minikube service kibana --url -n kube-system 명령어를 통해 주소를 알아냈다. 3.DaemonSet로 fluentd 구축하기DeamonSet은 파드를 관리하는 리소스로 모든 노드에 하나씩 배치된다. 로그 컬렉터같이 호스트마다 특정할 역할을 하는 에이전트를 두고자 할 때 적합하다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455apiVersion: apps/v1kind: DaemonSetmetadata: name: fluentd namespace: kube-system labels: app: fluentd-logging version: v1 kubernetes.io/cluster-service: &quot;true&quot;spec: selector: matchLabels: app: fluentd-logging template: metadata: labels: app: fluentd-logging version: v1 kubernetes.io/cluster-service: &quot;true&quot; spec: tolerations: - key: node-role.kubernetes.io/master effect: NoSchedule containers: - name: fluentd image: fluent/fluentd-kubernetes-daemonset:elasticsearch env: - name: FLUENT_ELASTICSEARCH_HOST value: &quot;elasticsearch&quot; - name: FLUENT_ELASTICSEARCH_PORT value: &quot;9200&quot; - name: FLUENT_ELASTICSEARCH_SCHEME value: &quot;http&quot; - name: FLUENT_UID value: &quot;0&quot; resources: limits: memory: 200Mi requests: cpu: 100m memory: 200Mi volumeMounts: - name: varlog mountPath: /var/log - name: varlibdockercontainers mountPath: /var/lib/docker/containers readOnly: true terminationGracePeriodSeconds: 30 volumes: - name: varlog hostPath: path: /var/log - name: varlibdockercontainers hostPath: path: /var/lib/docker/containers 위를 apply 하자. 이는 fluent/fluentd-kubernetes-daemonset:elasticsearch 이미지를 사용한다.로그를 전달받을 Elasticsearch의 주소를 환경변수에 설정하고 데이터나 로그가 저장될 위치인 /var/lib/containers에 볼륨을 마운트한 다음 fluentd컨테이너에서 로그를 받아간다. 책에서 나온 예제를 그대로 따라하면 fluentd가 Crash났다고 뜬다.로그를 찾아 구글링 해보니 환경변수에 FLUENT_UID / 0 을 추가하라고 해서 해결함. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546apiVersion: v1kind: Servicemetadata: name: echospec: selector: app: echo ports: - protocol: TCP port: 80 targetPort: http nodePort: 30080 type: NodePort---apiVersion: apps/v1kind: Deploymentmetadata: name: echo labels: app: echospec: replicas: 1 selector: matchLabels: app: echo template: metadata: labels: app: echo spec: containers: - name: nginx image: gihyodocker/nginx:latest env: - name: BACKEND_HOST value: localhost:8080 - name: LOG_STDOUT value: &quot;true&quot; ports: - name: http containerPort: 80 - name: echo image: gihyodocker/echo:latest ports: - containerPort: 8080 위의 파일을 만들고 apply하자. minikube service echo –url 나온 주소로 curl 을 보내보자 로그 확인kibana로 접속하여 인덱스 패턴을 logstash-*로 생성한다. 이는 fluent/fluentd-kubernetes-daemonset 이미지의 기본 설정에 따라 생성된것이다. discover에서 curl보낸것에 대한 로그들을 볼 수 있다. echo 컨테이너에서 어플리케이션이 출력한 log 필드에 등록되며 그 외 레이블, 파드명, 컨테이너 명등을 볼 수 있다. 도커 쿠버네티스 로그 관리 원칙어플리케이션 로그는 모두 표준 출력으로 출력한다.nginx 등의 미들웨어는 로그가 표준 출력으로 출력되도록 이미지를 빌드한다.표준 출력으로 출력으로 출력되는 로그는 모두 JSON포멧으로 출력해 각 속성을 검색할 수 있게 한다.쿠버네티스 환경에서는 fluentd/fluentd-kubernetes-daemonset를 포함하는 파드를 DaemonSet를 사용해 각 호스트에 배포한다.쿠버네티스 리소스에는 적절히 레이블을 부여해 로그를 검색할 수 있게한다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://KKimSangHeon.github.io/tags/kubernetes/"}]},{"title":"14. 쿠버네티스 배포 전략(롤링업데이트, 블루그린)","slug":"kube17","date":"2019-06-15T12:30:25.000Z","updated":"2019-06-16T11:40:35.289Z","comments":true,"path":"2019/06/15/kube17/","link":"","permalink":"http://KKimSangHeon.github.io/2019/06/15/kube17/","excerpt":"","text":"어플리케이션을 컨테이너로 배포하는 시대에 들어오면서 배포 전략에도 변화가 생겼다. 컨테이너의 장점을 살려 작업을 자동화하고 서비스 무중단을 어떻게 유지해야 할지를 고민한다. 롤링 업데이트디플로이먼트의 파드를 교체하는 전략은 .specs.strategy.type로 정의 되며 RollingUpdate(기본값), Recreate(기존 파드가 모두 삭제된 다음 새로운 파드를 생성함) 중 선택한다. 다음 코드를 통해 서비스와 디플로이먼트를 생성하고 롤링업데이트가 어떻게 진행되는지 보자. 해당 서비스는 get 요청에 버전정보를 리턴하는 서비스이다.12345678910111213141516171819202122232425262728293031323334apiVersion: v1kind: Servicemetadata: name: echo-version labels: app: echo-versionspec: ports: - port: 80 targetPort: 8080 selector: app: echo-version---apiVersion: apps/v1kind: Deploymentmetadata: name: echo-version labels: app: echo-versionspec: replicas: 1 selector: matchLabels: app: echo-version template: metadata: labels: app: echo-version spec: containers: - name: echo-version image: gihyodocker/echo-version:0.1.0 ports: - containerPort: 8080 get요청을 지속적으로 보내어 버전정보를 출력하기 위한 파드를 정의하자.1234567891011121314151617181920apiVersion: v1kind: Podmetadata: name: update-checker labels: app: update-checkerspec: containers: - name: kubectl image: gihyodocker/fundamental:0.1.0 command: - sh - -c - | while true do APP_VERSION=`curl -s http://echo-version/` echo &quot;[`date`] $APP_VERSION &quot; sleep 1 done 다음을 입력하여 배포하자.12$ kubectl apply -f 생성한 파일(디플로이먼트,서비스)$ kubectl apply -f 생성한 파일(파드) 출력되는 버전정보를 확인해보자.1$ kubectl logs -f update-checker 위에 이미지의 버전을 변경해보자. 그리고1image: gihyodocker/echo-version:0.1.0 -&gt;image: gihyodocker/echo-version:0.2.0 반영 후 롤링업데이트를 확인해보자.123$ kubectl apply -f 수정된파일.$ kubectl logs -f update-checker 재배포 과정: 새로운 파드가 생성되고 있을 때 기존 파드는 여전히 Running이다. 이후 새로운 파드가 생성되어 실행상태가 되고 기존파드는 Terminating이 된다. 그 후 기존파드는 완전히 폐기된다. 실행중인 컨테이너에 대한 헬스체크 설정쿠버네티스의 컨테이너 헬스체크에는 livenessProbe, readinessProbe 기능이 있다. livenessProbe: 어플리케이션 헬스 체크 기능으로 어플리케이션이 의존하는 컨테이너 안의 파일이 존재하는지를 확인하는 용도로 사용된다.readinessProbe : 컨테이너 외부에서 HTTP 요청같은 트래픽을 발생시켜 이를 처리할 수 있는 상태인지를 확인하는 기능이다. 헬스체크 기능을 포함한 컨테이너는 Running 상태가 되어도 READY 가 0/1 로 나오다가 모든 헬스 체크를 통과하고 1/1로 된다. 블루그린 배포롤링업데이트는 강력하지만 새버전, 구버전이 동시에 존재하는 경우도 생길 수 있다. 이는 때로는 부작용을 가져올 수 있다. 이럴 때 사용할 수 있는것이 블루그린 배포인데 블루그린은 새버전, 구버전의 2세트의 서버를 마련하고 한꺼번에 교체하는 배포 방법이다. 이는 로드 밸런서 혹은 서비스 디스커버리 수준에서 참조 대상을 교체하는 방식으로 이뤄지는 배포형태이다. 이는 서버군이 아닌 켄테이너군을 통해 구현되고 배포할 서버군을 2게통으로 유지해야 하므로 롤링 업데이트보다 필요 리소스 양이 늘어난다. 그럼에도 다음 두가지의 장점을 누릴 수 있다.1.신버전과 구버전이 혼재하는 시간없이 순간적인 교체가능2.한쪽 서버군을 릴리즈 전 스탠바이 상태로 사용할 수 있음 블루그린 배포 실습2세트를 미리 만둘어주자. echo-version-blue.yaml12345678910111213141516171819202122232425apiVersion: apps/v1kind: Deploymentmetadata: name: echo-version-blue labels: app: echo-version color: bluespec: replicas: 1 selector: matchLabels: app: echo-version color: blue template: metadata: labels: app: echo-version color: blue spec: containers: - name: echo-version image: gihyodocker/echo-version:0.1.0 ports: - containerPort: 8080 echo-version-green.yaml12345678910111213141516171819202122232425apiVersion: apps/v1kind: Deploymentmetadata: name: echo-version-green labels: app: echo-version color: greenspec: replicas: 1 selector: matchLabels: app: echo-version color: green template: metadata: labels: app: echo-version color: green spec: containers: - name: echo-version image: gihyodocker/echo-version:0.2.0 ports: - containerPort: 8080 echo-version-blue / echo-version-green으로 정의한 두개의 디플로이먼트파일을 준비하자. metadata.label을 주목해서 보자. 그 후 다음명령어를 통해 디플로이먼트를 배포하자12$ kubectl apply -f echo-version-blue.yaml$ kubectl apply -f echo-version-green.yaml 셀렉터 레이블을 변경해 디플로이먼트를 변경할 수 있다.echo-version-service.yaml123456789101112131415apiVersion: v1kind: Servicemetadata: name: echo-version labels: app: echo-versionspec: ports: - port: 80 targetPort: 8080 selector: app: echo-version color: blue 123kubectl apply -f echo-servicekubectl logs -f update-checker 위의 명령어를 통해 서비스를 배포하고 업데이트 체크를 해보자. 1kubectl patch service echo-version -p &apos;&#123;&quot;spec&quot;:&#123;&quot;selector&quot;:&#123;&quot;color&quot;:&quot;green&quot;&#125;&#125;&#125;&apos; 위의 명령어를 입력하여 서비스 대상 디플로이먼트를 변경하자. 이후에 출력되는 버전을 보면 버전이 바뀐것을 확인할 수 있다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://KKimSangHeon.github.io/tags/kubernetes/"}]},{"title":"실습3. 프로젝트 생성 및 테스트","slug":"kube16","date":"2019-06-14T10:34:59.000Z","updated":"2019-06-15T12:27:53.138Z","comments":true,"path":"2019/06/14/kube16/","link":"","permalink":"http://KKimSangHeon.github.io/2019/06/14/kube16/","excerpt":"","text":"깃랩에 프로젝트를 커밋하기 위해 다음 과정을 거친다.다음과 같이 프로젝트를 깃랩에 생성 및 코드 반영1234567git config --global user.name &quot;sangheonKim&quot;git config --global user.email &quot;tkdgjs1501@nate.com&quot;git initgit remote add origin http://35.200.116.34/sangheonKim/sangheonProject.gitgit commit -m &quot;init&quot;git push origin master 커밋하는데 아래와 같은 에러가 뜰 경우 레파지토리 이름에 .git를 넣었는지 확인해보자. 123error: RPC failed; result=22, HTTP code = 404fatal: The remote end hung up unexpectedly 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107def label = &quot;master&quot; def notifyStarted() &#123; slackSend (color: &apos;#FFFF00&apos;, message: &quot;STARTED: Job &apos;$&#123;env.JOB_NAME&#125; [$&#123;env.BUILD_NUMBER&#125;]&apos; ($&#123;env.BUILD_URL&#125;)&quot;)&#125; def notifySuccessful() &#123; slackSend (color: &apos;#00FF00&apos;, message: &quot;SUCCESSFUL: Job &apos;$&#123;env.JOB_NAME&#125; [$&#123;env.BUILD_NUMBER&#125;]&apos; ($&#123;env.BUILD_URL&#125;)&quot;)&#125; def notifyFailed() &#123; slackSend (color: &apos;#FF0000&apos;, message: &quot;FAILED: Job &apos;$&#123;env.JOB_NAME&#125; [$&#123;env.BUILD_NUMBER&#125;]&apos; ($&#123;env.BUILD_URL&#125;)&quot;)&#125; podTemplate(label: label, containers: [ containerTemplate(name: &apos;maven&apos;, image: &apos;maven:3.3.9-jdk-8-alpine&apos;, ttyEnabled: true, command: &apos;cat&apos;), containerTemplate(name: &apos;docker&apos;, image: &apos;docker:stable&apos;, ttyEnabled: true, command: &apos;cat&apos;), containerTemplate(name: &apos;kubectl&apos;, image: &apos;lachlanevenson/k8s-kubectl:v1.8.0&apos;, command: &apos;cat&apos;, ttyEnabled: true) ], volumes: [hostPathVolume(hostPath: &apos;/var/run/docker.sock&apos;, mountPath: &apos;/var/run/docker.sock&apos;), hostPathVolume(hostPath: &apos;/root/.m2&apos;, mountPath: &apos;/root/.m2&apos;) ] ) &#123; node(label) &#123; try &#123; stage(&apos;Get Source&apos;) &#123; git &quot;http://35.200.116.34/sangheonKim/sangheonProject&quot; &#125; def props = readProperties file:&apos;deployment/pipeline.properties&apos; /*def tag = VersionNumber (versionNumberString: &apos;$&#123;BUILD_DATE_FORMATTED, &quot;yyyyMMdd&quot;&#125;-develop-$&#123;BUILDS_TODAY&#125;&apos;)*/ def tag = props[&apos;version&apos;] def gitSrc = props[&apos;gitSrc&apos;] def dockerRegistry = props[&apos;dockerRegistry&apos;] def image = props[&apos;image&apos;] def deployment = props[&apos;deployment&apos;] def service = props[&apos;service&apos;] def selector = props[&apos;selector&apos;] def namespace = props[&apos;namespace&apos;] stage(&apos;Build Maven project&apos;) &#123; container(&apos;maven&apos;) &#123; sh &quot;mvn -B clean package&quot; &#125; &#125;/* stage(&apos;Inspection Code&apos;) &#123; container(&apos;maven&apos;) &#123; sh &quot;mvn sonar:sonar \\ -Dsonar.projectKey=sangheon \\ -Dsonar.host.url=http://34.85.31.212:9000 \\ -Dsonar.login=62cf8d43f8fda31db0c5682c71b584c8650f4509&quot; &#125; &#125;*/ stage(&apos;Build Docker image&apos;) &#123; container(&apos;docker&apos;) &#123; docker.withRegistry(&quot;$&#123;dockerRegistry&#125;&quot;, &apos;registry-credentials&apos;) &#123; sh &quot;docker build -t $&#123;image&#125;:$&#123;tag&#125; .&quot; sh &quot;docker push $&#123;image&#125;:$&#123;tag&#125;&quot; sh &quot;docker tag $&#123;image&#125;:$&#123;tag&#125; $&#123;image&#125;:latest&quot; sh &quot;docker push $&#123;image&#125;:latest&quot; &#125; &#125; &#125; stage( &apos;Clean Up Existing Deployments&apos; ) &#123; container(&apos;kubectl&apos;) &#123; withCredentials([[$class: &apos;UsernamePasswordMultiBinding&apos;, credentialsId: &apos;registry-credentials&apos;, usernameVariable: &apos;DOCKER_HUB_USER&apos;, passwordVariable: &apos;DOCKER_HUB_PASSWORD&apos;]]) &#123; sh &quot;kubectl delete deployments -n $&#123;namespace&#125; --selector=app=$&#123;selector&#125;&quot; &#125; &#125; &#125; stage( &apos;Deploy to Cluster&apos; ) &#123; container(&apos;kubectl&apos;) &#123; withCredentials([[$class: &apos;UsernamePasswordMultiBinding&apos;, credentialsId: &apos;registry-credentials&apos;, usernameVariable: &apos;DOCKER_HUB_USER&apos;, passwordVariable: &apos;DOCKER_HUB_PASSWORD&apos;]]) &#123; sh &quot;kubectl apply -n $&#123;namespace&#125; -f $&#123;deployment&#125;&quot; sh &quot;sleep 5&quot; sh &quot;kubectl apply -n $&#123;namespace&#125; -f $&#123;service&#125;&quot; &#125; &#125; &#125; notifySuccessful() &#125; catch(e) &#123; print(e) currentBuild.result = &quot;FAILED&quot; notifyFailed() &#125; &#125;&#125; 12345678version=0.1.0cluster=devcluster.icpnamespace=defaultdockerRegistry=http://docker-registry.default.svc.cluster.local:5000image=http://docker-registry.default.svc.cluster.local:5000/default/masterapideployment=deployment/masterapi-deploy.yamlservice=deployment/masterapi-svc.yamlselector=masterapi 1234567891011121314151617apiVersion: extensions/v1beta1kind: Deploymentmetadata: name: masterapi-sangheonkimspec: replicas: 3 template: metadata: labels: app: masterapi-sangheonkim spec: containers: - name: masterapi-sangheonkim image: http://docker-registry.default.svc.cluster.local:5000/default/masterapi imagePullPolicy: Always ports: - containerPort: 8280 다음 그림처럼 파이프라인을 생성하자 kubectl create clusterrolebinding default-binding –clusterrole=cluster-admin –user=admin –user=kubelet –group=system:serviceaccounts:default 1234567Running in Durability level: MAX_SURVIVABILITY[Pipeline] Start of Pipeline[Pipeline] podTemplate[Pipeline] &#123;[Pipeline] nodeStill waiting to schedule taskWaiting for next available executor 위와 같은 오류가 뜬다면","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://KKimSangHeon.github.io/tags/kubernetes/"}]},{"title":"실습2. 젠킨스 설정(깃랩, 도커레지스트리,슬랙, 소나큐브 연동)","slug":"kube15","date":"2019-06-11T10:57:54.000Z","updated":"2019-06-14T11:15:22.586Z","comments":true,"path":"2019/06/11/kube15/","link":"","permalink":"http://KKimSangHeon.github.io/2019/06/11/kube15/","excerpt":"","text":"젠킨스 플러그인 설치Jenkins관리 -&gt; 플러그인 관리에 들어가서 다음 항목을 설치하자.1234567891011Build Pipeline(Build Pipeline Plugin?)Aqua MicroScannerGitlab Authentication pluginGitLab PluginKubernetesPipelinePipeline Utility StepsSimple Theme PluginSlack NotificationSonarQube ScannerVersion Number Plug-In 젠킨스 설정1. 깃랩과 연결우측 상단 이미지를 클릭하고 User Setting로 들어가서 Access Token 탭을 선택한다.3개 모두 체크하고 토큰을 생성하자. Jenkins 관리-&gt; 시스템 설정으로 들어간 후 위와같이 connection name, gitlab host url(이전에 생성했던) 설정 위의 화면의 Credentials 옆 Add-&gt;Jenkins를 선택 Kind를 위와 같이 선택하고 API token, Id, Description 입력하고 추가하고 Test Connection을 눌러 잘 동작하나 확인해보자. Jenkins location을 설정하고 email을 위와같이 설정 2. 도커레지스트리와 연결위와같이 설정 Add 버튼 클릭 3. 슬랙과 연동슬랙에서 Apps선택하고 jenkins검색하여 view를 클릭하면 새 창이 나온다. Add Configuration 클릭 노티를 보낼 슬랙을 선택 후 Add Jenkins CI integration 클릭 다음과 같이 친절하게 스탭별로 알려주므로 따라하면 된다. 스텝에서 설명하는 그림과 약간 다를 경우 Integration Token Credential ID 옆의 Add를 누르고 Secret text로 선택하여 추가하면 된다. 그 후 Test Connection을 클릭하여 테스트해보자 4. 소나큐브 연동생성한 소나큐브에 접속 및 admin/admin으로 로그인 Create new project 선택 다음과 같이 프로젝트키, 디스플레이 네임 입력. 생성된 토큰을 기록해둔다. Continue를 클릭하여 다음과같이 진행한다.(프로젝트의 종류에 따라 다를 수 있음)","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://KKimSangHeon.github.io/tags/kubernetes/"}]},{"title":"실습1. helm을 이용한 툴 설치","slug":"kube14","date":"2019-06-11T10:57:50.000Z","updated":"2019-06-15T14:58:59.586Z","comments":true,"path":"2019/06/11/kube14/","link":"","permalink":"http://KKimSangHeon.github.io/2019/06/11/kube14/","excerpt":"","text":"깃랩설치1.깃랩설치helm install –name sangheon-gitlab –set externalUrl=http://sangheon-gitlab.com stable/gitlab-ce 2.접속1234$ kubectl get svc -w sangheon-gitlab-gitlab-ce # 설치가 잘 되었나 확인$ export SERVICE_IP=$(kubectl get svc --namespace default sangheon-gitlab-gitlab-ce -o jsonpath=&apos;&#123;.status.loadBalancer.ingress[0].ip&#125;&apos;)$ echo http://$SERVICE_IP/ # 접속해보자 처음 접속하면 root 계정의 password를 설정하게 된다. 설정하고 root로 로그인해보자. 젠킨스 설치1.젠킨스 설치1$ helm install --name sangheonkim-jenkins stable/jenkins 2.접속1234567$ printf $(kubectl get secret --namespace default sangheonkim-jenkins -o jsonpath=&quot;&#123;.data.jenkins-admin-password&#125;&quot; | base64 --decode);echo출력값을 잘 기억하자. admin의 password이다.$ kubectl get svc --namespace default -w sangheonkim-jenkins$ export SERVICE_IP=$(kubectl get svc --namespace default sangheonkim-jenkins --template &quot;&#123;&#123; range (index .status.loadBalancer.ingress 0) &#125;&#125;&#123;&#123; . &#125;&#125;&#123;&#123; end &#125;&#125;&quot;)$ echo http://$SERVICE_IP:8080/login 출력된 주소로 접속하여 admin/출력된 password를 입력하자. 소나큐브 설치1.설치 1$ helm install --name sangheonkim-sonarqube stable/sonarqube 2.접속12345$ kubectl get svc -w sangheonkim-sonarqube-sonarqube$ export SERVICE_IP=$(kubectl get svc --namespace default sangheonkim-sonarqube-sonarqube -o jsonpath=&apos;&#123;.status.loadBalancer.ingress[0].ip&#125;&apos;)$ echo http://$SERVICE_IP:9000 dockerRegistry 구축1.설치1$ helm install --name docker-registry stable/docker-registry 2.접속12345$ export POD_NAME=$(kubectl get pods --namespace default -l &quot;app=docker-registry,release=docker-registry&quot; -o jsonpath=&quot;&#123;.items[0].metadata.name&#125;&quot;)$ echo &quot;Visit http://127.0.0.1:8080$ kubectl port-forward $POD_NAME 8080:5000 http://127.0.0.1:8080 로 앱에서 접속가능한듯? 포트포워딩을 통해 5000으로도 가능?http://docker-registry.default.svc.cluster.local:5000 /","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://KKimSangHeon.github.io/tags/kubernetes/"}]},{"title":"MSA이론4. DevOps","slug":"msa4","date":"2019-06-08T05:19:44.000Z","updated":"2019-06-11T11:05:58.469Z","comments":true,"path":"2019/06/08/msa4/","link":"","permalink":"http://KKimSangHeon.github.io/2019/06/08/msa4/","excerpt":"","text":"DevOpsUsing DevOps to Solve your Delivery Challenges 배포는 너무 오래걸린다. 테스트에 대해 혼란스럽다. 특정 개인에 대한 높은 의존성. 데브옵스 모델은 lock을 제거한다. 데브옵스 모델은 프로비저닝한다. Delivery는 Continuous integration + continuous deployment를 의미한다. 데프옵스의 특징 높은신뢰성, 높은 퍼포먼스 데브옵스는 프로덕트, 툴이아니다. 데브옵스는 문화이다. 고수준의 자동화 프로세스 정기적이고 반복적인 플로우를 따른다. 싸이클은 짧고, 작고 잦은 변경을 선호한다. DevOps 데브옵스의 철학은 개발과 운영의 통합 문화를 만들고, 협업 변화를 촉진하기 위해 기술의 linked toolchain 을 요구하는 것이다.toolchain? : Target 시스템의 Software 개발을 진행하기 위해 필요한 host system의 Cross Compile(교차 컴파일) 환경이다. DevOps의 toolchain은 수십개의 non-collaborative 툴을 포함할 수 있고, 복잡하고 어려운 작업을 자동화를 통해 task로 만들 수 있다. DepOps의 정의에 따르면 one-size-fits-all이 해결책이 아니다. DevOps는 특정 문제 및 과제에 대한 정보를 제공한다. DevOps를 위한 microservice requirements microservice에 기반한 새로운 어플리케이션을 빌드하라 기존 microservice 어플리케이션을 클라우드로 마이그레이션하라 하이브리드 microservice 어플리케이션을 배포하라 존재하는 어플리케이션들을 microservice architecture로 발전하라. Microservice 배포를 위해 따라야 할 Roles 개발자는 테스트를 반복하며 각 테스트는 pass해야한다. 또한 계속되는 피드백에 대비하자. 테스터는 자동화 된 파이프라인에 컴포넌트, 통합, 회귀를 포함하고 크로스 플랫폼간 API를 통해 테스트가 가능토록 하자. 성능테스터는 로딩 테스팅을 모니터링하고 blue/green, rolling 배포를 하자. rolling 배포:일반적인 배포를 의미하는데, 단순하게 한 대씩 재시작한다. 코드 변경에 따른 side effect가 발생할 수 있다blue-green 배포: 예전 배포물을 블루(blue), 신규 배포물을 그린(green)이라고 해서 붙여진 이름이다. 새로운 배포물을 배포하고 모든 연결을 새로운 배포물만 보게 하며 코드 변경에 따른 side effect가 없다. (배포시 중단시점이 없음!) Release 하는사람은 성능 측정을 해야한다. 운영자는 가용성을 모니터링하고 blue/green 배포를 해야한다. 엔드유저는 지속적인 피드백을 주고 변경에 대해 대비한다. DevOps의 평가기준배포빈도(얼마나 자주 배포하나) 최상: 요구될때마다 보통: 일주일 혹은 한달에 한번 최하: 한달에서 여섯달 사이에 한번 Lead time for changes(ie.코드가 커밋되고 정상적으로 동작하는데 걸리는 시간) 최상: 한시간 이내 보통: 일주일 ~ 한달사이 최하: 한달~여섯달 사이 Mean time to recover(복구하는데 걸리는 시간) 최상: 한시간 이내 보통: 하루 이상 최하: 하루 이상 Change failure rate 최상: 0~15% 보통: 31~45% 최하: 16~30% Database 관련 생각해봐야 할것들 Production data에 대한 보호,보안(바꾸는 것은 리스크가 있다) Test data 필요 환경이 다름 의존성 다수 어플리케이션이 동일 db에 접근한다. 이전버전과 호환성 유지 롤백을 어떻게 할지 DevOps ValuesCALMS Culture - 변화를 수용하라 Automation - CI/CD Lean - 엔드유저가 생상하는 value에 초점을 맞추고, 배치사이즈를 작게하라 Measurement - 모든것을 측정하고 개선된것을 보여줘라 Sharing - 정보를 공유하고 협업하라 DevOps ToolsConfiguration Automation / Management: Puppet, Ansible, Chef, SaltContinuous Integration:Jenkins, CruiseControl, CapistranoMonitoring:Icinga (nagios), Zenoss, Sweet, GraphiteContainerization: Docker, Rocket DevOps 관련용어CI/CD Continuous Integration 그리고 Continuous Deployment의 약어 Continuous integration 최신코드에서 변경된것을 사용가능하도록 빌드한다. Continuous deployment 가능한 빠르게 배포 단계를 거치고 빌드된 해당 패키지가 프로덕션 환경으로 전환되도록 한다. Continuous delivery Continuous integration + continuous deployment Delivery pipeline 일련의 자동화 단계로써 CI/CD를 수행한다. Continuous Integration아래와 같은 단계를 빈번하게 수행한다. 1. Development 배치 테스를 거친 작은 변화들이 빠르게 구현된다. 2. SCM(Source Code management) 여러 개발자의 변경된것사항을 병합한다.(GitHub, SVN … 활용) 3. Build 배포할것을 만든다.(Jenkins, Gradle, Maven … 활용) 4. Package 런타임때 빌드를 설치한다. 변경할 수 없는 이미지를 런타임때 releasing 한다. 클라우드에 푸쉬하고 컨테이너 이미지 빌드 Continuous integration – package steppackage step에선 변경 불가능한 이미지가 만들어진다. 이는 deploying instance를 생성할 때 사용된다. 이미지를 변경하고 싶다면 삭제하고 새로 만들어야 한다. Continuous DeploymentProduction 배포까지의 과정1. Deploy to Test functional testing 진행, test tool을 활용한 자동화2. Deploy to Stage Production 배포 전 리허설 통합 testing 진행3. Deploy to Prod 사용자가 사용할 수 있도록 빌드 Continuous Delivery vs continuous Deployment Zero Downtime Deployment서비스 중단없이 새로운 버전을 배포하는것을 의미한다. DevOps는 잦은 배포를 하므로 필요하다. Zero Downtime Deployment 특징 어플리케이션은 항상 사용가능하다. 사용자가 중단(Downtime)없이 사용할 수 있다. 이전버전, 새버전이 동시에 배포됨 - 트래픽이 둘 다로 전달됨. Implementing Zero Downtime Deployment – Blue GreenDeployment필요한경우 이전버전으로 신성하게 되돌릴 수 있다. 1.v1(blue)이 배포되어 사용자들이 사용하고 있을 때 v2(green)을 배포한다.2.자동화된 테스트 도구로 테스트, 검증을 진행하고 사용자를 v1에서 v2환경으로 변환한다.3.v1(blue)을 삭제한다. DevOps로의 Transformation Top to Bottom문화를 변화시키는 것이 핵심이다. 교육을 늘리고 커뮤니케이션하고 cross-skilling 하라 DevOps가 가능한 새로운 프로세스를 평가하라 스스로 재평가하고 재빌드하라 DevOps를 지원하는 새로운 기술 평가 조직을 작게 나눠라 Bottom-Up Implementation 협업을 위한 방법을 찾아라. (사람들을 초기부터 참가시킨다.) 자동화 방법을 찾아라 metrics driven이 되어라 새로운것을 배우고 지속적으로 개선해라 작은 batches와 함께 병렬적으로 일해라 리팩토링을 허락해라 경영진에게 비즈니스 가치를 입증해라 비즈니스의 목표, metrics, 우선순위를 이해하라. Top-Down Implementation 시험 케이스를 파일럿으로 선택하라 우수 사레를 문서화하고 전파하라 팀의 역량을 강화하고 가치를 이끌어내라 측정 가능한 결과를 요구하라 과거의 baseline이 충분치 않을때 변명하지 마라 빠르게 실패하고 지속적으로 향상하라 작은성공을 기반으로 나아가라 비효율적인 경우 그룹간 역할 및 책임을 조율하라.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"MSA","slug":"MSA","permalink":"http://KKimSangHeon.github.io/tags/MSA/"}]},{"title":"MSA이론3. Database Design for Microservices","slug":"msa3","date":"2019-06-08T05:18:22.000Z","updated":"2019-06-11T11:05:18.913Z","comments":true,"path":"2019/06/08/msa3/","link":"","permalink":"http://KKimSangHeon.github.io/2019/06/08/msa3/","excerpt":"","text":"Database Design for Microservices트랜잭션, Aggregates에 영향을 많이끼친다. Front Microservice는 쉽다. ACID가 적용되는 것들Transaction, Aggregates, Entity ACID vs BASEACID Atomicity, Consistency, Isolation, and Durability Strong consistency commit에 초점을 맞춘다. 보수적이다.(혁신이 어렵다) BASE Basically Available, Soft-state, Eventual consistency Weak consistency Availability first 간단하고 빠르다(혁신이 쉽다) 구현을 위해 생각해보자 마이크로서비스에서 데이터는 dependency를 갖기 때문에 어려운부분이다. microservice에 각각의 db가 있을 때 어떻게 읽고 어떻게 업데이트할까? join활용 data inside, 서비스, data outside 를 이해할 필요가있다. 데이터를 어떻게 읽고 업데이트하는가? 읽고 쓰는 명령 쿼리를 분할한다.(CQRS, Command Query Responsibility Segregation) Two-phase commit모든 트랜잭션은 트랜잭션 관리자를 거쳐야 한다. 이는 모든 서비스에서 트랜잭션을 보장하며 커밋 요청, 커밋 두단계의 메커니즘을 거친다. 커밋요청단계(커밋 투표단계라고도 함) : 관리자가 모든 서비스에 커밋메세지 쿼리를 보낸다. 관리자는 모든 서비스의 투표 결과를 대기하고 각 서버는 커밋해야 할 지점까지 트랜잭션을 수행한다. 서비스는 일부가 준비되지 않아도 동의한다는 응답을 보낸다. 커밋단계(완료단계라고도 함) 관리자가 모든 서비스에서 동의를 받았을 때: 관리자는 트랜잭션 커밋을 요청하는 메세지를 모든 서비스에게 전송한다. 커밋 후에 서비스는 트랜잭션이 끝났다는 확인을 관리자에게 보낸다. 관리자가 하나 이상의 거절을 받았을 때 : 관리자는 모든 서비스들에게 롤백을 요청하고 서비스는 롤백 후 관리자에게 승인응답을 보낸다. Two-phase commit 의 장점많은 DB가 영향을 받을경우 이를 하나의 트랜잭션으로 다루는것이 좋다.준비단계는 모든 구성요소가 커밋을 허용하는지 확인하는 단계이다. Two-phase commit 의 단점 관리자는 서비스에서 메세지를 수신할 때 까지 잠금이 걸려 리소스가 해제되지 않음.(가용성 측면) 서비스 중 하나가 커밋을 거부하면 모든 서비스가 롤백한다.(일관성을 유지할 수 있다는 장점) 서비스에서 응답을 수신할 때 까지 잠금,리소스가 해제되지 않음 NoSQL을 지원하지 않음. 최소 O(4n) 메세지 발생, 여러번시도할 경우 O(n^2) lock으로 인한 처리량 감소 Distributed Transactions in Microservices microservice에는 ACID를 적용하기가 복잡하다. 이는 microservice Architecture가 Single Responsibility Principle (SRP)를 따르므로 각 microservice가 해당 데이터를 유지하고 관리해야하고, microservice의 책임에 대한 지식없이는 다른서비의 데이터에 접근할 수 없기때문이다. 위 그림에서 두개의 microservice가 하나의 db에 연결되어있는게 왜 잘못되었을까? 우측의 경우에는 API, Queue로 해당 호출이 가능하다. 하지만 좌측의 경우에는 두개의 db 아답터가 가 존재해야 하는데 Isolation 원칙을 위배한다. Distributed Transaction – Event Driven Architecture &amp; Two Phase Commit 이는 가장 일관된 시스템을 제공하지만 Two Phase Commit으로 인해 시스템 성능에 부정적 영향을 끼친다. 이벤트는 트랜잭션의 매 단계를 실행시키는 트리거이며 각 이벤트는 고유한 ID를 갖는다. 또한 작업이 처리되었으면 커밋되었음을 나타내야 한다. 위의 그림은 microservice1이 microservice2에 자동이체를 하는 트랜잭션이다. completed라는 컬럼은 트랜잭션이 커밋되어야 하는지를 나타내며 microservice1이 완료되면 microservice2를 호출하여 트랜잭션을 완료한다.(그림은 microservice1의 작업이 커밋되고 microservice2의 작업이 커밋되기 전 단계) CAP Theorem 분산시스템에서는 일관성(Consistency), 가용성(Availability,항상 데이터를 읽고 쓸 수 있음), 분할 용인(Partition tolerance,데이터베이스를 분할할 수 있고 네트워크 중단에도 계속 동작할 수 있다.)이라는 세 가지 조건을 모두 만족할 수 없다. 대부분 세 조건중 두 가지만 만족시킬 수 있다.만약 가용성을 만족시키려면 BASE(Basically available, soft state, eventually consistent)를 생각해 볼 수 있다. 이를 위해 앞서 설명한 Event Driven Architecture를 도입할 수 있다.BASE : 기본적으로 Availability하고, 사용자가 관리하지 않으면 데이터가 expire 될 수 있으며, 언젠가는 데이터가 일관성을 가진다는 것. Eventual Consistency and Compensation microservice에서 일관성을 다루는 것중 가장 실현 가능한것은 Eventual Consistency이다. microservice에서 분산 ACID 트랜잭션을 사용하지 않는다. 대신 미래의 어떤시점에서는 시스템이 결국 일관성을 유지할것을 제안한다. Eventual Consistency 서비스는 종종 BASE를 제공하는것으로 분류된다. Eventual Consistency는 분산 소프트웨어의 복잡성을 증가시킨다고 비판받기도 하는데 이는 동일값을 읽는다는 안전보장을 하지 않기 때문에 발생한다(결국에는 읽었을 때 동일값을 반환 함 예시로 배치프로그램이 있음). Eventual Consistency의 예시다음의 문제를 해결해야 된다고 가정해보자. user profile 등록 백그라운드에서는 사용자가 시스템에 접근할 수 있는지 자동으로 확인 Eventual Consistenc 적용을 하려면.. user의 접근 가능유무는 반드시 필요하다. user검증 시간이 오래 걸리더라도 microservice로 분할해야한다. compensation을 포함한 message-driven방법 적용 user profile을 등록하는 작업 백그라운드에서 유효성을 검사하는 microservice 지속적인 큐를 제공하는 메세지 플랫폼(메세지 플랫폼은 microservice가 보낸 메세지가 지속가능토록 한다. 수신부가 문제가 있다면 나중에 배달해주기도 함)-이는 하나의 microservice가 중지될 경우 정보는 다른 큐, 서비스에 존재한다. 즉 지속성을 보장한다. 위의 방법을 적용했을 때 좋은 시나리오 user microservice는 user를 등록하고 로컬 db에 정보를 저장한다. user microservice는 플래그를 활용해 해당 user가 검증 과정을 거치지 않음을 표시한다. user에게 지금 당장은 접근 불가능하다는 경고를 보낸다. user microservice는 백그라운드에서 user검증을 위해 validation microservice에 메세지를 보낸다. 검증결과 접근가능하다면 user microservice는 user를 unblock한다/ 검증결과 접근 불가능하다면 user microservice는 user 계정을 제거한다. (이를 compensation(보상)단계라고 볼 수 있다.) 일련의 과정을 거친후에는 시스템은 일관된 상태이다. 하지만 일정기간동안은 사용자 엔티티가 불완전한 상태였다. 위의 방법을 적용했을 때 좋지 않은 시나리오 validation microservice에 접근할수 없는경우 메세지 플랫폼은 나중에 validation microservice가 접근 가능하게 되었을 때 validation microservice는 메세지를 받아볼 수 있다. 메세지 플랫폼에 문제가 발생하면 user microservice는 또 다시 다른 user의 검증 메세지를 보낸다. validation microservice가 메세지를 받게되면 user를 검증하지만 메세지 플랫폼 문제가 발생하면 응답을 보내지 못하고 추 후 다시 보낸다. 그러나 일부메세지가 여러번 발행되더라도 데이터 일관성에는 영향을 미치지 않는다.발생할 수 있는 좋지 않은 시나리오들을 고려함으로써 Eventual Consistency를 충족시킬 수 있으며 비용소모가 심한 distributed transactions를 처리할 필요가 없다. Distributed Transactions: The Solution결제하고 배송하는 시스템을 Distributed Transaction방식으로 구현한다고 해보자 위와 같은 방식으로 할 수 있으나 일련의 과정은 동기방식이다.이를 비동기 방식으로 처리하기 위해 아래와 같은 방식을 따르면 된다. 즉 쓰레드를 하나 만들어서 처리한다. 안전한 Distributed Transactions를 위해서 원격 업데이트에 대한 영향 감수 원격 업데이트를 시도하고 응답을 받지 못했을 경우 재시도를 해야한다. 또한 응답이 오더라도 자체 대기열을 업데이트하지 못할 경우 대기열이 사용가능해지면 다시 시도해서 업데이트 해야한다. 재시도로 발생하는 중복수신은한번만 처리한다 하나의 작업단위를 완료하더라도 시스템 오류가 발생하면 동기화 되지 않을 수 있다. 이를통해볼 때 microservice는 Distributed 트랜잭션에 호의적이지 않다. 동기관련 문제를 해결할 수 있는 메세지 브로커 Two Consequences of Eventual Consistency 재시도를 하는것은 시스템에 문제가 생긴것을 의미한다. 일관성이 결국에는 생기는것이기 때문에 비즈니스 일관성이 충돌하는 경우도 있을 수 있다.만약 책을 구매하는 비즈니스가 있다고 할 때 결제를 하는순간 재고가 있어 결제가 진행되었는데 결제가 완료되는 순간 재고가 없을 때를 가정해보자. 이 때는 비동기식으로 사용자에게 다시 보고하지 않고 환불절차를 진행 후 직원이 처리 할 내용을 conflicts큐에 넣고 제공할 수 있다. Saga Pattern : microservice에서 어떻게 비즈니스 트랜잭션을 구현 할것인가.트랜잭션은 어플리케이션의 필수적인 부분이다. 트랜잭션이 없다면 데이터의 일관성을 유지하는 것은 불가능하다. 가장 강력한 트랜잭션 유형중 하나는 Two-Phase Commit이다. 이는 여러 엔티티를 동시에 업데이트 할 때 유용하다.(ex. 주문확인 및 재고 업데이트) 그러나 microservice로 작업할 경우 데이터베이스가 분리되므로 로컬 Two-Phase Commit를 활용하여 전체 시스템의 일관성을 간단하게 유지할 수 없다. 이 경우 RDBMS와 마찬가지로 단일엔티티 원자 트랜잭션이 가능한 Couchbase와 같은 NoSQL 데이터베이스를 사용하면 수십배 빠르게 처리할 수 있다. 그래서 microservice를 사용하는 대다수 기업들이 NoSQL을 사용하고 있다. SAGA Pattern 분산 트랜잭션의 잘알려진 패턴중 하나가 SAGA이다. SAGA는 일련의 local 트랙잭션들을 의미하며 각 트랜잭션은 하나의 서비스안에서 데이터를 업데이트 한다. 첫 번째 트랜잭션은 시스템 작업에 해당하는 외부 요청에 의해 시작되고 이후엔 이전단계 완료가 될 때마다 트리거링되어 작동한다.-SAGA 트랜잭션을 구현하는 인기있는 두 가지 방법이 있다.1. Events/Choreography각 서비스는 다른 서비스의 event, decides를 보고 action을 할지 말지 결정하며 non centralize 한것. (발레와 유사함) 첫번째 서비스는 트랜잭션을 실행하고 이벤트를 publish한다. 발행된 이벤트는 하나 혹은 그 이상의 서비스가 지켜보며 해당 이벤트는 로컬 트랜잭션을 실행하고 새로운 이벤트를 publish한다.분산 트랜잭션은 마지막에 서비스가 로컬 트랜잭션을 실행할 때 종료된되며 마지막 이벤트는 이벤트를 publish하지 않는다.분산 트랜잭션의 경우 롤백에 대한 로직은 직접 만들어야 한다. Event/Choreography design의 장단점 이해하기 쉽고 SAGA패턴을 구현하는 자연스러운 방법이다. 구축에 많은 노력이 필요하지 않으며 느슨한 결합을 유지한다. 2~4단계로 구성되는 트랜잭션에 매우 적합하다. 어떤 서비스가 어떤 이벤트를 수신하는지 추적하기 어렵기 때문에 단계를 계속 추가할 경우 혼란스러울 수 있다. 2. Command/Orchestration : coordinator 서비스가 의사결정 및 sequncing 비즈니스 로직에 대한 책임이 있는 것. 즉 centralize 한것. (오케스트라와 유사함) Orchestration 접근법에서는 각 참가자에게 할 일을 알려줄 책임이 있는 새로운 서비스를 정의한다. 각 서비스와 명령/응답 형태로 통신하여 수행해야 할 작업을 알려준다. 위 그림의 경우 Orchestration은 트랜잭션을 실행하는데 필요한 흐름을 알고있다. 만약 트랜잭션이 실패하면 이전 작업을 취소하기 위해 각 참가자에게 롤백 명령을 보내야 한다. 롤백은 Orchestrator을 갖고있으면 훨씬 쉽다. saga orchestrator을 모델링하는 표준 방법은 각 변환이 명령 또는 메세지에 해당하는지에 대한 State Machine이다. State Machine는 구현하기 쉽고 테스트에 적합하기 때문에 잘 정의된 동작을 구조화 하는데 훌륭한 패턴이다. Event/Choreography design의 장단점 saga orchestrator는 saga participants를 호출할 수 있지만 saga participants는 saga orchestrator를 호출할수 없기에 서비스간 cyclic 종속성을 피할수 있다. command에 대해 응답 혹은 실행만 하므로 participants간 복잡성을 줄일 수 있다. 새로운 단계가 추가될 때 트랜잭션의 복잡성은 linear하게 늘어난다. 쉬운 롤백관리 가능 첫번째,두번째 트랜잭션이 동일한 개체를 변경하고자 할 때 orchestrator를 활용하여 첫번째 트랜잭션이 끝날때 까지 두번째 트랜잭션을 보류상태로 둘 수 있다. 하지만 이는 orchestrator에 많은 로직이 들어가 risk가 있다 추가 서비스를 관리해야 하므로 인프라 복잡성이 증가한다. Saga Pattern Tips트랜잭션마다 unique Id를 만들어라 이를 통해 추적이 가능하고 participants간 통신을 위한 표준방법을 갖는데 도움을 준다.command에 응답 address를 추가해라 participant가 고정된 주소에 응답하기 보다는 message에 응답 address를 추가하여 보내는것을 고려해봐라. 이를 통해 participants는 여러 orchestrator에 응답할 수 있다. 큐(SQS, Kafka, RabbitMQ, etc)를 사용할 경우 서비스간 통신할 수 있다. 버그로 인해 원치않은 메세지를 수신함으로써 데이터베이스가 엉망이 될 수 있다.동기식 통신을 피하라 이를 통해 더 많은 데이터를 요청할 수 있고 다른 서비스가 오프라인 일 때도 서비스가 로컬 트랜잭션을 실행할 수 있다. orchestrator는 각 요청/응답을 다뤄야하므로 선형적으로 복잡성이 증가한다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"MSA","slug":"MSA","permalink":"http://KKimSangHeon.github.io/tags/MSA/"}]},{"title":"MSA이론2. Microservice Architecturure","slug":"msa2","date":"2019-06-08T05:18:16.000Z","updated":"2019-06-11T11:09:16.950Z","comments":true,"path":"2019/06/08/msa2/","link":"","permalink":"http://KKimSangHeon.github.io/2019/06/08/msa2/","excerpt":"","text":"Microservices Architecture 비즈니스 로직을 나누었다. 큰 프로그램 대신 몇몇의 작은 어플리케이션이다. 잘 정의된 API로 소통한다.(HTTP, AMQP 활용) 하나의 서비스가 정지될경우 다른것에 영향을 미치지 않는다 What is Microservice Architecture? 각각의 컴포넌트를 시스템에 집어넣는것이며 각각 빌드되고 배포될수 있다. Microservice 는 vertical 하며 layered하다. 또한 Process driven 형태이다. Microservice를 잘 정의하면 TDD가 가능하다. 엔터프라이즈 아키텍처가 아니다. Microservice Architecture는 SOA와 유사하다. 단일 비즈니스 기능을 구현한다. 자신만의 데이터베이스를 갖는것이 일반적이나 데이터베이스를 갖지않는경우도 있다. HTTP, AMQP 로 통신한다. 독립적으로 배포가 가능하다. 각각의 레파지토리를 갖는다. 마이크로 서비스 팀은 몇명이 적당할까? 피자 두판을 먹을 수 있을만한 인원수! 6명 ? 좋다! Microservice의 구성 Data Store Application/Logic Public API(POST, GET ) Microservices application의 전형적인 생태계원칙1. Microservices들은 각 public API에 서로 의존한다. 백엔드의 마이크로 서비스는 노출되면 안된다. 오직 프론트 마이크로 서비스만 노출되어야 한다. 원칙2. 작업에 적합한 tool(ex. 프레임워크)을 사용하라. 원칙3. 서비스 보안에 신경써라 원칙4. 생태계에서 좋은 시민이 되어라! 모니터링, 로깅, 추적을 분산하라 원칙5. 기술 변화 이상의 것이다. 조직 변화를 수용하라 원칙6. 모든것을 자동화하라(DevOps!) Micro Service를 위해서… 비즈니스 도메인을 이해하자 일관성 유지하자 서비스 발견해보자 불필요한 상호통신이 많다면 조정해보자 Microservice 계획하기 정말 옳은 선택인가?(트레이드 오프 고려) 시스템의 주요기능을 식별하자 서비스 컴포넌트의 스코프를 세부적으로 결정하라(Function의 크기, 타입, 복잡성) API들을 디자인하라 커뮤니케이션의 메커니즘을 결정하라 데이터 모델을 결정하라(중앙 데이터베이스 vs 여러 데이터 저장소) Benefits of microservices 각각의 microservices를 쉽개 확장할 수 있다 빠른 빌드, 테스트, 릴리즈의 싸이클 agility의 증가 빠른혁신이 가능하다. 명확한 소유권 그리고 책임의 분배. Microservice Architecture 각 microservice는 컨테이너에 할당된다. 컨테이너는 microservice 기반 어플리케이션을 개별적으로 개발, 배포하기 좋은 방법이다. microservice 간 stateless server 형태로 소통한다. 클라이언트는 서비스를 바로 호출할수 없고 API 게이트웨이가 클라이언트의 요청을 적절한 microservice로 전달한다.(API 게이트웨이는microservice로인가요? 하드웨어나 소프트웨어로 볼 수 있다. microservice로 일수도 있지만 아닐수도 있다.) 각 서비스는 상호 독립적이다. Single-responsibility 원칙을 따름 아무것도 공유하지 않는다. 비동기가 가능하다. configuration의 외부화 결합도가 느슨하다. 하나의 서비스가 문제를 일으켜도 나머지는 상관없다. Microservices - DisadvantagesComplex networking으로 인해 데이터베이스, 서버의 오버헤드 발생 Monolithic Architecture vs Microservice Architecture Monolithic Architecture : 모든 기능이 단일 코드베이스에 위치하고 하나의 DB를 사용한다. 또한 한 기능이 마비되면 전체가 마비되며 크고 복잡한 어플리케이션형태 Microservices vs SOA SOA 컨센은 centrallize이다.MS는 not centrallize이다.즉 SOA는 오케스트라와 같다. (한 지위자가 전체를 통솔한다) Microservices는 발레와 같다. (각 댄서가 각자 율동한다) Monolithic Architecture vs SOA vs Microservices coarse-grained : 특정 프로세스(서비스)를 큰 덩어리로 나누는것fine-grained : 특정 프로세스(서비스)를 잘게 쪼개는 것 Microservices를 구현해야 하는 9가지 이유 Easy To Build &amp; Maintain Continuous Delivery Hybrid Technologies Cross Team Coordination Higher Quality Code Smarter Scaling Risk Reduction Promote Big Data Best Practices Improved ROI with reduced TCO Illustration of Monolithic Module Refactoring Microservice Architecture는 3계층이다.Container/ Orchestration /Application The twelve FactorsI. Codebase: One codebase that is tracked in revision control, with many deploymentsII. Dependencies: Explicitly declare and isolate dependenciesIII.Configuration: Store Configuration in the environmentIV.Backing services: Treat backing services as attached resourcesV. Build, release, run: Strictly separate build and run stagesVI.Processes: Execute the app as one or more stateless processesVII.Port binding: Export services with port bindingVIII.Concurrency: Scale out using the process modelIX.Disposability: 빠른 시작 및 효율적인 종료가 가능하다.X. Development and production parity: Keep development, staging, and production as similar as possibleXI.Logs: Treat logs as event streamsXII.Admin processes: Run administrative and management tasks as one-off processes","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"MSA","slug":"MSA","permalink":"http://KKimSangHeon.github.io/tags/MSA/"}]},{"title":"MSA이론1. Domain-Driven Design / Aggregates","slug":"msa1","date":"2019-06-06T10:26:59.000Z","updated":"2019-06-11T11:08:15.923Z","comments":true,"path":"2019/06/06/msa1/","link":"","permalink":"http://KKimSangHeon.github.io/2019/06/06/msa1/","excerpt":"","text":"Implementing Domain-Driven Design For Microservices ArchitectureDDD의 원칙Values: Meaning, Unity, Usability, Fitness, Flexibility, MaintainabilityPrinciples: Continuous Learning, Knowledge Rich Design, Ubiquitous Language, Model-Driven Design, Separation of ConcernsDeep Models, Declarative StylePatterns:Layered ArchitectureUbiquitous Language (Entities, Value Objects, Services, Modules, Aggregates, Factories, Specification) /Supple Design (Intention-Revealing Interfaces, Side-Effect Free Functions, Assertions, Conceptual Contours, Standalone Classes, Closure of Operations) What is Domain Driven Design도메인 전문가, 기술 전문가가 소프트웨어 개발를 위해 협엽하는 기술아이디어와 도메인은 공통언어를 통해 코드에 반영되어야 한다.Domain Driven Design 에 대해 알아보기 위해 다양한 Domain에 대해 알아보자. Domain?팀은 특정 비즈니스 도메인에 맞게 일한다.팀은 비즈니스 도메인에 초점을 맞춘다도메인의 세부사항은 팀의 포지션마다 다르다. 도메인의 예시Hotel / Banking / Mortgage / Credit / Debit Accounts / Credit Cards / Retails loans Subdomains 도메인은 서브도메인으로 구성된다. 서브도메인은 Bounded Context와 유사하며 이는 서로 커뮤니케이션할 수 있다. 서브도메인은 또다른 서버도메인을 포함할 수 있다. Core domain 돈을 벌게해주는 중요한 도메인 경쟁업체와 높은 차별성을 갖음 Supporting Subdomain기술적으로 서포팅하지만 COTS-Software가 아니다.외부지원으로 구현될수 있지만 사내 팀이 주도해야 한다. Commercial, off-the-shelfCOTS 란 완성품으로 일반 대중에게 판매, 대여 또는 권한을 부여할 수 있는 컴퓨터 소프트웨어나 하드웨어, 기술 또는 컴퓨터 제품 등을 의미한다. Generic SubdomainSuitable for Outsourcing, COTS Bounded Contexts큰 도메인을 작은 Context로 나눈것.각각의 Context는 자신만의 공통언어, 모델을 갖을 수 있다.또한 Bounded Contexts는 일부 도메인을 공유할 수 있다.Ubiquitous Language(공통언어)로 모델되어야 하며 프로그램에서 비즈니스 니즈를 정의한다. This is Domain Driven DesignDDD의 Concepts and OverviewDomain-Driven Desigin은 기본 비즈니스 이해에 중점을 둔 소프트웨어 디자인방식이다.이러한 접근방식은 다음 두가지 전제를 둔다. 복잡한 도메인 디자인은 모델을 기반으로 한다. 대부분의 소프트웨어 프로젝트는 도메인 및 도메인로직에 중점을 둔다. (시스템 구현을 위한 특정 기술에 중점을 두는것이 아님) 전통적인 Layered Architecture User Interface: 정보를 보여주고 사용자의 명령을 해석Application : 비즈니스 rule,지식 미포함 / 작업 조율 그리고 도메인에 작업 위임역할Domain : 비즈니스로직, 룰 포함/ 소프트웨어의 심장부Infrastructure : 상위 레이어를 지원하는 기술제공 Domain-Driven Design with Onion Architecture Core: 특정 도메인이나 기술에 국한되지 않는 building blocks로 볼 수 있다. 예로 List, Maps, Case Classes, Actor and Lenses가 있다.Domain : 공통언어를 통해 작성된 비즈니스 로직 관련 메소드, 클래스가 상주하는 영역이다.API : 도메인의 진입점 역할을 한다. API는 도메인을 조작하지 못하도록 immutable한 객체만 노출해야 한다. 코어, 도메인은 API에 액세스할 수 있지만 Infrastructure는 API에 액세스할 수 없다.Infrastructure : DB, 사용자 인터페이스 같은 다얗안 기술을 포함하는 가장 바깥쪽 영역이다. 모든 영역은 Infrastructure 영역에 접근 할 수 있다. Bounded Contexts 에 대해 자세히 알아보자전체 비즈니스 모델은 너무 커 한번에 이해하기 힘들다. Bounded Contexts는 서로 다른 모델간 경계와 관계를 표현하기 위해 존재하는 명시적인 경계로서 경계 내의 Ubiquitous Language는 특정한 의미를 갖는다. Bounded Context의 구현 Bounded Context당 한팀이 존재한다. 코드 Repository가 Bounded Context마다 존재한다. Domain Model + DB Schema + UI + Web Services (API)로 구성된다. Bounded Context는 Ubiquitous Language와 domain model을 캡슐화하나 도메인 모델과 상호작용하는 것, 도메인 모델을 서포트 하는 기능을 포함한다. 또한 Bounded Context안에 Aggregates Entity(유니크한 트랜잭션), Value Object(불변의 객체)가 존재하는데 이는 바로 뒤에서 설명하니 참고하도록 하자. What are Entities?Domain object를 엔티티로 정의하는데 그것은 제각각 다르다. 또한 엔티티의 정체성을 적절히 결정하고 어떻게 가져올지 결정한다.최종 사용자,각 어플리케이션,data store은 identity를 만들어낸다. AggregatesAggregates는 루트엔티티로 간주되는 연관된 객체 그룹이다. (트랜잭션과 같음) Aggregates의 특징 트랜잭션과 마찬가지로 Atomic, Consistent, Isolated, Durable 특징을 갖는다.(사람모형 레고는 2개의 팔, 다리, 얼굴을 갖는데 이를 Product’s Invariant(불변성)이라 한다.) 경계가 명확하다.(외부 개체는 신경쓰지 않음) 내부 개체를 보호한다. 외부개체는 루트 Aggregates를 통해 접근 가능하며 Aggregates의 상태는 변경 불가능하다. Aggregates는 자신이 소유한 entity, value object들의 무결성을 보호해야할 책임이 있다. 12345678910@Entitypublic class Cart implements Aggregate &#123; @EmbeddedId private CartId id; @Embedded private CustomerId customerId; @OneToMany(cascade = CascadeType.All, orhanRemoval = true) @JoinColumn(name=&quot;cartId&quot;) private Set&lt;CartItem&gt; items;&#125; 위와같은 코드가 있을 때 cart id는 루트 엔티티 이다. 또한 CartItem이라는 엔티티들의 레퍼런스를 갖고 있으며 CustomerId를 ValueObject로서 사용한다. Aggregates rule 모델은 불변해야 하며 일관되게 경계안에 있어야 한다. Aggregates 작게 디자인해라.(클 경우 확장성 저하 가능성) 다른 Aggregates참조는 Identity로 하라. 경계밖에서의 일관성유지 Relationships Between AggregateRelationshipsBetweenAggregate Aggregate Root만 다른 Bounded Context의 Aggregate Root에 접근 가능 Aggregate 팁 Aggregate는 항상 정답이 아니다. Aggregates는 루트와 연결될 수 있다. 루트가 아닌 엔티티를 FK로 사용하는것을 간과하지 마라. Aggregates가 중요한 이유개체를 그룹화하고 카테고리화 하면 복잡한것을 쉽게 관리할 수 있다.주인없는 레코드를 방지하여 GC가 쉬워진다.DB와의 고수준의 통신이 가능케한다. Value Object가능한 엔티티 대신 값 개체를 사용하여 모델을 작성해야 한다.Value 인지 아닌지 결정하기위해 다음 것들을 확인해보자. 도메인을 측정하고, 정량화 할수있는지 불변의 상태로 유지될 수 할수있는지 관련된 속성을 필수 단위로 하여 전체를 구성하는지 상황이 바뀌면 교체 가능한지. Value를 사용하는 다른값과 비교될 수 할수있는지 collaborators에게 부작용을 없는 행동을 하는지 What are Domain Services도메인의 일부는 객체로 모델링하는것이 자연스럽지 않다.Application Service와 다르다. Application Service는 Domain Service의 클라이언트다.일반적인 사용 예 성능이 중요한 비즈니스 프로세스 도메인 객체를 다른것의 구성요소로 변환할 때 둘 이상의 도메인 객체에서 입력을 요구할 때 Domain Building BlocksEntity : identity가 있는 명사 가변적이며 다른 엔티티 혹은 value object와 연관될 수 있다. 공유될 수 없다. Value Object : identity가 없는 명사 불변하며 다른 엔티티와 연관될 수 있다.. 공유될 수 있다. Aggregate : 하나의 Aggregate당 하나의 root entity가 있다. 관련있는 Aggregate는 루트 entity를 통해 참조할 수 있지만 Aggregate의 다른 entity는 참조할 수 없다. 모든 작업은 루트를 통해 수행된다. Service : 서비스는 어플리케이션에서의 액션이다. 서비스는 엔티티의 상태변화를 일으킨다 서비스는 상태가 없다. 서비스는 어플리케이션,도메인, 인프라스트럭쳐의 어느 곳의 일부가 될 수 있다. Factory : 엔티티나 value object를 생성한다 엔티티의 생성이 복잡할 때 사용한다. DDD의 이점 기술보다는 비즈니스에 초점을 맞춘다, 코드르 재사용하고 읽기 쉽다. 개선사항이 있을 때 유연하다. 성공적인 DDD 도메인전문가, 기술 전문가의 협업을 통해 모델 빌드 어플리케이션의 반복적인 빌드 테스트하고 테스트하고 또 테스트하라 세계지도에서 DDD가 어떻게 적용되는지 보자.Model Driven DesiginDomain = Word MapSub domain = 오세아니아, 아시아, 북아메리카,….Bounded Context = Countries(South Korea)Ubiquitous Language = Korean LanguageDomain Model = Map of Korea","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"MSA","slug":"MSA","permalink":"http://KKimSangHeon.github.io/tags/MSA/"}]},{"title":"13. 헬름","slug":"kube13","date":"2019-06-06T08:17:59.000Z","updated":"2019-06-11T10:58:31.407Z","comments":true,"path":"2019/06/06/kube13/","link":"","permalink":"http://KKimSangHeon.github.io/2019/06/06/kube13/","excerpt":"","text":"하나 이상의 클러스터를 운영하다 보면 같은 어플리케이션을 여러 클러스터에 배포해야 하는 경우가 발생한다.이럴 때 배포 환경에 따라 달라지는 설정값들때문에 문제점들이 많이 발생한다. 그래서 배포 환경에 따라 달라지는 설정값만 정의해 둔 다음 이에 따라 배포하는 메커니즘이 필요했는데 이를 해결한것이 바로 헬름이다.헬름은 쿠버네티스 차트를 관리하기 위한 도구이다. 차트는 사전 구성된 쿠버네티스 리소스의 패키지다. 즉 헬름은 패키지 관리도구이며, 차트가 리소스를 하나로 묶은 패키지에 해당한다. 헬름 : 차트를 관리 차트(매니패스트 템플릿으로 구성) : 차트를 사용하여 매니페스트 파일 생성 매니페스트 파일 : 매니페스트 파일에 기초한 쿠버네티스 리소스 관리 쿠버네티스 헬름으로 차트를 관리하는 목적은 번잡해지기 쉬운 매니페스트 파일을 관리하기 쉽게하기 위한것이다. 헬름은 단순한 패키지 관리자가 아니라, 차트를 중심으로 하는 쿠버네티스 개발 업무의 종합 관리도구이다. 실무에서는 여러 환경에 배포해야 하는 어플리케이션은 모두 차트로 패키징해 kubectl 대신 헬름으로 배포 및 없데이트를 수행한다. 헬름 설치123$ curl -LO https://git.io/get_helm.sh$ chmod 700 get_helm.sh$ ./get_helm.sh 헬름 초기화틸러라는 서버 어플리케이션이 kube-system 네임스페이스에 배포된다. 틸러는 helm 명령에따라 설치 등의 작업을 담당한다. 1$ helm init 잘 만들어졌나 확인해보자1$ kubectl -n kube-system get service,deployment,pod --selector app=helm 버전을 확인해보자.1$ helm version 여러 클러스터를 다룰 때는 클라이언트/서버의 버전을 일치시키는것이 좋다. 이를 위해 다음을 입력하여 업그레이드하자.1$ helm init --upgrade 헬름?헬름은 클라이언트(cli)와 서버(쿠버네티스 클러스터에 설치되는 틸러)로 구성된다. 클라이언트는 서버를 대상으로 명령을 지시하고 서버는 클라이언트에서 전달받은 명령에 따라 쿠버네티스 클러스터에 패키지 설치, 업데이트, 삭제 등의 작업을 수행한다. 쿠버네티스는 서비스나 디플로이먼트, 인그레스 같은 리소스를 생성하고 매니페스트 파일을 적용하는 방식으로 어플리케이션을 배포한다. 이 매니패스트 파일을 생성하는 템플릿을 여러 개 패키징한것이 차트이다. 차트는 헬름 레파지토리에 tgz 파일로 저장되며 틸러가 매니페스트를 생성하는데 사용한다. 리포지토리헬름의 리포지토리는 다음과 같은 종류가 있다. local : 헬름 클라이언트가 설치된 로컬 리포지토리. 로컬에서 생성한 패키지가 존재stable : 안정버전의 차트가 존재하는 리포지토리.incubator : 아직 stable 하지는 못하지만 곧 stable로 넘어갈 예정인 차트 stable 리포지토리는 기본값으로 사용되며 깃허브 github.com/helm/charts에 저장된다.(궁금하면 참고해보자) 차트의 구성차트는 다음과 같은 디렉터리 구성을 갖는다.12345678chart_name/ --- templates/ 매니페스트 파일 템플릿 디렉터리 | |- xxxx.yaml 각종 쿠버네티스 리소스의 매니페스트 템플릿 | |-_helper_tpl 매니페스트 랜더링에 사용되는 템플릿 헬퍼 | |-NOTE.txt 차트 사용법 등의 참조 문서 템플릿 | |-chart/ 이 차트가 의존한느 차트의 디렉토리 |-Chart.yaml 차트 정보가 정의된 파일 |-values.yaml 차트 기본값 value 파일 차트는 어플리케이션의 동작을 제어하는 설정의 기본값을 values.yaml 파일에 정의한다. 차트를 이용해 어플리케이션을 설치하려면 helm install 명령을 사용한다. 어플리케이션을 업데이트,삭제하기 위해서는 릴리즈 네임이 필요한데 –name 옵션으로 붙여준다. 이는 해당 클러스터 안에서 유일한 값이어야 한다. 1$ helm install [--name 릴리스_네임] 차트_리포지토리/차트명 helm install 명령을 실행하면 차트에 포함된 기본값 value 파일에 정의된 설정값으로 어플리케이션이 설치된다.그러나 기본값 value파일을 사용하는 경우는 드물며 일부 기본값을 수정한 커스텀 value 파일을 주로 사용한다. 이를 위해 각 리포지토리에서 제공하는 참고문서를 참고하자. 레드마인 설치 예제문서에 규정된 설정값에 따라 커스텀 value 파일을 작성한다. 이를 redmine.yaml파일로 정의한다. 내용은 다음과 같다.yaml파일에는 기본값에서 수정할 항목만 포함하면 된다.12345redmineUsername: sangheonredminePassword: sangheonredmineLanguage: enserviceType: NodePort -f 옵션으로 커스텀 value 파일을 지정해서 레드마인을 설치한다.12$ helm install -f redmine.yaml --name redmine stable/redmine --version 4.0.0 에러발생시namespaces &quot;default&quot; is forbidden: User &quot;system:serviceaccount:kube-system:default&quot; cannot get resource &quot;namespaces&quot; in API group &quot;&quot; in the namespace &quot;default&quot; helm list라고 입력했을때Error: configmaps is forbidden: User &quot;system:serviceaccount:kube-system:default&quot; cannot list resource &quot;configmaps&quot; in API group &quot;&quot; in the namespace &quot;kube-system&quot; 라는 에러 발생시 해결방법 rbac-config.yaml 파일로 다음과 같이 생성한다.123456789101112131415161718apiVersion: v1kind: ServiceAccountmetadata: name: tiller namespace: kube-system---apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRoleBindingmetadata: name: tillerroleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: cluster-adminsubjects: - kind: ServiceAccount name: tiller namespace: kube-system 다음을 순서대로 입력12$ kubectl create -f rbac-config.yaml$ helm init --service-account tiller --history-max 200 --upgrade 다시 다음을 입력하여 설치하면 될것이다.1$ helm install -f redmine.yaml --name redmine stable/redmine --version 4.0.0 다음을 입력해서 설치한것을 확인할 수 있다. 12$ helm ls$ kubectl get service,deployment --selector release=redmine 설치한것을 다시 삭제해보자1$ helm delete redmine 헬름에서 제공하는 롤백기능 사용해보자12$ helm ls --all$ helm rollback redmine 1 #리비전 숫자 입력하기 리비전 기록을 남기지 않고 제거하기1$ helm del --purge redmine RBAC를 지원하는 어플리케이션 설치공개된 차트 중에는 RBAC를 활성화할 수 있는 어플리케션도 있다. RBAC를 활성화한 어플리케이션을 설치하려면 실제 설치 작업을 수행할 틸러에 cluster-admin이라는 롤(ClusterRole)이 부여돼야 한다. 다음과 같이 cluster-admin 롤을 갖는 서비스 계정을 생성한 다음, 이 계정을 실행중인 틸러의 서비스 계정으로 설정한다. 123$ kubectl create serviceaccount --namespace kube-system tiller$ kubectl create clusterrolebinding tiller-cluster-rule --clusterrole=cluster-admin --serviceaccount=kube-system:tiller$ kubectl patch deploy --namespace kube-system tiller-deploy -p &apos;&#123;&quot;spec&quot;:&#123;&quot;template&quot;:&#123;&quot;spec&quot;:&#123;&quot;serviceAccount&quot;:&quot;tiller&quot;&#125;&#125;&#125;&#125;&apos;","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://KKimSangHeon.github.io/tags/kubernetes/"}]},{"title":"12. 사용자 관리와 RBAC(role-based access control)","slug":"kube12","date":"2019-06-06T08:17:55.000Z","updated":"2019-06-09T07:34:17.107Z","comments":true,"path":"2019/06/06/kube12/","link":"","permalink":"http://KKimSangHeon.github.io/2019/06/06/kube12/","excerpt":"","text":"쿠버네티스 사용자마다 권한을 제어하는 것은 쿠버네티스 운영하는데 있어 보안을 확보하는 기본적인 방법이다. 쿠버네티스 사용자는 두 가지 개념으로 나뉜다.일반사용자: 클러스터 외부에서 쿠버네티스를 조작하는 사용자로 다양한 방법으로 인증을 거친다. 개발자 및 운영 실무자가 쿠버네티스를 조작하기 위해 사용하며 쿠버네티스 클러스터 외부로부터 들어오는 접근을 관리하기 위한 사용자이다.배포와 관련된 서비스나 디플로이먼트의 접근 권한을 일부 사용자에게만 허용하거나 파드의 로그 열람 권한을 다른 일반 사용자에게도 허용하는 등의 정책을 일반 사용자 권한 부여로 실현할 수있다. 서비스 계정: 쿠버네티스 내부적으로 관리되며 파드가 쿠버네티스 API를 다룰 때 사용하는 사용자.(kubectl또한 쿠버네티스 API와 통신해 작동함) 주어진 권한에 따라 쿠버네티스 리소스(파드, 디플로이먼트 등)를 다룰 수 있다.서비스 계정은 어플리케이션을 통해 쿠버네티스 조작을 통제할 수 있다는 점이 장점이다. 클러스터 안에서 봇을 동작시키는 파드에 권한을 부여해두고, 이 봇으로 기존 디플로이먼트를 업데이트하거나 레플리카 수를 조절하는 식으로 활용할 수 있다. 서비스 계정 및 일반 사용자의 권한은 RBAC(role-based access control) 라는 메커니즘을 통해 제어된다. RBAC는 롤에 따라 리소스에 대한 권한을 제어하는 기능이자 개념이다. Role, Cluster Role은 접근가능한것에 대한 범위이고 binding은 롤을 주는것을 의미한다고 판단. 롤 : 각 쿠버네티스 API의 사용권한을 정의. 네임스페이스 안에서만 유효롤바인딩 : 일반 사용자 및 그룹/서비스 계정과 롤을 연결클러스터롤: 각 쿠버네티스 API의 사용 권한을 정의. 클러스터 전체에서 유효클러스터롤바인딩: 일반사용자 및 그룹/서비스 계정과 클러스터롤을 연결 262p부터","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://KKimSangHeon.github.io/tags/kubernetes/"}]},{"title":"11. 쿠버네티스 실전편(잡, 크론잡, 시크릿)","slug":"kube11","date":"2019-06-02T08:11:52.000Z","updated":"2019-06-06T08:27:16.197Z","comments":true,"path":"2019/06/02/kube11/","link":"","permalink":"http://KKimSangHeon.github.io/2019/06/02/kube11/","excerpt":"","text":"파드, 레플리카세트, 디플로이먼트, 서비스, 인그레스는 데몬으로 동작하는 서버 어플리케이션을 구축할 때 사용되는 기본 리소스이다쿠버네티스는 데몬으로 동작하는 서버 어플리케이션 외에도 배치 서버등 다양한 형태의 어플리케이션을 구축할 수 있다. 잡잡은 하나 이상의 파드를 생성해 지정된 수의 파드가 정상 종료될 때까지 이를 관리하는 리소스다.잡이 생성한 파드는 정상 종료된 후에도 삭제되지 않고 그대로 남아있기 때문에 작업이 종료된 후에 파드의 로그나 실행 결과를 분석할 수 있다. 그러므로 배치작업 위추의 어플리케이션에 적합하다.잡은 파드 여러개를 병렬로 실행하는 방법으로 쉽게 스케일 아웃이 가능하다. 123456789101112131415161718192021222324apiVersion: batch/v1kind: Jobmetadata: name: pingpong labels: app: pingpongspec: parallelism: 3 # 동시에 실행하는 파드의 수를 지정하는 속성. 파드를 병렬로 실행해야할 때 편리 template: metadata: labels: app: pingpong spec: containers: - name: pingpong image: gihyodocker/alpine:bash command: [&quot;/bin/sh&quot;] args: - &quot;-c&quot; - | echo [`date`] ping! sleep 10 echo [`date`] pong! restartPolicy: Never 위의 코드를 yaml파일로 만들고 아래 명령어를 통해 확인해보자.12$ kubectl apply -f test.yaml$ kubectl get pod -l app=pingpong --show-all parallelism와 replicas의 차이점은 무엇일까?replicas가 3이면 동일한 파드를 3개 만들라는 것이고, parallelism이 이면 동시에 3개의 파드를 실행하는것인데… 확인해보니 parallelism도 파드를 3개 만들긴함. 잡 리소스는 restartPolicy 속성을 Never, OnFailure중 하나를 설정해야 한다. 크론잡잡 리소스는 파드가 단 한번만 실행되는데 반해 크론잡 리소스는 스케줄을 지정해 정기적으로 파드를 실행할 수 있다. 즉 정기적으로 파드를 실행할 수 있다.123456789101112131415161718192021222324apiVersion: batch/v1beta1kind: CronJobmetadata: name: pingpongspec: schedule: &quot;*/1 * * * *&quot; jobTemplate: spec: template: metadata: labels: app: pingpong spec: containers: - name: pingpong image: gihyodocker/alpine:bash command: [&quot;/bin/sh&quot;] args: - &quot;-c&quot; - | echo [`date`] ping! sleep 10 echo [`date`] pong! restartPolicy: OnFailure spec.schedule속성에 Cron과 같은 포맷으로 파드를 실행할 스케줄을 정의한다. 또한 spec.jobTemplate 아래에 잡 리소스와 마찬가지로 파드 정의가 들어가면 된다.보통의 경우 리눅스 crontab으로 스케줄에 맞춰 스크립트를 실행하는게 대부분이었따. 하지만 크론잡 리소스를 이용하면 이 모든것을 컨테이너로 해결할 수 있다. 시크릿쿠버네티스의 시크릿 리소스를 사용하면 기밀정보 문자열을 Base 인코딩으로 만들 수 있다. 1234567apiVersion: v1kind: Secretmetadata: name: nginx-secrettype: Opaquedata: .htpasswd: eW91cl91c2VybmFtZTpyejc5SXpTalplaWZvCg== 위 코드를 활용해 아래에 적용가능하다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859apiVersion: v1kind: Servicemetadata: name: basic-authspec: type: NodePort selector: app: basic-auth ports: - protocol: TCP port: 80 targetPort: http nodePort: 30060---apiVersion: apps/v1kind: Deploymentmetadata: name: basic-auth labels: app: basic-authspec: replicas: 1 selector: matchLabels: app: basic-auth template: metadata: labels: app: basic-auth spec: containers: - name: nginx image: &quot;gihyodocker/nginx:latest&quot; imagePullPolicy: Always ports: - name: http containerPort: 80 env: - name: BACKEND_HOST value: &quot;localhost:8080&quot; - name: BASIC_AUTH_FILE value: &quot;/etc/nginx/secret/.htpasswd&quot; volumeMounts: - mountPath: /etc/nginx/secret # 이 경로에 .htpasswd가 생성된다. name: nginx-secret readOnly: true - name: echo image: &quot;gihyodocker/echo:latest&quot; imagePullPolicy: Always ports: - containerPort: 8080 env: - name: HTTP_PORT value: &quot;8080&quot; volumes: - name: nginx-secret secret: secretName: nginx-secret 인증정보를 환경 변수로 관리하는 기법또한 존재한다. 이는 259p를 참고하자.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://KKimSangHeon.github.io/tags/kubernetes/"}]},{"title":"10. 쿠버네티스의 스토리지","slug":"kube10","date":"2019-06-01T04:17:08.000Z","updated":"2019-06-02T08:11:02.042Z","comments":true,"path":"2019/06/01/kube10/","link":"","permalink":"http://KKimSangHeon.github.io/2019/06/01/kube10/","excerpt":"","text":"마스터 슬레이브 형태로 MySQL을 구성하자. 쿠버네티스의 스토리지쿠버네티스에서는 호스트에서 분리할 수 있는 외부 스토리지를 볼륨으로 사용할 수 있다. 파드가 다른 호스트로 재배치 되어도 외부 스토리지 형태의 볼륨은 새로 배치된 호스트에 자동으로 할당된다. 그러므로 호스트와 데이터 볼륨의 결합이 느슨해지고 외부 스토리지를 사용하므로 퍼시스턴스 데이터를 다루는 애플리케이션을 컨테이너로 운영하기가 쉽다.쿠버네티스에서 관련 리소스는 다음의 요소들이 있다. 퍼시스턴트볼륨 퍼시스턴트볼륨클레임 스토리지클래스 스테이트풀세트 퍼시스턴트볼륨과 퍼시트턴트볼륨클레임퍼시스턴트볼륨은 스토리지 자체이며 퍼시스턴트볼륨클레임은 추상화된 논리 리소스로 퍼시스턴볼륨과 달리 용량을 필요한 만큼 동적으로 확보 할 수 있는것이다.퍼시스턴트볼륨클레임은 클러스터가 구축된 플랫폼을 지원하는 퍼시스턴스 볼륨을 생성하기 위해 사용된다. 다음은 퍼시스턴스볼륨클레임 리소스의 매니페스트 파일이다.1234567891011apiVersion: v1kind: PersitentVolumeClaimmetadata: name: pvc-examplespec: accessModes: - ReadWriteOnce storageClassName: ssd resource: requests: storage: 4Gi 위의 accessModes는 파드가 스토리지에 접근한는 방식을 지정한다. ReadWriteOnce 는 마운트 될 수 있는 노드를 하나로 제한한다는 의미이다. 이 외에도 ReadOnlyMany 혹은 ReadWriteMany가 있다. 이들은 이러한 제약이 없으며 플랫폼에 따라 사용할 수 없는 경우가 있으므로 주의하storageClassName는 StorageClass리소스의 종류 즉 어떤 스토리지를 사용할지를 정의한다. 스토리지클래스(StorageClass)스토리지클래스는 퍼시스턴트볼륨으로 확보한 스토리지 종류를 정의하는 리소스다. 앞에서의 storageClassName속성값의 실체가 이것이다. GCP의 경우 storageClassName의 종류는 표준,SSD가 있다. 1234567891011kind: StorageClassapiVersion: storage.k8s.io/v1metadata: name: ssd annotations: storageclass.kubernetes.io/is-default-class: &quot;false&quot; labels: kubernetes.io/cluster-service: &quot;true&quot;provisioner: kubernetes.io/gce-pdparameters: type: pd-ssd SSD 스토리지를 사용하도록 스토리지 클래스의 name 속성을 ssd로 하고 provisioner는 GCP 의 퍼시스턴스 스토리지인 GCEPersistentDisk에 해당하는 gcd-pd로 지정한다. 그리고 파라미터의 type 속성값을 pd-ssd로 지정한다. 스테이트풀세트(StatefulSet)디플로이먼트는 함께 포함된 파드 정의를 따라 파드를 생성하는 리소스로 하나만 있으면 되는 파드 혹은 퍼시스턴스 데이터를 갖지않는 즉 상태가 없는(stateless) 어플리케이션을 배포하는데 적합하다.이에 비해 스테이트풀 세트는 데이터 스토어처럼 데이터를 계속 유지하는 상태가 있는 애플리케이션을 관리하는데 적합한 리소스다. 디플로이먼트에서 생성한 파드는 무작위로 생성된 식별자가 부여된다. 스테이트풀세트는 pod-1, pod-2, pod-2와 같이 일련번호가 붙는 유일한 식별자를 붙여 파드를 생성한다.이 식별자는 파드를 재생성해도 유지되며, 스케일링 할 때도 식별자의 일련번호가 계속 이어진다. 파드가 재생성되어도 스토리지가 계속 같은 파드에 연결되어 파드의 데이터를 그대로 복원할 수 있다. /","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://KKimSangHeon.github.io/tags/kubernetes/"}]},{"title":"9. GCP 를 활용한 실습환경 구축","slug":"kube9","date":"2019-06-01T04:15:34.000Z","updated":"2019-06-09T08:31:04.737Z","comments":true,"path":"2019/06/01/kube9/","link":"","permalink":"http://KKimSangHeon.github.io/2019/06/01/kube9/","excerpt":"","text":"온프레미스 환경 또는 퍼블릭 클라우드에서 쿠버네티스를 실제로 사용해 보자.클라우드에서 Google Kubernetes Engine을이용하거나 온프레미스 환경에서 Kuberspray를 이용해 클러스터를 구축하자 윈도우 OS의 경우GCP를 생성하고 구글 클라우드 SDK를 설치하자 아래의 링크에서 GCP 설치https://cloud.google.com/sdk/docs/quickstart-windows?hl=ko 환경변수에 다음 추가1C:\\Users\\SangHeon\\AppData\\Local\\Google\\Cloud SDK\\google-cloud-sdk\\bin gcloud 버전 업데이트1$ gcloud components update 아래 입력 후 계정입력1$ gcloud auth login 아래를 입력하여 대상 프로젝트 ID 선택1$ gcloud config set project xxxx 아래 입력 하여 리전 설정1$ gcloud config set compute/zone asia-northeast1-a CentOS일 때Centos 환경에서의 진행 아래를 복붙하자12345678910sudo tee -a /etc/yum.repos.d/google-cloud-sdk.repo &lt;&lt; EOM[google-cloud-sdk]name=Google Cloud SDKbaseurl=https://packages.cloud.google.com/yum/repos/cloud-sdk-el7-x86_64enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpgEOM 아래 명령어 입력1# sudo yum install google-cloud-sdk 1# gcloud init 나오는 url로 들어가 코드 복사 및 붙여넣기 아래 입력 하여 리전 설정1$ gcloud config set compute/zone asia-northeast1-a 쿠버네티스 클러스터를 생성해보자 https://console.cloud.google.com/apis/api/container.googleapis.com/overview?project=xxxxxx 으로 접속해서 사용 설정가능토록 해주자 아래 명령어로 클러스터 생성1$ gcloud container clusters create sangheon --cluster-version=latest --machine-type=n1-standard-1 --num-nodes=3 –cluster-version 으로 클러스터 버전 지정–num-nodes 으로 인스턴수 수 지정 1$ gcloud components install kubectl #센토스의 경우 안될경우 10줄짜리를 다시 복붙해보고 sudo yum update kubectl 로 kubectl 에 인증정보 설정1$ gcloud container clusters get-credentials sangheon 잘되었나 확인해보자1$ kubectl get nodes 다음을 입력하여 로컬에서 접속해보자1kubectl proxy /","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://KKimSangHeon.github.io/tags/kubernetes/"}]},{"title":"8. 인그레스","slug":"kube8","date":"2019-05-29T10:23:51.000Z","updated":"2019-05-29T12:56:24.086Z","comments":true,"path":"2019/05/29/kube8/","link":"","permalink":"http://KKimSangHeon.github.io/2019/05/29/kube8/","excerpt":"","text":"NodePort의 경우 L4레벨까지 다룰수 있기 때문에 HTTP/HTTPS처럼 경로를 기반으로 서비스를 전환하는 L7레벨의 제어는 불가능하다.이를 해결하기 위한것이 인그레스이다. 서비스를 이용한 쿠버네티스 외부에 대한 노출(NodePort)과 가상 호스트 및 경로 기반의 정교한 HTTP 라우팅(인그레스)을 양립시킬 수 있다.(무슨말인지 이해가 되지 않는다면 아래 밑줄부분을 보자.) 클러스터 외부에서 온 HTTP 요청을 서비스로 라우팅 하기위해 다음을 입력하자.1234$ kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.16.2/deploy/mandatory.yaml$ kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.16.2/deploy/provider/cloud-generic.yaml$ kubectl get pod,svc -n ingress-nginx 서비스를 다음과 같이 생성하고 반영시켜보자.12345678910apiVersion: v1kind: Servicemetadata: name: echospec: selector: app: echo ports: - name: http port: 80 다음과같이 인그레스를 정의하고 반영해보자.12345678910111213apiVersion: extensions/v1beta1kind: Ingressmetadata: name: echospec: rules: - host: ch05.gihyo.local http: paths: - path: / backend: serviceName: echo servicePort: 80 잘 생성되었는지 확인해보자.1$ kubectl get ingress 인그레스는 L7 라우팅이 가능하므로 가상 호스팅 기능처럼 지정된 호스트 혹은 경로와 일치하는 서비스로 요청을 전달할 수 있다 가령 헤더에 Mobile라는 값이 포함될경우 특정 URL로 리다이렉트 할 수 있다. apiVersion??항상 맨위에 위치하는 apiVersion은 무엇일까?쿠버네티스 리소스를 생성, 수정, 삭제하는 작업은 쿠버네티스 클러스터에 배포된 API가 수행한다. 이 API는 여러 API를 하나로 묶은 형태로 구성되는데 이 apiVersion은 해당 작업에 사용되는 API의 종류를 나타내는 것이다. 다음명령어를 통해 쿠버네티스에서 사용할 수 있는 명령어들을 볼 수 있다.1$ kubectl api-versions 서비스나 파드는 쿠버네티스의 핵심 API인 v1, 디플로이먼트는 파드의 생성을 제어하는 API인 apps/v1에 해당한다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://KKimSangHeon.github.io/tags/kubernetes/"}]},{"title":"7. 서비스","slug":"kube7","date":"2019-05-29T10:23:39.000Z","updated":"2019-05-29T10:24:38.043Z","comments":true,"path":"2019/05/29/kube7/","link":"","permalink":"http://KKimSangHeon.github.io/2019/05/29/kube7/","excerpt":"","text":"쿠버네티스 클러스터 안에서 파드의 집합(주로 레플리카세트)에 대한 경로나 서비스 디스커버리(API 주소가 동적으로 바뀌어도 클라이언트가 대상을 바꾸지않고 접근할 수 있음)를 제공하는 리소스이다. 서비스의 대상이 되는 파드는 서비스에서 정의하는 레이블 셀렉터로 정해진다. spec.selector 속성값으로 특정 파트의 레이블값을 설정하여 특정 파드만 접근할 수 있도록 yaml파일을 작성해보자. 1234567891011apiVersion: v1kind: Servicemetadata: name: echospec: selector: # 특정 파드만 접근할수 있도록 함. app: echo release: summer ports: - name: http port: 80 위의 서비스를 실행하고 컨테이너 안에 존재하는 아무 컨테이너에 들어가서 curl http://echo 를 입력하면 잘 동작하는것을 확인할 수 있다.12345678$ kubectl exec -it 파드명 bash혹은$ kubectl run -i --rm --tty debug --image=gihyodocker/fundamental:0.1.0 --restart=Never -- bash -il# curl http://echo 다음명령어를 통해 로그를 summer안에서 생기는 로그를 확인할 수 있다.1$ kubeclt logs -f echo-summer-dtblk -c echo 쿠버네티스 클러스터는 서비스명.네임스페이스명.svc.local로 연결해준다. 1234567$ curl http://echo.default.svc.local$ curl http://echo.default# svc.local 생략가능$ curl http://echo # 같은네임스페이스일 경우만 가능 ClusterIP 서비스서비스의 종류는 여러가지가 있고 기본값은 ClusterIP 서비스이다. ClusterIP를 통해 클러스터 내부 IP 주소에 서비스를 공개할 수 있다. NodePort 서비스이는 클러스터 외부에서 접근할 수 있는 서비스이다. ClusterIP를 만든다는 점은 ClusterIP 서비스와 같다. 각 노드에서 서비스 포트로 접속하기 위한 글로벌 포트를 개방하는것이 차이점이다. 123456789101112apiVersion: v1kind: Servicemetadata: name: echospec: type: NodePort # 추가함 selector: app: echo release: summer ports: - name: http port: 80 다음 명령어를 통해 포트를 알아내고 curl요청을 보낼 수 있다.1$ kubectl get svc echo LoadBalancer 서비스이는 각 클라우드 플랫폼에서 제공하는 로드밸런서와 연동하기 위해 사용된다. ExternalName 서비스이는 셀렉터도 포트 정의도 없는 특이한 서비스다. 쿠버네티스 클러스터에서 외부 호스트를 네임 레졸루션 하기위한 별칭을 제공한다.아래의 경우 gihyo.jp를 gihyo로 참조할 수 있게해준다.1234567apiVersion: v1kind: Servicemetadata: name: gihyospec: type: ExternalName # 추가함 externalName: gihyo.jp","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://KKimSangHeon.github.io/tags/kubernetes/"}]},{"title":"6.쿠버네티스의 주요 개념(리소스 개요,파드,네임스페이스,레플리카세트,디플로이먼트","slug":"kube6","date":"2019-05-27T11:01:24.000Z","updated":"2019-05-29T10:21:11.518Z","comments":true,"path":"2019/05/27/kube6/","link":"","permalink":"http://KKimSangHeon.github.io/2019/05/27/kube6/","excerpt":"","text":"docker container prunedocker container prune [options]도커를 오래 사용하다 보면 디스케이 컨테이너와 이미지가 점점 늘어나게 된다. 이런 경우 prune 명령을 사용해 필요없는 컨테이너를 일괄 삭제할 수 있다. docker image prune [options]도커를 오래 사용하다 보면 디스케이 컨테이너와 이미지가 점점 늘어나게 된다. 이런 경우 prune 명령을 사용해 필요없는 이미지를 일괄 삭제할 수 있다. docker system prune [options]사용하지 않는 도커 이미지 및 컨테이너,볼륨,네트워크 등 모든 리소스를 일괄적으로 삭제할 수 있다. 쿠버네티스로 실행하는 애펄리케이션은 애플리케이션을 구성하는 다양한 리소스가 함께 연동해 동작한다. 리소스의 종류 및 용도노드 : 컨테이너가 배치되는 서버네임스페이스 : 쿠버네티스 클러스터 안의 가상 클러스터.파드 : 컨테이너의 집합 중 가장 작은 단위로 컨테이너 실행 방법을 정의한다.레플리카 세트: 같은 스펙을 갖는 파드를 여러개 생성하고 관리하는 역할을 한다.디플로이먼트 : 레플리카 세트의 리비전을 관리한다.서비스: 파드의 집합에 접근하기 위한 경로를 정의한다.인그레스:서비스를 쿠버네티스 클러스터 외부로 노출시킨다.컨피그맵 : 설정 정보를 정의하고 파드에 전달한다.퍼시스턴트 볼륨 : 파드가 사용할 스토리지의 크기 및 종류를 정의.퍼시스턴스 볼륨 클레임 : 퍼시스턴트 볼륨을 동적으로 확보.스토리지 클래스 : 퍼시스턴트 볼륨이 확보하는 스토리지의 종류를 정의스테이트풀 세트 : 같은 스펙으로 모두 동일한 파드를 여러개 생성하고 관리한다.잡: 상주 실행을 목적으로 하지 않는 파드를 여러개 생성하고 정상적인 종료를 보장한다.크론잡: 크론 문법으로 스케줄링되는 잡.시크릿 : 인증 정보같은 기밀 데이터를 정의한다.롤: 네임스페이스 안에서 조작 가능한 쿠버네티스 리소스의 규칙을 정의한다.롤바인딩: 쿠버네티스 리소스 사용자와 롤을 연결 짓는다.클러스터룰: 클러스터 전체적으로 조작 가능한 쿠버네티스 리소스의 규칙을 정의한다.클러스터롤바인딩:쿠버네티스 리소스 사용자와 클러스터 롤을 연결 짓는다.서비스 계정: 파드가 쿠버네티스 리소스를 조작할 때 사용하는 계정 쿠버네티스 클러스터와 노드쿠버네티스 리소스 중에서 가장 큰 개념은 노드이다. 쿠버네티스는 클러스터 전체를 관리하는 서버인 마스터가 적어도 하나 이상 있어야 하며 쿠버네티스 클러스터는 마스터와 노드의 그룹으로 구성된다. 네임스페이스쿠버네티스는 클러스터 안에 가상 클러스터를 또 다시 만들 수 있다. 이를 네임스페이스라 한다. 클러스터를 처음 구축하면 default, docker, kube-public, kube-system의 네임스페이스 4개가 이미 만들어져 있다. 파드파드는 컨테이너가 모인 집합체의 단위로 적어도 하나 이상의 컨테이너로 이루어진다. 쿠버네티스에서는 결합이 강한 컨테이너를 파드로 묶어 일괄 배포한다.파드 하나는 여러 노드에 걸쳐 배치될 수 없다. 함께 배포해야 정합성을 유지할 수 있는 컨테이너 등에도 해당 컨테이너를 같은 파드로 묶어두는 전략이 유용하다.쿠버네티스에서는 관리용 서버인 마스터가 클러스터 전체를 제어하며 마스터 노드는 관리용 컴포넌트가 담긴 파드만 배포된 노드이다. 어플리케이션에 사용되는 파드는 배포할 수 없다. 파드생성 및 배포파드생성은 kubectl만 사용해도 가능하지만, 버전관리 관점에서도 yaml파일로 정의하는것이 좋다. 1234567891011121314151617apiVersion: v1 # 리소스의 유형을 지정하는 속성kind: Podmetadata: # 리소스에 부여되는 메타데이터. metadata.name 속성의 값이 리소스의 이름이 된다. name: simple-echospec: # 리소스를 정의하기 위한 속성. containers: - name: nginx # 컨테이너 이름 image: gihyodocker/nginx:latest # 도커 허브에 저장된 이미지 태그값 env: # 환경변수 - name: BACKEND_HOST value: localhost:8080 ports: # 컨테이너가 노출시킬 포트를 지정 (도커파일에서 지정한 경우 따로 지정할필요 x) - containerPort: 80 - name: echo image: gihyodocker/echo:latest ports: - containerPort: 8080 아래 명령어를 입력하여 클러스터에 배포할 수 있다.123$ kubectl apply -f simple-pod.yaml$ kubectl get pod를 입력하여 파드 정보를 볼 수 있다. READY에 분모는 파드에 정의된 컨테이너 수이고 분자는 실행 상태의 컨테이너 수 이다. 아래 명령어를 통해 파드안에 있는 컨테이너의 표준 출력을 화면에 출력할 수 있다.뒤 -c는 컨테이너를 지정한것.1$ kubectl logs -f simple-echo -c echo 파드를 삭제하기 위해 다음명령어를 사용할 수 있다1$ kubectl delete pod simple-echo 매니페스트 파일로도 파드를 삭제할 수 있다. 이 경우 메니패스트에 작성된 리소스 전체가 삭제된다. 1$ kubectl delete -f simple-pod.yaml 파드에는 각각 고유의 가상 IP주소가 할당된다. 이는 파드에 속하는 모든 컨테이너가 공유하며 이로인해 같은 파드 안의 모든 컨테이너의 가상 IP가 같기 때문에 컨테이너간 통신이 가능해진다. 레플리카세트레플리카세트는 똑같은 정의를 갖는 파드를 여러개 생성하고 관리하기 위한 리소스다. 12345678910111213141516171819202122232425262728apiVersion: apps/v1kind: ReplicaSetmetadata: name: echo labels: app: echospec: replicas: 3 selector: matchLabels: app: echo template: # template 아래는 파드 리소스 정의와 같음 metadata: labels: app: echo spec: containers: - name: nginx image: gihyodocker/nginx:latest env: - name: BACKEND_HOST value: localhost:8080 ports: - containerPort: 80 - name: echo image: gihyodocker/echo:latest ports: - containerPort: 8080 디플로이먼트레플리카세트보다 상위에 해당하는 리소스로 디플로이먼트가 있다. 디플로이먼트는 어플리케이션 배포의 기본단위가 되는 리소스이다.디플로이먼트의 정의는 레플리카세트의 정의와 크게 다르지 않다. 차이가 있다면 디플로이먼트가 레플리카세트의 리비전 관리를 할 수 있다는 점 정도다. 12345678910111213141516171819202122232425262728293031apiVersion: apps/v1kind: Deploymentmetadata: name: echo labels: app: echospec: replicas: 3 selector: matchLabels: app: echo template: # template 아래는 파드 리소스 정의와 같음 metadata: labels: app: echo spec: containers: - name: nginx image: gihyodocker/nginx:latest env: - name: BACKEND_HOST value: localhost:8080 ports: - containerPort: 80 - name: echo image: gihyodocker/echo:patched env: - name: HOGE value: fuga ports: - containerPort: 8080 레플리카세트의 생애주기실제운영에서는 디폴로이먼트 매니페스트 파일을 통해 레플리카 세트를 다룬다.디플로이먼트를 수정하면 레플리카세트가 새로 생성되고 기존 레플리카 세트와 교체된다. 레플리카 세트의 다양한 경우의 수파드 개수만 수정할 경우 (replicas값을 3에서 4로) 레플리카세트가 새로 생성되지 않는다. 컨테이너 이미지가 수정된 경우 기존 파드는 단계적으로 정지된다. 또한 kubectl rollout history deployment echo를 입력해보면 새로운 리비전으로 변경된것을 확인할 수 있다. 롤백하기undo를 실행하면 디플로이먼트가 바로 직전 리비전으로 롤백된다.1$ kubectl rollout undo deployment echo 디플로이먼트는 다음 명령어를 통해 삭제할 수 있다. 이와 관련된 레플리카세트와 파드가 함께 삭제된다.1$ kubectl delete -f simple-deployment.yaml","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://KKimSangHeon.github.io/tags/kubernetes/"}]},{"title":"5.도커 운영과 관리를 위한 명령","slug":"kube5","date":"2019-05-26T08:30:05.000Z","updated":"2019-05-27T12:19:49.742Z","comments":true,"path":"2019/05/26/kube5/","link":"","permalink":"http://KKimSangHeon.github.io/2019/05/26/kube5/","excerpt":"","text":"docker container prunedocker container prune [options]도커를 오래 사용하다 보면 디스케이 컨테이너와 이미지가 점점 늘어나게 된다. 이런 경우 prune 명령을 사용해 필요없는 컨테이너를 일괄 삭제할 수 있다. docker image prune [options]도커를 오래 사용하다 보면 디스케이 컨테이너와 이미지가 점점 늘어나게 된다. 이런 경우 prune 명령을 사용해 필요없는 이미지를 일괄 삭제할 수 있다. docker system prune [options]사용하지 않는 도커 이미지 및 컨테이너,볼륨,네트워크 등 모든 리소스를 일괄적으로 삭제할 수 있다. docker iamge prunedocker image prune [options]이미지도 컨테이너와 마찬가지로 사용하지 않는 것이 점차 누적된다. 디스크 용량을 너무 차지하지 않도록 정기적으로 삭제 해줘야 한다. docker image prune명령은 태그가 붙지않은 모든 이미지를 삭제한다. docker system prune사용하지 않는 도커 이미지 및 컨테이너, 볼륨, 네트워크 등 모든 도커 리소스를 일괄적으로 삭제한다. docker container stats시스템 리소스 사용 현황을 컨테이너 단위로 확인할 때 사용한다. 유닉스 계열 운영 체제의 top 명령과 같은 역할을 한다고 보면 된다.docker container stats [options] [대상_컨테이너ID] 80P부터","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://KKimSangHeon.github.io/tags/kubernetes/"}]},{"title":"4.도커 컨테이너 다루기","slug":"kube4","date":"2019-05-26T08:29:48.000Z","updated":"2019-05-26T08:32:04.209Z","comments":true,"path":"2019/05/26/kube4/","link":"","permalink":"http://KKimSangHeon.github.io/2019/05/26/kube4/","excerpt":"","text":"컨테이너는 파일 시스템과 어플리케이션이 함께 담겨있는 박스이다. 컨테이너의 생명주기도커 컨테이너는 실행 중, 정지, 파기의 3가지 상태를 갖는다. 이를 도커 컨테이너의 생애주기라고 한다. 각 컨테이너는 같은 이미지로 생성했더라도 다른 상태를 갖는다. 실행 중 상태 : docker container run 명령의 인자로 지정된 도커 이미지를 기반으로 컨테이너가 생성되면 이 이미지를 생성했던 Dockerfile에 포함된 CMD 및 ENTRYPOINT 인스트럭션에 정의된 어플리케이션이 실행된다. 이를 실행 중 상태라고 한다.서버의 경우 실행 기간이 길지만 명령이 바로 실행되고 끝나는 명령행 도구 등의 컨테이너는 실행 중 상태가 길게 유지되지 않는다. 정지 상태실행 중 상태에 있는 컨테이너를 사용자가 명시적으로 정지하거나 컨테이너에서 실행된 어플리케이션이 정상/오류 여부를 막론하고 자동으로 정지 상태가 된다.정지시키면 가상 환경으로는 더 이상 동작하지 않지만, 종료되던 시점의 상태가 저장돼 남는다. 그러므로 정지시킨 컨테이너를 다시 실행할 수 있다. 파기상태정 상태의 컨테이너는 명시적으로 파기하지 않는 이상 디스크에 그대로 남아있다. 한번 파기한 컨테이너는 다시는 실행할 수 없다. docker container run도커 이미지로부터 컨테이너를 생성하고 실행하는 명령이다. 도커 컨테이너를 싱행중 상태로 만들기 위해 사용한다.docker container run [options] 이미지명[:태그] [명령] [명령인자..]docker container run [options] 이미지ID [명령] [명령인자..] docker container run -it alpine:3.7 uname -a이 경우 Dockerfile에 정의되어있는 CMD 인스트럭션을 오버라이딩하여 uname -a가 실행되도록 할 수 있다. 컨테이너 이름 붙이기컨테이너를 다루는 명령을 실행할 때는 ID등으로 컨테이너를 특정해줘야 한다. 매번 docker container ls를 통해 id나 이름을 확인하기 번거롭기 때문에 이름을 붙여 활용할 수 있다.docker container run –name [컨테이너명] [이미지명]:[태그] docker container lsdocker container ls [options]실행 중이거나 종료된 컨테이너의 목록을 보여주는 명령 docker container ls -q 를 통해 컨테이너 ID만 추출할 수 있다. docker container stopdocker container stop 컨테이너ID또는컨테이너명실행중인 컨테이너를 정지하는 명령이다. docker container restartdocker container restart 컨테이너ID또는컨테이너명파기하지 않은 정지 상태의 컨테이너 재시작 docker container rmdocker container rm 컨테이너ID또는컨테이너명 docker container logs현재 실행중인 특정 도커 컨테이너의 표준 출력 내용을 확인할 수 있다.docker container logs [options] 컨테이너ID또는컨테이너명 docker container execdocker container exec [options] 컨테이너ID또는컨테이너명 컨테이너에서실행할명령 docker container cp컨테이너끼리 혹은 컨테이너와 호스트간에 파일을 복사하기 위한 명령이다. Dockerfile에 포함된 COPY 인스트럭션은 이미지를 빌드할 때 호스트에서 복사해 올 파일을 정의하기 위한것이고, docker container cp 명령은 실행중인 컨테이너와 파일을 주고받기 위한 명령이다. 컨테이너 안에 있는 /echo/main.go 파일을 호스트의 현재 작업 디렉터리로 복사하려면 다음과 같이 하면된다.docker container cp echo:/echo/main.go . 호스트쪽에서 컨테이너로 파일을 복사하려면 다음과 같이 한다.docker container cp dummy.txt echo:/tmp /","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://KKimSangHeon.github.io/tags/kubernetes/"}]},{"title":"3. 도커 이미지 다루기","slug":"kube3","date":"2019-05-22T11:48:50.000Z","updated":"2019-05-26T08:31:11.662Z","comments":true,"path":"2019/05/22/kube3/","link":"","permalink":"http://KKimSangHeon.github.io/2019/05/22/kube3/","excerpt":"","text":"도커이미지는 도커 컨테이너를 만들기 위한 템플릿이다컨테이너의 템플릿 역할을 하는 이미지를 만드는 과정을 일반적으로 도커 이미지를 빌드한다고 한다. 그리고 컨테이너를 실행할 때 빌드된 이미지를 사용한다. docker image build도커파일에 기술된 구성을 따라 도커 이미지를 생성하는 명령.docker image build -t 이미지명[:태그명] Dockerfile의 경로 docker searchdocker search [options] 검색_키워드도커 허브에 등록된 레파지토리를 검색할 수 있다.docker search jenkins 를 하면docker search library/jenkins와 같다.공식 레파지토리의 네임스페이스는 일률적으로 library이다. docker image pulldocker image pull [options] 리포지토리명[:태그명]인자로 지정한 레포지토리명과 태그는 도커 허브에 이미 존재하야 한다. docker image ls호스트 운영체제에 저장된 도커 이미지의 목록을 보여준다. docker image tag도커 이미지의 특정 버전에 태그를 붙일 때 사용한다.태그는 이미지의 특정 버전을 구별하기 위한것이다.같은 태그에 여러 도커이미지를 빌드했을 때 최근 빌드된 이미지만 해당 태그를 갖고 나머지는 none가 된다.태그는 이미지 ID에 태그명을 별명으로 붙이는 명령이다.도커 이미지는 빌드할 때마다 다시 생성되는데 그 내용의 해시값을 이미지 ID로 삼기 때문에 내용이 바뀌면 이미지 ID도 새값으로 바뀐다.docker image tag 기반이미지명[:태그] 새이미지명[:태그] docker image push도커 이미지를 도커 허브 등의 레지스트리에 등록하기 위해 사용docker image push [options] 리포지토리명[:태그]","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://KKimSangHeon.github.io/tags/kubernetes/"}]},{"title":"2.도커 컨테이너 실행","slug":"kube2","date":"2019-05-21T10:16:49.000Z","updated":"2019-05-23T13:06:39.516Z","comments":true,"path":"2019/05/21/kube2/","link":"","permalink":"http://KKimSangHeon.github.io/2019/05/21/kube2/","excerpt":"","text":"도커에서 제공하는 스크립트로 설치 12$ sudo wget -qO- https://get.docker.com/ | sh$ sudo usermod -aG docker shkim 도커 이미지 : 도커 컨테이너를 구성하는 파일 시스템과 실행할 어플리케이션 설정을 하나로 합친것으로, 컨테이너를 생성하는 템플릿 역할을 한다. 도커 컨테이너 : 도커 이미지를 기반으로 생성되며, 파일 시스템과 어플리케이션이 구체화돼 실행되는 상태. Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?이라는 에러 뜰 때 sudo systemctl start docker 실습1$ sudo docker image pull gihyodocker/echo:latest 위를 입력하여 이미지를 내려받자. 1$ docker container run -t -p 9000:8080 gihyodocker/echo:latest 를 입력하여 내부 8080포트로 포트포워딩이 가능토록 해보자 1$ curl http://localhost:9000 을 입력하면 정상적으로 동작함을 볼 수 있다. 1$ docker container stop $(docker container ls -q) 을 입력하여 컨테이너를 중지시킬 수 있다. DockerfileFROM : 도커 이미지의 바탕이 될 베이스 이미지. dOCKERFILE로 이미지를 빌드할 때 먼저 from 인스트럭션에 지정된 이미지를 내려받는다. 받아오는 이미지는 모두 도커 허브 레지스트리에 공개된 것이다. 콜론 뒤에 붙는것은 버전이라고 볼 수 있다. RUN : 도커 이미지를 실행할 때 컨테이너 안에서 실행할 명령을 정의하는 인스트럭션. 도커 안에서 실행할 명령을 그대로 기술한다. COPY : 도커가 동작중인 호스트 머신의 파일이나 디렉토리를 도커 컨테이너 안으로 복사하는 인스트럭션이다. CMD : 도커 컨테이너를 실행할 때 컨테이너 안에서 실행할 프로세스를 지정한다. RUN은 이미지를 빌드할 때 실행되고 CMD는 컨테이너를 시작할 때 한번 실행된다. RUN은 어플리케이션 업데이트 및 배치에, CMD는 어플리케이션 자체를 실행하는 명령이라고 생각하면된다.CMD [“실행파일”,”인자1”,”인자2”] - 실행파일에 인자를 전달한다.CMD 명령 인자1, 인자2 - 명령과 인자를 지정한다. 셸에서 실행되므로 셸에 정의된 변수를 참조할 수 있다.CMD [“인자1”, “인자2”] - ENTRYPOINT에 지정된 명령에 사용할 인자를 전달한다. ENTRYPOINT : 컨테이너의 명령 실행 방식을 조정할 수 있다. CMD와 마찬가지로 컨테이너안에서 실행할 프로세스를 지정하는 인스트럭션인다. ENTRYPOINT를 지정하면 CMD의 인자가 ENTRYPOINT에서 실행하는 파일에 인자로 주어진다. 즉, ENTRYPOINT에 지정된 값이 기본 프로세스를 지정하는 것이다. LAVEL : 이미지를 만든 사람의 이름 등을 적을 수 있다. ENV : 도커 컨테이너 안에서 사용할 수 있는 환경변수를 지정한다. ARG : 이미지를 빌드할 때 정보를 함께 넣기위해 사용한다. 이미지를 빌드할 때만 사용할 수 있는 임시적인 환경변수 이다.`` 도커 이미지 빌드도커파일 작성이 끝났으면 docker image build 명령으로 도커 이미지를 빌드할 수 있다. 문법은 다음과 같다.-t 옵션으로 이미지명을 지정한다. 태그명도 지정할 수 있으며 생략시에는 latest태그가 붙는다.-t 옵션과 이미지명은 반드시 지정해야 한다고 생각하는 편이 좋다. -t 옵션 없이도 빌드 자체는 가능하지만, 이미지명 없이는 해시값만으로 이미지를 구분해야 하므로 사용하기 번거롭다. 1docker image build -t 이미지명[:태그명] Dockerfile의 경로 실습을 진행해보자1$ docker image build -t example/echo:lastest . example은 네임스페이스를 의미한다. 이미지명에 이렇게 사용자 네임스페이스를 추가할 수 있으며 이미지명의 충돌을 피하기 위해 네임스페이스를 붙이는것이 좋다. 1$ docker image ls 를 입력하여 생성된 이미지의 정보를 확인할 수 있다. ENTRYPOINT1234FROM golang:1.10ENTRYPOINT [&quot;go&quot;]CMD [&quot;&quot;] 위와같이 도커파일을 만들고 아래를 입력하여 빌드해보자 1$ docker image build -t sh/golang:latest . 아래 명령어는 컨테이너 안에 들어가 go version을 입력한 것과 같다.즉 아래 명령어의 version이 도커파일의 CMD 부분에 대입되는것이다.1$ docker container run sh/golang:latest version 이처럼 ENTRYPOINT는 이미지를 생성하는 사람이 컨테이너의 용도를 어느정도 제한하려는 경우에도 유용하다. 도커 컨테이너 실행다음 명령어로 실행 할 수 있다.1$ docker container run example/echo:latest 다음 명령어로 데몬으로 실행할 수 있다. 명령어의 결과로 나오는 값은 컨테이너의 id이다. 도커 명령으로 컨테이너를 조작할 때 사용된다.1$ docker container run -d example/echo:latest 포트 포트포워딩HTTP 요청을 받는 애플리케이션은 컨테이너 밖에서 온 요청을 컨테이너 안에 있는 어플리케이션에 전달해줘야 한다. 이를 바로 포트 포워딩이라 한다. 포트 포워딩이란 호스트 머신의 포트를 컨테이너 포트와 연결해 컨테이너 밖에서 온 통신을 컨테이너 포트로 전달한다. 이 기능 덕분에 컨테이너 포트를 컨테이너 외부에서도 이용할 수 있다. 다음 명령어로 포트포워딩을 할 수 있다. 9000포트로 접속할 경우 컨테이너 내부 8080포트로 연결된다.1$ docker container run -d -p 9000:8080 example/echo:latest 또는 아래와 같이 빈 포트로 자동할당되도록 할 수 있다.12345$ docker container run -d -p 8080 example/echo:latest// 빈 포트가 에페메랄 포트로 자동 할당된다.$ docker container ls//포트를 확인해보자 /","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://KKimSangHeon.github.io/tags/kubernetes/"}]},{"title":"1.도커의 기초","slug":"kube1","date":"2019-05-18T14:49:26.000Z","updated":"2019-05-20T13:39:41.371Z","comments":true,"path":"2019/05/18/kube1/","link":"","permalink":"http://KKimSangHeon.github.io/2019/05/18/kube1/","excerpt":"","text":"도커 &amp; 쿠버네티스도커와 쿠버네티스에 대해 더 공부해보고 싶어 아래책을 구매하였고 포스팅해 볼 예정이다. 도커란 무엇인가도커는 컨테이너형 가상화 기술을 구현하기 위한 상주 어플리케이션(dockered라는 데몬)과 이 어플리케이션을 조작하기 위한 명령행 도구로 구성되는 프로덕트이다. 어플리케이션 배포에 특화되어 있기 때문에 어플리케이션 개발 및 운영을 컨테이너 중심으로 할 수 있다.로컬 환경에 도커만 설치하면 몇 줄짜리 구성 파일과 명령어 한줄로 어플리케이션이나 미들웨어가 이미 갖춰진 테스트용 가상환경을 빠르게 구축할 수 있다. 가상화 소프트웨어와 비교해도 오버헤드가 적이진다는 장점이 있다. 도커의 장점 기존 가상화 소프트웨어보다 더 가볍다. 이식성이 뛰어나다. 설치가 번거로운 명령형 도구를 도커 컨테이너로 가져다 사용함으로써 호스트를 깔금하게 유지하면서도 바로 실행할 수 있다. 다양한 의존 라이브러리나 도구를 도커 컨테이너에 포함시켜 배포함으로써 실행 환경과 상관없이 스크립트의 동작 재현성을 높임. 도커 컨테이너를 HTTP 부하 테스트의 워커로 사용해 HTTP 요청 수를 증가시킴. 컨테이너는 운영체제의 동작을 완전히 재현하지는 못하기 때문에 엄밀한 리눅스 계열 운영체제의 동작이 요구되는 가상환경을 구축해야 한다면 VMWare가 더 적합할 수 있다. 컨테이너 가상화?도커는 컨테이너형 가상화 기술을 사용하는데 이를통해 가상화 소프트웨어 없이도 운여 체제의 리소스를 격리해 가상 운영체제로 만들 수 있다. 이 가상 운영 체제를 컨테이너라 한다. 컨테이너를 만들면서 발생하는 오버헤드는 다른 가상화 소프트웨어보다 더 적다. 빠르게 시작 및 종료할 수 있고 이에 들어가는 리소스도 작은 편이다. 운영체제 가상화?운영체제 위에서 가상화 소프트웨어를 사용해 하드웨어를 에뮬레이션 하는 방법으로 게스트 운영체제를 만드는 방식을 호스트 운영체제 가상화 라고 한다. 컨테이너형 가상화와 비교하면 구조적으로 오버헤드가 크다. 컨테이너 가상화의 경우 하이퍼바이저와, Guest OS를 만들지 않는것을 확인할 수 있다. 그림에 대해 조금 더 알아보자 VMware, VirtualBox는 호스트 OS위에 게스트 OS 전체를 가상화 하여 사용하는 방식 도커는 게스트 OS를 설치하는 방식이 아닌 서버 운영을 위한 라이브러리만 이미지에 담아 설치하게 되므로 기존의 방법들(전가상화, 반가상화)보다 경량화 된 상태입니다. 즉, 하드웨어를 가상화하는 계층이 없어졌기 때문에 기존 가상머신에 대해 보다 빠른 속도를 제공합니다.https://real-dongsoo7.tistory.com/60 참고 컨테이너는 하이퍼바이저와 다르다. 컨테이너는 하이퍼바이저와 가상화라는 같은 목표를 갖고 있다. 하지만 하이퍼바이저는 OS 및 커널이 통째로 가상화 되지만 컨테이너는 파일시스템만 가상화가 된다. 컨테이너는 호스트 PC의 커널을 공유한다. 따라서 init등의 프로세스가 떠 있을 필요가 없고 가상화 프록르ㅐㅁ과는 다르게 적은 메모리 사용량 적은 오버헤드를 보인다. 도커를 사용하는 의의변화하지 않는 실행환경으로 멱등성 확보코드를 통한 실행환경 구축 및 어플리케이션 구성실행환경과 어플리케이션의 일체화로 이식성 향상시스템을 구성하는 어플리케이션 및 미들웨어의 관리 용이성 환경의 차이로 인해 발생하는 문제에 대해 나온것들1.코드로 관리하는 인프라코드 기반으로 인프라를 정의한다는 개념. 멱등성을 확보하기위해 어플리케이션이 의존하는 런타임이나 라이브러리 모두가 확실하게 특정 버전으로 설치되도록 해야한다. 멱등성 보장을 위해 항구적인 코드를 계속적으로 작성하는것은 운영 업무에 부담을 주기 쉽다. 또한 서버의 대수가 늘어날 수록 모든서버에 구성을 적용하는 시간도 늘어난다. 이러한 문제에 대한 대책이 불변인프라 개념이다. 2.불변인프라불변 인프라는 어떤 시점의 서버 상태를 저장해 복제할 수 있게 하자는 개념이다. 제대로 설정된 상태의 서버를 항상 사용할 수 있단는 점이 가장 큰 장점이다. 서버에 변경을 가하고 싶은 경우에는 기존 인프라를 수정하는 대신 새로운 서버를 구축하고 그 상태를 이미지로 저장한 다음 그 이미지를 복제한다. 한번 설정된 서버는 수정없이 파기되므로 멱등성을 신경쓸 필요가 없다. 도커를 활용할 경우 위의 두 개념을 쉽고 낮은 비용으로 실현할 수 있다. 도커는 컨테이너형 가상화 기술을 사용하다. 가상 머신의 OS를 재현하는게아닌 운영체제 대부분을 호스트 운영체제와 공유한다. 실행에 걸리는 시간이 짧은만큼 인프라를 완전히 새로 만드는 불변 인프라와 궁합이 잘 맞는다. 도커 컴포즈가 단일 서버를 넘어 여러 서버에 걸쳐있는 여러 컨테이너를 관리할 수 있도록 한 도구가 도커 스웜이다. 여러컨테이너를 관리하는 것만이 목적인 도커 컴포즈와 달리 도커 스웜은 컨테이너 증가 혹은 감소는 물론이고 노드의 리소스를 효율적으로 활용하기 위한 컨테이너 배치 및 로드 밸런싱 기능 등 더욱 실용적인 기능을 갖추고 있다. 또한 롤링업데이트(오래된 컨테이너와 새로운 컨테이너를 단계적으로 서비스에 교체 투입하는것)가 가능하다. 이처럼 여러 서버에 걸쳐있는 여러 컨테이너를 관리하는 기법을 컨테이너 오케스트레이션이라 한다. 컨테이너 오케스트레이션 분야에서 사실상 표준으로 자리 잡은 것은 쿠버네티스이다. 도커를 통해 인프라와 어플리케이션이 모두 컨테이너 형태로 제공되면서 인프라와 어플리케이션의 설정을 모두 코드수준에서 쉽게 수정할 수 있게됐다. 기존에는 명확했던 인프라 엔지니어와 서버 사이드 엔지니어의 영역 구분이 점점 희미해지고 있다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://KKimSangHeon.github.io/tags/kubernetes/"}]},{"title":"(K8s) 6. 윈도우에서 실습해보기","slug":"kubernetes6","date":"2019-05-06T14:26:48.000Z","updated":"2019-06-22T07:57:47.885Z","comments":true,"path":"2019/05/06/kubernetes6/","link":"","permalink":"http://KKimSangHeon.github.io/2019/05/06/kubernetes6/","excerpt":"","text":"도커툴박스설치 https://docs.docker.com/toolbox/overview/ virtual machine 가 없다면 체크하여 설치 PowerShell 관리자 권한으로 실행 12345678910111213141516$ ExecutionPolicy &lt;-- 현재상태확인$ Set-ExecutionPolicy Unrestricted$ Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))$ choco install minikube kubernetes-cli$ minikube start$ kubectl run sangheonkim --image=gcr.io/google-samples/kubernetes-bootcamp:v1 --port=8080$ minikube dashboard 파드 내부에서 출력하는 로그를 보자123$ kubectl get pods를 통해 파드의 정보를 복사하자,$ kubectl logs $POD_NAME 컨테이너로 들어가서 여러 명령어를 실행해보자123$ kubectl exec $POD_NAME env$ kubectl exec -ti $POD_NAME bash 서비스를 만들어보자 12345678$ kubectl get services서비스를 확인해보자. 미니쿠베가 만든게 하나 존재한다.$ kubectl expose deployment/sangheonkim --type=&quot;NodePort&quot; --port 8080서비스를 노출시켜보자$ kubectl describe services/sangheonkim서비스를 자세히 보자 Deployment를 자세히보자1$ kubectl describe deployments 보면 레이블이 있는것을 확인할 수 있는데 디플로이먼트는 저절로 레이블이 하나 생긴다. 레이블을 변경해보자12345678$ kubectl label pod $POD_NAME app=v1를 입력하여 레이블을 app=v1 으로 변경하고$ kubectl describe pods $POD_NAME을 입력하여 확인해보자.$ kubectl get pods -l app=v1을 입력하여 잘반영되었나 확인해보자 서비스를 삭제해보자1$ kubectl delete service -l run=sangheonkim","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://KKimSangHeon.github.io/tags/kubernetes/"}]},{"title":"(K8s) 5. 여러 인스턴스를 실행하기. Scaling 하기","slug":"kubernetes5","date":"2019-04-23T12:08:06.000Z","updated":"2019-04-28T09:42:12.109Z","comments":true,"path":"2019/04/23/kubernetes5/","link":"","permalink":"http://KKimSangHeon.github.io/2019/04/23/kubernetes5/","excerpt":"","text":"Scaling애플리케이션 스케일링하기이전 모듈에서 서비스를 만들고 퍼블릭하게 노출했다. 해당 디플로이멘트는 하나의 파드로 증가하도록 했다. 트래픽이 증가하면 사용자가 요구하는대로 어플리케이션을 실행할 필요 있다,.스케일링은 디플러이먼트의 어플리케이션 replicas를 몇개할지 정하는것이다. 하나만 감싸고 있는 서비스를 여러노드에 거쳐 서비스를 스케일 아웃을 할 수 있다.디플로이먼트를 스케일 아웃하면 신규 파드가 생성되어서 가용한 자원이 있는 노드에 스케줄된다. 스케일링 인은 파드개수를 줄이는것을 의미한다. 이는 또한 오토스케일링을 지원하기도 한다.(즉 들어오는 유동적으로 결정해주기도 함)제로로 스케일링하는것도 가능한데 이는 디플로이먼트에 정의되어있는 파드를 모드 제거 하는것이다. 애플리케이션의 인스턴스를 복수로 구동하게 되면 트래픽을 해당 인스턴스 모두에 분산시킬 방법이 필요해진다. 서비스는 노출된 디플로이먼트의 모든 파드에 네트워크 트래픽을 분산시켜줄 통합된 로드밸런서를 갖는다. 서비스는 엔드포인트를 이용해서 구동중인 파드를 지속적으로 모니터링함으로써 가용한 파드에만 트래픽이 전달되도록 해준다. 일단 여러인스턴스가 실행되면 롤링 업데이트를 자동으로 할 수 있다. kubectl get deployments를 입력하여 디플로이 먼트 리스트를 보자DESIRED는 설정에서 정의된 replicas 개수를 의미CURRENT는 현재동작중인 개수UP-TO-DATE 는 DESIRED를 맞추기 위해 뭐가 바뀌었는지AVAILABLE 유저한테 가용할 수 있는 개수 replicas을 네개로 바꿔보자kubectl scale deployments/kubernetes-bootcamp –replicas=4 kubectl get deployments를 입력하여 4개가 도는지 확인해보자 파드는 각 다른 아이피를 갖는데kubectl get pods -o wide를 입력하여 4개에 대해 자세히 볼수 있다. kubectl describe deployments/kubernetes-bootcamp를 입력하여 변경사항을 기록한 로그를 확인할 수 있다.(replicas를 4개로 바꾼것 확인 가능) kubectl describe services/kubernetes-bootcamp를 입력하여 서비스가 어떤아이피로 제공하고 있는지 확인할 수 있다. 12export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template=&apos;&#123;&#123;(index .spec.ports 0).nodePort&#125;&#125;&apos;)echo NODE_PORT=$NODE_PORT 를 입력하여 포트를 확인해보자. 이번엔 아래를 입력하여 스케일 다운해보자 replicas를2개로 바꾸자kubectl scale deployments/kubernetes-bootcamp –replicas=2 kubectl get deployments를 입력하여 디폴로이 먼트의 파드 개수를 확인해보자. kubectl get pods -o wide를 입력하여 2개의 파드가 종료된것을 확인할 수 있다. Rolling update유저는 어플리케이션을 항상 사용할수 있도록 원한다. 그리고 개발자는 하루에 여러번 배포할 수 있길 바란다. 이를 쿠버네티스에서 제공한느 롤링 업데이트를 통해 할 수 있다. 이는 디플로이먼트를 제로다운타임으로 점진적으로 파드를 업데이트 할 수 있다. 새파드는 가용한 리소스를 사용하여 새로운 파드가 만들어질 수 있다. 이전에는 여러 인스턴스를 에서 스케일링하는것을 배웠다. 기본적으로, 업데이트가 이루어지는 동안 이용 불가한 파드의 최대 개수와 생성 가능한 새로운 파드의 최대 개수는 하나다. 두 옵션은 기본적으로 업데이트할 때 파드 개수만큼 한번에 꺼버릴수있다. 그리고 최대갯수만큼 파드를 생성할 수있다.(즉 비율을 적용하여 할 수 있다.) 쿠버네티스에서 업데이트는 버전으로 관리되고 어떠한 디플로이먼트 업데이트라도 이전버전으로 원복이 가능하다. 어플리케이션 스케일링과 비슷하게 디플로이먼트가 노출되어있으면 서비는 가용한 파드한테만 보낸다.롤링업데이트는 다음과 같은 행동을 허용한다. 어플리케이션 환경 변경(컨테이너 이미지 변경방법) 이전버전으로 롤백 CI/CD 제로다운타임으로 새버전으로 업데이트 하고 롤백해보자 kubectl get deployments 를 입력하여 디폴로이 먼트들을 확인해보자(4개가 떠있다) kubectl get pods 를 입력하여 돌아가고 있는 파드들을 보자 kubectl describe pods를 입력하여 이미지 버전을 보자 이미지를 version2로 바꾸기 위해 다음을 입력하자 kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2 kubectl get pods를 입력하면 4개는 종료하고 러닝은 4개인것을 볼 수 있다.즉 한번에 4개를 죽여버리고 4개를 실행제로 다운타임이 아니다!! kubectl describe services/kubernetes-bootcamp를 입력하여 앱이 돌아가고 있는것과 아이피 포트를 확인하자 12export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template=&apos;&#123;&#123;(index .spec.ports 0).nodePort&#125;&#125;&apos;)echo NODE_PORT=$NODE_PORT 를 입력하여 포트 설정 후 1curl $(minikube ip):$NODE_PORT 을 입력하여 잘 돌고있나 보자 kubectl rollout status deployments/kubernetes-bootcamp를 입력하여 롤 아웃된것을 확인할 수 있다 kubectl describe pods를 입력하여 현재 이미지 버전을 볼 수 있다. kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=gcr.io/google-samples/kubernetes-bootcamp:v10를 입력하여 이미지를 버전 10으로 바꾸자 kubectl get deployments를 입력하여 디플로이먼트의 현재상황을 보자하나가 문제가 생긴것을 확인할 수 있다. kubectl get pods를 하면 파드들을 더 자세히 볼 수 있다. kubectl describe pods를 입력하여 파드들의 상태를 보자. 이미지가 바뀐지 보자봤는데 이미지가 바뀌지 않은것을 확인할 수 있다.레파지토리에 v10 이 없어서 그렇다. 그러므로 롤백하자. kubectl get pods를 입력하여 4개가 잘 돌고있는지 보고 kubectl describe pods를 입력하여 이미지가 잘 돌고있는지 보자","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://KKimSangHeon.github.io/tags/kubernetes/"}]},{"title":"(K8s) 4. 서비스를 사용하여 앱을 외부로 공개하기 , 서비스 / 레이블","slug":"kubernetes4","date":"2019-04-23T12:08:01.000Z","updated":"2019-04-23T12:18:16.726Z","comments":true,"path":"2019/04/23/kubernetes4/","link":"","permalink":"http://KKimSangHeon.github.io/2019/04/23/kubernetes4/","excerpt":"","text":"서비스를 사용하여 앱을 외부로 공개하기https://kubernetes.io/ko/docs/tutorials/kubernetes-basics/expose/expose-intro/ 지금까지의 앱은 컨테이너 안에서 도는데 private하고 네트웍도 isolate되어있었다. 그러므로 proxy 를 붙여서 동작했었다 쿠버네티스 서비스에 대한 개요파드는 언젠가 죽는것이다. 즉 라이프사이클이 있다. 어떤 워커노드가 죽으면 그 노드에서 돌고있는 파드도 죽는다. 그렇게되면 ReplicationController 가 클러스터를 동적으로 새로운노드를 만듬으로서 복구한다. 예를들어 이미지 처리하는 백엔드가 3개의 어플리케이션을 갖고있다 해보자. 프론트엔드는 백엔드 파드가 없어지는것 생기는것에 대해 신경쓰지 말고 동작하여야 한다. 각 파드는 유니크한 아이피를 갖고있는데 애플리케이션이 계속해서 동작할 수 있도록 발생하는 변화들을 서로 감지하는 방법이 필요하다. 서비스쿠버네티스에 있는 서비스는 파드의 set을 논리적으로 정의 한것이고 그 파드들에게 어떻게 접근할 수 있는지에 대한 정책을 정의한것이다.서비스는 파드들간에 커플링을 낮춘다. 서비스는 모든 쿠버네티스 오브젝트들과 같이 YAML (보다 선호하는) 또는 JSON을 이용하여 정의되고. 서비스가 대상으로 하는 파드 셋은 보통 LabelSelector에 의해 결정된다 서비스 외부로 노출하기비록 각각의 파드가 제각각의 IP를 갖고있지만 서비스 없이는 클러스터 바깥으로 노출되지 않는다. 서비스는 어플리케이션이 트래픽을 받게할 수 있는데 ServiceSpec에 type을 지정하여 노출 할 수 있다. ServiceSpec의 type ClusterIP (기본값) - 클러스터 내에서 내부 IP 에 대해 서비스를 노출해준다. 이 방식은 오직 클러스터 내에서만 서비스가 접근될 수 있도록 해준다. NodePort - NAT가 이용되는 클러스터 내에서 각각 선택된 노드들의 동일한 포트에 서비스를 노출시켜준다. :를 이용하여 클러스터 외부로부터 서비스가 접근할 수 있도록 해준다. CluserIP의 상위 집합이다. LoadBalancer - (지원 가능한 경우) 기존 클라우드에서 외부용 로드밸런서를 생성하고 서비스에 고정된 공인 IP를 할당해준다. NodePort의 상위 집합이다. ExternalName - 프록시를 사용하지 않고 임의의 Name을 사용해서 expose 하는방법으로 externalName을 스펙에다 정의함(YAML 혹은 JSON) kube-dns 1.7 이상 요구됨 추가적으로 셀렉터를 지정하지 않는경우도 있는데 셀렉터를 지정하지 않은것은 엔드포인트를 오브젝트를 만들지 않을것이다. 그렇게 함으로써 유저들로 하여금 직접 서비스를 특정엔드포인트에 매핑할 수 있도록 해준다. selector를 생략하게 되는 또 다른 가능성은 여러분이 type: ExternalName을 이용하겠다고 확고하게 의도하는 경우이다. 서비스와 레이블서비스는 파드들의 묶음인데 하나의 ip로 묶인다. 하나의 아이피는 외부에 노출되어 서비스안에 존재하는 파드들에 접근할 수 있게해준다. 서비스는 파드셋에다가 트래픽을 라우팅(쿠버네티스 서비스들에 의해 처리된다.)하는데 서비스는 파드가 애플리케이션에 영향을 주지않고 혼자 죽거나 살아날 수 있도록 한다. 파드 셋을 label이랑 selector을 사용하여 매치한다. label은 key / value 쌍이며 오브젝트에 붙어있고 여러가지 방식으로 사용될 수 있다. 개발, 테스트, 그리고 상용환경에 대한 객체들의 지정 임베디드된 버전 태그들 태그들을 이용하는 객체들에 대한 분류 레이블은 오브젝트가 만들어 질때 붙일수도 있고 나중에 붙일수있고 아무때나 수정할 수 있다. kubectl get pods를 입력하고 파드들을 확인해보자. kubectl get services를 입력하여 서비스를 확인해보자. 만들지도 않았는데 하나가 돌아가고 있는데 클러스터에서 미니큐브를 만들면 실행되는것이다. 새로운 서비스를 만들고 노출하려면 다음과 노트 포트를 파라미터로 줘야한다.kubectl expose deployment/kubernetes-bootcamp –type=”NodePort” –port 8080내부 8080포트에 붙으라는것. kubectl get services를 입력하여 서비스를 확인해보자.하나가 더 추가가 된것을 알 수 있다. 서비스가 클러스터ip로 인터널, external 포트가 있다. kubectl describe services/kubernetes-bootcamp를 입력하여 자세히 살펴보자. 노드포트라는 환경변수를 만들자123export NODE_PORT=$(kubectl get services/kubernetes-bootcamp -o go-template=&apos;&#123;&#123;(index .spec.ports 0).nodePort&#125;&#125;&apos;)echo NODE_PORT=$NODE_PORT 아래를 입력하여 접근해보자1curl $(minikube ip):$NODE_PORT 디플로이먼트는 자동으로 레이블이 하나있다.이를통해 파드리스트를 쿼리해보자.kubectl get pods -l run=kubernetes-bootcamprun=kubernetes-bootcamp이 label이다. kubectl get services -l run=kubernetes-bootcamp를 입력하여 run=kubernetes-bootcamp 이라는 레이블을 갖고있는 서비스를 조회해보자. 12export POD_NAME=$(kubectl get pods -o go-template --template &apos;&#123;&#123;range .items&#125;&#125;&#123;&#123;.metadata.name&#125;&#125;&#123;&#123;&quot;\\n&quot;&#125;&#125;&#123;&#123;end&#125;&#125;&apos;)echo Name of the Pod: $POD_NAME 를 입력하여 파드 네임을 환경변수에 넣어보자. app=v1으로 새로운이름을 주자.kubectl label pod $POD_NAME app=v1 kubectl describe pods $POD_NAME레이블 확인해보자. kubectl get pods -l app=v1바뀐 레이블로 파드를 조회해보자. kubectl delete service -l run=kubernetes-bootcamp를 입력하여 서비스를 삭제하자. kubectl get services서비스를 확인해보자. 라우팅도 잘 안되나 확인해보자.1curl $(minikube ip):$NODE_PORT 파드안에서 동작하는 아래의 명령어를 통해 아직 파드가 동작는지 보자.kubectl exec -ti $POD_NAME curl localhost:8080","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://KKimSangHeon.github.io/tags/kubernetes/"}]},{"title":"(K8s) 3. Pods and Nodes","slug":"kubernetes3","date":"2019-04-23T12:07:56.000Z","updated":"2019-04-23T12:14:58.383Z","comments":true,"path":"2019/04/23/kubernetes3/","link":"","permalink":"http://KKimSangHeon.github.io/2019/04/23/kubernetes3/","excerpt":"","text":"Podshttps://kubernetes.io/ko/docs/tutorials/kubernetes-basics/explore/explore-intro/ 디플로이먼트를 만들면 쿠버네티스는 파드를 만들어 어플리케이션 인스턴스를 호스트 해준다. 파드는 쿠버네티스 인스턴스이며 하나 또는 여러 컨테이너(도커나 rkt) 그룹을 추상화한것이다. 컨테이너 뿐만아니라 컨테이너들이 사용하는 리소스도 포함해서 파드라고 한다. 리소스는 다음을 포함한다. 볼륨과 같은, 공유 스토리지 클러스터 IP 주소와 같은, 네트워킹 컨테이너 이미지 버전 또는 사용할 특정 포트와 같이, 각 컨테이너가 동작하는 방식에 대한 정보 파드는 어플리케이션에 특화된 논리적인 호스트를 모델링한것이고 다른 어플리케이션 컨테이너를 이 안에 담아놓을 수 있으며 비교적 관련있는것들 끼리 모아놓은것이다. 예를 들어 하나의 팟안에다 두개의 컨테이너를 하나에 파드에 넣을 수 있다, 하나의 파드안에 들은 컨테이너들은 IP와 포트를 공유한다. 그래서 항상 같이 존재하며 같이 스케줄링된다. 파드는 atomic unit 이다. 쿠버네티스에서 디플로이먼트를 만들었을때 디플로이먼트는 컨테이너를 갖고있는 파드를 만든다.(컨테이너를 직접 만드는것이 아님)각각의 파드가 특정한 노드에 묶이게 되고 그 노드안에서 살게된다. 노드가 실패하면 동일한 파드를 또다른 클러스터에 있는 다른노드에서 실행한다.즉 파드 단위로 옮겨다닌다. Node파드를 실행하는게 노드이며 노드는 쿠버네티스에서 워커머신이다.(쿠버네티스는 마스터, 워커노드가 존재) 노드는 버츄얼 피지컬 머신일 수 도있다. 노드는 마스터에서 관리되면 여러개의 파드를 갖고있으며 쿠버네티스 마스터는 자동으로 어떤 파드를 노드에 올릴지 클러스터링 한다. 마스터의 자동 스케줄링은 가용한 리소스를 고용해서.. 모든 쿠버네티스 노드는 최소한 다음을 실행한다 Kubelet(팀장님)은, 쿠버네티스 마스터(본부장님)와 노드 간 통신을 책임지는 프로세스이며, 하나의 머신 상에서 동작하는 파드와 컨테이너를 관리한다. (도커, rkt)와 같은 컨테이너 런타임은 레지스트리에서 컨테이너 이미지를 가져와 묶여 있는 것을 풀고 애플리케이션을 동작시키는 책임을 맡는다. 노드 개요노드안에 파드가 여러개 들어갈 수 있고 파드는 각 아이피를 할당받는다. Kubelet이 노드들을 관리 kubectl을 통해서 배포된 앱들의 정보를 가져올 수 있다.kubectl get - 자원을 나열한다kubectl describe - 자원에 대해 상세한 정보를 보여준다.kubectl logs - 파드 내 컨테이너의 로그들을 출력한다kubectl exec - 파드 내 컨테이너에 대한 명령을 실행한다. 언제 애플리케이션이 배포되었으며, 현재 상태가 어떠한지, 그것의 구성은 어떠한지 등을 보기 위해 이러한 명령을 이용할 수 있다. kubectl get pods를 입력하여 파드가 있나 확인해보고 없으면 빌드를 다시해라 kubectl describe pods를 입력하여 파드에 대한 자세한 정보를 보자.IP, Port, Event결과물은 kubectl describe node를 입력하여 노드 정보를 갖고올 수 있다. 파드가 isolate, private 네트웍에서 동작하기에 kubectl proxy를 써서 사용하였었다. kubectl proxy를 입력하여 프록시르 띄우자 파드네임과 쿼리를 갖고와 프록시를 해보자.12export POD_NAME=$(kubectl get pods -o go-template --template &apos;&#123;&#123;range .items&#125;&#125;&#123;&#123;.metadata.name&#125;&#125;&#123;&#123;&quot;\\n&quot;&#125;&#125;&#123;&#123;end&#125;&#125;&apos;)echo Name of the Pod: $POD_NAME 동작하고 있는 애플리케이션 정보를 보고싶다면curl http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/proxy/를 입력하면 된다. 애플리케이션에서 보통 STDOUT로 내보내는데 그것이 로그가 된다. 이를 쿠버네티스 다음명령오로 가져올 수 있다.kubectl logs $POD_NAME(지금은 컨테이너가 파드안에 하나이기 때문에 지정하지 않아도 된다.) 파드가 동작하고 있으면 그안에 컨테이너에게 명령어를 실행할 수 있는데 다음과 같이 하면된다.kubectl exec $POD_NAME env(컨테이너 이름을 생략할수 있는것은 지금은 파드안에 컨테이너가 하나이기 때문에) kubectl exec -ti $POD_NAME bash를 입력하여 NodeJS 가 돌고있는 배쉬가 생겼다.이를통해 컨테이너 안에서 명령들을 동작해볼 수 있다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://KKimSangHeon.github.io/tags/kubernetes/"}]},{"title":"(K8s) 2. 클러스터 생성 및 앱 배포, 마스터 / 노드","slug":"kubernetes2","date":"2019-04-23T12:07:53.000Z","updated":"2019-04-23T12:12:46.994Z","comments":true,"path":"2019/04/23/kubernetes2/","link":"","permalink":"http://KKimSangHeon.github.io/2019/04/23/kubernetes2/","excerpt":"","text":"클러스터 생성 및 앱 배포이번에는 쿠버네티스란 무엇인지, 미니큐브는 무엇인지에 대해 알아보자. https://kubernetes.io/ko/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/ 참고 쿠버네티스 클러스터쿠버네티스는 높은 가용성을 클러스터 하는것이다. 즉 하나의 유닛으로 일하는 여러 컴퓨터들의 클러스터를 의미한다. 도커이미지를 배포할 수 있는 클러스터이다.특정 머신한테 배포 설정하는것이 아니라 쿠버네티스한테 배포하라고 던지면 쿠버네티스가 알아서 배포한다. 이를 사용하려면 어플리케이션은 특정 호스트에 묶이지 않은상태로 패키지 되어야 한다. 컨테이나이저 어플리케이션은 예전 배포모델보다 유연하다. (예전모델은 특정 머신에 의존성이 있었다.) 쿠버네티스는 좀더 효율적인 방법으로 클러스터에 어플리케이션을 어떻게 배포하고 스케줄링해야되는지에 대해 자동화함. 쿠버네티스는 오픈소스이며 클러스터 환경에서 쓸 수 있다. 쿠버네티스는 마스터, 노드로 구성된다.(스웜으로 비교하자면 각각 매니저, 워커이다. 스웜에서는 매니저, 워커 둘다 컨테이너를 띄울 수 있었다. 쿠버네티스에서는 노드에서만 컨테이너를 띄울 수 있다.) 쿠버네티스의 마스터, 노드마스터는 어플리케이션 스케줄링, 특정 상태로 만드는일, 스케일링하는일, 새 버전을 차곡차곡 배포해 나가는것을 관리함 노드들은 vm이거나 물리적인 컴퓨터인데 쿠버네티스에서 워커 머신역할을 한다.각각의 노드는 큐블릿을 갖고있는데 이는 노드를 관리하기 위한 에이전트이고 쿠버네티스 매니저와 의사소통한다. 노드는 도커 혹은 rkt와 같은 컨테이너 오퍼레이팅 툴이 필요하다. 쿠버네티스 클러스터는 프로덕션 트래픽을 다룰 수 있는데 이를 위해 최소 3개 이상의 노드를 갖고있어야 한다. 쿠버네티스의 배포과정 애플리케이션을 쿠버네티스에 배포할 때 마스터한테 어플리케이션 클러스터를 실행하라고 한다. 그럼 마스터는 컨테이너들을 클러스터 노드들에게 실행하도록 스케줄링 한다. 그럼 노드는 쿠버네티스 API를 활용해 마스터와 의사소통해서 쿠버네티스 API를 호출할 수 있다. 엔드유저 또한 API를 사용할 수 있다. 미니큐브 활용쿠버네티스 클러스터는 vm 혹은 물리적 컴퓨터에도 배포할 수 있다. 배포를 위해서는 미니큐브를 사용하라. 이는 쿠버네티스 경량버전이며 vm이 하나만 있다. 로컬머신에 설치할 수 있고 노드가 하나이다.즉 미니큐브는 vm을 만들어주는것이고 이 안에는 노드가 하나만 들어있다. 실습미뉴큐브가 미리 설치되어있는 온라인 환경에서 진행한다. minikube start를 입력하여 미니큐브를 실행하자 kubectl version을 입력하여 버전을 한번 보자. kubctl cluster-info를 입력해보자. kubctl get nodes를 입력하여 노드 정보를 보자.아까 말한대로(미니큐브에서는 노드 하나만 들어있는) 하나가 떠있는것을 볼 수 있다. kubectl을 활용하여 애플리케이션 배포동작하는 쿠버네티스가 있으면 컨테나이저된 앱을 배포할 수 있는데 이를 위해 쿠버네티스 배포 설정을 만들어야 한다.배포 설정은 쿠버네티스가 어떻게 인스턴스를 만들고 갱신해야하는지에 대한 역할을 한다. 이를 만들면 마스터가 노드에 배포를 한다. 애플리케이션 인스턴스가 한번 만들어지면 쿠버네티스 배포 컨트롤러는 지속적으로 인스턴스를 모니터링 한다. 만약 노드가 다운되거나 삭제되면 다른 노드에 배포하게 함으로서 셀프 힐링 매커니즘을 제공한다. 오케스트레이션이 없던시절에서는 스크립트를 사용했었다. 머신에 문제가 있을때 처리방법은 없었다. 쿠버네티스는 애플리케이션 인스턴스를 만들고 노드에 계속 실행하는것으로서 이전과는 다르다. kubectl을 통해 배포를 관리하고 만들 수 있다. 이는 쿠버네티스 API를 통해 소통한다(즉 마스터와 소통한다.) 배포를 만들때는 컨테이너 이미지를 적어야되고, 몇개의 어플리케이션을 실행하기 원하는지 적어줘야함. kubectl get nodes입력하여 노드를 확인 이제 앱 배포를 따라해보자 kubectl run은 배포를 새로만드는것이다.이를 위해 앱 이름과, 위치를 알려줘야 한다. 도커허브에 올라가있는 이미지가 아닌경우 레파지토리 uri까지 줘야한다. 앱을 특정포트에서 실행하고 싶다면 포트 파라미터까지 줘야한다. kubectl run kubernetes-bootcamp –image=gcr.io/google-samples/kubernetes-bootcamp:v1 –port=8080을 입력하여 배포하자. deployment 를 만듦과 동시에 배포됨.이를 통해 앱을 배포할 적절한 노드를찾았고 스케줄링을 했고 클러스터를 설정했다. kubectl get deployments를 입력하여 deployments정보를 얻어보자 파드란 쿠버네티스 안에서 도는것인데 private 하고 isolate하다. 기본적으로 쿠버네티스 안에있는 파드, 서비스들 끼리는 볼 수 있지만 쿠버네티스 클러스터 밖에서는 박에서 못본다, kubectl을 사용하여 api endpoint를 사용해서 어플리케이션과 의사소통할 수 있다. 어플리케이션을 쿠버네티스 클러스터에서 노출시키는 방법은 모듈 4에서 본다. kubectl proxy를 입력하여 프록시 다른탭에서 만들면 클러스터 wide , private network와 의사소통 할 수 있게된다. 프록시를 컨트롤 씨로 종료시킬 수도 있다 디폴리먼트 하나, 파드하나 , 레플리카 셋이 하나 있는것을 웹 프리뷰로 볼 수 있다. 이를 만들면 호스트와 쿠버네티스 클러스트간에 연결된것이고, 프록시를 사용하면 API 를 직접 사용할 수 있다. 여기서 말하는 API는 쿠버네티스 매니저의 API API서버는 자동으로 endpoint 를 각각의 pod기반으로 만들어준다. 우리는 pod네임을 가져오려면 다음과 같이하면된다.12export POD_NAME=$(kubectl get pods -o go-template --template &apos;&#123;&#123;range .items&#125;&#125;&#123;&#123;.metadata.name&#125;&#125;&#123;&#123;&quot;\\n&quot;&#125;&#125;&#123;&#123;end&#125;&#125;&apos;)echo Name of the Pod: $POD_NAME curl http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/proxy/를 입력하여 pod의 api로 라우팅할수있다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://KKimSangHeon.github.io/tags/kubernetes/"}]},{"title":"(K8s) 1. 쿠버네티스 개요","slug":"kubernetes1","date":"2019-04-23T12:07:19.000Z","updated":"2019-04-23T12:09:25.350Z","comments":true,"path":"2019/04/23/kubernetes1/","link":"","permalink":"http://KKimSangHeon.github.io/2019/04/23/kubernetes1/","excerpt":"","text":"쿠버네티스 개요https://kubernetes.io/ko/docs/tutorials/kubernetes-basics/ 참고 컨테이너화된 애플리케이션들을 관리할 수 있게 해준다. 컨테이너화 된 어플리케이션을 클러스터에 배포하는가. 즉 도커이미지로 만든것을 클러스터 배포하는가. 이번엔 스웜이 아닌 쿠버네티스라는 클러스터에 배포하는것. 어떻게 스케일할것인가. 어떻게 새 버전을 배포할것인가 어떻게 디버깅할것인지 카타코드를 사용하여 가상머신을 웹에서 실행 할 수 있다.미니큐브는 작게 만든 쿠버네티스이며 아무곳에서나 설치할 수 있다. 쿠버네티스로 할수 있는것.모던한 서비스는 24시간 7일동안 무정지를 기대한다. 개발자들도 새버전을 하루에 몇번씩 배포 할 수 있다는것을 기대한다. 즉 배포에 대한 수준이 높아졌다. 커테나이제이션을 통해 위의 높아진 수준에 부응할 수 있다. 쿠버네티스는 컨테나이저된 어플리케이션을 어디서든 실행할 수 있도록 도와준다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"http://KKimSangHeon.github.io/tags/kubernetes/"}]},{"title":"(Docker) 4. Stacks","slug":"docker4","date":"2019-04-21T10:40:15.000Z","updated":"2019-04-21T10:53:13.101Z","comments":true,"path":"2019/04/21/docker4/","link":"","permalink":"http://KKimSangHeon.github.io/2019/04/21/docker4/","excerpt":"","text":"docker-machine start $(docker-machine ls -q)를 입력하여 도커머신들을 띄우자 Swarm?스웜은 도커를 실행하는 머신들의 클러스터이며 애플리케이션을 배포할 수 있다. 컨테이너를 실행하고 여러머신에서 실행할 수 있다. Stack?이번에는 구조중 가장 맨위에 있는 스택을 다루겠다. 스택은 의존성을 공유하고 있는 관련있는 서비스들의 집합이다. 스택은 전체 어플리케이션과 어떻게 조화를 이루어야하는지 짤 수 있다. 복잡한 어플리케이션의 경우 여러개의 스택을 사용할 수 있다. docker-machine ssh myvm1 “docker swarm init –advertise-addr “을 입력하여 스웜 매니저로 띄워주자위를 입력하면 docker swarm join –token …..이라고 출력되는데 이는 스웜에 워커를 추가하고 싶으면 이렇게 입력하라는 것이다, 두번째 머신에 아래와 같이 입력하여 워커를 추가하자docker-machine ssh myvm2 “위에서 출력된값 복붙” 이제 머신 두개를 띄웠다.즉 스웜 매니저, 워커로 띄움 여러개의 멀티 머신에서 띄워보자. yml 파일을 아래와 같이 수정하자.이전것에서 visualizer 라는 서비스가 추가됨.추가된것은 호스트에 있는 파일을 컨테이너 안에다 집어넣어놨다.(dockersamples/visualizer:stable 안에 /var/run/docker.sock:/var/run/docker.sock 파일 넣음)default12345678910111213141516171819202122232425262728293031version: \"3\"services: web: # replace username/repo:tag with your name and image details image: username/repo:tag deploy: replicas: 5 restart_policy: condition: on-failure resources: limits: cpus: \"0.1\" memory: 50M ports: - \"80:80\" networks: - webnet visualizer: image: dockersamples/visualizer:stable ports: - \"8080:8080\" volumes: - \"/var/run/docker.sock:/var/run/docker.sock\" deploy: placement: constraints: [node.role == manager] networks: - webnetnetworks: webnet: docker-machine ev myvm1을 입력하여 매니저와 연결하자. docker stack deploy -c docker-compose.yml getstartedlab 를 입력하자. (이는 myvm1에서 실행하는것이다.) docker-machine ls를 입력하여 머신의 ip를 입력하고 8080포트로 접속해보자. 아래를 입력하여 레디스를 추가하자default12345678910111213redis: image: redis ports: - \"6379:6379\" volumes: - \"/home/docker/data:/data\" deploy: placement: constraints: [node.role == manager] command: redis-server --appendonly yes networks: - webnet docker stack deploy -c docker-compose.yml getstartedlab 를 입력하여 디플로이 하자. 레디스는 매니저에서만 실행되므로 동일한 파일 시스템을 쓴다.(워커것과 섞이지 않음)영속화를 위해 볼륨파일을 로컬에서 갖다 쓰고 매니저에서만 돌린다. docker service ls를 입력해서 돌아가고 있는 서비스를 확인해보자. docker container ls를 입력해서 각 떠있는 컨테이너들을 확인하자. Deploy배포하는 방법은 CE(Cloud Provider),Enterprise(Cloud provier), Enterprise(On-Premise)가 있다 도커 클라우드를 써서 앱을 관리할 수 있다.외부 클라우드에 배포하는 방법을 알아보자. 도커 클라우드는 스탠다드모드, 스웜모드로 쓸 수 있다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://KKimSangHeon.github.io/tags/Docker/"}]},{"title":"(Docker) 3. Swarms","slug":"docker3","date":"2019-04-17T14:06:35.000Z","updated":"2019-04-21T10:49:24.025Z","comments":true,"path":"2019/04/17/docker3/","link":"","permalink":"http://KKimSangHeon.github.io/2019/04/17/docker3/","excerpt":"","text":"이전강의에서는 만든 앱을 가져와서 어떻게 컴포즈로 정의해야 하는지 docker-compose.yml파일로 정의했었다.이번에는 애플리케이션을 클러스터에 배포한다. 멀티 컨테이너, 멀티 머신, 멀티 어플리케이션을 스웜이라 불리는 도커나이저 클러스터인 스웜에 배포할것이다. 스웜?스웜은 도커로 실행하는 머신들의 그룹이고 클러스터로 조인되어있다. 도커 커맨드를 그대로 사용할 수 있고 클러스터에 있는 스웜매니저에 도커 커맨드를 쓰는것이다. 스웜에 있는 머신들을 물리적, 가상적이어도 되고 스웜에 들어가있는 머신들을 노드라고 한다. 스웜매니저 : 여러개의 컨테이너를 어떻게 실행할지에 대한 전략이 있다. empiiest node 전략을 사용하면 컨테이너를 띄우가 위해 최소한의 머신을 쓴다.golbal전략은 컨테이너가 하나의 인스턴스를 갖도록 해준다. 즉 모든서버가 컨테이너 하나는 갖도록 해준다. 이는 컴포즈 파일을 통해 스웜매니저에게 알려줘야 한다.스웜에 들어간것은 노드라 하는데 이들에게 명령을 내릴수 있는건 스웜매니저라 하고 이러한 매니저들은 다른 스웜에 워커로 조인할 수 있도록 해준다. 워커는 컨테이너를 돌릴 수 있는 리소스를 제공해주고 다른머신에 작업을 명령할 권한은 없다. 도커는 스웜모드로 변경될 수 있다. 스웜모드로 바꾸면 현재의 머신이 스웜매니저가 되고 명령어는 현재머신에 시키는것이 아니라 스웜매니저에 시킨다. 스웜은 여러개의 물리 혹은 가상의 머신으로 이뤄진다. docker swarm init으로 스웜모드를 실행시키면 현재 머신이 스웜 매니저가 된다.docker swarm join을 다른 머신에서 사용하면 다른 머신에서 내가 만든 스웜매니저에 조인하게 된다. docker-machine create –driver virtualbox myvm1docker-machine create –driver virtualbox myvm2을 입력해 도커 머신을 생성하자. docker-machin ls 를 입력하면 생성된 머신을 확인할 수 있다. 이후docker-machine start myvm1 을 입력하여 머신을 띄우자. 이제 myvm1을 스웜매니저로 만들고 myvm2을 워커로 만들것이다. 첫번째 머신을 매니저로 먼들기위해 도커에 명령을 보내야한다.docker-machine ssh myvm1 “docker swarm init –advertise-addr “을 입력하면 docker swarm join –token …..이라고 출력되는데 이는 스웜에 워커를 추가하고 싶으면 이렇게 입력하라는 것이다,두번째 머신에 아래와 같이 입력하여 워커를 추가하자docker-machine ssh myvm2 “위에서 출력된값 복붙” docker-machine ssh myvm1 “docker” 앱을 스웜클러스터에 배포스웜매니저(myvm1)만 도커 커맨드를 실행할 수 있다는점을 잊지말자 지금까지는 ssh를 활용하여 가상머신에다 가상명령어를 실행했는데 다른방법으로는 docker-machine env 를 활용하여 쉘에서 도커데몬 vm을 연결하여 활용할 수 있다.이는 로컬에 있는 docker-compose.yml을 쓸 수 있으므로 유용하게 쓸 수 있다.다시설명하자면 이전에는 docker-compose.yml파일을 주고 디플로이를 해야했다. vm에는 해당 파일이 없으므로 vm에 떠있는 스웜매니저와 쉘을 연결하여 쉽게 사용할 수 있다. docker-machine env myvm1을 입력하여 쉘이랑 머신을 붙이고 맨아래 나오는 커맨드를 입력하자.그럼 myvm1에 들어온것과 같다. docker node ls를 입력하여 사용할 수 있는데 마치 myvm1이라는 스웜매니저에 들어온것같이 도커 커맨드를 사용할 수 있다. 즉 도커 디플로이를 하면서도 로컬에 있는 파일을 사용할 수 있게되었다! vm으로 파일을 옮기거나 하는 작업들이 필요없어졌다. docker stack deploy -c docker-compose.yml getstartedlab을 입력하여 배포 가능하다. 그러면 vm들에 컨테이너가 들어가게 된다. docker stack ps getstartedlab을 입력하여 여러 노드에 깔린것을 확인할 수 있다. 쉘이 다른 머신에 붙도록 하고싶으면 docker-machine env 명령을 활용하면 된다. 하지만 myvm2는 도커 매니저가 아니라 워커이기 때문에 도커 명령어를 실행할 수 없다. 접속해보자. docker-machine ls를 입력하여 ip를 확인하고 들어가보자. 네트웍은 두 노드끼리 공유되고 로드밸런싱된다. yml 파일의 replicas를 4로 바꾸고docker stack deploy -c docker-compose.yml getstartedlab을 입력하여 업데이트 하고docker stack ps getstartedlab을 입력하여 확인해보자 2개,2개씩 골고루 배치된것을 확인할 수 있다. cleanup and rebootdocker stack rm getstartedlab을 입력하여 도커를 내려보자, docker-machine ssh myvm2 “docker swarm leave”를 통해 도커 스웜에서 제거하자(워커는 이렇게 제거하면 된다.) docker-machine ssh myvm1 “docker swarm leave –force”를 통해 도커 스웜에서 제거하자(매니저는 이렇게 force를 넣어 제거하면 된다.) eval $(docker-machine env -u)env에 붙은 도커 머신 떼어내자.쉘이 도커 머신에서 떨어져 나간다.이제 로컬에 있는 도커 커맨드가 실행된다.. docker-machine stop를 입력하여 도커 머신을 멈추자. https://www.youtube.com/watch?v=p58k2_HMWRM&amp;list=PLfI752FpVCS84hxOeCyI4SBPUwt4Itd0T&amp;index=2의 53분부터 보면 요약 잘해주신다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://KKimSangHeon.github.io/tags/Docker/"}]},{"title":"(Docker) 2. Docker Services","slug":"docker2","date":"2019-04-17T14:05:48.000Z","updated":"2019-04-21T10:52:29.843Z","comments":true,"path":"2019/04/17/docker2/","link":"","permalink":"http://KKimSangHeon.github.io/2019/04/17/docker2/","excerpt":"","text":"Docker Serviceshttps://docs.docker.com/get-started 를 참고하여 진행 Compose를 설치하자. (보통 도커 설치하면 미리 깔린다.) 이번엔 어플리케이션을 로드밸런싱하고 스케일한다. 즉 컨테이너를 여러개 띄운다. 지난번엔 컨테이너를 했고 이번엔 서비스를 배운다.이전에도 얘기했듯이 컨테이너 위에 서비스 서비스 위에 스택이 존재한다. 서비스?분산된 앱에서는 각각을 서비스라 한다. 비디오 어플리케이션에서 데이터를 db에 저장하는 서비스, 비디오를 변환하는 서비스, 프론트엔드를 위한 서비스가 있을것이다. 서비스는 실제환경에서 쓰이는 컨테이너를 의미. 서비스는 오직 하나의 이미지만 실행한다. 서비스는 컨테이너들이 어떤 포트를 사용하고 얼마나 띄워야할지 씨피유는 얼마나 써야할지를 codify한다. 스케일링?서비스를 스케일링하는것은 실행할 컨테이너의 갯수를 변경하는것을 의미한다.또한 더많은 컴퓨터 자원을 서비스에 할당하는것을 의미 이는 도커에서 매우 쉽다.docker-compose.yml 파일을 사용하면 된다.이는 도커컨테이너가 프로덕션 환경에서 어떻게 동작해야 하는지 정의한다. 실습docker-compose.yml을 만들고default1234567891011121314151617181920212223242526272829version: \"3\"services:# 서비스의 이름은 web이다. web: # replace username/repo:tag with your name and image details # 아래의 이미지를 읽어와라 image: tkdgjs1501/get-started:part2 deploy: #다섯개의 컨테이너를 만든다. replicas: 5 resources: limits: #각각의 컨테이너는 10%의 CPU를 사용하고 cpus: \"0.1\" #50M를 할당한다. memory: 50M #무언가 잘못되었을 때 컨테이너를 다시 띄운다. restart_policy: condition: on-failure #컨테이너의 호스트의 4000번 컨테이너의 80번 포트를 연결 ports: - \"4000:80\" #다섯개의 컨테이는 로드밸런스를 통해 호스트의 80번 포트를 공유해야한다. 이를 위해 네트웍을 webnet 사용 networks: - webnet # webnet의 정의networks: webnet: 를 붙여넣음 위 파일은 도커한테 어떤 행동을 해야할지 알려주는것. docker swarm init을 입력하자 docker stack deploy -c docker-compose.yml getstartedlabgetstartedlab 라는 앱 네임으로 docker service lsgetstartedlab_web라는게 생성되는데 앱네임 뒤에 web이 붙여진것이다. 서비스안에 돌고있는 다섯개의 컨테이너를 태스크라 부르는데 태스크는 각각의 ID가 있고 순차적으로 증가한다. docker service ps getstartedlab_web를 입력하여 태스크를 나열해 볼 수 있다.task에 대한 정보들 http://localhost:4000/를 접속할 수 있는데 접속할때마다 호스트 네임이 바뀌는것을 확인할 수 있다.호스트네임 == 컨테이너 ID docker container ls컨테이너에 대한 정보들 스케일링 하기docker-compose.yml 파일의 replicas를 수정하여 스케일링 할 수 있다. replicas: 7로 바꾸고docker stack deploy -c docker-compose.yml getstartedlab를 입력하면 업데이트를 한다. docker service ps getstartedlab_web를 입력하면 7개로 변경된것을 확인할 수 있다. 정리하기docker stack rm getstartedlabdocker swarm leave –force","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://KKimSangHeon.github.io/tags/Docker/"}]},{"title":"(Docker) 1. Docker Orientation, Container","slug":"docker1","date":"2019-04-17T14:04:15.000Z","updated":"2019-04-21T10:49:21.876Z","comments":true,"path":"2019/04/17/docker1/","link":"","permalink":"http://KKimSangHeon.github.io/2019/04/17/docker1/","excerpt":"","text":"Docker Orientation, Container도커란?도커는 개발자, 시스템관리자를 위한 플랫폼이다. 애플리케이션을 컨테이너를 사용해 개발하고 배포할 수 있는 시스템. 컨테이너?컨테이너는 이미지를 실행한 런타임 인스턴스 이미지?이미지는 실행 가능한 패키지. https://blog.hanumoka.net/2018/04/28/docker-20180428-windows10pro-install-docker/ 도커의 구성하이라키의 맨아래는 컨테이너이고 그 위는 서비스 그위에는 스택이 있다,스택 - 서비스들간 어떻게 동작해야 하는지 (yml 파일의미)서비스 - 어떻게 컨테이너들이 프로덕트에서 동작하는지 정의 (yml안에서 정의됨 )컨테이너- 이미지를 실행한 런타임 인스턴스 과거엔 파이선을 시작할때 환경을 설치하는것 부터 시작했다. 이를 위해 로컬에 완벽한 환경을 세팅했어야헀다.도커는 포터블한 파이썬 이미지를 가져와 빌드를 가능하게 했다. 이는 도커 파일로 정의한다.도커파일은 컨테이너 안에 있는 파일들을 어떻게 구성해야하는지에 정의하는것이다. 네트워크 환경, 디스크 드라이브 등.도커파일을 한번 세팅해서 빌드하면 어디서 하든 동일하게 동작한다. https://docs.docker.com/get-started 를 참고하여 진행 도커 이미지 빌드 및 컨테이너 실행.한 디렉토리에 app.py , Dockerfile, requirements.txt 를 만들고 docker build –tag=friendlyhello .를 입력하여 이미지를 빌드한다. docker image ls를 입력하여 확인가능 docker run -p 4000:80 friendlyhello를 입력하여 파이썬은 80번을 통해 서비스하고 로컬에서는 4000을 통해 접속할 수 있게된다. http://localhost:4000를 입력하여 접속하여 보자 docker run -d -p 4000:80 friendlyhellodetacth모드로 실행하는 것이다. docker container ls현재 돌아가고 있는 컨테이너를 확인할 수 있다. docker container stop 1fa4ab2cf395를 입력하여 돌아가고 있는 컨테이너를 중지시킬 수 있다. docker container ls를 입력하여 돌아가고 있는 컨테이너 확인 이미지 publishdocker login을 통해 로그인 docker tag friendlyhello tkdgjs1501/get-started:part2(docker tag image username/repository:tag) 형태를 통해 도커 태그를 생성한다. docker image ls태그된 이미지 확인 docker push tkdgjs1501/get-started:part2(docker push username/repository:tag) 형태를 통해 push 진행 컨테이너, 이미지 제거.docker container rm docker image rm 원격에서 레파지토리에서 pull받고 image run하기docker run -p 4000:80 tkdgjs1501/get-started:part2(docker run -p 4000:80 username/repository:tag) 형태","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"MSA","slug":"CS/MSA","permalink":"http://KKimSangHeon.github.io/categories/CS/MSA/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://KKimSangHeon.github.io/tags/Docker/"}]},{"title":"규칙 17. 계승을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 계승을 금지하라","slug":"effective","date":"2019-04-14T07:39:51.000Z","updated":"2019-04-14T08:59:41.039Z","comments":true,"path":"2019/04/14/effective/","link":"","permalink":"http://KKimSangHeon.github.io/2019/04/14/effective/","excerpt":"","text":"계승을 위한 설계와 문서를 갖춘다는것은 무슨의미일까?메서드를 재정의 하면 어떤일이 생기는 지 문서에 잘 남겨야 한다. 즉 재정의 가능 메소드가 내부적으로 어떻게 동작하는지 문서에 남기라는 것이다. public, protected로 선언된 모든 메서드와 생성자에 대해 어떤 재정의 가능 메서드를 어떤 순서로 호출하는지 호출결과는 어떤 영향을 미치는지 남기라는 것이다.예를들어 후면 스레드가 호출할 수도 있고 static 초기화 구문 안에서 호출할 수도 있다. 관습적으로는 재정의 가능 메서드를 어떤식으로 호출하는지 주석 마지막에 명시한다. 좋은 API 문서는 메서드가 하는 일이 무엇인지 명시하지 어떻게 하는지 명시하면 안되지 않아?그렇다. 이는 맞는말이다. 계승이 캡슐화 원칙을 침해하기 때문에 발생하는 결과로 볼 수 있다. 문서만 제대로 썼다고 계승에 적합한 설계가 되지는 않는다. 너무 애쓰지 않고도 효율적인 하위클래스를 정의하기 위해서는 클래스 내부 동작에 개입할 수 있는 훅을 신중하게 고른 protected 메서드 형태로 제공해야 한다. 그렇다면 클래스를 설계할 때 protected로 선언할 멤버는 어떻게 정해?딱히 정해진 방법은 없다. 생각하고 신중하게 고른 다음 실제로 하위 클래스를 만들어 보면서 테스트하는것이 최선이다. protected 멤버 개수는 가능한 한 줄여야 하는데 구현 세부사항에 대한 일종의 서약 구실을 하기 떄문이다.즉 계승을 위해 설계할 클래스를 테스트할 유일한 방법은 하위 클래스를 직접 만들어 보는것이다. 만일 중요한 멤버를 protected로 선언하는것을 잊었다면 하위클래스에서 고통스러울 수 있다. 반대로 하위 클래스를 몇개 만들어봐도 사용할 일이 없는 protected 멤버는 private로 선언해야 한다. 그렇게 까지 신중하게 정해야하나?널리 사용될 클래스를 계승에 맞게 설계할 때는 문서에 명시한 내부 호출 패턴 뿐 아니라 메서드와 필드를 protected로 선언하는 과정에 함축된 구현 관련 결정들을 영원히 고수해야 한다는 점을 기억해야 한다. 따라서 다음 릴리스에 성능이나 기능을 개선하기 어려워진다.또한 계승용 문서는 API문서를 어지럽힐 수 있다. 계승을 허용하기 위해 따라야 할 제약사항.1.생성자는 직접적이건 간접적이건 재정의 가능 메서드를 호출해서는 안된다.이유:상위클래스 생성자는 하위클래스의 생성자보다 먼저 실행되므로, 하위클래스에서 재정의한 메서드는 하위클래스 생성가가 실행되기 전엔 호출될 것이다. 재정의한 메서드가 하위 클래스 생성자가 초기화한 결과에 의존할 경우 그 메서드는 원하는대로 실행되지 않을것이기 떄문에. 2.계승용 클래스가 Cloneable과 Serializable 와 같은 인터페이스를 구현하도록 하는것은 바람직하지 않다.이유:클래스를 계승할 프로그래머에게 과도한 책임을 지우기 때문이다. 하지만 하위 클래스 프로그래머가 이들 인터페이스를 선택적으로 구현할 수 있도록 하는 특별한 방법들이 있는데, 이런 조치들에 대해서는 규칙 11, 규칙 74에서 설명한다.만약 계승용 클래스가 Cloneable과 Serializable 와 같은 인터페이스를 구현해야 한다면 clone이나 readObject 메서드 안에서 직접적이건 간접적이건 재정의 가능한 메서드를 호출하지 않도록 주의해야 한다. 3.Serializable 인터페이스를 구현하는 계승용 클래스에 readResolve와 writeReplace 메서드가 있다면 priavte가 아닌 protected로 선언해야 한다.이유 :private로 선언해 버리면 하위 클래스는 해당 메서드들을 조용히 무시하게 된다. 이것은 계승을 허용하기 위해 구현 세부사항을 클래스 API의 일부로 포함시켜야 하는 사례 가운데 하나다. 정리계승에 맞도록 설계하고 문서화 하지 않은 클래스에 대한 하위클래스는 만들지 말라.가장 쉬운 방법은 클래스를 final로 선언하거나 모든 생성자를 private나 package-private로 선언하고 생성자 대신 public 정적 팩터리 메서드를 추가하는것. 규칙 15에서 설명한 대로 이방법을 사용하면 클래스나 패키지 내부에서는 하위 클래스를 만들어 쓸수도 있으므로 편리하다.계승을 반드시 허용해야 한다고 느껴지면 재정의 가능 메서드는 절대로 호출하지 않도록 하고 그 사실을 반드시 문서에 남겨라.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"규칙 16.계승하는 대신 구성하라","slug":"effective1","date":"2019-04-07T03:51:41.000Z","updated":"2019-04-21T10:52:11.245Z","comments":true,"path":"2019/04/07/effective1/","link":"","permalink":"http://KKimSangHeon.github.io/2019/04/07/effective1/","excerpt":"","text":"계승은 코드 재사용을 돕는 강력한 도구지만 항상 최선은 아니다. 계승을 적절히 사용하지 못한 소프트웨어는 깨지기 쉽다. 계승은 상위 클래스와 하위 클래스 구현을 같을 프로그래머가 통제하는 단일 패키지 안에서 사용하면 안전하다. 또한 계승을 고려하여 설계되고 그에 맞는 문서를 갖춘 클래스에 사용하는것도 안전하다. 일반적인 객체 생성 가능 클래스라면 해당클래스가 속한 패키지 밖에서 계승을 시도하는 것은 위험하다. 계승은 캡슐화 원칙을 위반한다.하위 클래스가 정상 동작하기 위해서는 상의 클래스의 구현에 의존할수밖에 없다. 상위 클래스는 릴리즈가 계속되면서 바뀔 수 있는데 이때 하위클래스는 망가질 수 있다. 또한 하위클래스는 상위클래스의 변화에 발맞춰 진화해야 한다. HashSet 를 계승하여 요소가 몇개나 추가되었는지에 대한 코드를 작성한다 가정해보자.default12345678910111213141516171819202122232425262728public class InstrumentHashSet&lt;E&gt; extends HashSet&lt;E&gt; &#123; //요소 삽입횟수 private int addCount = 0; public InstrumentedHashSet()&#123; &#125; public InstrumentedHashSet(int initCap, float loadFactor) &#123; super(initCap, loadFactor); &#125; @Override public boolean add(E e) &#123; addCount++; return super.add(e); &#125; @Override public boolean addAll(Collection&lt;? extends E&gt; c) &#123; addCount+= c.size(); return super.addAll(c); &#125; public int getAddCount() &#123; return addCount; &#125;&#125; 위의 코드는 제대로 동작하지 않는다. 가령 다음과같은 코드를 실행한다 해보자.InstrumentedHashSet s = new InstrumentedHashSet();s.addAll(Arrays.asList(“A”,”B”,”C”)); addAll은 3을 반환하는것이 아니라 6을 반환한다. HashSet의 addAll 메소드는 add메서드를 통해 구현되어 있기 때문이다. 이는 HashSet 문서에는 나와있지 않은 내용이다.하위클래스에서 재정의한 addAll 메서드를 삭제하거나 addAll메서드가 반복하며 add를 호출하도록 하여 해결할 수 있지만 이는 addAll 메소드가 add 위에서 구현되었다는 사실에 의존적이다. 이 또한 add메서드가 private일 경우 사용할 수 없다.또한 상위 클래스에 새로운 메서드가 추가될 경우 하위클래스의 구현을 망가뜨릴 수 있다.예를들어 특정 리스트에 데이터를 삽입할 때 “ksh” 라는 문자열이 붙도록 하는 메소드가 어느순간 추가되었을 때 삽입 작업만 호출하는 부모클래스의 메소드만을 호출할 때 .. 즉 InstrumentedHashSet 클래스는 깨지기 쉬운 클래스일수밖에 없다. 구성과 전달을 활용해 위의 문제를 해결하는 방법기존 클래스를 계승하는 대신, 새로운 클래스에 기존 클래스 객체를 참조하는 privae 필드를 하나 두는것. 이를 구성이라 하며 기존클래스가 새 클래스의 일부가 되는것을 말한다.새로운 클래스에 포함된 각각의 메서드는 기존 클래스에 있는 메서드 가운데 필요한 것을 호출해서 결과를 반환하면 된다. 이러한 구현 기법을 전달(forwarding)이라고 하고 전달 기법을 사용해 구현된 메소드를 전달메서드(forwarding method)라고 부른다.구성기법을 통해 구현된 클래스는 기존 클래스의 구현 세부사항에 종속되지 않기 때문에 견고하다.(기존 클래스에 또다른 메서드가 추가되더라도 새로운 클래스에 영향이 없음) default1234567891011121314151617181920212223242526272829303132333435//계승 대신 구성을 사용하는 포장(wrapper) 클래스public class instrumentedSet&lt;E&gt; extends ForadingSet&lt;E&gt; &#123; private int addCount = 0; public InstrumentedSet(Set&lt;E&gt; s)&#123; super(s); &#125; @Override public boolean add(E e)&#123; addCount++; return super.add(e); &#125; @Override public boolean addAll(Coolection&lt;? extends E&gt; c)&#123; addCount += c.size(); return super.addAll(c); &#125; public int getAddCount() &#123; return addCount; &#125;&#125;//재사용 가능한 전달(forwarding) 클래스public class ForwardingSet&lt;E&gt; implemetns Set&lt;E&gt; &#123; private final Set&lt;E&gt; s; public ForwardingSet(Set&lt;E&gt; s) &#123; this.s = s; &#125; public void clear() &#123;s.clear();&#125; public boolean contains(Object o) &#123;return s.contains(o);&#125; .....&#125; InstrumentedSet을 이렇게 설계할 수 있는것은 HashSet이 제공해야 할 기능을 규정하는 Set라는 인터페이스가 있기 때문이다. 이런 설계는 안정적일 뿐 아니라 유연성도 아주 높다.이전의 예제중 계승을 한 것에서는 한 클래스에서만 적용이 가능하고 상위 클래스 생성자마다 별도의 생성자를 구현해야 했다.하지만 포장 클래스 기법을 쓰면 어떤 Set 구현도 원하는대로 수정할 수 있고 이미 있는 생성자도 그대로 사용할 수 있다. 포장클래스의 단점이 별로 없으나 callback프레임워크와 함께 사용하기에는 적합하지 않다. 역호출 프레임워크에서 객체는 포장 객체에 대해서는 모르기 때문에, 자기 자신에 대한참조를 전달할 것이다. 따라서 역호출 과정에서 포장 객체는 제외된다. 이 문제는 SELF문제로 알려져있다. 요약계승은 강령하지만 캡슐화 원칙을 침해하므로 문제를 발생시킬 소지가 있다. 상위, 하위 클래스가 IS-A 관계일 때만 사용하는것이 좋고 그렇지 않을때는 구성과 전달기법을 사용하는것이 좋다. 포장 클래스 구현에 적당한 인터페이스가 있다면 더욱 그렇다.포장 클래스는 하위 클래스보다 견고할 뿐 아니라 더 강력하다.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"규칙 15.변경 가능성을 최소화하라","slug":"effective1","date":"2019-04-06T04:39:07.000Z","updated":"2019-04-21T10:51:51.806Z","comments":true,"path":"2019/04/06/effective1/","link":"","permalink":"http://KKimSangHeon.github.io/2019/04/06/effective1/","excerpt":"","text":"변경 불가능 클래스는 그 객체를 수정할 수 없는 클래스이다. 객체 내부의 정보는 객체가 생성돌 때 주어진 것이며, 객체가 살아있는 동안 그대로 보존된다.변경불가능 클래스를 만드는 이유는 변경 가능 클래스보다 설계하기 쉽고 구현하기 쉬우며, 사용하기도 쉽다. 오류 가능성도 적고, 더 안전하다. 변경 불가능 클래스가 따라야 할 규칙1.객체 상태를 변경하는 메서드를 제공하지 않는다.2.계승(상속)할 수 없도록 한다. 보통 final을 붙인다.3.모든 필드를 final로 선언한다. - 객체에 대한 참조가 동기화 없이 다른 스레드로 전달되어도 안전.4.모든 필드를 private로 선언한다.5.변경 가능 컴포넌트에 대한 독점적 접근권을 보장한다. - 클래스에 포함된 변경가능 객체에 대한 참조를 클라이언트는 획득할 수 없어야한다. 그런 필드는 클라이언트가 제공하는 객체로 초기화해서는 안되고 접근자 또한 그런 필드를 반환해서는 안된다. 따라서 생성자나 접근자, readObject 메서드 안에서는 방어적 복사본을 만들어야 한다. 대부분의 변경 불가능 클래스는 함수형 접근법을 사용한다.특정 연산 후 this객체를 변경하는 대신 새로운 객체를 만들어 반환하는것을 함수형 접근법이라 한다. 이르 사용하는 이유는 피연산자를 변경하는 대신 연산을 적용한 결과를 새롭게 만들어 반환하기 때문이다. 함수형 접근법의 장점함수형 접근법은 불가능성을 보장하므로 장점이 많다.1.변경불가능 객체는 단순하다. - 생성될 때 부여된 한 가지 상태만 갖는다. 따라서 생성자가 불변식을 확실히 따른다면 해당 객체는 불변식을 절대로 어기지 않게된다. 변경 불가능 객체의 장단점1.변경 불가능 객체는 스레드에 안전할수밖에 없다. 어떤 동기화도 필요없으며 여러 스레드가 동시에 사용해도 상태가 훼손될 일이 없다. 그러므로 변경불가능한 객체는 자유롭게 공유할 수 있다. 변경 불가능 클래스는 클라이언트가 기존 객체를 재사용하도록 적극 장려해서 이런 장점을 충분히 살릴 필요가 있다. 그렇게 하는 가장 쉬운 한가지 방법은 자주 사용되는 값을 public static final 상수로 만들어 제공하는 것이다.가령 Complex클래스는(변경 불가능클래스, 필드가 private final이며 생성자를 통해 한번만 초기화되고 setter또한 없다) 아래와 같이 제공될 수 있다.public static final Complex ZERO = new Complex(0,0); 2.자주 사용하는 객체를 캐시하여 이미 있는 객체가 거듭 생성되지 않도록 하는 정적 팩터리를 제공할 수있다. - 기존 객체를 공유하므로 메모리 요구량,GC비용이 줄어든다.3.변경 불가능 객체를 자유롭게 공유할 수 있다는점은 방어적 복사본을 만들 필요가 없다는 뜻이기도 하다. 사실 복사본을 만드는 메소드가 불필요하다.아니 만들면 안된다.(어차피 자기자신과 동일할테니)4.변경 불가능한 객체는 그 내부도 공유할 수 있다. 다른 클래스가 변경불가능 객체내에 있는 배열필드를 사용해도 된다.5.변경 불가능 객체는 다른 객체의 구성요소로도 훌륭하다. - 변경 불가능 객체는 맵의 키나 집합의 원소로 활용하기 좋다. (변하지 않으므로) 단점1.변경 불가능 객체의 유일한 단점은 값마다 별도의 객체를 만들어야 한다는 것이다.이는 단계별로 새로운 객체를 만들고 결국에는 마지막 객체를 제외한 모든 객체를 버리는 연산을 수행해야 하는 경우 성능 문제는 커진다.이를 해결하기 위한 방법은 두가지가 있다.첫 번째 방법은 다단계 연산 가운데 자주 요구되는것을 기본연산으로 제공하는 것이다. (BigInteger클래스는 package-private로 선언된 변경 가능 동료클래스를 사용해 모듈라 멱승같은 연산의 속도를 높인다. 이는 다단계 연산이 어떻게 적용될지 확실하게 예측할 수 있을때 쓴다.)두 번째 방법은 변경 가능한 public 동료 클래스를 제공하는것이다. 변경 불가능 클래스의 두번째 구현방법보통은 하위 클래스 정의가 불가능하도록 하기 위해 final로 선언하지만 다른방법도 있다.이는 모든 생성자를 private나 package-private로 선언하고 public 생성자 대신 public 정적 팩터리를 제공하는 것이다. 방어적 복사?BigInteger, BigDecimal은 클래스가 만들어질 당시 변경 불가능 클래스를 final로 선언해야 한다는 사실을 이해하지 못했기 때문에 final로 되어있지 않다. 즉 상속을 할 경우 해당 클래스는 변경이 가능할 수도 있다.만일 신뢰할 수 없는 클라이언트가 전달한 BigInteger나 BigDecimal 인자의 변경 불가능성에 보안이 좌우되는 클래스를 작성할 때는 전달된 인자가 BigInteger나 BigDecimal의 하위 클래스가 아니라 진짜 BigInteger나 BigDecimal 클래스 인지 확인해야 한다. 만일 하위 클래스 객체라면 해당 객체가 변경 가능한 객체일지도 모른다는 가정하에 방어적복사를 시행해야 한다.default12345public static BigInteger safeInstace(BigInteger val) &#123; if(val.getClass() !=BigInteger.class) return new BigInteger(val.toByteArray()); return val;&#125; 요약변경 가능한 클래스로 만들 타당한 이유가 없다면 변경 불가능 클래스로 만들어라.변경 불가능한 클래스로 만들 수 없다면, 변경 가능성을 최대한 제한하라. 특별한 이유가 없다면 생성자 이외의 public 초기화 메서드나 정적 팩터리 메서드를 제공하지 마라.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"규칙 14. public 클래스 안에는 public 필드를 두지 말고 접근자 메서드를 사용하라.","slug":"effective","date":"2019-04-06T04:37:42.000Z","updated":"2019-04-21T10:51:44.200Z","comments":true,"path":"2019/04/06/effective/","link":"","permalink":"http://KKimSangHeon.github.io/2019/04/06/effective/","excerpt":"","text":"default1234class Point &#123; public double x; public double y;&#125; 데이터 필드를 직접 조작할 수 있어서 캡슐화의 이점을 누릴 수 없다. API를 변경하지 않고서는 내부 표현을 변경할 수 없고, 불변식도 강제할 수 없고, 필드를 사용하는 순간에 어떤 동작이 실행되도록 만들수도 없다. 이는 private 필드와 public 접근자 메서드로 바꿔야 한다. public 클래스의 데이터 필드를 공개하게 되면, 그 내부 표현을 변경할 수 없게 된다. 변경하면 이미 작성된 클라이언트 코드를 깨뜨리게 되게 때문이다. 하지만 package-private 클래스나 priavte 중첩 클래스는 데이터 필드를 공개하더라도 잘못이라 말할 수 없다. 요약public 클래스는 변경 가능 필드를 외부로 공개하면 안된다. 변경 불가능 필드인 경우에는 외부로 공개하더라도 많이 위험하진 않지만, 그럴 필요가 있을까? package-private나 private로 선언된 중첩 클래스의 필드는 그 변경 가능 여부와는 상관없이 외부로 공개하는것이 바람직할 때도 있다.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"규칙 13. 클래스와 멤버의 접근 권한은 최소화하라","slug":"effective","date":"2019-04-04T13:05:19.000Z","updated":"2019-04-21T10:51:39.143Z","comments":true,"path":"2019/04/04/effective/","link":"","permalink":"http://KKimSangHeon.github.io/2019/04/04/effective/","excerpt":"","text":"정보은닉,캡슐화잘 설계된 모듈과 그렇지 못한 모듈을 구분짓는 중요한 속성은 세부사항을 구현사항을 다른 모듈에 잘 감추느냐의 여부이다. 잘 설계된 모듈은 구현 세부사항을 전부 API 뒤쪽에 감춘다. 모듈들은 이를 API를 통해서만 서로 통신하며 각자 내부정으로 무슨짓을 하는지는 신경쓰지 않는다. 이를 바로 정보은닉 또는 캡슐화라고 알려져있다.. 이는 소프트웨어 설계의 기본적인 원칙 가운데 하나이다,. 정보은닉의 중요성모듈사이의 의존성을 낮춰서(decouple), 각자 개별적으로 개발하고, 시험하고, 최적화하고, 이해하고, 변경할 수 있도록 한다는 사실에 기초한다. 이를통해 개발속도 향상, 병렬개발 가능, 유지보수 부담 저하, 모듈에 대한 쉬운이해가능, 다른 모듈에 영향없이 디버깅 진행가능이라는 장점이 있다. 또한 정보은닉 원칙이 좋은 성능을 자동적으로 보장하는 것은 안지만 효과적인 성능 튜닝을 가능하게 한다. 시스템이 완성된 다음에 어떤 모듈이 성능문제를 일으키는지 프로파일링 하기 용이하기 때문에,. 또한 이는 소프트웨어의 재사용 가능성을 높이고 대규모 시스템 과정의 위험성도 낮춘다(전체 시스템은 성공적이지 않더라도, 각각의 모듈은 성공적으로 구현 될수 있기 때문에) 각 클래스와 멤버는 가능한 접근 불가능하도록 만들라.개발중인 소프트웨어의 정상적인 동작을 보증하는 한도 내에서 가장 낮은 접근 권한을 설정할것.최 상위 레벨 클래스와 인터페이스에 부여할 수 있는 접근 권한은 package-private(default)와 public 두 가지다.최상위 레벨 클래스나 인터페이스에 public를 붙일 경우 해당 개체는 전역적 개체가 되고 public을 붙이지 않으면 해당패키지 안에서만 유효한 겍체가 된다. 최상위 레벨 클래스나 인터페잇는 가능한 package-private로 선언해야한다. 이를 통해 API 일부가 아니라 구현 세부사항에 속하게 되므로 다음번 릴리스에 클라이언트 코드를 깨뜨릴 걱정없이 자유로이 변경하거나 삭제하거나 대체할 수 있게된다. public으로 선언하게 되면 호환성을 보장하기 위해 해당객체를 계속 지원해야 한다. package-private(default)로 선언된 최상위 레벨 클래스 혹은 인터페이스를 사용하는 클래스의 사용자 클래스가 하나라면 사용자 클래스의 private 중첩 클래스로 만들것을 고려해 보자. 이를 통해 하나의 클래스만이 해당 클래스의 접근 권한을 갖게된다. protected는 자제하자package-private에서 protected로 변경하면 멤버를 사용할수 있는 범위가 엄청 넓어진다. 이는 해당 protected멤버에 대해 해당클래스의 구현 세부사항에 대한 공개적 약속과도 같으며 공개 API로서 영원히 유지되어야 한다. 원래 메서드의 접근보다 낮은 권한을 설정할 수없다.원래 안되는것이다. 넓힐순 있어도 좁힐 수는 없다. 이걸 어기면 컴파일 오류가 발생한다. 따라서 인터페이스를 구현하는 클래스를 만들 때는 인터페이스에 속한 모든 메서드를 해당 클래스의 public메서드로 선언해야 한다. 인터페이스의 모든 멤버는 원래 public이기 때문에 겍체 필드는 절대로 public으로 하지마라public로 할 경우 메서드를 통해 값을 변경할 수 있게된다. 따라서 그 필드에 관계된 불변식을 강제할 수 없다. 또한 public 필드를 가진 필드는 다중 스레드에 안전하지도 않다. static으로 선언된 필드특정 상수들을 public static final 필드들로 선언하여 공개할 수 있다. 이런 필드들은 반드시 기본 자료형 값들을 갖거나, 변경 불가능한 객체를 참조해야 한다. 변경 불가능한 객체를 public static final 필드가 가르키게 되면 참조대상 객체가 변경될 경우 끔찍한 결과가 초래된다. public static final 배열필드는 정의하지 마라.길이가 0이 아닌 배열은 언제나 변경 가능하므로 public static final 배열 필드를 두거나, 이를 반환하는 접근자를 정의하면 안된다. 이를 통해 배열 내용을 변경할 수 있게되므로, 보안에 문재가 생긴다.public static final Thing[] VALUES={ … }; //보안 문제를 초래할 수 있는 코드정의 했을경우 해결법.1.public으로 선언했던 배열은 private로 바꾸고 변경이 불가능한 public 리스트를 하나 만든다,default1234public static final Thing[] VALUES=&#123; ... &#125;;public static final Thing[] values( )&#123; Collection.unmodifiableList(Arrays.asList(PRIVATE_VALUES));&#125;2.어느 자료형으로 반환해야 클라이언트가 성능을 낼 수 있을까를 생각해보자. 요약접근권한은 가능한 낮추고 최소한의 public API를 설계하고 다른 모든클래스, 인터페이스, 멤버는 API에서 제외하라. public static final 필드를 제외한 어느 필드도 public 필드로 선언하지 마라. 그리고 public static final 필드가 참조하는 객체는 변경 불가능 객체로 만들어라","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"규칙12. Comparable 구현을 고려하라.","slug":"effective1","date":"2019-04-02T12:09:29.000Z","updated":"2019-04-21T10:51:26.853Z","comments":true,"path":"2019/04/02/effective1/","link":"","permalink":"http://KKimSangHeon.github.io/2019/04/02/effective1/","excerpt":"","text":"compareTo 메서드는 Comparable 인터페이스에 포함된 유일한 메서드이다. Object의 equals 메서드와 비슷하지만 단순한 동치성 검사 이외에 순서 비교가 가능하며 좀더 일반적이다.compareTo 메서드의 일반 규약은 equals와 비슷하다. 규약규약 객체와 인자로 주어진 객체를 비교한다. 이 객체의 값이 인자로 주어진 객체보다 작으면 음수, 같으면 0, 크면 양수를 반환한다. 인자로 전달된 객체의 자료형이 비교불가능한 자료형일 땐 ClassCastException예외를 던진다. 규약1. compareTo를 구현할 때는 모든 x와 y에 대해 sgn(x.compareTo(y))== -sgn(y.compareTo(x))가 만족되도록 해야 한다. (y.compareTo(x)가 예외를 발생시킨다면 x.compareTo(y)도 그래야하고, 그 역도 성립해야 한다.규약2. compareTo를 구현할 때는 추이성이 만족되도록 해야한다. (x.compareTo(y)&gt;0 &amp;&amp; y.compareTo(z) &gt;0 ) 이면 x.compareTo(z)&gt;0 이어야 한다.규약3. 마지막으로 x.compareTo(y) == 0 이면 sgn(x.compareTo(z)) == sgn(y.compareTo(z))의 관계가 모든z에 대해 성립하도록 해야 한다.sgn함수는 음수일때 -1, 0일때 0, 양수일때 1을 반환 또한 강력히 추천되지만 절대적으로 요구되는것이 아닌 조건으로 (x.compareTo(y) ==0) == (x.equals(y))이다. 일반적으로 Compareble 인터페이스를 구현하면서 이 조건을 만족하지 않는 클래스는 반드시 그 사실을 명시해야 한다. equals와 다르게 compareTo는 비교대상이 서로다를 경우 ClassCastException을 던지는것이 허용되어있다. 그리고 통상적으로 반드시 이렇게 동작해야 한다. 규약에서 이를 강제하지는 않지만 1.6 에 속한 어떤 클래스도 이런 비교를 하지 않는다! compareTo 규약을 준수하지 않는 클래스는 TreeSet, TreeMap, Arrays, Collection 같은 비교연산에 기반한 클래스들을 오작동 시킬 수 있다. 즉 compareTo 또한 반사성, 대칭성, 추이성을 만족해야 한다. 따라서 compareTo 규약을 만족하면서 클래스를 계승하여 새로운 값 컴포넌트를 추가할 방법은 없다. Compareble 인터페이스를 구현하는 클래스에 값 요소를 추가하고 싶을 때는 원래 클래스를 계승하여 확장하는 대신, 원래 클래스 객체를 필드로 포함하는 새로운 클래스를 만들고, 원래 클래스의 객체를 반환하는 뷰메서드를 추가한다, 이렇게 하면 원하는대로 compareTo 메서드는 원하는 대로 정의할 수 있다. Comparable 인터페이스Comparable 인터페이스는 자료형을 인자로 받는 제네릭 인터페이스이므로 compareTo 메서드의 인자 자료형은 컴파일 시간에 정적으로 결정된다. 따라서 인자로 받은 객체의 자료형을 검사하거나 형 변환할 필요가 없다. 잘못된 자료형 객체를 인자로 넘길경우 컴파일이 불가능하기 호출이 불가능하다. 또한 null이 인자로들어왔을 때는 NullPointerException 예외를 발생시켜야 한다.또한 객체참조 필드는 compareTo 메서드를 재귀적으로 호출하여 비교한다. 비교할 필드가 Comparable을 구현하지 않고 있거나 좀 특이한 순서 관계를 사용해야 할 경우에는 Comparator를 명시적으로 사용할 수 있다. Comparetor는 직접 작성할 수도 있고 아래의 compareTo 메서드에서처럼 이미 있는 Comparator를 사용할 수도 있다(String.CASE_INSENSITIVE_ORDER.compare(…..)같이). 비교클래스에 선언된 중요 필드가 여러개인 경우 비교 순서가 중요하다. 가장 중요한 필드부터 차례로 비교해야 한다.compareTo 메서드의 일반 규약이 반환값의 부호면 명시하고 그 크기에 대해서는 언급하고 있지않다. 이점을 이용해default1234public int compare(PhoneNumber pn)&#123; ... return a-b;&#125;와같이 정의하는게 코드를 단순화하고 보다 빠르게 동작하도록 할 수 있다.하지만 i가 큰 int값이고 j가 큰 음수 int 값일 때 (i-j)는 오버플로 되어 음수가 되어버리므로 부적절한 결과가 나온다.치명적 시스템 문제를 발생시키도 있으므로 주의하자.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"규칙 11. clone을 재정의할 떄는 신중하라","slug":"effective","date":"2019-03-31T12:14:01.000Z","updated":"2019-04-02T12:09:01.959Z","comments":true,"path":"2019/03/31/effective/","link":"","permalink":"http://KKimSangHeon.github.io/2019/03/31/effective/","excerpt":"","text":"Cloneable의 괴상함Cloneable은 어떤 객체가 복제를 허용한다는 사실을 알리는 데 쓰려고 고안된 믹스인(mixin) 인터페이스이다. 해당 인터페이스에는 clone 메서드가 없으며 Object의 clone 메서드는 protected로 선언되어 있다.Cloneabledms protected로 선언된 Object의 clone 메소드가 어떻게 동작할지 결정한다. 어떤 클래스가 Clonable을 구현하면 Object의 clone메서드는 해당 객체를 필드 다누이로 복사한 객체를 반환하고 Cloneable을 구현하지 않은 클래스라면 clone 메서드는 CloneNotSupportedException을 던진다. clone 메서드의 일반 규약객체의 복사본을 만들어서 반환한다. 그리고 다음을 따른다.x.clone() != x 의 조건은 참이어야 한다, x.clone().getClass() == x.getClass()위의 조건은 참이겠지만 반드시 그래야 하는 것은 아니다. x.clone().equals(x)위의 코드를 실행한 결과도 true가 되겠지만 반드시 그래야하는것은 아니다. 위의 코드를 실행한 결과도 true가 되겠지만 반드시 그래야 하는 것은 아니다.객체를 복사하면 보통 같은 클래스의 새로운 객체가 만들어지는데, 내부 자료 구조까지 복사해야 될 수도 있다. 어떤 생성자도 호출되지 않는다. 규약의 문제점어떠한 생성자도 호출되지 않는다는 점은 심하다. 복사본의 내부 객체는 생성자로 만들 수도있다. 클래스가 final로 선언되어 있다면, 생성자로 만든 객체를 반환하도록 clone을 구현할 수도 있다. 하지만 클래스가 final이든 아니든 생성자로 객체를 반환한다면 이 경우 원하는 클래스가 아닐것이다. 즉 clone를 재정의 할 때는 반드시 super.clone을 호출 해 얻은 객체를 반환해야 한다. 제대로된 사용방법1.Cloneable인터페이스를 구현하는 클래스는 제대로 동작하는 public clone 메서드를 제공해야 하고 이를 위해서는 상위클래스들이 제대로된 public 또는 protected clone 메서드를 제공해야 한다. 2.clone() 메소드의 반환형은 적절한 형태로 반환하여 라이브러리가 할 수 있는 일을 클라이언트에게 미루지 말자. 즉 라이브러리가 형변환을 하고 클라이언트는 변환하여 사용하지 않도록 하자. 3.복제할 객체가 변경가능 객체에 대한 참조 필드를 가지고 있을경우 deepCopy를 통해 극복하도록 하자.(ex 링크드 리스트의 배열!) 이방법이 싫다면 super.clone 호출 결과로 반환된 객체의 모든 필드를 초기상태로 되돌려 놓은 다음에 상위레벨 메서드를 호출해서 객체상태를 다시 만드는것이다. 다중스레드에 안전해야 하는 thread-safe 클래스를 Cloneable로 만들려면, clone 메서드에도 동기화 메커니즘을 적용해야 한다. Object.clone 메서드에는 동기화 메커니즘이 적용되어 있지 않으므로 설사 Object.clone 이 대체로 만족스럽다고 하더라도 super.clone()을 호출하는 동기화된 clone 메서드를 만들어야 할 것이다. clone의 주의사항1.clone 메서드는 또 다른 형태의 생성자이다. 원래 객체를 손상시키지 않아야 하며 복사본의 불변식도 만족시켜야 한다.2.clone 메서드는 복사본의 비-final 메서드, 즉 재정의 가능 메서드를 복사 도중에 호출해서는 안된다. 만일 하위 클래스에서 재정의한 메서드를 clone 안에서 호출하면 해당 메서드는 복사본의 상태가 완성되기 전에 호출될 것이며 복사본의 상태를 망가뜨릴것이다. 정리하자면계승을 위해 설계된 클래스에 clone을 재정의 할 때 Object.clone을 그대로 흉내내야 한다. protected로 선언하고, CloneNotSupportedException 예외를 던지고, Cloneable 인터페이스는 구현하지 않아야한다. 그래야 Object 클래스를 직접 계승한 클래스가 그렇듯, 하위 클래스가 Cloneable 구현 여부를 마음대로 정할 수 있다. 또한 Cloneable을 구현하는 모든 클래스는 반환값 자료형이 자기 자신은 public clone 메서드를 재정의 해야한다. 또한 처음에 super.clone을 호출해야한다. 그렇게 해서 만들어진 객체를 두고 수정해야 하는 필드를 수정한다.(deepCopy 등을 활용) 반전의 결론객체복제를 지원하는 좋은 방법은, 복사 생성자나 복사 팩터리를 제공하는 것이다. 복사 생성자는 단순히 같은 클래스의 객체 하나를 인자로 받는 생성자이다. 복사 팩터리 또한 같은 클래스의 객체 하나를 인자로 받는것이다.이는 Cloneable/clone보다 좋은점이 많다. 언어 외적 객체생성 수단에 의존하지 않으며 , 규약에 충실할 것을 요구하지도 않으며, final 필드 용법과 충돌하지도 않으며, 불필요한 예외를 검사하도록 요구하지도 않으며 형 변환도 필요없다.또한 해당 메서드가 정의된 클래스가 구현하는 인터페이스를 인자로 받을 수 있다.즉 Cloneable은 단점이 너무많다.. 쓰는것을 지양하자.. 배열의 clone메소드는 어쩔수 없이 쓰는경우가 있다.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"규칙 10. toString은 항상 재정의하라","slug":"effective","date":"2019-03-29T11:30:46.000Z","updated":"2019-03-31T12:15:46.120Z","comments":true,"path":"2019/03/29/effective/","link":"","permalink":"http://KKimSangHeon.github.io/2019/03/29/effective/","excerpt":"","text":"java.lang.Object 클래스가 toString 메서드를 제공하긴 하지만 이 메서드가 반환하는 문자열은 일반적으로 사용자가 보려는 문자열이 아니다. toStirng의 일반 규약에는 “모든 하위 클래스는 이 메서드를 재정의함이 바람직하다”라고 나와있다.equals와 hashCode의 일반 규약을 지키는 것보다는 덜 중요하지만 toString을 잘 만들어놓으면 클래스를 좀 더 쾌적하게 사용할 수 있다.toString메서드를 재정의하면 해당객체 뿐만아니라 이를 참조하는 특히 컬렉션 까지 혜택을 본다. 가능하다면 toString 메서드는 객체 내의 중요 정보를 전부 담아 반환해야 한다. 문자열에 담긴 내용은 척 보면 그 의미를 알 수 있도록 하는 것이 제일 바람직하다.하지만 객체가 아주 크거나 문자열로 반환하기 까다로운 상태정보의 경우 전부 문자열로 반환하는것은 바람직하지 않다. 문자열의 형식toString의 반환값 즉 문자열의 형식을 지정(ex. xml) 해 둘 경우 프로그래머가 객체를 문자열로, 문자열을 객체로 자유로이 변환할 수 있어 편리하다. 하지만 문자열의 형식을 명시 해 둘 경우 해당클래스가 널리 쓰인다고 가정했을 때 그 형식을 바꾸지 못한다는 단점이 있다. 이를 파싱해서 쓰는 사람도 있을것이고 지속적으로 저장하려는 사람도 있을것이기 때문에 혹시라도 toString이 반환하는 형태를 바꾸게 되면 많은 문제점들이 야기될것을 뻔한일이다. 결국 toString이 반환하는 문자열의 형식을 명시하건 그렇지 않건 간에 어떤 의도인지는 문서에 분명하게 남겨야 한다.또한 toString을 통해 갖고올 수 있는 정보들은 프로그래밍을 통해서도 갖고올 수 있어야한다.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"규칙 9. equals를 재정의 할 때는 반드시 hasCode도 재정의 하라","slug":"effective","date":"2019-03-27T13:57:46.000Z","updated":"2019-03-27T13:58:47.028Z","comments":true,"path":"2019/03/27/effective/","link":"","permalink":"http://KKimSangHeon.github.io/2019/03/27/effective/","excerpt":"","text":"많은 버그는 hashCode 메서드를 재정의하지 않아서 생긴다. equals 메서드를 재정의하는 클래스는 반드시 hashCode 메서드도 재정의 해야한다. 그렇지 않을경우 HashMap,HashSet 등과 같은 해시기반 컬렉션과 함께 사용하면 오작동하게 된다. hashCode의 일반적인 규약은 다음과 같다.1.응용프로그램 실행 중에 같은 객체의 hashCode를 여러 번 호출하는 경우 equals가 사용하는 정보들이 변경되지 않았다면 언제나 동일한 정수가 반환되어야 한다. 다만 프로그램이 종료되었다 실행되어도 같은 값이 나올 필요는 없다.2.equals(Object) 메서드가 같다고 판정한 두 객체의 hashCode값은 같아야 ㅎ나다,3.equals(Object) 메서드가 다르다고 판정한 두 객체의 hashCode값은 꼭 다를 필요는 없다. 그러나 서로 다른 hashCode 값이 나오면 해시테이블의 성능이 향상될 수 있다. Object의 hashCodeequals메서드가 논리적으로 같다고 판단한 두 객체라 해도 Object의 hashCode입장에서 보면 공통점이 없는 객체일 뿐이므로 같은정수를 반환하는것이 아닌 무작위로 선택된것같은 수를 반환한다. 좋은 해시함수좋은 해시함수는 다른 객체에서는 다른 해시코드를 반환하는 경향이 있다. 또한 이상적인 해시 함수는 서로 다른 객체들을 모든 가능한 해시 값에 균등하게 배분해야 한다.이상적인 해시함수를 만들기 위해서는 아래의 규약을 따르면된다.책 65p 참고 참고사항 중복필드는 해시코드 계산 과정에서 제외해도 된다. equals계산에 쓰이지 않는 필드는 반드시 제외해야 한다. result를 계산할 때 초기값 17은 임의로 잡은값이다. 이를 통해 해시값(c)이 0인것들도 해시값에 영향을 주게 된다. 절차 2.B에 사용된 곱셈은 필드 순서에 따라 계산 결과가 달라지도록 한다. 따라서 유하한 필드가 여러개 있으면 더 좋은 해시값이 나온다. 31은 소수이면서 홀수이기 때문에 선택된 값이다.(전통적으로 소수가 널리 사용된다. 또한 &lt;&lt;5 -i 연산을 통해 더욱 빠른 성능을 낼 수 있다.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"규칙 8. equals를 재정의 할 때는 일반 규약을 따르라","slug":"effectivejava2","date":"2019-03-26T13:21:31.000Z","updated":"2019-03-27T13:58:49.642Z","comments":true,"path":"2019/03/26/effectivejava2/","link":"","permalink":"http://KKimSangHeon.github.io/2019/03/26/effectivejava2/","excerpt":"","text":"equals는 생각보다 재정의 하기 어렵다. 실수로 인한 결과는 끔찍해 질 수 있다. 다음중 하나라도 만족할 경우에는 equals를 재정의 하지 않아도 된다.1.각각의 객체가 고유하다.(ex. Thread 객체)2.클래스에 논리적 동일성 검사방법이 있건 없건 상관없다(ex. Random class)3.상위클래스에서 재정의한 equals가 하위 클래스에서 사용하기에도 적당하다.(ex. AbstractSet의 equals 메소드)4.클래스가 private 또는 pakage-private로 선언되었고 , equals 메서드를 호출할 일이 없다.(필자는 실수로 equals를 호출할 수 있는 경우도 있으므로 재정의 해야 한다고 함) equals를 재정의하는게 바람직한 때?객체 동일성이 아닌 논리적 동일성의 개념을 지원하는 클래스일 때, 상위 클래서의 equals가 하위 클래스의 필요를 충족시키지 못할 때이다.대체로 값 클래스는 두 가지 요건을 충족시키지만 개체 통제 기능을 사용할 때, 열거형일때는 equals 메소드를 재정의 할 필요가 없다. equals 메서드를 재정의 할 때 준수해야 하는 일반규약메서드는 동치관계를 구현한다. 다음과 같은 관계를 동치 관계라 한다.반사성 : null이 아닌 참조 x가 있을 때 x.equals(x)는 true를 반환한다.대칭성 : null이 아닌 참조 x,y가 있을 때 x.equals(y)는 y.equals(x)가 true일 때만 true를 반환한다.추이성 : null이 아닌 참조 x,y,z가 있을 때 x.equals(y)가 true이고 y.equals(z)가 true이면 x.equals(z)도 true이다.일관성 : null이 아닌 참조 x와 y가 있을 때 equals를 통해 비교되는 정보에 아무 변화가 없다면, x.eqauls(y)호출 결과는 항상 같아야 한다.null이 아닌 참조 x에 대해서 x.equals(null)은 항상 false이다. 컬렉션 클래스를 비롯한 상당수 클래스는 전달되는 객체가 equals 규칙을 따른다고 가정하고 구현되어 있으므로 equals 는 잘 구현해야 한다!","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"규칙 7. 종료자 사용을 피하라","slug":"effectivejava1","date":"2019-03-26T13:21:22.000Z","updated":"2019-03-26T13:24:26.546Z","comments":true,"path":"2019/03/26/effectivejava1/","link":"","permalink":"http://KKimSangHeon.github.io/2019/03/26/effectivejava1/","excerpt":"","text":"종료자는 예측 불가능하며 대체로 위험하고 일반적으로 불필요하다. 종료자의 단점 및 주의할 점1.C++의 소멸자와는 다른개념이다. 종료자는 즉시 실행되리라는 보장이 전혀 없다. 그러므로 긴급한 작업을 종료자 안에서 처리하면 안된다. 종료자의 실행시점은 GC 알고리즘에 좌우되는데 이는 JVM 구현마다 크게 다르다. 또한 클래스에 종료자를 붙여놓으면 객체 메모리 반환이 지연될 수 있다.2.종료자는 즉시 실행되는것을 보장하지 않기때문에 지속성이 보장되어야 하는 중요상태정보는 종료자로 갱신하면 안된다.3.종료자를 사용하면 프로그램 성능이 떨어진다.즉 종료자를 사용하지 말고 명시적인 종료메서드를 하나 정의하고 이를 호출해라! 또한 종료여부를 객체안에 private로 보관하라명시적 종료의 예로 OutputStream, InputStream의 close 메서드가 있다. 주로 finally안에서 호출하여 예외가 발생해도 실행될 수 있도록 한다, 종료자의 쓰임1.명시적 종료메서드 호출을 잊을 경우에 대비하는 안전망으로의 역할 2.네이티브 피어와 연결된 객체를 다룰 때 - 일반 객체가 아니므로 GC가 알 수 없다. 하위클래스에서의 종료자 생성하위클래스에서 종료자를 오버라이딩 하면 상위클래스의 종료자를 호출 해 줘야 한다. 하지만 이를 잊어먹고 하지 않는경우 이로인한 문제가 발생한다.이를 방지하기 위해 익명클래스 안에 종료자를 정의하여 사용하는 방법이 좋다. 이를 종료 보호자(finalizer guardian)라 함.종료보호자에 대한 설명: 익명클래스로 finalize를 오버라이딩 하면 해당 스코프를 벗어나면 GC가 finalize를 호출하게 되어 상속받은 하위클래스가 super.finalize를 호출하지 않아도 된다.https://stackoverflow.com/questions/6872857/how-does-a-finalizer-guardian-work-in-java 즉 네이티브 자원을 종료시키려는것이 아니라면 종료자는 사용하지 말고 종료자를 불가피하게 사용해야할 경우에는 super.finalize()를 호출해라.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"규칙 6. 유효기간이 지난 객체 참조는 폐기하라","slug":"effectivejava","date":"2019-03-26T13:19:16.000Z","updated":"2019-03-26T13:24:23.412Z","comments":true,"path":"2019/03/26/effectivejava/","link":"","permalink":"http://KKimSangHeon.github.io/2019/03/26/effectivejava/","excerpt":"","text":"GC가 메모리 관리를 알아서 해주면 메모리관리의 중요성을 잊게 될 수도 있는데 그러지 말자 만기참조를 없애라더이상 참조되지 않는 만기참조의 경우 제거해주지 않으면 의도치 않은 객체 보유문제(실수로 객체 참조를 계속 유지하는 경우 해당 객체만 쓰레기 수진에서 제외되는것이 아니라 그객체를 통해 참조되는 다른 객체들도 쓰레기 수집에서 제외되는것)를 유발할 수 있다.이러한 문제는 쓸일이 없는 참조객체의 경우 null로 만들어 주는것으로 해결 가능하다. null처리에 대한 강박관념은 좋지않다.객체 사용이 끝나면 null처리를 해야된다는 강박관념에 사로잡히면 코드를 난잡하게 만들 수 있다. 그러므로 이는 규범이라기 보다는 예외적인 조치가 되어야 한다. 만기참조를 제거하는 가장 좋은 방법은참조가 보관된 변수가 유효범위(scope)를 벗어나게 두는 것이다. 즉 변수를 정의 할 때 유효범위를 좁게 만들면 자연스럽게 해결된다. 메모리 누수가 자주 일어나는곳들1.캐시객체 참조를 캐시 안에 넣어놓고 일어버리는 일이 많기 때문.WeakHashMap을 가지고 캐시를 구현하면 키에대한 참조가 만기 참조가 되는 순간 캐시안에 보관된 키-값 쌍은 자동으로 삭제된다. 2.리스너 등의 역호출자(Callback)역호출자를 명시적으로 제거하지 않을 경우, 적절한 조치를 취하기 전까지 메모리는 점유된 상태로 남아있게된다. gc가 역호출자를 즉시 처리하게 하려면 역호출자에 대한 약한참조만 저장하는것! WeakHashMap의 키로 저장하는것이 그 예이다. WeakHashMap?http://blog.breakingthat.com/2018/08/26/java-collection-map-weakhashmap/ 참고하자","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"규칙 5.불필요한 객체는 만들지 말라","slug":"effectivejava-1","date":"2019-03-24T04:06:59.000Z","updated":"2019-04-21T10:51:03.005Z","comments":true,"path":"2019/03/24/effectivejava-1/","link":"","permalink":"http://KKimSangHeon.github.io/2019/03/24/effectivejava-1/","excerpt":"","text":"기능적으로 동일한 객체는 매번 만드는것보다 재사용하는 편이 낫다.가령 String s = new String(“test”);라는 문장을 반복문안에 넣을경우 매번 String 객체가 생성된다.이는 String s = “test”; 로 대체하는것이 낫다. 이는 실행할 때마다 객체를 만드는 대신 동일한 String 객체를 사용하며 같은 JVM안에서는 해당 객체를 재사용하게 된다.생성자와 정적팩터리 메서드를 함께 제공하는 변경 불가능 클래스의 경우 생성자 대신 정적 팩터리 메소드를 이용하면 불필요한 객체 생성을 피할 수 있을 때가 많다. (Boolean(String) 보다는 Boolean.valueOf(String)쪽이 더 바람직하다. 생성자는 호출할 때마다 객체를 만들지만 정적 팩터리 메서드는 그러지 않는다.) 변경 불가능한 객체 뿐 아니라 변경가능한 객체도 재사용할 수 있다.default1234567891011..public boolean isIn( )&#123; Calendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\")); gmtCal.set(.....); Date strart = gmtCal.getTime(); gmaCal.set(...); Date end = gmtCal.getTime(); ...&#125;와 같은 코드가 존재할 때 isIn메서드는 호출될 때 마다 Caendar, TimeZone,Date객체 두개를 쓸데없이 만들어낸다.이는 정적 초기화 블록을 통해 개선하는것이 좋다.default12345678910111213private static final Date START;private static final Date END;public boolean isIn( ) &#123; static&#123; Calendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\")); gmtCal.set(.....); START = gmtCal.getTime(); gmaCal.set(...); END = gmtCal.getTime(); &#125;&#125; 이렇게 할 경우 Caendar, TimeZone,Date 객체는 클래스가 초기화 될 때 한번만 만들어진다. 이를통해 성능향상, 코드가 명료해진다(START, END가 상수라는것을 한눈에 알 수 있다) 만약 isIn() 메소드가 호출되지 않는다면 쓸데없는 초기화 과정이 진행된것인데 이는 초기화 지연기법을 사용하면 피할 수있다. 즉 isIn() 메서드가 처음 호출될 때 초기화한다. 이는 구현이 복잡해지고 성능을 개선시키기 어려워 질 수 있는상황을 만들수있다, 객체를 무작정 만들지 말라는것은 아니고 코드의 명확성, 단순성을 높이고 프로그램의 능력을 향상시킬 수 있을 때 만들라는것!객체 풀을 만들어 객체 생성을 피하는 기법 또한 객체생성 비용이 극단적으로 높지않다면 사용하지 말라.(DB접속 할때는 허용) 최신 JVM은 고도로 최적화된 GC를 갖고있으므로 풀보다 월등한 성능을 보여준다.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"규칙 4. 객체 생성을 막을 때는 private 생성자를 사용해라","slug":"effectivejava","date":"2019-03-24T04:06:27.000Z","updated":"2019-04-21T10:51:09.748Z","comments":true,"path":"2019/03/24/effectivejava/","link":"","permalink":"http://KKimSangHeon.github.io/2019/03/24/effectivejava/","excerpt":"","text":"정적 메서드나 필드만 모은 클래스가 필요한 경우는 다음 세가지로 볼 수 있다.1.자바의 기본 자료형 값 또는 배열에 적용되는 메서드를 한군데 모아둘 때.(java.lang.Math, java.lang.Arrays)2.특정 인터페이스를 구현하는 개체를 만드는 팩터리 메서드 등의 정적 메서드를 모아놓을 때(java.util.Collection)3.final 클래스에 적용할 메서드들을 모아놓을 때(상속하여 메서드 추가가 불가능하므로) 위의 경우에 객체를 생성하는건 이상하다!.하지만 생성자를 생략하면 디폴트 생성자가 만들어진다. 이로인해 자신이 생각도 못한사이에 API에 추가되어 있을 수 있다그렇다고 abstract로 선언하는것도 바보같은일이다. 상속으로 인해 객체 생성이 가능하므로…객체생성을 막기위해서는 private 생성자를 생성하자이를 통해 하위 클래스 또한 만들 수 없게 할수 있다.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"190323. Write the docs 밋업 참가","slug":"writethedocs","date":"2019-03-23T05:06:12.000Z","updated":"2019-12-25T13:28:11.002Z","comments":true,"path":"2019/03/23/writethedocs/","link":"","permalink":"http://KKimSangHeon.github.io/2019/03/23/writethedocs/","excerpt":"","text":"Write the docs밋업도 열고 구인구지도 하고 문서화에 대한 다양한 이야기를 진행한다. 글쓰는 개발자 모임, 글또변성윤님(쏘카 데이터 그룹 머신러닝 엔지니어) 네이버 블로그를 통해 글을 꾸준히 쓰던 습관 형성까먹는게 싫어서 개발 블로그 시작 글또?- 글쓰는 똘아이가 세상을 바꾼다10마넌을 넣어넣고 주니어개발자들 끼리 진행했다. 글을 안쓰면 마넌씩 삭감여러가지의 규칙을 만들어 놓고 진행해나감..(월 2개의 포스팅을 작성, 800자이상 등…) 어떤글을올렸나?에러가 왜 발생했을까? 해결방안만 올리지 않고 원인을 정리, 프로젝트 진행하는것, 회고(1년 주기로) 등.. 13명의 글을 2주마다 피드백을 통해 더 나은 글을 목표로함점검은 오타, 전개바식, 이해 가능성, 가독성, 이미지 품질. 지금까지 낙오자 없이 잘 끝났다! 성과 : 구성원들의 글쓰기 역량 향상! 높은 충성도! 이직할때 도움(실제로 도움을 받았다고 하심!)! 양질의 글로 개발 생태계에 기여 사람을 만날수 있는 연결고리!결론 : 글을 쓰는건 쉽지 않지만 함꼐하면 꾸준히 할수 있따! 물론 예치금이 중요하지만 ㅋㅋ 기술블로그 생존전략: 구글시대의 글쓰기김대권님(당근마켓 인프라 클라우드 개발)44bits.io 운영 중 우리는 왜 글을 쓸까요? 읽히기 위해서!사람들을 어떤 경로를 통해 블로그로 접근할까?Social, Organic Search 검색이 주요 유입원.SNS의 경우 생명령이 짧다. 짧으면 3일 길어봤자 1주일… 그렇지만 즉각적인 반응이 장점!물론 팔로워가 없으면 효과가 떨어짐…방치된 블로그의 경우 Organic Search 가 주요 유입원이다. 즉 블로그는 소셜보다 오랫동안 읽혀질 확률이 높다!! 하지만 이는 예측이 어렵다..(즉각적인 반응이 없다)또한 티끌모아 태산이다!! 신뢰성을 쌓게되면 검색에서의 결과로 뜰 수 있어진다.!! 컨텐츠가 더 잘 발견되기 위해서는 장기적으로 봤을때 검색유입을 목표로 하자구글을 어떻게 검색결과를 보여줄까??? 정밀도, 재현도를고려한다는데 이해하기 어렵다… 검색엔진은 백과사전이 아니라 거대한 추천시스템이다. 즉 수집한 문서들 중 검색 키워드 중 가장 추천할 만한 글을 정렬해서 보여준다. 어떻게 해야 내 글이 검색될까?문서와 웹 사이트문서 - 검색엔진이 검색한것은 웹사이트가 아니라 문서이다! 사이트를 잘만드는것도 중요하지만 구성요소 즉 문서를 단단히 하는것이 중요하다.메타데이터보다는 제목과 본문이 중요하다. 좋은 제목은 아무리 강조해도 지나치지 않음. 핵심 키워드가 포함되고, 본문을 잘 드러내야 한다. 그리고 본문의 질이 좋아야 한다.구글을 글을 보고 질 좋은 컨텐츠를 알아볼 수 있다. 그러므로 메타데이터는 중요하지 않다고 한것! 질좋은 컨텐츠를 위핸 제언1.완성된 글을 작성한다. 이상한 글을 쓰면 블로그의 신뢰도를 떨어뜨린다.(예를들어 한줄짜리, 자신의 메모, 완성되지 않은 문장, 설명보다 코드가 긴 글, 링크만 모아놓은 글, 개인노트를 그대로 공개한 글, 직접 작성한 내용이 없는 글)2.적당한 분량의 글을 작성한다. 7분정도 읽히는글(5600자 정도 즉 7페이지)이 가장 좋다! 그림의 유무 여백에 따라서 다르지만 600~1200자 정도가 적당!!!!!!! 짧은 뉴스는 2000~3000 긴글을 20000~30000 이것보다 길면 나눠서 쓰자! 블로그에 쓸 수 있는글튜토리얼, 하우투, 해설, 뉴스기사, 에세이 Page Rank과거에는 페이지의 랭크를 구글에서 제공했다. 페이지의 신뢰도를 쌓아라. 나무위키의 경우에도 잘못된 정보들이 많지만 랭커는 높다.장기적인 관점에서 잘 운영하는것이 중요하다!!! 처음 블로그를 시작하려면관심사 -&gt; 키워드 -&gt; 글쓰기 -&gt; 공유1.관심사들을 정리하고 키워드를 정하여 구글에서 검색해보자. 아직 좋은 글이 별로없는, 적당한 범위의 키워드를 정하자.2.5000자 이상의 글을 작성하자. 제목에는 반드시 키워드를 포함하자.3.게시하고 공유하고 기다려라. 지식 공유를 시작하려는 개발자홍연의님(LINE+ Developer Realations 팀) Developer Realations팀에 어떻게 가게 되었나요? IT출판사에서 IT도서 기획 편집자로 일을 시작했다.다양한 커뮤니티 활동을 진행했다. 또한 책을 만들어내기 위해 저자의 전문지식을 잘 가공해서 지식공유를 돕는일을 진했했었다. DE팀에서 라인 개발자달의 전문성을 세상사람이 알 수 있게 해는것. 하는일 : 사내개발자 기고 글관리 등…개발자 대상 행사 주최. 라인의 개발자와 개발자 문화를 세상에 알릴 수 있는 모든 일. 라인의 개발자가 쉽게 지식 공유할 수 있도록 돕는 일 지식공유를 시작하려는 개발자에게...블로그, 책, 영상, 강의, 발표등을 통해 지식고유를 할 수 있지만 쉽지만은 않다. 지식공유를 통해 인생의 또다른 기회를 갖게될 수 있따. 기회뿐만이 아니라 누군가에게 도움이 된다는 뿌듯함을 얻을 수도 있다. 사용자를 외면하지 않는 릴리스 노트조은별님(시큐아이, 보안회사 테크니컬 라이터) 테크니컬 라이터는 어떤 일은 하나요?기술사업 분야에서 특정사용자를 대상으로 기술적인 정보를 제공하는 문서를 제작.사용자메뉴얼, 릴리스노트, API문서, 화이트 페이퍼, UI용어/메시지 등…. 릴리스 노트의 정의문제를 정의하고 해결점을 기술한 문서. 즉 소프트웨어가 업데이트 될때 마다 업데이트 정보를 제공하기 위해 요약되어 작성되는 문서신규기능, 개선된기능, 오류수정.. 릴리스 노트의 필요성앱스토어에서도 자주 보여진다. 자세하게 어떤부분이 어떻게 업데이트 되었는지 알려주는것이 매력적이다.함축적이고 연관된 이슈에 대해 알려주는것도 좋은방법이라 할 수 있다. 릴리스 노트의 포멧신규기능을 나누고 신규기능에 대한 설명을 통해 직관성을 제공하는것이 좋다.ex:[신규기능]ㅁㅁ메뉴에 xx추가했습니다. [개선된기능]보기의 ㅇㅇ을 ㅇㅇ할수있도록 개선했습니다. 릴리스 노트 작성 시 고려할것1.제품/사용자 특성 : 누가 읽는것인지?2.일관된 문서 포맷: 어떻게 읽는 것인지? 3.세 줄 요약 : 무엇을 익는 것인지?개발자는 왜 블로그를 해야하나요?이동욱님(우아한 형제들, 백엔드 개발자, jojuldu 블로그 운영) 마크타운 파일을 티스토리에 올릴 수 있는 플러그인 개발 플로그를 좋아하고 개선하고 혜택을 받음블로그를 하면 좋은이유한달에 1000달러 정도… 출판제의, 신간제의 등 부수익 창출기회. 다른 회사의 wiki에 내 블로그에 링크된다. 멀리서 세미나 발표로, 책으로 보기만 했던 개발자분의 채용추천. 사내 기술 블로그 작성 요청에 부담이 적음. 왜 블로그를 해야하나요연봉/회사/직위/재산 빼면 나를 표현할 수 있는게 뭐가있을까? 블로그는 자신을 표현할 수 있다.블로그는 아이덴티티라고 생각한다. 개발 관련 기술 블로그 운영하기변정훈님(Outsider’s Dev Story 운영)글 작성3일에 글 1개 작성목표, 글 1개에 짧게는 2~4시간 길게는 2~3일, 퇴고는 잘 하지 않는다. 글의 주제개발하면서 적을 수 있는건 전부새로운 도구, 환경 설치/절정새로 알게된 라이브러리.도구의 사용법최근에 겪고 해결한 장애와 처리방법개발관련 공유할 만한 내용 왜 개발 블로그를 운영하는가공부할게 많으니까. 글쓰는것 공부하는것을 같은것으로 본다.처음엔 배운걸 자꾸 잊어버려서, 전에 겪어본것들인데 기억이 안나서.회고와 비슷하다. 어디에 적어놓았는가개인노트, TIL(Today I learned), 공개블로그 글을 공개로 쓸 때의 장점글을 정리하려면 잘 알고 있어야 한다. 또한 글로 정리하면서 다시 고민해 볼 수 있다. 명성이 오른다. 글을 흐름1.하고자 했던일을 적는다.(Context, 왜 웹사이트를 만들고 싶은지, 왜 이기술을 쓰고싶은지, 어떻게 하다가 해당 장애를 만났는지)2.경험한 문제 상황 정리(격리된 상황, )3.시도해본 방법(내가아는 지식, )4.왜 동작이 안되는가? 왜 동작하는가?(가설)5.문제상황 재현 MCVE최소한의, 완성된, 입증가능한 예제(Minimum, Complete, and Verifiable Example)해결책을 받고싶으면 스택오버플로우에서 이런식으로 질문을 올려라는것!블로그도 마찬가지이다.! 블로그를 하는 이유?공유문화를 좋아한다.일하면서도 글을 많이 작성한다.(Slack, Issue tracker, Wiki) 글을 지속적으로 쓰려면 어떻게 해야 하나요?블로그를 만들기만 하는 개발자들이 많다. 새로운 스킨적용 스킨 변경의 반복….열심히 해라 지속적으로 하다보면 근육처럼 붙게된다. 하다보면 어느순간 도움이 된다는것을 깨달을 수 있다. 사람들이 많이 보는 글자잘한 팁 돈이 되나요?안됩니다. 돈이 목표라면 기술블로그 보다는 다른영역으로 해라","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"강연","slug":"Etc/강연","permalink":"http://KKimSangHeon.github.io/categories/Etc/강연/"}],"tags":[{"name":"Write the docs,","slug":"Write-the-docs","permalink":"http://KKimSangHeon.github.io/tags/Write-the-docs/"}]},{"title":"운영체제 핵심!","slug":"operating-system","date":"2019-03-18T13:11:03.000Z","updated":"2019-03-24T04:23:07.112Z","comments":true,"path":"2019/03/18/operating-system/","link":"","permalink":"http://KKimSangHeon.github.io/2019/03/18/operating-system/","excerpt":"","text":"운영체제란부팅커널, 쉘?배치프로세싱시스템멀티프로그래밍 시스템타임쉐어링 시스템다중프로세서 시스템분산시스템실시간 시스템인터럽트- 하드웨어인터럽트 , 소프트웨어인터럽트ISR이중모드-모니터비트MMU운영체제의 매니지먼트들 - 프로세스 메인메모리 파일 보조기억장치 입출력장치프로세스의 상태-new ready running wating terminatedPCB-상태정보, PC(지금은 몇번지인지. 번지정보), registers, MMU info (base, limit), CPU time(CPU 이용시간), process id, list of open files(얘가 지금 어떤파일을 사용하고 있는지) job queue , ready queue, device queueJob scheduling(Long-term scheduler) CPU Scheduler( Short-term scheduler ) Device SchedulerMedium-term scheduler프로세스는 크게 두가지로 나눌 수 있다,i/o-boundCPU-bound process context switchingDispatcherCPU스케줄링Preemptive vs Non-preemptiveScheduling criteria(척도) 응답시간, 대기시간, 반환시간, 처리율,cpu 이용율 fcfs,sjf,Shortest-Remaining-Time-FirstPriority,Round-Robin (RR),Multilevel Queue,Multilevel Feedback Queue, 쓰레드쓰레드 구조프로세스의 메모리 공간 공유 : (code, data)프로세스의 자원 공유 : (file, i/o, …)비공유: 개별적인 PC, SP, registers, stack 프로세스(쓰레드) 동기화임계영역 해결을 위한 방법 3가지상호베타 진행 유한대기 동기화세마포어 모니터(2개의 큐?)odering 상호베제 용도로 쓰임 교착상태교착상태 필요조건상호베타 점유및대기 비선점 환형대기 메모리 낭비방지기법1.Dynamic Loading2.Dynamic Linking3.Swapping 외부단편화first fitbest fitworst fit 외부단편화 해결: compaction, 페이징페이지테이블(mmu의 집합,TLB에 저장)내부단편화 해결 : 세그멘테이션 페이지, 세그멘테이션의 보호적인 측면의 차이 가상메모리요구페이징pure demand paging vs prepagingPage Replacement Algorithms: FIFO,OPT,LRUBelady’s AnomalyGlobal vs Local Replacement쓰레싱(Thrashing 프레임 할당은 크게 정적할당 동적할당으로 나뉜다. 정적 할당 (static allocation) 또한 균등할당, 비례할당으로 나뉜다. block devicecharacter device연속 할당 (Contiguous Allocation) - 장단점연결 할당 (Linked Allocation) - 장단점 및 디렉토리 / FAT색인 할당 (Indexed Allocation) - linked,multi level, combined 디스크 스케줄링fcfs, sstf, scan scheduling(cscan,look,c-look)","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"다시돌아온 간략한 스프링정리시간","slug":"spring1","date":"2019-03-12T07:48:03.000Z","updated":"2019-03-13T12:33:16.618Z","comments":true,"path":"2019/03/12/spring1/","link":"","permalink":"http://KKimSangHeon.github.io/2019/03/12/spring1/","excerpt":"","text":"IoC?의존성이 뒤바뀐것. 어떻게 바뀐거야?내가 만드는것이 아니라 밖에서 넣어주는 형태1234567class ShController &#123; private ShRepository repo; public ShController(ShRepository repo) &#123; this.repo = repo; &#125; &#125; IoC 컨테이너ApplicationContext 는 IoC 컨테이너로써 우리가 직접 쓸 일은 거의 없다(Spring boot에서)빈들을 만들고 빈들의 의존성을 엮어주는 역할을 한다. (객체생성 관리등…) 1234@AutowiredApplicationContext applicationContxt;.....applicationContxt.getBean(A.class); //객체를 가져올 수 있다. 빈스프링 IoC가 관리하는 객체이다. 즉 ApplicationContext안에서 관리되는 객체인터페이스도 빈이 될수 있을까? 그렇다. 빈을 등록하는 방법은?빈을 쓰기위해서는 그것(클래스) 또한 빈이어야 한다.why? 빈만 빈을 쓸 수 있다/ 1.@ComponentScan얘가 @Component인 애들을 찾아 빈으로 등록한다. @Controller은 왜 빈으로 인식되는거야? @컨트롤러 코드를 열어보면 @Componet로 되어있다. 즉 같은것으로 볼 수 있다. 2.XML이나 자바 설정 파일에 등록 3.직접 등록하는 방법 이때는 @Configuration 이라는 애노테이션을 갖고있는 클래스에서 등록이 이뤄져야 한다.12345678@Configurationclass BeanTest&#123; @Bean public String sh()&#123; return \"sh\"; &#125;//String type의 빈을 하나 등록.&#125; 12345public class AController&#123; @Autowired String sh; //sh가 들어간다 &#125; 의존성 주입@Autowired , @Inject이라는 어노테이션을 활용하여 의존성을 주입한다. 어떤 빈에 생성자가 하나만있고 생성자의 매개변수 타입이 빈으로 등록되어있다면 빈을 주입해준다.@Autowired가 없더라도..즉 아래와 같은 형태 123456789101112public class AController&#123; private final ARepository aRepository; private final BRepository bRepository; //방법 1 //@Autowired 없어도 됨.(있어도 됨) public AController(ARepository aRepository,BRepository aRepository) &#123; this.aRepository = aRepository; this.bRepository = bRepository; &#125;&#125; 의존성 주입하는 두번째 방법1234567public class AController&#123; @Autowired private final ARepository aRepository; @Autowired private final BRepository bRepository;&#125; 즉 위의 두가지 모두 의존성이 주입된다고 볼 수 있다. @Autowired , @Inject은 어디에 붙이는것이 좋은가?클래스에 반드시 필요한 객체일경우 생성자로 의존성주입하는것이 좋다.세터가 있다면 세터에 붙이고세터가 없다면 필드에 붙이는것이 좋다. AOP흩어진 코드를 한곳으로 모아라 AOP를 구현하는 기법 바이트 코드를 조작하는방법컴파일을 하면 .class가 나오는데 이를 조작하는것. 컴파일된 코드안에 공통되는 부분을 끼워넣는 방법 프록시 패턴을 사용하는 방법A 클래스를 상속받아class AProxy extends A{ }안에서 공통되는 부분을 호출하는것. 사방으로 흩어진 코드를 한곳으로 모으고 다른 클래스들은 자신의 일만 하도록 하는것즉 Single Response Principle에 적합하게 코딩하도록 도와주는 코딩기법. PSA Portable Sevice Abstract잘만든 인터페이스라 보자.어떤 기술에 특화되어있는 코드, 확장성이 좋지 않은 코드를 쓰면 테스트를 만들기도 어렵고 기술이 변경될 때 마다 코드를 변경해야 한다. 잘만든 인터페이스를 활용한다면 테스트하기도 좋고 바꿔끼기도 좋다. 어노테이션의 정의가 바뀌더라도 우리는 그대로 쓸 수 있다!","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Spring","slug":"Web-App/Spring","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://KKimSangHeon.github.io/tags/Spring/"}]},{"title":"29. SCAN 알고리즘 및 변종","slug":"operating-system29","date":"2019-03-06T13:40:17.000Z","updated":"2019-03-06T13:45:55.148Z","comments":true,"path":"2019/03/06/operating-system29/","link":"","permalink":"http://KKimSangHeon.github.io/2019/03/06/operating-system29/","excerpt":"","text":"프로세스 관리(CPU 스케줄링,동기화), 메인메모리 관리(디멘딩 페이지), 파일관리(연속,연결,색인할당) 디스크의 헤더의 움직이는데 오래걸린다. 물론 ms는 느린게 아니지만 컴퓨터의 수준에서 느린것이다.200개의 실린더가 있을 때 어떻게 조금만 움직일 수 있을까?맨안에 원이 트랙1 그다음이 2… 다중프로그래밍 환경에서의 디스크 큐(disk queue)에는 많은 요청(request)들이 쌓여있다.요청들을 어떻게 처리하면 탐색시간을 줄일 수 있을까? FCFS (First-Come First-Served) 온 순서대로 처리해준다. SSTF Scheduling현재위치를 기준으로 헤더를 조금움직이기 위해 위한것.이는 Starvation문제가 발생할 수 있다. 큐에 줄서있는 순서대로 제공하는것이 아니라 가까운놈 순으로 제공하기 때문에 멀리있는놈은 가까운놈들이 계속 들어올 때 기아상태가 된다..SSTF가 가장 좋은것인가???? 아니다… 200 cylinder disk, 0 .. 199Disk queue: 98 183 37 122 14 124 65 67Head is currently at cylinder 53 SSTF의 경우 Total head movement = 236 cylinders일 때최적의 경우: 53 - 37 - … = 208 cyl으로 최적으로 돌릴 수 있다. SCAN Scheduling디스크 헤더가 전체에걸쳐 들어갔다 나왔다 한다. 200 cylinder disk, 0 .. 199Disk queue: 98 183 37 122 14 124 65 67Head is currently at cylinder 53 (moving toward 0) - Total head movement = 53+183 cylinders (less time) 디스크 헤더를 끝까지 넣었다가 뺐다가 하는것.53-37-14-0-65-67-….18353부터~0 까지 + 0부터 ~183까지 스캔 알고리즘을 적용할 때 방향이 중요하다. 최적은 왼쪽으로 갔다 오른쪽으로 간다. 왼쪽으로 갔다 오른쪽으로 갔다면 걸린 시간이 다르다. 프로세스의 개수가 많으면 골고루 요청이 분포되어 있을것이다. SCAN의 변종 1.C-SCAN53부터~0 까지 처리했으면 53부터 ~183까지 처리하는것이 더욱 효율적일것이다. 이를 Circular SCAN SCAN의 변종 2.LOOK처음 53부터 0에서 제일 가까운 14까지만 가고 헤더를 옮겨 다시 53에서 183까지 가는것.The head goes only as far as the final request in each directionLook for a request before continuing to move in a given direction SCAN의 변종 3.C-LOOK처음 53부터 0에서 제일 가까운 14까지만 가고 헤더를 옮겨 183부터 65까지 이동 스캔알고리즘을 엘리베이터 알고리즘이라 한다.올라가면서 서비스하고 내려오면서 쭉 서비스를 제공하기 때문에","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"28.색인할당, 디스크 탐색시간, FCFS, SSTF","slug":"operating-system28","date":"2019-03-05T13:03:20.000Z","updated":"2019-03-06T13:44:50.323Z","comments":true,"path":"2019/03/05/operating-system28/","link":"","permalink":"http://KKimSangHeon.github.io/2019/03/05/operating-system28/","excerpt":"","text":"보조기억장치중 하드디스크를 배운다동심원이 있고 원판이 있다. 원판에 자성물질을 발라서 디스크 헤더에 전기를 흘려 기록을 하고 읽을 때는 고속으로 회전시켜 코일에 전류가 유도되는데 이를통해 읽는다.이를 트랙이라 하고 보통 디스크는 앞 뒤로 쓰는데 트랙이라는 용어보다는 실린더라는 용어를 많이 쓰고 있다.트랙을 쪼개서 섹터라 한다 섹터는 512b정도 된다. 이를 네개정도 모아서 블록이라고 한다.하드디스크를 포멧하면 내용을 다지우고 나면 poll of block이라 한다. 연속할당블록 하나가 1kb라고 가정하자 3.6kb파일을 하나 만들었을때 블록을 연속적으로 만들어주면 내부단편화가 발생한다.하지만 헤더가 많이 안움직여도 되므로 빠르다. 디스크 헤더의 이동 최소화 = 빠른 i/o 성능하지만 데이터를 지웠을 때 외부단편화가 발생한다.(곳곳에 흩어지는 holes로 인해) 연결할당디렉토리라는것은 메인메모리에 저장되고 OS에서 관리된다. 파일 이름, 만들어진날짜 등등을 보관한다. 하지만 우리눈엔 안보이고 커널에만 보이는것이 있는데 파일의 위치가 그것이다. 파일의 시작위치를 지정해두고 파일이 연결리스트 형태로 이어진다. 포인터 저장을 위해 4바이트가 필요하다는점, 헤더가 많이 움직여야한다는점, 중간부터 읽을 수 없다는점이 단점이다. FAT연결할당의 단점을 해결하기 위해 포인터만을 모은 테이블(FAT)을 만든것. 색인할당 (Indexed Allocation)3.6kb 파일을 만드려면 한 블록이 1kb일때 4개가 필요한데 인덱스 테이블을 특정한 블록에 저장하고 디렉토리에는 파일의 인덱스 블록의 주소를 갖고있다. 즉 인덱스 블록은 포인터의 모음이며 하나의 파일당 하나씩 갖고있다. 데이터가 들어있는것은 데이터블록 주소가 들어있는것은 인덱스 블록이며 파일 하나당 인덱스 블록이 필요하다.Direct access 가능하고 외부 단편화 없다. 인덱스 블록을 위해 블록을 할당해야 하는것이 단점이다. 1바이트 짜리를 저장하는데도 블록의 크기만큼(예를들었을 경우 1kb)만큼 할당해줘야 한다. 파일의 최대크기: 1블록의 크기가 512바이트라 가정해보자. 주소를 표현하는데는 4바이트 이므로 128개의 인덱스를 갖을 수 있다. 여기서 512바이트 * 128을 계산하면 64kb이다. 즉 파일의 최대 크기는 64kb이다. 예제: 1블록 = 1KB = 4바이트 x 256개 인덱스즉 256 * 1KB = 256KB 해결방법1: Linked : 이를 개선하기 위해 인덱스를 갖는 블록이 다른 인덱스 블록을 가르키는것. 해결방법2: Multilevel index : 하나의 인덱스 블록이 여러개의 인덱스 블록을 가르키는것. 해결방법3: Combined : 처음 인덱스 블록에서 앞쪽은 실제로 데이터를 가르키고 나머지 블록은 인덱스 블록을 가르키고..이는 유닉스에서 쓰임.. 디스크 스케줄링.대표적인 보조기억장치는 하드디스크이다. 디스크는 원판에 트랙이 있고 디스크를 움직여서 해당되는 트랙으로 이동한다. 제일 오래 걸리는 시간이 헤더를 움직이는 Seek time이 오래걸린다, 디스크가 도는 시간은 rotational delay(1분에 7200번돈다) 트랙이 헤더를 지나가면서 읽히는 시간이 transfer time이라 한다. 다중 프로그래밍 환경에서 여러개의 프로세스가 동시에 돌아간다. 여러프로세스가 디스크를 사용하려면 디스크 큐에 들어가야한다. 이때 어떻게 하면 탐색시간 즉 디스크 헤더를 가장 적게 움직일 수 있을까… 디스크 스케줄링 1. FCFS먼저온놈한테 먼저 서비스를 제공.200 cylinder disk, 0 .. 199Disk queue: 98 183 37 122 14 124 65 67Head is currently at cylinder 53Total head movement = 640 cylinders 극혐이다,…. 디스크 스케줄링 2. SSTFShortest-Seek-Time-First 의 약어로서 최소화 되는것을 먼저하는것. 즉 지금위치를 기준으로 했을 때 가장 짧은곳을 먼저 가는것.200 cylinder disk, 0 .. 199Disk queue: 98 183 37 122 14 124 65 67Head is currently at cylinder 53Total head movement = 236 cylinders","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"27.연속할당, 연결할당의 장단점","slug":"operating-system27","date":"2019-03-05T13:02:56.000Z","updated":"2019-03-06T13:49:55.622Z","comments":true,"path":"2019/03/05/operating-system27/","link":"","permalink":"http://KKimSangHeon.github.io/2019/03/05/operating-system27/","excerpt":"","text":"하드디스크는 poll of free blocks 즉 빈 블록들의 집합이다. 한블록이 1kb이고 파일A 5kb, 파일B 3kb, 파일C 4kb 일때 어느블록에 넣을까?0~19까지의 블록이 있을때 어떤식으로 배치할 수 있을까?? 연속할당각 파일에 대해 디스크 상의 연속된 블록을 할당즉 A는 0~4까지 할당, B는 5~7 , C는 8~11 까지 연속적으로 할당하는 방법60~70년대에 사용되는 방법 장점 : 일고 쓸때 디스크 헤더의 움직임을 최소화 할 수 있다. 이는 빠른 i/o 성능과 직결동영상, 음악, VOD 등에 적합sequential access 순차접근이라고 한다.특정 부분을 바로 읽을 수도 있다 (direct access 직접접근) 단점 : 파일을 지울 경우 문제가 된다. A,C를 지우고 6kb의 데이터를 넣으려고 하면 못넣는다. 외부단편화가 발생!즉 외부 단편화로 인한 디스크 공간 낭비이를 방지하기 위해 hole을 모으는 Compaction을 하면 되지만 시간이 오래걸린다.또한 파일을 생성할 때 파일의 크기를 예측 할 수 없기 때문에 어디에 할당해야 할지 알 수 없다. 또한 파일의 크기가 계속증가할 수 있기때문에 기존의 hole로는 배치가 불가능하게 될 수 있다. 연결할당연속할당을 개선하기 위해 나온것이 연결할당 각 블록들에 포인터를 달아놓고 이어지는 블록을 가르킨다. 처음 블록 위치는 파일 디렉토리가 갖고 있다. 각 블록은 포인터 저장을 위한 4바이트 또는 이상 소모. 이는 외부단편화를 없앨 수 있다.디렉토리라는것은 메인메모리에 저장되고 OS에서 관리된다. 파일 이름, 만들어진날짜 등등을 보관한다. 하지만 우리눈엔 안보이고 커널에만 보이는것이 있는데 파일의 위치가 그것이다 단점 : 연속할당의 경우 블록의 위치를 가늠할 수 있지만 연결할당의 경우 중간부터 읽기는 어려움이 있다. 즉 Direct access가 불가하고 동영상의 중간부터 보기가 불가능하다는것이다. 포인터 저장을 위해서 4바이트 이상이 손실한다, 또한 포인터가 끊어질 경우 접근이 불가능하므로 신뢰성이 낮다. 외부단편화는 없지만 데이터들이 흩어져있기 때문에 헤더가 계속 움직여야하기 때문에 io시간이 오래걸린다. 연속할당의 문제(단편화)를 해결했지만 이 또한 문제가 있다. 연결할당을 개선한 FAT 파일 시스템USB메모리가 주로 FAT32를 쓰는데 뭔지 알아보자연결할당의 변종으로서 File Allocation Table 파일 시스템이다. MS-DOS, OS/2, Windows 등에서 사용한다, 포인터들을 따로 모아서 포인터 테이블을 디스크 블록에 따로 저장한다. 포인터들만 모인 테이블을 FAT라고 한다. 이를 통해 블록을 읽지 않고 테이블만 읽음으로써 direct access 또한 가능하게 된다. 주기적으로 FAT에 변동사항을 넣어주고 하나의 블록이 깨지더라도 FAT 내용만 살아있다면 나머지를 읽을 수 있다. 즉 신뢰성 향상. FAT가 고장나면 큰일나기 때문에 보통 FAT 카피본을 저장하고 있다. FAT 는 일반적으로 메모리 캐싱 즉 direct access , 신뢰성(FAT 손실 시 복구 위해 이중 저장)을 높였다.FAT를 얼마나 할당할까? 32비트를 할당하면 2^32 개의 주소를 저장할 수 있다. 이를 FAT32라고 한다. 색인할당.다음 포스팅에..","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"26. 파일할당","slug":"operating-system26","date":"2019-03-05T13:02:47.000Z","updated":"2019-03-06T13:44:45.174Z","comments":true,"path":"2019/03/05/operating-system26/","link":"","permalink":"http://KKimSangHeon.github.io/2019/03/05/operating-system26/","excerpt":"","text":"OS 프로세스관리 배웠고/ 메인메모리 관리 배웠고/ 파일시스템중 파일 할당에 대해 배운다 OS는 컴퓨터 자원을 관리한다.CPU: 프로세스 관리 (CPU 스케쥴링, 프로세스 동기화)주기억장치: 메인 메모리 관리 (페이징, 가상 메모리)보조기억장치: 파일 시스템 관리 파일이 어떻게 할당되어지는가에 대해 알아보자.하드디스크는 구조: 원판에 자성물질을 바르고 모터를 달아서 돌린다. 데이터는 동심원 상에 저장된다. 또한 헤더가 존재하는데 헤더에는 코일이 감겨있고 여기에 전기를 흘리면 데이터가 기록된다. 데이터를 읽을 때는 판을 빨리 돌리면 판이 지나가면서 전기가 유도되는데 이 값을 통해 데이터를 읽어낸다.하드디스크에는 트랙이 있고 이를 잘라 섹터라 한다. 실린더는 하나의 하드디스크 안에 여러 판을 넣을 수 있다. 즉 실린더란 같은 거리에 있는 트랙들의 집합을 의미한다. 즉 원통같은것을 의미. 보통 한섹터는 512 bytes이고 섹터를 모아놓은것을 block이라 한다. 하드디스크에 읽고 쓰는것은 블록 단위로 이뤄지는데 이때문에 하드디스크를 block device라고 한다. 이와 반대되는것을 character device라 하는데 대표적인것이 키보드가 있다. 메모장을 켜서 한글자를 입력하고 저장만 하고 속성을 들어가보자, 이때 크기는 1바이트인데 디스크 할당크기는 4바이트이다. 이를 통해 한 블록 크기가 4바이트인것을 알 수 있다.(억울하다,,,) 블록 크기는 운영체제 설계자가 정한다, 디스크는 pool of free blocks 즉 free 블록들의 모음이다. 각각의 파일에 대해 free block을 어떻게 할당해줄까???연속적으로 할당할 수 도 있고 떨어져있는것들로 할수도있고.. 어떤것이 더 좋을까/??? 이는 3가지로 나뉘는데 연속 할당 (Contiguous Allocation) /연결 할당 (Linked Allocation) / 색인 할당 (Indexed Allocation)이 존재한다. 이에 대해서는 다음포스팅에서 알아보자.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"25.프레임 할당, 정적/동적 할당, 쓰레싱, 페이지 크기","slug":"operating-system25","date":"2019-03-04T13:33:17.000Z","updated":"2019-03-06T13:47:13.899Z","comments":true,"path":"2019/03/04/operating-system25/","link":"","permalink":"http://KKimSangHeon.github.io/2019/03/04/operating-system25/","excerpt":"","text":"프로세스 매니지먼트에서는 CPU 스케줄링, 프로세스 동기화가 중요하다,메인메모리 매니지먼트에서는 페이징, 가상주소(요구페이징, 요구 세그먼트 페이징이 있다)가 중요하다. 요구페이징을 하다보면 언젠가는 페이지가 가득차는데 어떤 페이지를 희생자로 택할것인가를 페이지 리플레이스먼트 알고리즘이다. 여기서 FIFO, Optimal 알고리즘이 있다. Optimal은 비현실적이여서 LRU가 많이 사용된다. 지금은 Allocation of Frames를 배운다. 어느프로세스에게 얼마만큼의 프레임을 줄것인가에 대한것. 페이징은 프로세스를 페이징 단위로 잘라서 메모리에 올린다. 이를 디맨딩 페이지라 한다. 다시말해 Allocation of Frames는 3개의 프로세스가 있고 페이지가 100개가 있을 때 각각 얼마씩 나눠줄까에 대한것. 정적할당 동적할당이 있는데 동적할당은 프로그램이 더 크면 크게줄 경우 이를 비례할당이라 하고 그냥 33개씩 동등하게 나눠주는것을 균등할당이라 한다.하지만 균등할당은 말이 안되고 비례할당 또한 말이 안된다. 프로그램이 크다고 해서 우리가 해당프로그램의 모든 기능을 다 쓰는것은 아니기 때문에… 즉 실행해봐야 얼마나 필요한지 알수있는데 이를 동적할당이라 한다. 동적프레임 할당동적프레임 할당 1.Working set model시간대별로 이용하는 페이지들을 나열해 봤을 때 특정 시간에 이용하는 프레임들을 봤을 때 이용되는 프레임들의 셋을 Locality라고 한다. locality들을 기반으로 어떤 페이지들이 사용되었는지 예측하는것이 좋은데 과거의 것들을 working set이라고 한다. 또한 과거의 어느정도까지 볼것인가에 대한 것을 Working set window이라 하는데 이는 OS만드는 사람이 결정한다. 결국 Working set window가 3ms 라 했을때 현재시점부터 과거 3ms까지의 locality들의 집합이 working set이며 이를 기반으로 프레임을 할당한다. 동적프레임 할당 2.Page-Fault Frequency (PFF)Working set model보다 간단한 방법으로 가로축이 할당된 프로세스의 갯수 세로축이 page fault rate라 했을 때 반비례 그래프가 나온다. OS는 Page fault 발생 비율의 상한/하한선을 기억해두고 페이지 폴트가 상한선 초과 프로세스인 경우에 더 많은 프레임 할당하고 하한선 이하인경우 프로세스의 프레임은 회수한다. 페이지 크기디멘드 페이징이나 페이징할때 페이지는 어떤 크기로 자를까???일반적 크기: 4KB ~ 4MB 페이지의 크기는 커지는중.. 프로세스의 크기도 커지고있으므로 페이지 사이즈는 큰게 좋을까 작은게 좋을까????-내부단편화 측면에서는 페이지 사이즈는 작은게 좋다.-페이지 폴트가 발생했을 때 페이지 인 아웃의 시간이 오래걸리는데 이때 페이지 크기는 큰것이 유리하다. 백킹스토어에서 헤더가 움직이고 데이터를 읽어오는것은 꽤 많은 시간이 들기 때문에…-CPU가 내는 주소를 변환하기 위해 존재하는 페이지 테이블의 크기가 작으면 SRAM의 비용이 덜 들어가고 이를 위해서는페이지의 크기가 커야한다.-Memory resolution입장에서는 우리가 필요한것만 위치하게 되는데 이를 위해 페이지 크기가 작은게 좋다. 페이지 크기가 필요없는것도 왕창 들어있을테니까.-페이지 폴트가 적게 일어나기 위해서는 페이지의 크기가 클 수 록 좋다. CPU가 100번지를 읽으면 그다음에는 104번지,108번지 읽는데 넓게 갖고오면 당분간은 페이지 폴트가 발생하지 않는데 이를 위해 처음부터 크게 갖고오는것이 좋다. 즉 관점에 따라 메모리 크기는 큰게 좋을 수도 작은게 좋을 수도 있다.일반적으로는 메모리, 프로그램의 크기는 점차 크지므로 점점 커지고 있다. 페이지 테이블의 위치페이지 테이블은 CPU도 아니고 메모리에도 넣지 않고 TLB캐시라는곳에 넣고 있다.하지만 최근은 반도체가 좋아지다 보니까 별도의 칩으로 하지않고 TLB 그리고 여러 캐시 메모리가 CPU안에 들어가게 되었다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"24.FIFO, OPT, LRU, 전역/지역교체","slug":"operating-system24","date":"2019-03-03T23:22:17.000Z","updated":"2019-03-04T13:33:39.613Z","comments":true,"path":"2019/03/04/operating-system24/","link":"","permalink":"http://KKimSangHeon.github.io/2019/03/04/operating-system24/","excerpt":"","text":"메모리 용량이 작을수록 페이지 폴트가 자주일어난다 Belady’s Anomaly메모리 용량이 늘어나느데도 페이지 폴트가 발생하는 이상한 현상이 발생한다.언제? FIFO를 사용할때! Optimal (OPT)2를 몰아냈는데 2가 필요한 경우가 생길 수 있다. 즉 억울한 경우이런일이 안일어나게 하기위해 앞으로 사용되지 않을것을 희생자로 선택한다.이는 비현실적이다. 앞으로 뭐가 사용안될지 잘 모르는것이다,SJF와 비슷하다. 이 또한 어떤놈이 제일 짧은지 알 수 없다. Least-Recently-Used (LRU)최근에 가장 적게 사용된놈을 희생양으로 삼는다. 대부분의 컴퓨터가 사용하는 방식.가장 좋은것은 앞으로 사용안될것을 희생양으로 삼는게 좋겠지만 현실적으로 판단하기 어려움으로, Global vs Local ReplacementGlobal replacement - 희생자를 선택할 때 메모리 상의 모든 프로세스 페이지에 대해 교체Local replacement- 희생자를 선택할 때 메모리 상의 자기 프로세스 페이지에 대해 교체 성능 비교 - Global replacement 가 더 효율적일 수 있다. CPU utilization vs Degree of multiprogramming CPU utilization - CPU 이용률Degree of multiprogramming - 메인메모리에 올라와있는 프로세스의 갯수 메모리 안에프로세스를 많이 올리니까 일정범위를 넘어서면 CPU의 이용률이 감소했다.왜그럴까? : 너무 많은 프로세스로 인해 빈번한 page in/out가 발생한다. 즉 디스크 IO가 많아져서 CPU이용율이 떨어진다. 이를 쓰레싱(Thrashing)라고 한다. 쓰레싱??? : 일정범위를 넘어서면 CPU이용율이 떨어지는데 이범위를 쓰레싱이라 한다. 쓰레싱을 극복하기 위한 방법.Global replacement 보다는 local replacement 활용프로세스당 충분한/적절한 수의 메모리(프레임) 할당 프레임 할당(Allocation of Frames)프레임 할당은 크게 정적할당 동적할당으로 나뉜다. 정적 할당 (static allocation) 또한 균등할당, 비례할당으로 나뉜다.균등 할당 (Equal allocation) : 메인메모리에 프레임 수가 100개고 프로세스 수가 3개면 각 프레세스에 프레임을 33개씩 할당해주는것. 조금 적절하지 않다. hwp와 메모장이 올라와 있을 때 동일하게 분배한다는것은 옳지않다!! hwp는 조금더 무겁잖아비례 할당 (Proportional allocation) : 사이즈가 큰놈한텐 많이 나눠주고 작은놈한텐 적게 나눠주는것. 사실 hwp에서 특별한 기능은 많이 쓰지 않으므로 정적할당은 올바르지 않다, 동적 할당 (dynamic allocation) 또한 Working set model , Page fault frequency 등으로 나뉜다.Working set model :Page fault frequency : 다음 포스팅에서….","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"23.페이지 교체 필요성, 희생 페이지 설정 원칙","slug":"operating-system23","date":"2019-02-28T05:39:51.000Z","updated":"2019-02-28T05:40:18.477Z","comments":true,"path":"2019/02/28/operating-system23/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/28/operating-system23/","excerpt":"","text":"가상메모리프로세스를 페이지 크기로 쪼개서 메인메모리로 올리는데 당장 필요한 것들만 올리고 보자 그러다 메모리가 꽉차게 되면 한놈을 쫒아내고 필요한놈을 불러온다, Demand Paging프로세스 이미지는 backing store 에 저장프로세스는 페이지의 집합 가상메모리를 위한 하드웨어 지원valid 비트 추가된 페이지 테이블backing store (= swap device) Memory full!메모리가 가득 차면 추가로 페이지를 가져오기 위해어떤 페이지는 backing store 로 몰아내고 (page-out)그 빈 공간으로 페이지를 가져온다 (page-in) - 용어: victim page 어느 페이지를 몰아낼 것인가?i/o 시간 절약을 위해 기왕이면 modify 되지 않은 페이지를 victim 으로 선택방법: modified bit (= dirty bit) Page reference stringCPU 가 내는 주소: 100 101 102 432 612 103 104 611 612Page size = 100 바이트라면페이지 번호 = 1 1 1 4 6 1 1 6 6Page reference string = 1 4 6 1 6 설명: fault가 발생하면 100바이트씩 (한페이지씩) 갖고오게 되기 떄문에 100번지를 못찾을경우 100~199까지 갖고오므로 그다음의 101은 fault가 발생하지 않는다. 즉 연속적일 때 앞에서 한번만 갖고오게 한다. Page Replacement AlgorithmsFIFO (First-In First-Out) : 메인메모리에 먼저 올라온놈을 내보낸다.OPT (Optimal) :LRU (Least-Recently-Used) FIFO 기법Idea: 초기화 코드는 더 이상 사용되지 않을 것이라는 생각을 바탕으로 만들어짐! 가장 간단하다. 예제페이지 참조열 = 7 0 1 2 0 3 0 4 2 3 0 3 2 1 2 0 1 7 0 1of frames = 315 page faults Optimal(OPT)","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"22.가상메모리 개요와 원리","slug":"operating-system22","date":"2019-02-26T22:48:09.000Z","updated":"2019-03-06T13:46:43.737Z","comments":true,"path":"2019/02/27/operating-system22/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/27/operating-system22/","excerpt":"","text":"일정크기로 자르는 페이징논리적 크기로 자르는 세그멘테이션 보호와 공유적인 측면에서는 페이징보다 세그먼트가 낫다. 세그먼트는 코드,데이터,스택이라고 잘랐을 때 각 크기는 다르다. 다른 데이터를 남는부분에 넣을라 하면 들어갈 수가 없다. 즉 외부단편화가 발생한다. 치명적인 문제! 외부단편화는 너무 치명적이다. 그럼 세그멘테이션과 페이징을 합치면 좋지않을까?1.처음에는 코드,데이터,스택으로 나누어 세그먼트로 자르고2.각 세그먼트를 일정한크기(페이지로) 자른다. 이를 Paged segmentation이라 한다. 하지만 이 경우 CPU - 세그먼트 테이블 - 페이지 테이블 - 메모리 를 거치게 되는데 두가지의 테이블을 거치기 때문에 느려진다. 가상메모리물리적인 메모리 크기의 한계를 극복하기 나옴,.내 컴퓨터의 메모리가 1gb이면 2gb의 프로세스를 올리지는 못한다. 요즘 나오는 컴퓨터는 모두 가상메모리 기법이 적용되어 있다. 어떤원리로?: 오류처리, 배열 등 지금은 불필요한것들은 올리지 않고 나중에 필요할 때 올린다. 동적 적재 (dynamic loading)과 비슷한 개념. 즉 각 프로세스를 페이지단위로 자르고 지금필요한것만 올린다. 이를 요구페이징(Demand Paging)이라고 한다. Demand Paging프로세스 이미지는 backing store 에 저장프로세스는 페이지의 집합지금 필요한 페이지만 메모리에 올린다(load) - 요구되는 (demand) 페이지만 메모리에 올린다 CPU가 페이지 테이블에 접근했을 때 자기가 읽고자 하는것의 valid 비트가 invalid 일 경우 인터럽트가 걸리게되고 CPU는 하던일을 정지하고 오류처리(필요한것을 들고오는 루틴)를 실행한다. 가상메모리를 만드는 방법은 Demand paging , virtual memory가 있다. Page FaultDemand Paging에서 페이지를 읽으려 했는데 페이지가 없다!이에따른 Page Falult Routine가 필요하다. pure demand paging vs prepagingpure demand paging : 프로그램 실행할 때 아무것도 들고오지 않음. 그러므로 처음시작부터 page fault가 발생하여 처음부터 필요한것을 갖고온다. 즉 이로 인해속도가 느려진다. 하지만 필요한것만 불러오므로 메모리가 절약된다. prepaging: 미리 필요한것을 예측하여 들고온다. 메모리는 낭비될 수 있으나 page fault가 적게일어나므로 속도적인 측면에서 부담이 적다 swaping vs demand pagingswaping : 화장실 가면 프로세스를 백킹스토어로 몰아내는것. 이때 왔다갔다하는 단위는 프로세스 단위이다,demand paging : 백킹스토어를 왔다갔다 하는 단위가 페이지 단위이다,","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"21.세그멘트 테이블, 주소변환","slug":"operating-system21","date":"2019-02-26T11:40:29.000Z","updated":"2019-02-26T11:42:25.812Z","comments":true,"path":"2019/02/26/operating-system21/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/26/operating-system21/","excerpt":"","text":"내부단편화, 페이지 테이블파워를 키면 OS가 메인 메모리로 올라간다. 프로세스들이 메모리에 연속으로 들어가게되면외부단편화 문제가 발생그래서 메모리에 프로그램을 프레임 단위로 나눠 흩어져서 들어가게 했다.하지만 CPU는 페이지 테이블로 인해 연속적으로 위치한다고 생각하게 된다.페이지를 이용해서 내부단편화가 발생하지만 이는 미미한 정도이다!! 페이지 테이블은 고속의 SRAM으로 만드는데 이를 TLB (Translation Look-aside Buffer)라 한다. 페이지 테이블에서 물리주소를 찾을 수 있을 때 히트했다고 한다. 보호모든 주소는 페이지 테이블을 경유한다. 그러므로 페이지테이블 엔트리(페이지 테이블의 끝쪽)마다 R,W,X 비트를 두어 접근 제어를 한다. 공유문서편집기를 세개 띄웠다고 가정하자. 각 프로그램마다 코드, 데이터, 스택이 따로 할당되면 메모리의 낭비이다. 코드는 공유가능하므로 하나만 만든다. 즉 페이지들이 코드영역은 셋다 똑같은 부분의 프레임을 가르키게 된다.코드가 공유되려면 코드의 내용이 실행중에 변경되면 안된다, 이를 non-self- modifying code = reentrant code = pure code 라고 한다.프로세스의 페이지 테이블 코드 영역이 같은 곳을 가리키게 세그멘테이션 Segmentation 페이지는 일정크기로 잘랐다.세그멘테이션은 프로세스를 논리적 내용(=세그멘트)으로 잘라서 메모리에 배치!코끼리를 자를때 페이지는 같은 크기로 자르지만 세그멘테이션은 논리적 크기(얼굴,몸통,꼬리)로 자른다. 프로세스는 세그멘테이션의 집합니다!. 프로세스는 코드 데이터 스택 세개의 뭉치가 존재한다. 하나의 프로세스는 세개의 프로세스의 집합이다! 일반적으로 세그먼트들의 크기는 다르다. 백킹스터어에 프로세스가 있을 때 메인메모리에 올리기 위해 세그먼트로 나누고 메모리로 올린다.(역시나 비연속적)CPU를 속이기 위해 역시나 세그먼트 테이블을 만든다. 그리고 CPU가 낸 세그먼트 번호, 변위이고 세그먼트 테이블의 인덱스에 속한값+변위로 실제 주소를 알 수 있다. 또한 세그먼트 테이블에는 1차원 배열형태인 페이지 테이블과 다르게 base, limit로 즉 2차원배열형태로 구성된다. 만약 CPU가 낸 d의 값이 limit보다 클 경우 CPU로 인터럽트를 보내게 된다. 논리주소 (Logical address)CPU 가 내는 주소는 segment 번호(s) + 변위(d) 주소변환: 논리주소 → 물리주소 (Physical address)세그멘트 테이블 내용: base 그리고 limit세그멘트 번호(s)는 세그멘트 테이블 인덱스 값s 에 해당되는 테이블 내용으로 시작 위치 및 한계값 파악한계(limit)를 넘어서면 segment violation 예외 상황 처리 물리주소 = base[s] + d예제Limit / Base1000 / 1400400 / 6300400 / 43001100 / 32001100 / 32001000 / 4700 논리주소 (2,100) 는 물리주소 무엇인가? 4400 논리주소 (1, 500) 은 물리주소? 6800이라하면 틀렸다!!! 해당주소 없음!!(limit를 넘는다) 정리운영체제를 처음배울땐 프로세스들이 순차적으로 들어가는지 알았다. 그러다 보니 메모리 낭비가 심해서 자르기로 함.그래서 일정크기로 자르는 페이징 기법이 나왔고 논리적 크기로 자르는 세그멘테이션이 나왔다.페이징을 사용하는 방법이 더 일반적이다. 세그멘테이션은 보호와 공유측면에서 페이징보다 낫다.왜 그럴까? : 모든 주소는 세그멘트 테이블을 경유하므로, 세그멘트 테이블 엔트리마다 r, w, x 비트 두어 해당 세그멘트에 대한 접근 제어 가능뭐야 페이지 뭐가다른데? : 페이지 단위로 자르면 일정한 크기이기 때문에 코드,데이터가 섞이는 부분이 생길 수 있다. 즉 안심,등심이 섞인 부분이 생겨 r로만 줄지 rw로 줄지 논란이 생길 수 있다. 그러나 대부분의 운영체제는 페이징을 쓴다왜? 그건 다음포스팅에서..","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"20.페이지 테이블, 주소변환/페이징에서의 주소변환","slug":"operating-system20","date":"2019-02-25T23:57:15.000Z","updated":"2019-02-26T00:02:13.052Z","comments":true,"path":"2019/02/26/operating-system20/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/26/operating-system20/","excerpt":"","text":"페이지 테이블, 주소변환 주소변환?컴퓨터에는 CPU, 메모리, 보조기억장치가 존재.파워를 켜면 메모리 안에 OS가 들어오고 요청하는 대로 프로그램들이 메모리로 들어온다.프로그램들이 연속으로 들어갈 경우 외부단편화 문제가 발생한다. 그래서 메모리를 프레임 단위로 쪼개서 넣는다. 프로세스들은 흩어져서 프레임 단위로 저장된다. 이것이 가능한것은 CPU와 메모리 사이에 페이지테이블이 존재하기 때문에..즉 CPU는 페이지 테이블로 인해 CPU는 프로세스가 연속한 상태로 착각한다.메모리 빈곳(hole)을 다합치면 메모리가 큰데 프로세스를 넣을 수 없는것을 외부단편화라 함 메모리 낭비를 위한기술다이나믹 로딩링킹스와핑 페이징(메모리 낭비를 줄이기 위한기술)메모리를 꼭 연속된 공간에 넣을 필요는 없다. 프로그램을 프레임 단위로 잘라서 메모리에 흩어져서 넣는다.프로세스는 페이지(page)의 집합메모리는 프레임(frame)의 집합 페이지를 프레임에 할당MMU 내의 재배치 레지스터 값을 바꿈으로서CPU 는 프로세스가 연속된 메모리 공간에 위치한다고 착각MMU 는 페이지 테이블 (page table) 이 된다. 예제Page size = 4 bytesPage Table: 5 6 1 2논리주소 13 번지는 물리주소 몇 번지? CPU가 내는 주소는 13이다. 이진수로 나타내면 1101(2) 인데 앞 두숫자 11이 p 이고 01이 d라고 볼 수 있다. (p는 페이지 사이즈 크기만큼 크기를 할당. 페이지 크기가 4이므로 두자리가 된다.) 페이지 테이블의 3번째 인덱스에 저장된 2가 f가 되고 d는 그대로 온다. 즉 10 01이 피지컬 어드레스가 된다. 즉 물리주소는 9번지가 된다. 9번지는 두번째 프레임에서 01만큼 떨어져있다고 할 수 있다. 예제Page Size = 1KBPage Table: 1 2 5 4 8 3 0 6논리주소 3000번지는 물리주소 몇 번지? 1kb는 10bit. 3000은 101110111000(2) 이다. 페이지 사이즈는 2^10 이므로 10bit로 표현 가능하다. 즉 d는 뒤의 10자리(1110111000(2)) 이고 p는 앞에 두개(10(2))이다. 즉 2번째 인덱스인 101(2) 그리고 d를 붙인 1110111000 (2) 가 물리주소이다. 물리주소 0x1A53 번지는 논리주소 몇 번지? 1 1010 0101 0011 인데 뒤의 10개가 d 나머지 앞에 110이 프레임 넘버. 6은 페이지 테이블의 7번지에 저장되어 있으므로111과 10 0101 0011 을 붙인것이 논리주소이다. 내부단편화페이지 사이즈가 4바이트일때 15바이트프로세스를 올리기 위해서는 페이지 4개가 필요하다.4/4/4/3만큼 할당이 되는데 마지막 페이지의 1바이트가 비게된다. 이는 아무도 쓸수 없으므로 내부단편화 발생. 외부단편화를 페이지로 없앴는데 내부단편화가 발생한다. 내부단편화는 외부단편화에 비해 크기가 미미하므로 큰 문제가 되지 않는다. 페이지 테이블은 CPU안에 넣을 수 있다. 그러면 레지스터로 만들수도있다. 또는 메모리에 넣을 수도 있다.‘CPU에 넣는경우’:페이지 테이블을 CPU레지스터로 만드면 주소변환이 정말 빠르다. 단점은 CPU에 넣어야 하므로 많은 데이터를 넣을 수없다.메모리 안에 넣을 경우: 페이지 테이블이 커도 문제가 되지 않는다. 그러나 변환속도가 느리다. 페이지테이블을 읽기위해 메모리를 한번읽고 또 한번 메모리를 읽어야 하므로 2배로 느려진다. 캐쉬메모리에 페이지 테이블을 넣는경우(실제로 사용됨): 페이지 테이블을 넣는 캐쉬메모리를 TLB (Translation Look-aside Buffer) 라 한다. 메모리에 넣는것보다 빠르고 CPU에 넣는것보다 많이 넣을 수 있다. 캐쉬메모리와 유사한 원리로 동작 CPU에서 낸 주소를 읽어오는덱 걸리는 시간을 유효메모리 접근시간이라 한다.Tm(메모리 읽는속도) = 100ns, Tb(버퍼 읽는속도) = 20ns, hit ratio = 80%CPU가 낸 주소가 페이지테이블 안에 존재할 경우 hit라고 한다,유효 메모리 접근시간 : hit확률 (Tb+Tm) + hit되지 않을 확률 (Tb+Tm)","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"19.최초적합, 최적적합, 최악적합","slug":"operating-system19","date":"2019-02-24T23:30:26.000Z","updated":"2019-02-25T13:54:57.309Z","comments":true,"path":"2019/02/25/operating-system19/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/25/operating-system19/","excerpt":"","text":"메모리 낭비를 줄이기 위한 기법1.Dynamic Loading2.Dynamic Linking3.Swapping 연속 메모리 할당최초의 컴퓨터는 프로세스가 하나만 올라갔다. 그이 후 O/S가 올라가게 되었다.하나의 운영체제에 여러개의 프로세스가 도는것이 다중프로그래밍. 즉 멀티프로그래밍이라 한다.부팅을 하면 메모리가 비어있다가 OS가 자리잡게된다. OS이외에 부분은 비어있는데 이를 big single hole 또는 hole이라고 한다. 부팅 직후 메모리 상태: O/S + big single hole프로세스 생성 &amp; 종료 반복 : scattered holes(프로세스가 생성됐다가 없어지고 하다보면 곳곳에 hole 발생하게 된다.) Hole 들이 불연속하게 흩어져 있기 때문에 프로세스 적재 불가한 경우가 생기는데 이를 외부단편화(external fragmentation)라 한다. First-fit (최초 적합) : 메모리를 뒤져서 가장 처음에 들어갈 수 있는곳에 들어가는것.Best-fit (최적 적합) : 사이즈가 제일 비슷한놈에 들어가는것.Worst-fit (최악 적합) : 크기가 제일 안맞는놈한테 넣는것.(물론 큰것중에) 예제Hole: 100 /500 / 600 / 300 / 200 KB프로세스: 212 417 112 426 KB First-fit (최초 적합)의 경우 : 212는 500에 들어간다. 417은 600에 들어감. 112는 300에 들어감. 426은 못들어감. Best-fit (최적 적합) : 212는 300에 들어간다 . 417은 500 112는 200 .426은 500 Worst-fit (최악 적합) : 212는 600에. 417은 500에. 112는 300에. 426은 못들어간다. 속도면에서는 First-fit가 빠르다.나머지는 다 봐야하기 때문에 느리다. 이용률의 경우 first-fit, best-fit이 높은 이용율이 보임.외부 단편화로 인한 메모리 낭비가 전체의 1/3 수준 (사용 불가) 이를 해결하기 위한 방법 : Compaction(hole들을 한곳으로 모으는것. 최적 알고리즘 없음, 고부담)즉 OS가 지켜보다가 hole들을 한곳으로 모은다.(계산 부담) 다른방법은 없을까? 페이징 페이징프로그램을 연속적으로 넣지 않고 일정한 단위로 잘라서 넣는다 이를 페이지라고 한다.(잘린것들을 말함).메모리를 자른것을 프레임이라 함. 프로세스를 자른것을 페이지라 하고 메모리를 자른것을 프레임이라 한다.페이지사이즈와 프레임사이즈 는 같으나 용어와 사용되는 위치가 다른것. 잘라서도 돌게하기 위해서는 CPU를 속여야한다. MMU 내의 Relocation Resgister을 여러개 둔다!이러한 목적으로 사용되는 MMU를 페이지 테이블 (page table) 이라 한다. 이를 통해 외부단편화를 해결! 페이징에서의 주소변환 논리주소를 물리주소를 변환하는것을 주소변환이라한다.CPU가 내는 주소가 m bit라 하자. 그럴 때 m-n은 페이지의 주소이고 n비트는 오프셋 또는 변위라고 한다.즉 n은 페이지의 사이즈에 의존적이다. 페이지의 사이즈가 16일때 n은 4로 표현가능 메인메모리는 프레임 단위로 나뉘어져있다. 프레임의 크기는 페이지의 사이즈와 동일하다,아까 말했듯 페이지 테이블(여러개의 mmu로 구성된것)은 프로세스가 페이지를 몇개쓰는가이 따라 달라진다. p가 2라면 페이지 테이블의 두번째를 가르키는 것이고 d가 오프셋을 의미 만약 CPU가 50이라는 주소를 냈다하자. 그럼 110010(2) 이다. 이때 한 페이지가 16바이트라 가정했을 때 뒤의 네 수를 d로 보고 앞에 두개 11을 p로 본다. 즉 3번째 페이지에 저장되어있는 값(8이라 가정하자)에 맞는 프레임을 찾아가고 d를 활용하여 세부적인 값을 알아낸다. 이때는 10000010(2)가 된다,(앞에 네개는 8을 의미 뒤에 네개는 d를 그대로 가져다 쓴것) 정리하면 CPU가 내는 50번지는 10000010 즉 128번지 + d(2) 이므로 130번지를 찾아간다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"18.동적적재, 동적연결, 스와핑","slug":"operating-system18","date":"2019-02-24T02:25:43.000Z","updated":"2019-02-24T03:24:56.823Z","comments":true,"path":"2019/02/24/operating-system18/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/24/operating-system18/","excerpt":"","text":"컴퓨터에서 메모리는 CPU 만큼 중요하다.하드디스크에 파일들이 들어있다. 파워를키면 OS가 메인메모리에 올라가고 특정 프로그램을 실행시키면 그 프로그램이 메인메모리로 올라간다. 이 메모리를 어떻게 잘 관리할것인가가 메모리 매니지먼트 실행파일을 메모리에 올리기src-obj-exe 메모리 몇 번지에?다중 프로그래밍 환경에서는? 항상 똑같은 곳에 올리는것을 보장하지 못함. 그래서 MMU를 활용. CPU가 메모리에 몇번째 주소를 읽겠다 하면 메모리는 CPU로 데이터를 전송해준다. MMU는 특정프로그램이 다른 프로그램으로 접근하지 못하게 해준다. CPU가 메모리에 주소를 전달할 때 MMU를 거치는데 자기영역에 맞는 주소를요청하는지 파악한다.(base, limit 레지스터 활용)MMU는 이뿐만 아니라 Relocation register을 둔다. 가령 A라는 프로그램이 있다고 하자. 개발자는 해당 프로그램이 0번지부터 시작한다고 생각하고 코딩을 했다. 하지만 이는 보장되지 않기 때문에 예측할 수 없다. 실제로는 프로그램이 1000번지에 로드되면 MMU 안에 Relocation register에 1000을 넣는다. 그러면 CPU는 0번지를 요청하지만 MMU를 거치면서 1000이 더해져 실제로 저장되어 있는 1000번지로 접근하게 된다. 즉 CPU를 속이게 된다.그 다음날 A라는 프로그램이 실행되었을 때 5000번지에 실행될 경우 이때는 Relocation register에 5000이 들어가고 CPU는 5000번지에 접근하여 데이터를 읽어올 수 있다. 여기서 CPU가 보내는 주소를 논리주소(logical address) 라 하고 실제로 메인메모리로 들어가는 주소를 물리주소 (physical address)라 한다. 메모리 낭비 방지운영체제는 컴퓨터 사용을 쉽게, 효율을 높게 하는것이 목표다.이를 위해 어떤노력을 하는지 알아보자,1.Dynamic Loading2.Dynamic Linking3.Swapping Loading : 프로그램(실행파일)을 메모리로 올리는것.Booting : OS를 메모리로 올리는것. 메모리 낭비 방지 기법 : Dynamic Loading프로그램을 메모리에 올릴때 오류처리 혹은 크게 생성한 배열 같은것들을 안올리고 오류가 일어나면 올린다. 나오게 된 배경:모든 루틴(routine)이 다 사용되는 것은 아니다 (예: 오류처리)모든 데이터(data)가 다 사용되는 것은 아니다 (예: 배열)자바: 모든 클래스가 다 사용되는 것은 아니다 즉 프로그램 실행에 반드시 필요한 루틴/데이터만 적재현대의 운영체제는 이를 활용. 이전에는 모든것을 올리는 정적 적재(Static loading)를 활용했다. 메모리 낭비 방지 기법 : Dynamic Linking프로그램을 메인메모리에 올리는데 공통 라이브러리 루틴(library routine)를 메모리에 중복으로 올리는 것은 낭비 이메일전송, 파일전송 둘다 네트워크를 사용한다. 즉 둘이 같은 라이브러리를 쓸것이다. 하나로 통 칠수있는경우이다. 이 기법은 오직 하나의 라이브러리 루틴만 메모리에 적재한다. 또한 exe파일을 만들때 link를 하지 않고 프로그램 실행 때 link하여 갖다 쓴게 한다. 그리고 다른 애플리케이션 실행 시 이 루틴과 연결(link)된다.원래는 link를 exe파일이 만들어지기 전에 한다(정적 연결,Static Linking) 리눅스에서는 공유 라이브러리 (shared library)라 부른다 – Linux윈도우에서는 동적 연결 라이브러리 (Dynamic Linking Library)라 부른다. - Windows 윈도우에서 .DLL파일을 본적이 있을것이다. 리눅스에는 .SO 파일.C:\\Windows\\System32 에 많다. 메모리 낭비 방지 기법 : Swapping메모리에 적재되어 있으나 현재 사용되지 않고 있는 프로세스 이미지를 몰아낸다프로그램을 사용하다 화장실에 갈경우 해당 프로그램은 아무것도 하지 않으면서 메모리를 잡아먹게 된다.이 경우 해당 프로세스를 쫒아낸다. 즉 프로세스 이미지를 하드디스크 일부에 몰아낸다. 이는 메모리 활용도 높이기 위해 Backing store (= swap device라고도 함) 로 몰아낸다 한다.Backing store (= swap device라고도 함)의 크기는 대략 메인메모리의 크기 정도면 충분하다.(메인메모리의 내용만 쫒아내는 구역이기 때문에.) 몰아내는것을 Swap-out라 하고 화장실에서 다시 돌아와 메모리로 다시 올리는것을 Swap-in이라고 한다. 서버는 Backing store 를위한 디스크를 따로 두기도 하며 슈퍼컴퓨터의 경우 Backing store를 하나의 메모리로 두기도 한다.(디스크 접근이 느리기 때문에)","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"17.주기억장치 관리 개요","slug":"operating-system17","date":"2019-02-23T00:48:52.000Z","updated":"2019-02-23T15:18:11.112Z","comments":true,"path":"2019/02/23/operating-system17/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/23/operating-system17/","excerpt":"","text":"CPU / 메모리 / 보조기억장치가 존재.O/S는 프로세스 관리를한다. CPU 관리를 하는데 이를 프로세스 매니지먼트라함.또한 O/S는 메모리 관리 즉 메모리 매니지먼트를 한다. OS : 하드웨어를 어플리케이션이 활용할 수 있도록 함.CPU 자원을 나눠주는 곳 : 프로세스 매니지먼트메인메모리를 관리하는곳 : 메모리 매니지먼트. 메모리 역사Core memory : 반지모양의 철심에 자성물질을 바르고 전기를 흐르게 한 후 자석이 되게 한 후 메모리로 사용.진공관 메모리 : 50~60년대 손가락 크기만함. 네다섯개가 한비트를 저장트랜지스터 메모리 : 손톱만한 크기로 한비트를 저장하는데 네개의 트랜지스터 필. 반도체 소자안에 들어간다.집적회로 메모리: SRAM, DRAM : 보통 생각하는 메모리 메모리 용량1970년대: 8-bit PC 64KB1980년: 16-bit IBM-PC 640KB &gt; 1MB &gt; 4MB1990년: 수MB &gt; 수십 MB2000년~: 수백 MB &gt; 수 GB 메모리가 지속적으로 커졌다!!메모리는 언제나 부족하다..이유 : 프로그램의 변천기계어/어셈블리어 작성C언어자바, 객체지향형 언어 작성숫자 처리 &gt; 문자 처리 &gt; 멀티미디어 순으로 패러다임이 변화함. 메모리 용량 증가 vs 프로그램 크기 증가언제나 부족한 메모리 ㅠㅠ 어떻게 메모리를 효과적으로 사용할 수 있을까?메모리 낭비를 없애고 가상메모리와 같은 기법을 활용! 메모리 구조? CPU가 몇번지를 읽겠다고 주소를 메모리로 보낸다. 그러면 거기에 저장되어있는 정보를 메모리가 CPU에게 제공한다.또한 데이터 저장을 위해서 CPU가 데이터를 전송하기도 한다메모리는 주소(Address) + 데이터(Data)로 구성된다. 프로그램은 어떻게 개발될까?컴파일러, 어셈블러, 링커, 로더에 대해 알아보자프로그램이 실행되기까진 아래의 순서를 따른다.main.c (고수준언어)-&gt;main.o(기계어) -&gt; link -&gt; 메인메모리로 올림첫번째 화살표 컴파일러가 진행두번째 화살표 링커가 진행세번째 화살표 로더가 진행 원천파일 (Source file): 고수준언어 또는 어셈블리언어목적파일 (Object file): 컴파일 또는 어셈블 결과실행파일 (Executable file): 링크 결과프로그램 실행을 위해 필요한것들: code + data + stack 실행파일을 메모리에 올리기 위해 메모리 몇번지에 올려야되지?(로더가 해결해준다) MMU의 사용MMU 안에 base limit가 있다했는데 재배치 레지스터가 있다. 프로그램을 개발할 때 0번지에 들어간다고 생각했는데 실제로는 500번지에 들어간다면 Relocation register에 500을 넣어줘 CPU가 봤을땐 0번지 이지만 500을 더한 500번지에 저장되게 한다. 즉 CPU는 얘가 0번지에 있는줄 안다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"16.프로세스 동기화의 다른 도구인 모니터 사용","slug":"operating-system16","date":"2019-02-22T13:51:04.000Z","updated":"2019-02-23T15:18:37.264Z","comments":true,"path":"2019/02/22/operating-system16/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/22/operating-system16/","excerpt":"","text":"모니터동기화 도구로 세마포어를 배웠다. 세마포어는 조금 오래된 동기화 도구인데 지금은 모니터를 많이쓴다. 주로 자바에서 많이쓴다.즉 세마포 이후 프로세스 동기화 도구 이며 세마포 보다 고수준 개념 세마포어의 구조정수변수, 큐, P(acquire)동작, V(release)동작 모니터의 구조공유자원 , 공유자원 접근함수 , 2개의 큐 2개의 큐?하나는 배타동기. 즉 한쓰레드만 공유자원에 접근할 수 있도록 하는 큐하나는 조건동기를 위한 큐 베타동기를 위한큐 | 다양한 함수 | 조건동기를 위한큐 1.쓰레드 한개만 공유자원 접근 함수에 접근할 수 있다. 즉 들어오고 싶어하는 애들은 베타동기를 위한 큐에서 기다려야 한다.2.진입 쓰레드가 조건을 만족하면(wait을 호출하여) 조건동기 큐로 들어가는데 이땐 블록된다. 그러면 새 쓰레드가 진입가능3.새 쓰레드는 조건동기로 블록된 쓰레드를 notify를 호출하여 깨울 수 있다4.깨워진 쓰레드는 현재 쓰레드가 나가면 재진입할 수 있다.(하나의 쓰레드만 접근 가능하므로) 세마포어에 비해 복잡하나 사용하기 편리하다. 배타동기: synchronized 키워드 사용하여 지정조건동기: wait(), notify(), notifyAll() 메소드 사용 베타동기: 하나만 특정함수에 들어갈 수 있다. 자바에서는 함수 정의 앞에 synchronized 키워드를 붙인다.조건동기는 wait 함수를 호출하여 조건동기를 위한 큐에 갇히게 할 수 있고 notify(하나깨우기) 혹은 notify all(전체깨우기) 을 호출하여 깨울 수 도 있다. 상호배제 용도로 사용1234567891011121314151617class BankAccount &#123; int balance; synchronized void deposit(int amt) &#123; int temp = balance + amt; System.out.print(\"+\"); balance = temp; &#125; synchronized void withdraw(int amt) &#123; int temp = balance - amt; System.out.print(\"-\"); balance = temp; &#125; int getBalance() &#123; return balance; &#125;&#125; 위처럼 하면 동기화가 가능하다. 세마포어 보다 쉽다! Ordering 용도로 사용P1은 공백/ S1/notify();P2는 wait/S2/공백 P1이 입금, P2가 출금 로직이라고 가정하고 생각해보자. P1,P2 반복해서 출력되게 하려면 boolean 변수 하나를 둬서 처리123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475int balacne = 0;boolean p_turn;synchronized void deposit(int amt) &#123; int temp = balance + amt; balance = temp; notify(); p_turn = false; wait();&#125;synchronized void withdraw(int amt) &#123; while(p_turn) wait(); int temp = balance - amt; balance = temp; p_turn = true; notify();&#125;---class Buffer &#123; int[] buf; int size, count, in, out; Buffer(int size) &#123; buf = new int[size]; this.size = size; count = in = out = 0;&#125;synchronized void insert(int item) &#123; while (count == size) try &#123; wait(); &#125; catch (InterruptedException e) &#123;&#125; buf[in] = item; in = (in+1)%size; notify(); count++;&#125;synchronized int remove() &#123; while (count == 0) try &#123; wait(); &#125; catch (InterruptedException e) &#123;&#125; int item = buf[out]; out = (out+1)%size; count--; notify(); return item; &#125;&#125;---교착상태에 대한 고려는 되지 않음.class Chopstick &#123; private boolean inUse = false; synchronized void acquire() throws InterruptedException &#123; while (inUse) wait(); inUse = true; &#125; synchronized void release() &#123; inUse = false; notify(); &#125;&#125;","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"15.교착상태 필요조건, 교착상태의 해결법","slug":"operating-system15","date":"2019-02-22T13:50:56.000Z","updated":"2019-02-22T13:56:55.165Z","comments":true,"path":"2019/02/22/operating-system15/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/22/operating-system15/","excerpt":"","text":"교착상태발생이유 : 프로세스들이 자원을 많이 필요로 한다. 하지만 누가 사용하고 있으면 기다려야한다.이러한 형태가 원을 이루면 교착상태가 발생한다. 교창상태 필요조건.Mutual exclusion (상호배타) : 자원을 서로 공유하지 못함Hold and wait (보유 및 대기) : 하나를 잡고있으면서 다른것을 원함No Preemption (비선점) : 다른것을 강제로 뺏어오지 못함.Circular wait (환형대기) : 자원을 갖고있으면서 기다리는데 원형형태 네가지가 만족되면 일어날 수 있다. 반드시 일어나는것은 아님 교착상태 처리교착상태 처리는 크게 네가지가 있다.1.교착상태 방지Deadlock Prevention 2.교착상태 회피Deadlock Avoidance 3.교착상태 검출 및 복구Deadlock Detection &amp; Recovery 4.교착상태 무시Don’t Care 1.교착상태 방지설명 : 필요조건 중 네가지 조건중에 하나라도 깨도록 하는것.상호베타 조건을 깨기: 이를 위해 공유가 가능하게 해야한다. 현실적으로 어렵다. 읽어내기만 하는 파일 같은 경우에는 가능하지만 일반적으로는 부적절 보유 및 대기 깨기: 동시에 젓가락 갖게하기. 왼쪽 젓가락 잡고 오른쪽 젓가락 잡을라 했는데 누가 오른쪽을 갖고있으면 왼쪽도 놓기. 이는 굶어 죽을 확률이 생김. 자원의 활용도가 떨어진다. 상호베타 조건깨는것보다는 쉽다.자원을 가지고 있으면서 다른 자원을 기다리지 않게 즉 자원이 없는 상태에서 모든 자원 대기; 일부 자원만 가용하면 보유 자원을 모두 놓아주기단점: 자원 활용률 저하, 기아 (starvation) 비선점 깨기: CPU의 경우에는 일부 가능하겠으나 일반적으로 불가능 환형대기 깨기 : 자원에다 번호 부여하고 자원의 오름차순으로 자원을 요청토록 함. 즉 R1,R2,R3 가 있을때 R1, R2 요청/ R2,R3 요청/ R1,R3요청처럼 구현. 자원의 활용도가 떨어진다. 보통 보유 및 대기 깨기 혹은 환형대기 깨기를 사용한다. 2.교착상태 회피설명 : 자원을 할당할 때 위험한 할당이 되지 않도록 하는것.자원을 프로세스 한테 골고루 나눠주는것을 OS가 한다. 이를 리소스 매지저 / 올로케이터라 한다.교착상태는 자원요청에 대한 잘못된 승인에 기인한다고 본다. 불안전한 할당 (Unsafe allocation)운영체제는 자원을 할당할 때 불안전 할당 되지 않도록불안전 할당 → 교착상태 유발대출전문 은행과 유사: Banker’s Algorithm 3.교착상태 검출 및 복구설명 : 프로세스가 필요한 대로 자원을 나눠주고 데드락이 발생하면 OS의 프로세스 복구.교착상태가 일어나는 것을 허용 그리고 주기적 검사진행. 주기적 검사는 이를 하기 위한 오버헤드가 크다.교착상태 발생 시 복구하기위해 주기적으로 이전의 상태를 기억하고 있어야 한다.이를 위해 한 프로세스를 강제로 종료시키거나 혹은 자원을 선점하여 일부 프로세스에게 할당. 4. 교착상태 무시설명 : 교착상태는 실제로 잘 일어나지 않으므로 그냥 무시해버린다.교착상태 발생 시 재시동. 컴퓨터에서 가장 중요한것은 메모리 관리이다. 이를 프로세스 매니지먼트 부서가 하는데 이는 CPU 스케줄링 부서, 프로세스 싱크로나이즈 부서로 구성된다. 싱크로나이즈에서는 데드락관리또한 중요. 메인메모리 관리가 메모리 매니지 부서가 있다. 다음부터 공부한다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"14.읽기-쓰기 문제, 식사하는 철학자 문제","slug":"operating-system14","date":"2019-02-22T13:50:49.000Z","updated":"2019-02-22T13:53:18.540Z","comments":true,"path":"2019/02/22/operating-system14/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/22/operating-system14/","excerpt":"","text":"읽기-쓰기 문제, 식사하는 철학자 문제 Reader &amp; WriterDB 읽기만 하는 프로세스 DB를 바꾸는 프로세스 A가 DB를 읽고 있을 때 B가 읽을 수 있다.즉 한 프로세스가 DB를 읽을 때 다른 프로세스도 읽을 수 있게 허용해줘야 한다. The first R/W problem (readers-preference)리더가 있으면 라이터가 미뤄지는것 The second R/W problem (writers-preference)라이터가 먼저 우선순위가 주어지는것 The Third R/W problem아무한테도 주지 않는것 정리 : 즉 리더가 들어왔는데 라이터가 들어오려면 블록되어야 하고라이터가 들어왔는데 리더가 들어오려면 블록되어야 하고리더가 들어와있는데 리더가 들어오면 허용해야한다 Dining Philosopher Problem다음 프로그램 설명철학자 5명이 둥근탁상에 앉아있다. 젓가락은 5개뿐. 즉 자신의 왼쪽 오른쪽에 젓가락이 위치.젓가락을 세마포어로 만들고 초기화를 1로한다.무한루프를 돌면서 왼쪽젓가락, 오른쪽 젓가락을 acquire 하고. 먹고 다시 왼쪽 오른쪽 젓가락을 release한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.concurrent.Semaphore;class Philosopher extends Thread &#123; int id; // philosopher id Semaphore lstick, rstick; // left, right chopsticks Philosopher(int id, Semaphore lstick, Semaphore rstick) &#123; this.id = id; this.lstick = lstick; this.rstick = rstick; &#125; public void run() &#123; try &#123; while (true) &#123; lstick.acquire(); rstick.acquire(); eating(); lstick.release(); rstick.release(); thinking(); &#125; &#125;catch (InterruptedException e) &#123; &#125; &#125; void eating() &#123; System.out.println(\"[\" + id + \"] eating\"); &#125; void thinking() &#123; System.out.println(\"[\" + id + \"] thinking\"); &#125;&#125;class Test &#123; static final int num = 5; // number of philosphers &amp; chopsticks public static void main(String[] args) &#123; int i; /* chopsticks */ Semaphore[] stick = new Semaphore[num]; for (i=0; i&lt;num; i++) stick[i] = new Semaphore(1); /* philosophers */ Philosopher[] phil = new Philosopher[num]; for (i=0; i&lt;num; i++) phil[i] = new Philosopher(i, stick[i], stick[(i+1)%num]); /* let philosophers eat and think */ for (i=0; i&lt;num; i++) phil[i].start(); &#125;&#125; 위의 프로그램은 쭉 가다가 정지된다. 그 이유는 기아상태 유발모든사람이 각자의 왼쪽 젓가락을 들었을 때 해당상황이 발생이를 교착상태라 한다. 운영체제에서 중요한것은 프로세스 관리. 이중 중요한것이 CPU 스케줄링, 동기화 문제이다.동기화에서 중요한건 크리티컬 섹션문제, 효율성 증대 즉 ordering 인데 ordering를 잘못하면 교착상태(Deadlock)에 빠지게 된다. 교착상태(Deadlocks)프로세스가 실행되기 위해서는 하드웨어 자원이 필요하다. 이를 리소스 즉 자원이라 한다. 자원을 사용하는 애플리케이션 즉 프로세스가 있고 중간에 OS가 있다. OS는 애플리케이션한테 자원을 잘 나눠줘야 한다. 자원은 한정되어 있는데 이를 사용하고자 하는 프로세스는 많다. 여기서 잘 나눠주지 못하면 교착상태가 발생한다. 어떤 자원은 갖고 있으나 다른 자원은 갖지 못할 때 (e.g., 다른 프로세스가 사용 중) 대기해야 한다.다른 프로세스 역시 다른 자원을 가지려고 대기할 때 교착상태 가능성 발생 교착상태는 어떤자원을 갖고있을 때 다른 자원을 갖고자 할 때 발생 교착상태 필요 조건 (Necessary Conditions)Mutual exclusion (상호배타) : 리소스가 상호 배타적이다. 즉 한프로세스가 A를 쓰고 있다면 다른 프로세스는 A를 쓰지 못한다.Hold and wait (보유 및 대기) : 왼쪽 젓가락 잡고있으면서 오른쪽 젓가락을 기다리는것.No Preemption (비선점) : 다른사람의 젓가락 하나를 강제로 뺏을 수 없다.Circular wait (환형대기) : 대기하는 형태가 원을 이룸. 교착상태OS에서는 데드락이 일어나지 않도록 미리 조취를 해야한다. 자원의 사용요청 (request) → 사용 (use) → 반납 프로세스가 자원을 쓰려면 OS에게 요청을 한다. 그 요청이 올바르면 OS는 그것을 허용하고 프로세스가 자원을 다 쓰면 OS에게 반납한다. 동일 자원동일 형식 (type) 자원이 여러 개 있을 수 있다 (instance) - 예: 동일 CPU 2개, 동일 프린터 3개 등 자원 할당도 (Resource Allocation Graph)시스템 내에 어느 자원이 있고 어떤 프로세스에게 할당되었는가에 대한 그래프어떤 자원이 어떤 프로세스에게 할당되었는가?어떤 프로세스가 어떤 자원을 할당 받으려고 기다리고 있는가?자원: 사각형, 프로세스: 원, 할당: 화살표 그래프 강의는 37분부터 보자 교착상태 필요조건자원 할당도 상에 원이 만들어져야 (환형대기) - 충분조건은 아님!자원에서 프로세스를 가르키면 프로세스가 자원을 할당받은 상태프로세스에서 자원을 가르키면 자원을 요청한 상태 짝수번 철학자는 왼쪽들고 오른쪽 들고홀수번 철학자는 오른쪽들고 왼쪽거 들기. 그러면 원형이 깨지게 되어 교착상태가 발생하지 않게된다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"13.전통적 동기화 문제, 생산자-소비자 문제","slug":"operating-system13","date":"2019-02-21T13:10:14.000Z","updated":"2019-02-22T13:52:46.125Z","comments":true,"path":"2019/02/21/operating-system13/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/21/operating-system13/","excerpt":"","text":"OS에서 가장중요한게 프로세스 관리이중 CPU 스케줄링, 프로세스 동기화가 중요하다.이때 임계구역 처리를 잘해야한다. 전통적 동기화 예제1.Producer and Consumer Problem(생산자-소비자 문제, 유한버퍼 문제 (Bounded Buffer Problem))2.Readers-Writers Problem(공유 데이터베이스 접근)3.Dining Philosopher Problem(식사하는 철학자 문제) Producer-Consumer Problem생산자-소비자 문제생산자가 데이터를 생산하면 소비자는 그것을 소비예: 컴파일러 &gt; 어셈블러, 파일 서버 &gt; 클라이언트, 웹 서버 &gt; 웹 클라이언트 Bounded Buffer보통 생산소비와 소비속도는 다르다.그래서 보통 창고(버퍼)에 저장하고 컨슈머가 조금씩 빼먹는다. 생산된 데이터는 버퍼에 일단 저장 (속도 차이 등)현실 시스템에서 버퍼 크기는 유한생산자는 버퍼가 가득 차면 더 넣을 수 없다.소비자는 버퍼가 비면 뺄 수 없다 버퍼가 가득차면 생산자는 버퍼가 비워질때까지 기다려야한다.버퍼가 비면 소비자는 빼갈것이 없다. 생산자가 10000번 넣고 소비자가 10000번 넣으면 0이되지 않을 수 있다.이유 : 공통변수 count, buf[] 에 대한 동시 업데이트공통변수 업데이트 구간(= 임계구역)에 대한 동시 진입 해결법 : 임계구역에 대한 동시 접근 방지 (상호배타)세마포를 사용한 상호배타 (mutual exclusion, mutex) Busy-wait바쁘게 기다린다.생산자: 버퍼가 가득 차면 기다려야 == 빈(empty) 공간이 있어야 한다소비자: 버퍼가 비면 기다려야 == 찬(full) 공간이 있어야 한다 이때 무한루프를 돌면서 기다리면 CPU는 다른일을 못하고 잡히게 된다. -&gt; 비효율적해결법 : 두개의 세마포어를 사용. empty의 초깃값은 BUF_SIZE 만큼 full의 초깃값은 0으로 하여 사용생산자 :empty.acquire();PRODUCE;full.release(); 소비자 :full.acquire();CONSUME; empty.release();","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"12.세마포를 사용한 프로세스 동기화","slug":"operating-system12","date":"2019-02-20T14:16:51.000Z","updated":"2019-02-20T14:17:22.281Z","comments":true,"path":"2019/02/20/operating-system12/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/20/operating-system12/","excerpt":"","text":"프로세스 관리에서 중요한것들CPU 스케줄링 : 이전포스팅 참고 프로세스(쓰레드) 동기화필요이유 : 보통컴퓨터 안에있는 프로세스들은 독립적이지 않고 협조적이므로 즉 공통된 자원에 접근함동기화가 되지 않으면? : 누군가는 계속 입금하고 누군가는 출금하는 로직이 있을 때 다 더한값이 0이 아닐 수 있다.임계구역 : 공통적으로 사용되는 부분 임계구역 문제 해결 : 상호베타, 진행, 유한대기 ( 모르겠으면 이전포스팅 보자)우리가 원하는대로 프로세스 순서를 맞추는것. 동기화 툴세마포어 : acquire P동작 release V동작이 있음누가 CPU 서비스를 받다가 acquire를 호출했는데 if문이 만족하면 세마포어 큐안에 잡혀들어간다. 이 후 누가 wake를 시켜주면 다시 레디큐로 들어가게 된다.세마포어는 Mutual exclusion을 위해 사용한다. 즉 크리티컬 섹션에는 한명만 들어갈 수 있다. 세마포어의 일반적 사용은 Mutual exclusion 그리고 Ordering으로 나뉜다.그 중 Ordering를 구현하기 위해서는 다음과 같이 하면 된다. P1 P2S1 S2 P1, P2가 있을 때 P1을 먼저 실행하고자 할 때(Ordering) : 세마포어의 value를 0으로 셋팅한다. 그 후 P2 앞에 sem.acquire를 호출한다.이러면 P1이 먼저 호출되면 우리가 원하던 대로 되는것이고 그렇지 않고 P2가 먼저 실행될 경우 세마포어 큐에 들어가서 block이 된다. 아무튼 P1이 먼저 실행되게 되고 실행을 완료하면 release를 호출하여 P2가 실행 될 수 있도록 한다.즉 다음과 같은 형태 P1 P2 acquireS1 S2release 세마포어 정리세마포어는 임계구역 문제 해결, 프로세스 실행 순서 제어를 한다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"11.임계구역 문제, 동기화 도구","slug":"operating-system11","date":"2019-02-19T11:04:12.000Z","updated":"2019-02-20T14:16:20.363Z","comments":true,"path":"2019/02/19/operating-system11/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/19/operating-system11/","excerpt":"","text":"임계구역 문제(critical-section problem)여러개의 쓰레드로 이뤄진 시스템에서 각각의 쓰레드는 코드영역을 갖고있는데 이를 크리티컬 섹션이라한다. 또한 쓰레드로 부터 공통으로 사용되고 변경될 수 있는 부분을 의미한다. 어떤 복수개의 쓰레드들이 공통적으로 사용하는 부분. 임계영역 해결이를 해결하기 위해 다음 세가지가 만족되어야 한다. Mutual exclusion (상호배타): 오직 한 쓰레드만 진입Progress (진행): 진입 결정은 유한 시간 내. 즉 누가 먼저 들어가야되는지 유한시간내에 결정해야 한다.Bounded waiting (유한대기): 어느 쓰레드라도 유한 시간 내 크리티컬 섹션안에 들어갈 수 있어야한다. 기다리는 시간이 한계가 정해져 있다. 동기화의 목적우리가 원하는대로 프로세스 혹은 쓰레드의 실행 순서를 결정 지을 수 있는것. O/S 가 가진 여러 매니지먼트(프로세스 매니지먼트,메모리 매니지먼트,파일 시스템 매니지먼트, I/O 매니지먼트) 중 가장 중요한것은 프로세스 매니지먼트. 프로세스 매니지먼트는 두 가지로 나뉘는데 하나는 CPU Scheduling, Synchronization Synchronization를 위한도구세마포어 모니터가 있다. Semaphores : 기차역에서 출발신호를 의미하는 깃발이다. 네덜란드사람 딕스트라가 만듦.내부구조는 정수 하나와 동작 두개로 구성된다. 하나는 P 동작 하나는 V 동작P: Proberen (test) 즉 acquire() 검사V: Verhogen (increment) 즉 release() 증가. 스택에는 푸쉬, 팝이라는 동작이 있다. 마찬가지로 세마포어도 내부에 정수가 있고 P,V가 존재한다.123456789101112131415void acquire() &#123; value--; if (value &lt; 0) &#123; add this process/thread to list; // 누가 호출하면 큐안에 넣는다. block; &#125;&#125;void release() &#123; value++; if (value &lt;= 0) &#123; remove a process P from list; //누군가 갇혀있으면 깨워준다. wakeup P; &#125;&#125; 저번에 배웠듯이 레디큐에서 CPU의 서비스를 받기 위해 기다리던 프로세스들이 CPU 서비스를 받다 IO를 만나면 IO서비스를 받으려 하는데 누가 IO서비스를 받고있다면 IO Queue(Device Queue)에서 대기하다 IO서비스를 받고 끝나면 다시 레디큐로 돌아온다. 타임쉐어링 시스템의 경우엔 IO를 만나지 않더라도 시간이 지나면 다시 레디큐로 돌아간다. 이는 프로세스의 큐잉 모델 즉 줄서서 기다리는 모델이다. 세마포어는 정수값도 있고 세마포어 큐도 있다. 어떤 프로세스가 레디큐에 있다 CPU를 쓰다가 acquire를 호출했는데 if문이 맞으면 갇혀버린다.(like 감옥) 이후에 누가 release를 해주면 감옥에서 탈출하여 다른 레디큐로 갈 수 있다. 위에서 value는 권한의 갯수로 생각하면 된다. 세마포어는 Mutual exclusion 상호베타를 위해 동작한다.세마포어의 초깃값이 1이라 하자. 이때 레디큐에 A, B가 있다고 하자.먼저 A가 acquire(); 을 호출하면 0이 되고 크리티컬 섹션 안으로 들어간다.(블록 걸리지 않음)이때 컨텍스트 스위칭이 되고 B가 acquire를 호출하면 이때는 value가 -1이므로 세마포어 큐에 갇히게 된다. (크리티컬 섹션 안으로 못들어간다). 그 후 A가 작업을 마치고 release를 호출하게 되면 value를 늘리고 세마포어 큐에 갇혀있는 B를 깨워 다시 레디큐로 들어가게 한다. 이를 상호베타라 한다. Monitors : 메모리 매니지먼트라파일 시스템 매니지먼트I/O 매니지먼트","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"10.프로세스 동기화의 중요성, 은행계좌 문제","slug":"operating-system10","date":"2019-02-18T13:31:45.000Z","updated":"2019-02-18T13:34:32.742Z","comments":true,"path":"2019/02/18/operating-system10/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/18/operating-system10/","excerpt":"","text":"1. 쓰레드란?프로그램 내부의 흐름, 맥 맥이 하나만 있는 프로그램 : 싱글쓰레드여러개있는것: 멀티(다중)쓰레드 쓰레드가 여러개가 빠르게 동시에(왔다갔다하면서) 실행됨. 우리는 CPU하나임을 가정하고 공부하기 때문에 1.1 쓰레드 구조프로세스의 메모리 공간 공유 : (code, data)프로세스의 자원 공유 : (file, i/o, …)비공유: 개별적인 PC, SP, registers, stack 운영체제의 프로세스 관리부서에서 중요한것은 프로세스 동기화 또는 쓰레드 동기화이다. 프로세스는 크게 두가지로 나뉜다.Independent process : p1, p2가 영향이 없다Cooperating process : p1, p2가 영향을 주던지 받던지 한다. 이런경우가 훨씬 많다.프로세스간 통신: 전자우편, 파일 전송프로세스간 자원 공유: 메모리 상의 자료들, 데이터베이스 등명절 기차표 예약, 대학 온라인 수강신청, 실시간 주식거래 2. 프로세스(쓰레드) 동기화공통데이터에 접근하는것은 문제가 발생할 수 있다. (공유되는 프로세스가 동시에 접근할 때.)동기화가 제대로 이뤄지지 않으면 똑같은 자리에 두명이상이 배정된다던가 하는 문제가 생긴다. 프로세스간에 순서를 잘 지정해서 이상한 상태에 빠지지 않도록 하여 데이터의 일관성을 유지 2.1 BankAccount Problem (은행계좌문제)부모님은 은행계좌에 입금; 자녀는 출금입금(deposit)과 출금(withdraw) 은 독립적으로 일어난다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"9.다중 큐 스케쥴링, 프로세스 생성과 소멸, 쓰레드","slug":"operating-system9","date":"2019-02-18T13:29:58.000Z","updated":"2019-02-18T13:31:23.624Z","comments":true,"path":"2019/02/18/operating-system9/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/18/operating-system9/","excerpt":"","text":"다중 큐 스케쥴링, 프로세스 생성과 소멸, 쓰레드다양한 CPU 스케줄링 알고리즘First-Come, First-Served (FCFS)Shortest-Job-First (SJF)PriorityRound-Robin (RR)Multilevel QueueMultilevel Feedback Queue 1. Multilevel Queue Scheduling1.1 Process groups : 프로세스는 그룹별로 묶일 수 있다.System processes : 가장 긴급하고 먼저 처리되어야 하는것.Interactive processes : 대화형 프로세스Interactive editing processes : ex 워드프로세스Batch processes : 인터액션이 따로 없다.Student processes 성격이 다양한것을 동일한 큐에 세우는것이 맞지 않다라고 판단.입출금은 빠르게 끝나는데 대출은 오래 끝나니까!이를 위해 큐를 여러개를 두자 이를 멀티레벨 큐. 1.2 Single ready queue → Several separate queues각각의 Queue 에 절대적 우선순위 존재또는 CPU time 을 각 Queue 에 차등배분각 Queue 는 독립된 scheduling 정책 큐가 여러개이므로 우선순위를 둬서 차등반영한다.또한 각 큐별로 다른 스케줄링 기법을 사용한다. 2. Multilevel Feedback Queue Scheduling큐를 여러개 둔다는점은 Multilevel Queue Scheduling와 같은데 하나의 입구로 진입해서 거의 실행되지 않는다면 다른큐로 이동한다. 2.1 다른 Queue 로의 점진적 이동모든 프로세스는 하나의 입구로 진입너무 많은 CPU time 사용 시 다른 Queue 로기아 상태 우려 시 우선순위 높은 Queue 로 상용운영체제는 여러 큐를 갖고있어 다양한 스케줄링 정책을 두어 적절히 활용한다. 3. Process Creation프로세스는 사람과 비슷하다. 프로세스는 프로세스에 의해 만들어진다. 그렇다면 제일 첫번째 프로세스는 어떻게 만들어졌을까??O/S가 메모리로 올라가고 초기화 작업을 하면 제일 처음 프로세스를 만든다. 제일 첫번째 프로세스 이름을 유닉스의 경우 init프로세스(OS마다 다름)라 한다. 이 프로세스가 다른 프로세스를 만든다. 3.1 Process Identifier (PID)사람의 주민등록번호와 같은것.처음 만들어지는 프로그램은 0이다.PPID? 부모 PID 3.2 프로세스 생성fork() system call - 새로운 프로세스 만드는것.exec() - 만들어진 프로세스의 실행파일을 메모리로 갖고오는것. 3.3 프로세스 종료exit() system call - 해당 프로세스가 가졌던 모든 자원은 OS에게 반환 (메모리, 파일, 입출력장치 등) 4. 쓰레드프로그램 내부의 흐름, 맥이라고 한다. 4.1 다중 쓰레드(Multithreads)하나의 프로그램에 맥이 2개이상 있는것.맥이 빠른 시간 간격으로 스위칭 된다 → 여러 맥이 동시에 실행되는 것처럼 보인다Web browser : 화면 출력하는 쓰레드 + 데이터 읽어오는 쓰레드Word processor : 화면 출력하는 쓰레드 + 키보드 입력 받는 쓰레드 + 철자/문법오류 확인 쓰레드 이전강의까지는 P1이 끝나면 P2로 넘어간다 했는데 그건 예전의 OS이다.즉 현재의 컴퓨터는 컨텍스트 스위칭 단위가 프로세스가 아니라 쓰레드 단위이다. 각 쓰레드는 코드와 데이터 공유하고 스택은 공유하지 않는다. 한 프로세스에는 기본 1개의 쓰레드 : 단일 쓰레드 (single thread) 프로그램한 프로세스에 여러 개의 쓰레드 : 다중 쓰레드 (multi-thread) 프로그램 4.2 쓰레드 구조프로세스의 메모리 공간 공유 : (code, data)프로세스의 자원 공유 : (file, i/o, …)비공유: 개별적인 PC, SP, registers, stack","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"8.SJF, Priority, RR 스케쥴링","slug":"operating-system8","date":"2019-02-16T04:17:07.000Z","updated":"2019-02-17T11:46:28.048Z","comments":true,"path":"2019/02/16/operating-system8/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/16/operating-system8/","excerpt":"","text":"CPU 스케줄링 알고리즘CPU 스케줄링은 레디큐에서 프로세스들이 CPU의 작업을 기다리고있을 때 누가 먼저 들어갈것인가에 대한것. FCFS는 이전포스트 참고 AWT를 평균대기시간이라 함.ATT를 Average turnaround time 반환시간이라함. SJF가장 짧은것을 먼저하는것.P1 6P2 8P3 7P4 3의 프로세스가있을 때 대기시간. p4, p1,p3,p2의 순서로 진행된다.평균 대기시간은 (3+16+9+0)/4 = 7 이다.FCFS로 하면(0+6+14+21) /4 = 10.25 이다. 실제로 프로세스가 얼마나 사용할지는 모른다. 해봐야 한다.대기시간을 줄이기 위해 적절한 방법이긴 한데 CPU 사용시간을 예측을 해야한다.(이를 정확하게 예측하기 위해서는 과거를 기억해야 하는등 계산하는데 오버헤드가 발생한다.) 실제로 적용하기엔 어렵다! Preemptive or Nonpreemtive 둘다 적용가능하다. Priority Scheduling우선순위가 높은것을 먼저 처리 우선순위는 내부적요소, 외부적 요소로 결정된다.내부요소: 타임 리밋이 짧은것을 높게주기, 메모리 적게잡는놈 높게주기, IO가 길고 CPU burst가 짧은거 높게주기 등등외부요소: 돈 많이 낸사람, 정치적요소 일반적으로 많이 사용된다. 이 또한 Preemptive or Nonpreemtive 둘다 적용가능하다. 문제점: 기아상태우선순위가 낮은 프로세스가 기다리는데 우선순위 높은것들이 자꾸 들어온다면 아무리 기다려도 자기 차례가 오지 않는다.해결방법 : againg 어떤 프로세스가 오래머물러 있다면 점진적으로 우선순위를 높여준다 Round Robin시간을 쪼개서 진행Time quantum 시간양자 = time slice (보통 10 ~ 100msec으로 잡는)Preemptive scheduling 타임퀀텀을 얼마로 잡느냐에 따라 AWT가 달라진다.즉 Time quantum에 의존적이다Time quantum을 무한대로 주면 FCFS와 동일하다 반대로 Time quantum을 0으로 주면 동시에 도는것과 같이느낄 수있다,context switching overhead 가 발생함.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"7.스케쥴링 척도, FCFS","slug":"os7","date":"2019-02-15T12:27:56.000Z","updated":"2019-02-17T11:45:42.025Z","comments":true,"path":"2019/02/15/os7/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/15/os7/","excerpt":"","text":"CPU 스케쥴링프로그램은 하드디스크안에 들어있고 아무런 동작도 하지안흔다. 메인메모리에 올라가서 실행이 되면 활동한다. 활동중에 있는 프로그램을 프로세스라함. 프로세스에 대한 것들을 PCB안에 넣어놓는다. 컴퓨터 안에는 여러가지 큐가 있는데 job queue, ready queue, device queue가 있다. 메인메모리에 여러 프로그램이 올라와있는게 멀티 프로그래밍프로그램이 몇개인가에 대한것이 Degree of multiprogramming 잡스케줄러가 하는일은 i/o-bound 를 CPU-bound process 적절히 분배하는것. short-term scheduler : 메모리에 올라온 프로세스들은 CPU를 받기위해 줄서있는데 어느놈을 선택해서 서비스해줄지에 대한것Long-term scheduler : 하드디스크에서 메인메모리에 올라가기 위해 job queue에 대기하는 프로그램중 어느놈을 먼저 올려야하는지에 대한것 메인메모리에 올라온 프로세스중에 일정시간동안 사용되지 않는것을 물리적인 하드디스크에 Swap out 한다.Medium-term scheduler : Swap out 리스트중 어느것을 Swap in 할지에 대한것을 의미함. 하드디스크는 파일시스템목적, Backing store(물리적인 하드디스크에 Swap out할 때 목적지) 용도로 사용된다. Context switchingCPU가 p1을 실행하다 p2로 넘어가는데 이를 문맥교환이라 한다. Scheduler레디큐에 있는 놈 중 어느놈을 CPU로 보내줄까에 대한것.지금있는 프로세스가 끝나면 어느놈을 선택할것인가에 대한것.O/S안에 들어있는 컴퓨터 프로그램이다. Dispatcher스케줄러가 선택한 프로세스를 실행하도록 여러가지 상태를 변경해주는것.p2가 선택되었다면 p2를 돌리기 위해 p1의 현재상태 프로그램카운터,스택포인터,레지스터,베이스레지스터 등을 P1의 PCB 에 저장해 놓아야한다.즉 p1의 현재상태를 pcb1에 저장해놓는다. p2의 PCB에저장된 값을 복원(restore)이런일을 하는것이 디스패처라 한다.이런일을 하는것은 오버헤드(부담)이 발생하게 된다. 이를 Context Switching Overhead라고 한다. 즉 컨텍스트 스위칭을 자주하는것은 손해이다.Dispatcher는 주로 어셈블리어와같은 low 레벨로 짜서 효율을 높인다. CPU스케줄링현재 실행중인 프로세스가 끝나면 어느것을 실행해줄까 Preemptive vs Non-preemptivePreemptive : CPU가 어떤일을 하고 있는데 IO를 만나거나 끝나지도 않았는데 강제로 끝내고 들어갈 수 있는것Non-preemptive : 이미 어떤프로세스가 실행중이면 끝나거나 IO를 만나지 않으면 변경되지 않는것 Scheduling criteria(척도)특정 Scheduling 기법을 판단하는 기준 CPU Utilization (CPU 이용률) : CPU가 놀지않고 얼마나 열심히 일하는가. a방법은 100%로 돌고 b방법은 80%로 들 때 a방법을 채택 Throughput (처리율) : 시간당 몇개의 작업을 처리하는가. Turnaround time (반환시간) : 작업이 ready queue로 들어가 작업을 끝내고 나오는 시간. Waiting time (대기시간) : CPU를 받기위해 ready queue에서 얼마나 기다려야 하는가. 당연히 짧을수록 좋다. Response time (응답시간) : interactive 환경에서 중요하다. 처음 응답이 나올때 까지 걸리는 시간. 주로 대화형 컴퓨터에서 척도로 삼음 기타 요소 존재…. First-Come, First-Served (FCFS)먼저온놈을 먼저 처리해준다. - Non-preemptive schedulling레디큐에 프로세스가 대기중이다. p1은 burst time 24p2는 3p3는 3 일때 평균적으로 기다린 시간은 (0 +24 + 27)/3 = 17 이다. P3,P2,P1 순으로 들어왔다고 할 경우 (0+3+6)/3 = 3 이라고 할 수 있다.당연히 아래방식이 더 좋다. 간트차트 추가 즉 이런방식으로 해주면 평균 대기시간을 고려할 때 그리 좋은방법이 아니다. Convoy Effect (호위효과) : CPU를 많이 잡아먹는놈이 앞에있으면 뒤에놈들이 오래 기다려야 한다. Shortest-Job-First (SJF)짧은 작업을 먼저 처리해준다. Shortest-Remaining-Time-FirstPriorityRound-Robin (RR)Multilevel QueueMultilevel Feedback Queue","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"6.프로세스의 정의, CPU 스케쥴러, 멀티프로그래밍","slug":"os6","date":"2019-02-15T12:24:01.000Z","updated":"2019-02-22T14:32:45.181Z","comments":true,"path":"2019/02/15/os6/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/15/os6/","excerpt":"","text":"프로세스 관리CPU를 프로세스한테 어떻게 잘 나눠주는가에 대한것. Process실행중인 프로그램. 프로그램은 무덤속에 있는것. 프로세스는 살아있는것.program in execution: text + data + stack, pc, sp, registers, … 프로세스의 상태new - 메인 메모리로 올라온 상태.ready - 실행할 준비가 모두 다 된상태 ( waiting이 끝나도 ready로 돌아옴)running - CPU가 실행중인 상태 (CPU를 잡게된 상태)waiting - 기다리는 상태. ( hwp 프로그램이 프린터를 요청하고 기다림. 즉 IO를 만나는 경우에도 wating상태가 된다,)terminated - 끝난상태. ready, running, wating의 반복으로 프로세스가 동작 타임쉐어링 시스템은 일정시간이 지나면 바로 ready 상태로 간다 PCB(Process Control Block )Task == Process프로세스 제어 블록이며 Task Control Block (TCB) 이라고도 함. PCB는 프로세스에 대한 모든 정보를 담고있다.하나의 프로세스에 대해 PCB를 갖고있다. 다른 프로세스로 처리가 넘어가다러도 다시 돌아올 수 있도록 관리.상태정보, PC(지금은 몇번지인지. 번지정보), registers, MMU info (base, limit), CPU time(CPU 이용시간), process id, list of open files(얘가 지금 어떤파일을 사용하고 있는지)… PCB는 OS의 프로세스 관리 부서(프로세스 매니지먼트,모르겠으면 이전포스팅 참고) 안에 들어있다. 모든프로그램은 원래 하드디스크 안에 들어있다. 여러가지 Queue하드디스크에서 메모리로 올라가기 위해서는 줄서서 기다려야한다. 그런것을 Job queue라고 한다. 메인메모리에 올라와서 CPU를 받으려면 줄서야 하는데 이를 Ready queue라고 한다. I/O를 사용하려 해도 줄서서 기다려야 한다. 이를 Device queue 라고 한다. I/O를 끝내면 ready상태로 가는데 여기서도 줄서서 기다려야 한다. Job scheduling(Long-term scheduler)하드디스크에서 메인메모리에 올라가기 위해 job queue에 대기하는 프로그램중 어느놈을 먼저 올려야하는지에 대한것을 Job scheduling(Long-term scheduler)라 한다. 잡 스케줄링은 역시 O/S 안에 프로세스 관리안에 존재한다.일반적으로 프로세스가 끝나고 메모리가 비워져야 일어나기 때문에 Long-term scheduler 라고도 한다. 즉 스케줄러가 일어나는 시간이 몇분이 걸린다. CPU Scheduler( Short-term scheduler )메모리에 올라온 프로세스들은 CPU를 받기위해 줄서있는데 어느놈을 선택해서 서비스해줄지에 대한것을 CPU Scheduler( Short-term scheduler )이라 한다.메인 메모리에 여러 프로그램이 있는데 스위칭이 빠르게 일어난다. 1초에 수십번,수백번도 발생한다. 그래서 Short-term scheduler 라고도 부른다. 다른 스케줄링 보다도 가장 중요한 스케줄링이다. Device Scheduler디바이스 서비스를 받기위해 기다리는것을 Device Scheduler이라 한다. 멀티프로그래밍메인메모리에 하나의 프로그램, 프로세스를 올리는것이 아니라 여러개를 올리는것. Degree of multiprogramming - 멀티프로그래밍의 정도 ( 메인메모리에 몇개의 프로세스가 올라와있는가) 프로세스의 구분프로세스는 크게 두가지로 나눌 수 있다,i/o-bound : 프로세스가 하는게 주로 I/O를 사용하는것(ex. 워드프로세서)CPU-bound process : 프로세스가 주로 cpu를 사용함.(ex. 일기예보와 같은 계산) O/S는 작업을 적당히 섞어서 잡 스케줄링결과로 CPU 혹은 IO에만 작업이 치중해 한쪽이 놀지 않도록 한다. Medium-term scheduler서버컴퓨터에 여러명이 사용중이라 가정하자. B라는 사람이 심심해서 커피를 마시러 갔다하자. 그동안 B를 위한 메모리는 올라와있지만 CPU는 아무역할도 하지 않는다. 즉 낭비다. B를 위한 자원을 쫒아내는것이 이득인데 이를 위해 디스크로 쫒아내고 비어있는 메모리공간을 확보한다. 여기서 쫒아내는 것을 Swap out라고 한다. 이처럼 디스크를 프로세스 이미지를 쫒아내는 목적으로 사용하는것을 swap device 라고 한다. 다시 B가 커피를 마시고 돌아와 마우스를 움직이면 Swap device로 갔던 프로세스를 불러들이는데 이를 Swap in이라 한다. swap device로 swap in되고 swap out 되는것을 Swapping 이라 한다. 이때 쫒겨났을때 쫒겨난 자리로 그대로 들어가는것을 보장하지는 않는다. 즉 Medium-term scheduler 는 현재 사용되고 있지 않은 어떤놈을 쫒아낼지 결정하는것이다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"5.운영체제의 주요 서비스 프로세스, 메모리, 파일관리, 시스템 호출","slug":"operating-system","date":"2019-02-14T13:01:23.000Z","updated":"2019-02-17T11:02:54.527Z","comments":true,"path":"2019/02/14/operating-system/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/14/operating-system/","excerpt":"","text":"운영체제 서비스지금은 서버컴퓨터 하나에 여러명이 동시에 사용하는 구조.이러한 구조에선 한사람이 잘못된 것을 할 경우 해악이 될 수있다. 다중유저시스템, 다중프로그래밍시스템에서 필요한 보호들 1.입출력장치 보호A,B가 바로 하드웨어에 접근하지 못하도록 함어떻게? In(입력),Out(출력) 명령을 특권명령으로 만들어 A,B는 이를 실행하지 못하고 O/S에게 부탁하여 실행토록 함.그러면 O/S가 프린터를 구동시켜줌 2.메모리 보호자기에게 넘어간 메모리 접근을 못하도록 하는것.유저1이 OS영역이나 다른사람 영역을 못들어가도록 함.어떻게? MMU를 활용하여 base, limit 값을 넘지 못하도록한다. 넘을경우 인터럽트를 발생시켜 프로그램 강제종료 3.CPU 보호while(a=1)…위의 경우 CPU가 한 사용자에 독점되게 된다.어떻게? 타이머를 걸어서 일정시간이 지나면 인터럽트를 걸도록 한다.인터럽트 서비스 루틴에는 CPU가 골고루 돌아가고 있는지. 한 프로그램에만 돌아가고 있지 않은지 파악하도록 짠다.인터럽트 &gt; 운영체제 &gt; 다른 프로그램으로 강제 전환 운영체제가 하는일정부가 하는일과 비슷하다.자원을 효율적으로 나눠주는 시스템을 OS라 한다.모든애플리케이션은 하드웨어를사는데 이 하드웨어를 적절하게 분배하는것을 OS라 한다. 프로세스 매니지먼트이 중 CPU를 나눠주는 부분이 프로세스 매니지먼트 프로세스는 ? 메인 메모리에서 실행중인 프로그램. 실행상태에 있는 프로그램하드디스크에는 많은 프로그램이 있지만 메인메모리로 올라와 있는 것을 프로세스라 함.그래서 프로그램 매니지먼트라 하지않고 프로세스 매니지먼트라 함. 프로세스들이 많아지만 교착상태가 발생할 수 있는데 이를 프로세스 관리부분이 처리해준다. 메인메모리 매니지먼트주기억장치를 나눠주는 부분이 메인메모리 매니지먼트 프로세스한테 메인메모리를 할당한다.메모리의 어느 부분이 어느 프로세스에게 할당되었는가 추적 및 감시프로세스 종료 시 메모리 회수 (deallocation)메모리의 효과적 사용가상 메모리: 물리적 실제 메모리보다 큰 용량 갖도록 파일 매니지먼트하드디스크 안에 파일을 관리하는것이 파일 매니지먼트 판 위에 트랙을 만들고 이를 잘라서 섹터라 한다. 즉 트랙, 섹터의 집합 파일을 만들기도 하고 없애기도 하고 디렉토리 생성 삭제에 관여파일에 대한 기본동작(open, close, read, write, create, delete) 지원백업(backup) 보조기억장치관리(Secondary storage management)보조기억장치는 트랙, 섹터의 집합인데 이를 어떻게 관리할것인가 하드 디스크, 플래시 메모리 등 섹터들을 모아서 block이라 하는데 block들에 데이터를 저장하게 되는데 빈 공간 관리, 저장공간 할당, 디스크 스케쥴링을 제공한다. 입출력 장치 관리장치드라이브 관리(웹켐, 사운드카드 등)입출력 장치의 성능향상을 위해 버퍼링, 캐싱, 스풀링을 활용한다 스풀링 메모리 대신 하드디스크를 중간 매체로 사용한다.스풀링 : 프린터는 일반적으로 느리기때문에 씨피유에 저장하기 보다는 씨피유보다 느리고 프린터 보다 빠른 하드디스크에 저장하는것.빈 공간 관리 (free space management)저장공간 할당 (storage allocation)디스크 스케쥴링 (disk scheduling) 네트워킹보호기타 등등…시스템 콜O/S가 제공하는 여러가지 기능을 받기 위해 호출하는것. OS에는 여러가지 관리 부서가 있다.또한 여러가지 프로그램이 메모리로 올라가 여러 프로세스가 존재한다,각 프로세스는 OS가 제공하는 관리 기능들이 필요한데 이때 이를 사용하기 위한것이 시스템 콜이라 한다. 주요 시스템 콜– Process: end, abort, load, execute, create, terminate, get/setattributes, wait event, signal event– Memory: allocate, free– File: create, delete, open, close, read, write, get/set attributes– Device: request, release, read, write, get/set attributes, attach/detache devices– Information: get/set time, get/set system data– Communication: socket, send, receive","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"4.사용자모드와 관리자모드, 하드웨어 보호","slug":"os4","date":"2019-02-11T12:29:11.000Z","updated":"2019-02-15T12:27:37.482Z","comments":true,"path":"2019/02/11/os4/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/11/os4/","excerpt":"","text":"이중모드, 하드웨어 보호한 컴퓨터를 여러 사람이 동시에 사용하는 환경이다.한사람의 실수가 전체에 영향을 끼칠 수 있으므로 일반유저는 STOP, HALT, RESET 등과같은 명령어는 일반 유저가 이용할 수 없도록 하는것. 이를 이중모드라 한다. 이를 사용자(user)모드, 관리자(supervisor) 모드 라고 한다.관리자 모드 = 시스템 모드 = 모니터 모드 = 특권 모드특권 명령(ex. STOP, HALT, RESET, SET_TIMER, SET_HW 등은 관리자 모드에서만 사용 가능) 이중모드 동작방식CPU안에 레지스터 ALU, 제어유닛이 있다, 레지스터는 비트들의 모음(32bit의 경우 32개가 있다.)레지스터 비트는 carry,zero, negative, overflow 와 같은 플래그도 갖고있다,또한 이중모드를 나타내기 위한 플래그(모니터 비트라 함) 또한 레즈스터에 존재한다. 모니터 비트가 1이면 시스템모드 0이면 유저모드이다. 가령 게임을 실행하고 저장한다고 가정해보자.1.처음 파워를 키면 부팅이 일어난다 이때는 모니터 비트가 1이다.(시스템 모드)2.OS의 부트가 끝나고 특정 게임을 실행한다고 하자, 그럼 디스크에서 게임을 메모리로 갖고올 것이다.3.그리고 실행이 게임으로 넘어갈 때 모니터 비트는 0 (유저모드)로 변경된다.4.다시 게임내용을 하드디스크에 저장할 때는 OS에게 부탁(SWI,소프트웨어 인터럽트)하여 OS가 저장하게 한다(다른파일을 덮어쓰는지와 같은 부정한 행위를 하는지에 대한 판단을 하고 저장하게 해줌). 이때는 모니터 비트가 다시 1이된다. //물론 게임 자체적으로 디스크에 저장할 수 있지만 보안상의 이슈 존재!5.저장을 완료하면 다시 게임 프로그램으로 돌아오고 모니터 비트가 0이된다. 운영체제 서비스 실행될 때는 관리자 모드사용자 프로그램 실행될 때는 사용자 모드하드웨어/소프트웨어 인터럽트 발생하면 관리자 모드운영체제 서비스가 끝나면 다시 사용자 모드 하드웨어 보호1.입출력장치에 대한 보호 하드웨어에 대한 적절한 보호가 없을 때의 경우내가 프린트하는데 누가 방해할라고 그놈도 계속 프린트 명령을 보내는상황이 발생했을 때.내가원하는 출력물, 상대가 원하는 출력물이 섞여서 나오는 경우가 생길 수 있다. 어떻게?아무유저나 In,Out 명령을 내리지 못하도록 특권명령으로 한다. 사용자가 입출력 명령을 직접 내린 경우?Privileged instruction violation 이라 하며 해당 프로그램을 강제로 중지시킨다. 메모리 보호멀티프로그래밍, 타임쉐어링 프로그래밍에서는 동시에 여러프로그램이 돌고있다.특정 프로그램이 돌면서 다른 프로그램 혹은 OS의 영역에 기웃거리지 못하게 한다. 어떻게?메모리에 접근하려면 어드레스 버스를 통해야하는데 어드레스 버스에 문지기를 두어 자기것에만 접근하는지 확인한다.확인할 때는 base, limit 를 참고한다. 잘못된 범위를 읽을 땐 인터럽트를 O/S로 보낸다. 잘못된 번지를 읽을 때 보내는 신호를 보통 Segment violation 라고 부른다. 여기서 문지기를 MMU(Memory Management Unit)라고 한다. base 와 limit 사이에 들어오는지 확인하며 base와 limit는 OS가 관리한다. 또한 base와 limit는 아무나 설정하면 안되므로 특권명령으로 관리된다. 3.CPU 보호","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"3.최근의 고급운영체제, 인터럽트에 기반한 현대 운영체제","slug":"os3","date":"2019-02-11T10:49:46.000Z","updated":"2019-02-15T12:27:37.793Z","comments":true,"path":"2019/02/11/os3/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/11/os3/","excerpt":"","text":"다중 프로세서 시스템메모리는 하난데 CPU가 여러개이다. 이를 병렬 시스템이라고도 한다.장점 : 병렬 시스템을 통한 성능향상을 목표 비용 : 하나의 강한 CPU 보다 여러개의 저렴한 CPU로 구성하는것이 일반적으로 저렴하다. 신뢰성 제공 : 하나가 고장나도 다른 CPU로 돌릴 수 있다. CPU가 여러개일 때 운영체제를 다중 프로세서 운영체제라 한다. 또한 강결합이라 한다. 분산 시스템멀티컴퓨터 시스템이라고도 하며 네트워크(LAN) 등으로 연결되어 있다.이는 메인메모리가 따로있고 랜으로 연결되어있으므로 소결합이라 한다.OS도 서로 다 따로따로 있다. 이를 분산 운영체제라 한다. 다중프로세서 시스템, 분산시스템의 공통점신뢰성, 성능, 비용절감을 목표로 한다. 실시간 시스템특정 시간내에 반드시 연산이 끝나야 하는것.시간제약 즉 Deadline를 정해둔다. 실시간 시스템은 네비게이션에서도 쓰인다. 실시간 경로안내할때 그 지점에 도착하기 전에 계산이 끝나야하기 때문에주로 공장자동화, 군사, 항공, 우주 분야에서도 쓰인다.실시간 시스템을 위한 운영체제는 실시간 운영체제(Real-time OS = RTOS)라 한다. 인터럽트현대 운영체제는 인터럽트 기반 시스템이다. 컴퓨터를 키면 ROM에 있는 부트로더가 디스크에서 O/S를 메모리로 갖고온다. 이를 부팅이라 한다.이 후 운영체제는 메모리에 상주하게 된다.이 다음에는 아이콘이 나타나고 깜빡거린다.이러다 우리가 마우스를 움직이면 전기신호가 발생하고 CPU에 인터럽트 선을 통해 전기신호를 올려준다.그럼 CPU는 지금하던일을 중지하고 OS안에 마우스가 어떤 전기신호를 보냈을 때 어떤 행동을 하라고 정의되어있는지(mouse interrupt service routine)에 따라 처리한다. 하드웨어 인터럽트인터럽트 결과 운영체제 내의 특정코드를 실행한다.(ISR)interrupt Service Routine 종료 후 다시 대기 소프트웨어 인터럽트SWI 명령어는 인터럽트가 걸리는것이다. 보통 인터럽트는 하드웨어가 걸리는데 SWI(Software interrupt) - ARM에서의 소프트웨어 인터럽트 명령INT - 팬티엄에서의 인터럽트 명령 hwp 프로그램이 실행되다가 하드디스크에 있는 내용을 읽어온다고 가정하자.하드디스크를 읽어오는 루틴은 O/S안에 존재한다. 이것또한 ISR이다. 아무튼 하드디스크 내용을 읽기위해 소프트웨어 인터럽트가 걸리게 되고 O/S안에 있는 하드디스크를 읽어오는 루틴을 실행하고 원래 실행중인 곳으로 돌아온다. 운영체제는 평소에는 대기상태이다운영체제는 평소에는 대기상태이다. 그러나 하드웨어 인터럽트, 소프트웨어 인터럽트, 내부인터럽트에 의해 운영체제 코드를 실행한다. 내부 인터럽트는 5를 0으로 나누는것과 같은 논리적인 오류가 있을 때 발생하는 인터럽트이다. 이 땐 divide by zero를 처리하는 ISR이 호출된다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"2.일괄처리부터 시분할시스템까지 운영체제 변천 역사","slug":"os2","date":"2019-02-10T13:33:13.000Z","updated":"2019-02-15T12:27:36.853Z","comments":true,"path":"2019/02/10/os2/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/10/os2/","excerpt":"","text":"컴퓨터의 역사2차세계 대전 중 1940년대 말 만들어졌다. 1.초기에는 운영체제가 존재하지 않았다. 2.이후엔 Batch processing system(일괄처리)이 나왔다이는 최초의 O/S로 볼 수 있다. 3.Multiprogramming system가령 수를 더해서 출력하고 다시 이를 특정 수를 반복해서 더하는 프로그램이 있다고 해보자.수를 더하는것은 CPU가 할 것이고 출력은 입출력 장치가 하게될것이다.이 때 CPU가 작업을 마치고 출력을 위해 입출력 장치가 출력을 실행하게 되면 느린 i/o의 성능으로 인해 CPU가 idle(노는시간) 즉 기다리는 시간이 생기게 된다. 이를 개선하기 위해 메모리에 여러 프로그램을 올리고 실행중인 프로그램이 i/o를 만나면 다른 프로그램을 실행토록 한다. 이를 통해 CPU가 노는 시간이 없도록한다.이와 관련하여 CPU scheduling가 나오게된다. 어떤 순으로 실행하여 성능을 좋게할까에 대한 알고리즘이다.메모리 관리또한 나오게된다. 이는 적절하게 프로그램을 메모리에 배치하기 위한 기법이다.보호개념또한 등장하게 되는데 메모리에서 다른 프로그램의 영역에 침범하면 안되므로! 4.Time-sharing system여러사람이 한 컴퓨터로 들어와 자신의 프로그램을 사용한다고 가정하자. 이 때 여러사람들은 Multiprogramming system에서는 동시에 사용하기란 불가능하다.(이는 I/O를 만나야 다른 프로그램을 동작시키는 로직이므로..)그래서 아주 짧은시간으로 나눠 여러 유저의 작업을 번갈아가며 CPU가 처리해주도록 한다. 이러한 시스템이 등장하며 특정유저가 다른 유저에게 데이터를 주고받는것이 즉 프로세스간 통신이 가능해졌다.또한 누가 먼저 앞서고 뒤서는지에 대한 동기라는 개념이 등장한다.또한 하드디스크의 일부를 메인메모리인냥 사용하는 기술인 가상 메모리 또한 등장하게된다. OS 기술 천이컴퓨터의 규모별 분류는 다음과 같다.과거의 분류 : Supercomputer &gt; Mainframe &gt; Mini &gt; Micro현재의 분류 : Supercomputer &gt; Server &gt; Workstation &gt; PC &gt; Handheld &gt; Embedded워크스테이션 : PC에서 처리못하는 조금 큰 작업 처리","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"1.\t운영체제의 정의와 역할","slug":"os","date":"2019-02-10T12:03:53.000Z","updated":"2019-02-22T14:15:21.308Z","comments":true,"path":"2019/02/10/os/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/10/os/","excerpt":"","text":"운영체제 포스팅은 http://www.kocw.net/home/search/kemView.do?kemId=978503 (KOCW) 를 참고하여 작성됩니다. 운영체제가 없는 PC는 어떨까?야생마와 같다. 프로그램 실행과 같은 동작을 할 수 없게된다.하드디스크에 있는 파일을 메모리에 올릴수 없다.즉 하드디스크에 있는 파일을 운영체제가 올려주는것! 운영체제란?하드웨어를 잘 관리하는것.(하드웨어: 프로세서, 메모리, 디스크…)이를 통해 성능을 올리고 사용자에게 편의성을 제공 부팅메모리는 램, 롬으로 나뉜다. 대부분은 램으로 구성된다. 롬은 많아야 수백키로바이트밖에 되지 않는다,그렇다면 ROM이 필요한 이유는? 전원을 껐다 켜면 램의 데이터는 다 날라가는데 ROM은 그렇지 않다. 컴퓨터를 부팅하면 프로세서는 ROM에 있는 코드를 읽어온다.그렇다면 ROM에는 어떤 프로그램이 있으며 부팅과정은?1.POST(Power On Self Test) 프로그램을 ROM에서 가져와 실행 POST? 모니터는 끼워져있는가, 키보드는 꽂아져 있나, 메모리는 얼마인가 등을 확인하는 프로그램2.부트로더(Boot loader)를 ROM에서 가져와 실행. 부트로더는? 하드디스크를 뒤져서 os를 메인메모리(RAM)로 갖고온다. 이를 부팅이라 한다. 메모리에 올라온 OS는 컴퓨터가 종료될때 까지 지워지지 않는다. 하지만 다른 응용프로그램들은 프로그램 종료에 따라 지워지게된다. 그래서 OS를 메모리 Resident라고 한다. 커널과 쉘OS는 하드웨어를 감싸고 있는데 하드웨어를 제외한 부분을 kernel이라고 한다. 또한 OS의 바깥부분을 (shell,command interpreter)이라 한다. 어떤 명령을 내릴 수 있도록 만드는것을 (shell,command interpreter)이라고 한다.다시말해 OS바깥부분에 위치해서 사용자의 명령을 받아들이는 곳. 그 명령을 인터프리터(해석해서) 명령을 실행해주는 것! 커널은 실제로 Cpu,메모리, 디스크를 관리하는것. 응용프로그램 동작?응용프로그램은 O/S위에서 동작한다.즉 맥킨토시 app을 윈도우에서 실행하면 동작하지 않는다. OS 는 정부와 비슷하다.주어진 자원을 어떻게 활용할까에 대한 고민을 하는것이 유사! 정부에도 여러가지 부서가 있듯이 OS안에도 많은 부서가 존재! 프로세스 매니지먼트 - 프로세스 관리부서메모리 매니지먼트 - 메모리 관리IO 매니지먼트 - 프린트, 키보드 관리파일 매니지먼트 - 파일관리네트워크 매니지먼트 - 네트워크 관리시큐어티 매니지먼트 - 보안관리…..이런부분을 모두 운영체제의 커널로 불린다. 가장중요한것은 프로세스 매니지먼트! CPU가 가장비싸니까 가장 중요하고 프로그램 동작에 핵심이다.그다음으로 중요한것이 메모리 매니지먼트","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"oneM2M, OMA-DM 생각정리..","slug":"mine","date":"2019-02-08T10:53:12.000Z","updated":"2019-02-10T08:02:03.813Z","comments":true,"path":"2019/02/08/mine/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/08/mine/","excerpt":"","text":"oneM2Miot 솔루션을 제공함에 있어 여러 벤더를 맞추기란 힘들다… oneM2M이라는 표준을 만들고 이를 여러 벤더가 맞춤으로써 응용개발사 또한 iot시스템을 개발함에 있어 개발공수를 낮출 수 있게된다.oneM2M에는 CSE라는게 있는데 공통서비스를 제공하는것이다. 가령 데이터 저장, 요금청구 등등 다양하게 있다.. CSE는 REST 형태로 제공되어 편리하다는 장점이 있으며 최근에는 일반 응용개발에 oneM2M을 적용하여 CSE를 적절히 활용하는 경우도 있다. 이를 Distributed Platform 형태 라고 한다통신사업자는 oneM2M 표준을 기반으로 CSE를 사용하는 플랫폼을 만들고 일반에 공개하게 되면 일반 개발자들은 통신사업자가 만든 플랫폼을 사용할 수 있게된다.(?? 맞는지 모르겠다.) OMA-DM이는 이동통신장치 관리표주으로서 내부 데이터에 접근하고 제어하는 표준이라 이해했다. xml기반 마크업 언어 SyncML 기반으로 명령과 결과를 주고받으며 심지어 운영체제 설치 그리고 응용프로그램의 파라미터 까지 변경이 가능하다고 한다. 여기서 관리할수 있는 자원을 관리객체(MO, Management Object)라고 한다. TR-069CPE WAN Management Protocol (CWMP) 이라 불리며 CPE 즉 사용자 단말을 관리하는 프로토콜인것같다. oneM2M과 OMA-DM의 상관관계???아래부터 개인적인생각입니다. 참고하지도 마세요!oneM2M은 장치에서 받은 데이터를 활용하고 정제 저장하는 표준이라고 생각한다. 즉 디바이스의 정보를 뭐 제어하거나 어떻게 가져오는건 아니라 생각한다.하지만 OMA-DM는 내부데이터 관리와 같은 디바이스 내부로 들어가는 표준인것같다. 아래 그림처럼 구분되나보다","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"IOT","slug":"CS/IOT","permalink":"http://KKimSangHeon.github.io/categories/CS/IOT/"}],"tags":[]},{"title":"onem2m","slug":"onem2m","date":"2019-02-08T09:44:50.000Z","updated":"2019-02-08T10:39:25.022Z","comments":true,"path":"2019/02/08/onem2m/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/08/onem2m/","excerpt":"","text":"https://www.youtube.com/watch?v=tBQ085PvR9E 요약 IOT의 4계층Application layer - 스마트홈, 스마트카, 헬스케어Service layer - IoT 서비스 개발이 용이하도록 공통으로 요구되는 기능 제공 oneM2M, AllJoyn, OICNetwork layer - 장치 간 또는 서비스간 연결, 정보전달 HTTP, CoAP, MQTT, Wi-Fi ...Device layer - 센서 또는 다른 하드웨어 oneM2M ?IoT 응용 개발이 용이하도록 공통 기능을 제공하는 국제표준 플랫폼 기술 데이터관리, 연결 제어, 구독/통지, 보안, 그룹관리 …. 등을 제공하는데 응용 개발자는 이를 적절히 활용하여 개발공수를 줄일 수 있다. oneM2M발생이유기존엔 응용이 특정한 디바이스를 타겟으로 개발되었다. 이를 개선할 수 있는것이 oneM2M oneM2M먼저 Use Case를 기반으로 요구사항을 도출해봤더니 다음과 같았다.일반요구사항: 성능, 네트워크 연결지원에 따른 다양한 IoT장치 지원, QoS 기반 메시지 전달, 과금관리…장치관리요구사항: OMA DM/ BBF TR-069, 펌웨어, 소프트웨어 제어, 고장제어보안 요구사항:요청자에 대한 인증/권한 부여, 기반 네트워크 보안기능 활용 이를 기반으로 공통기능 CSE를 도출해냄데이터관리 : 장치가 데이터를 저장할 수 없을때 플랫폼이 저장해준다연결제어 : 레이턴시는 10ms 이하여야 한다.(예시)구독. 통지 : 온도가 40도 이상이면 문자보내줘과금 : 통신플랫폼의 사업자 이므로 이 또한 가능이종 플랫폼 연동사업자간 로밍 : 나의 커넥티드 카가 해외로 넘어가게 되면 로밍을 제공기타 많은 공통기능 제공 oneM2M 안드로이드 플랫폼이랑 유사하다. CSE는 공통기능이 포함된 엔티티다. AE를 카카오톡이라고 보면 좋다. 카톡은 안드로이드에 존재하는 간단한 API를 호출해 메세지를 보낸다.즉 AE개발자는 CSE를 적절히 활용하면 된다. 여러플랫폼이 서로 연결되어 큰 iot를 만들어 낼 수 있게된다. Distributed Platform 형태인 oneM2MIOT의 호출순서는 다음과 같다고 가정 하자.디바이스 - 게이트웨이 - 클라우드 - 게이트웨이 - 디바이스과거에는 클라우드에만 CSE를 탑재하여 호출하였지만 최근에는 게이트웨이, 디바이스에도 이를 탑재하여 분산처리를 한다.물론 하드웨어의 용량이 부족할 경우 플랫폼 기능을 배제하기도 한다. 이 경우 Constrained Device Support 라고 한다. 그렇다면 CSE를 어떻게 호출할까?과거에는 RPC(Remote Procedure Call)을 활용하였지만 REST 기반 API구조를 사용한다.CSE의 기능들을 REST 형태로 개방한다. 즉 URI만 갖고있으면 웹브라우저에서 기능을 호출할 수 있다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"IOT","slug":"CS/IOT","permalink":"http://KKimSangHeon.github.io/categories/CS/IOT/"}],"tags":[]},{"title":"TR-069","slug":"TR-069","date":"2019-02-08T05:52:45.000Z","updated":"2019-02-10T08:35:10.602Z","comments":true,"path":"2019/02/08/TR-069/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/08/TR-069/","excerpt":"","text":"TR-069customer-premises equipment (CPE, 말단 사용자 장치)Auto Configuration Servers (ACS, 자동 설정 서버) TR-069 (Technical Report 069)는 DSL 포럼 (이후 Broadband 포럼으로 변경)의 기술 명세서이다. 이 문서의 정식 명칭은 CPE WAN Management Protocol (CWMP)이다. 이 문서는 말단 사용자 장치를 관리하기 위한 사용자 계층 프로토콜을 정의하고 있다. TR-069 프로토콜은 양방향 SOAP/HTTP 을 기반으로 customer-premises equipment (CPE, 말단 사용자 장치) 와 Auto Configuration Servers (ACS,자동 설정 서버) 간 통신을 가능하게 한다. 또한 안전한 자동 설정 기능을 제공하며 통합 환경 내에서 다른 CPE 관리 함수를 제어하고 동작시킬 수 있도록 해준다. 등장배경 브로드밴드 시장이 활성화 되면서 여러개의 다른 종류의 인터넷 접속 또한 많이 생겨났다. ( 모뎀, 라우터, 게이트웨이, 세트톱박스, VoIP-phone 등). 또한 동시에 이러한 장비들을 설정하는 것은 더욱 복잡해졌다. 말단 사용자에게는 이러한 설정이 더욱 어려운데 이러한 이유로 TR-069 표준이 개발되었다. TR-069 표준은 여러가지 접속 방법에 대한 자동 설정을 제공한다. 이에대한 구체적인 기술적인 사항은 Broadband 포럼에서 관리하고 발행하고 있다.TR-069을 이용해서 말단 장비들은 자동 설정 서버 (Auto Configuration Servers) (ACS)에 접속하고 필요한 설정을 자동으로 받아오게 된다. 이렇게 함으로써 사용자가 따로 설정하지 않아도 필요한 서비스를 사용하는 것이 가능해진다. TR-069는 DSL broadband 시장에서 터미널을 활성화하기 위해 현재 사용중인 표준이다. CPE WAN Management Protocol (CWMP)??서비스 프로바이더가 ACS를 통해 CPE를 원격으로 데이터 모델을 관리할 수 있게 해준다. 제공기능은 다음과 같다. 자동 구성 및 동적 서비스 프로비저닝소프트웨어 / 펌웨어 이미지 관리소프트웨어 모듈 관리 상태 및 성능 모니터링 진단 TR-069 아키텍처 All CWMP sessions begin with the CPE making the Inform RPC on the ACS. This is also referred to as “sending an Inform” or “an Inform message”. An Inform RPC, and consequently, a CWMP session, is always made for a specific reason, called an Event. These Events drive CWMP operation. TR-069 초기 세션ACS와 연결하기 위해서는 다음의 데이터가 필요하다. ACS URL : ACS에 접속하기 위한 URL 주기적인 알림 : ACS와 주기적인 소통이 정의되어야 한다. Username and password - 옵션데이터이나 보안을 위해 하는것이 좋다. 1.First, the CPE initiates a TCP session with ACS and negotiates a secure connection.2.The CPE begins every session by sending an Inform RPC to the ACS, with arguments that include the Event that caused the session. This is done over an HTTP Post.3.In the HTTP Response, the the ACS sends an InformResponse. Once processed by the CPE, this means that the Inform RPC is complete.4.There’s probably no other RPCs that CPE wishes to make on the ACS, so it sends an empty HTTP Post to indicate that it is finished. This may happen at any time during the session.5.The ACS begins to send remote procedure calls to the CPE, such as the GetParamterValues RPC.6.The CPE sends its GetParameterResponse in an HTTP Post, with the information the ACS was looking for. This ends the GetParameterValues RPC.7.The ACS makes any other RPCs it needs to during this session, such as SetParameterValues to change the state of the CPE, or SetParameterAttributes to set up a notification.8.When the ACS has no more RPCs to make, it sends an empty HTTP Response, just like the CPE did earlier. When both the CPE and the ACS have done this, the session is over and it’s time to tear down the connection. 전송방식CWMP는 텍스트 기반 프로토콜입니다. 장치 (CPE)와 자동 구성 서버 (ACS)간에 전송 된 주문은 HTTP 혹은 HTTPS 를 통해 전송됩니다. 이 수준 (HTTP)에서 CPE는 클라이언트 역할을하며 ACS는 HTTP 서버 역할을합니다. 별첨SOAPSOAP(Simple Object Access Protocol)은 일반적으로 널리 알려진 HTTP, HTTPS, SMTP 등을 통해 XML 기반의 메시지를 컴퓨터 네트워크 상에서 교환하는 프로토콜이다. SOAP은 웹 서비스에서 기본적인 메시지를 전달하는 기반이 된다. 참고자료https://www.qacafe.com/tr-069-training/","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"IOT","slug":"CS/IOT","permalink":"http://KKimSangHeon.github.io/categories/CS/IOT/"}],"tags":[]},{"title":"OMA-DM","slug":"oma-dm","date":"2019-02-08T01:29:08.000Z","updated":"2019-02-10T08:41:54.697Z","comments":true,"path":"2019/02/08/oma-dm/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/08/oma-dm/","excerpt":"","text":"OMA(Open Mobile Alliance)이동통신 서비스 애플리케이션 표준화 기구이며 일부 애플리케이션 프로토콜을 다루고 있는 산업 포럼의 증진에 응하기 위해 2002년 6월 설립되었다. Device Management(DM) ?장치 관리 기술이란 직접 수익을 창출하는 기술은 아니지만, 사업자가 응용 서비스를 시작하고 개선하고 관리하는 과정에서 겪는 문제점들을 해결해 줄 수 있는 효과적인 기술로서 이들 서비스를 통한 수익 창출에 효과적인 솔루션이다.WAP, 3G Partnership Project(3GPP), Open Service Gateway Initiative(OSGi), Telemanagement Forum(TMF)등은 그들이 개발한 응용 서비스를 관리해 줄 수 있는 기술, 그들이 개발한 서비스 관리 기법을 가능하게 해줄 기술을 필요로 하게 되었다. OMA-DM장치(단말기) 안에 존재하는 데이터를 서버가 원격으로 접근할 수 있도록 하는 Technology와 규격을 OMA가 제정함 OMA 장치 관리 기술은 범세계적인 이동 통신 시장의 특별한 Use Case와 요구 사항을 고려하여 개발되고 있으며, 특히 이동 단말기의 종류, 운영체제, 지역, 네트워크 기술에 제한되지 않은 열린 기술이기 때문에 결국 기존의 일부 특정 네트워크와 단말기에 국한된 장치 관리 기술들을 통합하거나 대체할 수 있는 기술이다. OMA-DM 은 초기 설정, 소프트웨어 및 펌웨어 관리, 원 격 제어, 진단 및 모니터링 등의 기능을 가지고 있으며, 스마트폰 등의 모바일 단말을 대 상으로 관리 서비스를 제공한다. OMA-DM 프로토콜두 통신 상대가 장치 관리 서비스를 제공하는 서버와 장치 관리 서비스를 받아 처리하는 클라이언트의 관계를 갖는다는 관점에서 비대칭 구조를 갖는 프로토콜이다.장치 관리 서버의 역할은 클라이언트에게 장치 관리 명령을 내리는 것이고 클라이언트의 역할은 주어진 명령을 수행하는 것이다. 장치 관리 서버는 장치 관리 명령을 통해 장치에 설치된 응용 서비스의 파라미터를 변경할 수 있으며, 새로운 파라미터를 생성하도록 할 수 있으며, 장치 내부의 정보를 읽어낼 수 있으며, 응용 소프트웨어를 장치에 설치하고, 그것들의 실행을 원격으로 제어할 수 있을 뿐 아니라 운용체제(OS)를 다시 설치할 수도 있다. 결국, OMA Device Management 프로토콜이란 장치의 자원을 장치 관리 서버가 원격으로 접근할 수 있게하는 프로토콜이며, 장치 관리 프로토콜을 통해 관리할 수 있는 이러한 자원을 관리 객체(Management Object) 라고 부른다 서버와 클라이언트간의 장치 관리 명령과 결과는 원격으로 XML에 기반한 마크업(Markup) 언어인 SyncML 메시지를 HTTP, WSP, OBEX 등의 유선, 무선, 또는 적외선 전송 프로토콜을 통해 서로 전송된다. 뿐만 아니라, Device Management(DM) Tree라는 장치 관리 프로토콜만의 파일 시스템을 정의하고 각 노드를 URI를 통해 접근할 수 있도록 하였다. 그리고, 장치 고유의 데이터 베이스 또는 파일 시스템은 DM Tree와 메핑을 통해 장치 관리 서버에게 투사된다. 그러므로 어떤 장치는 결국 장치 관리 서버에게 있어서 하나의 DM Tree로 나타나게 되는 셈이다. 또한 동일한 장치라도 주어진 접근 권한에 따라 서로 다른 서버에게 다른 형태로 나타나게 된다. OMA Device Management 기술 규격의 구성아래 그림의 규격 구성에 깔린 의도는 첫째로, 기본 규격(Base Protocol)을 다른“Silo”규격들과 분리함으로써 기본 규격이 오랜 기간동안 변하지 않고 꾸준한 안정화 과정을 지날 수 있도록 한다는 것이다. 안정적인 기본 프로토콜의 바탕 위에 변화하는 이동 통신 시장의 요구를 충족시키기 위한 독립적인“Silo”프로토콜들을 정의하도록 함으로써 최소한의 노력으로 안정된 토대 위에서 시장이 필요로 하는 규격을 공급할 수 있는 방안을 마련하였다. 이것은, 각“Silo”규격들이 오직 기본 프로토콜에만 의존적이면서 서로 간에 독립적인 구조를 갖는 프로토콜이기 때문이기도 하다. 둘째로, 자료 동기 프로토콜과 SyncML 파서와 SyncML Toolkit을 공유함으로써 기존 SyncML Toolkit에 기반한 네트워크 인프라를 보호하고 재활용할 수 있도록 하기 위함이다. Management Object (MO)OMA-DA의 관리 서버는 기기 내의 관리 객체(Management Object: MO)를 액세스함으로써 장치를 관리하도록 되어 있다. MO 에는 다음과 같은 것들이 있다. FUMO(Firmware Update Management Object): 펌웨어 업데이트 관리SCOMO(Software Management): 소프트웨어 컴포넌트 설치, 삭제, 관리DiagMon MO(Diagnostics and Monitoring): 배터리, 메모리, 라디오, QoS 파라메터 상태를 수집, 진단ConnMo(Connectivity): 베어러나 프록시 등 설정DCMO(Device Capabilities): 카메라, 블루투스, USB 등 주변기기를 원격으로 활성 화/비활성화하는 권한LAWMO(Lock and Wipe): 분실, 도난시 기기를 잠그거나 완전 삭제BMO(Browser): 브라우저 설정 관리: VirMO(Virtualization): 원격에 있는 가상 머신을 관리Management Policy MO: 어떤 이벤트가 발생하면 어떤 동작을 수행할 수 있도록 하는 정책을 배포 및 관리: OMA-DM 은 HTTP RESTful 메소드를 이용하며, XML 및 JSON 기반의 메시지를 이 용하고, SSL/TLS 보안 기술을 이용. OMA-DM의 가상시나리오어느 한 통신 사업자의 네트워크 관리자가 신규 가입자가 가입할 때 신청한 서비스 내역을 검토한 후 알맞은 응용 프로그램을 가입자 단말기에게 설치하도록 장치 관리 서버에게 요청한다.장치 관리 서버는 Connectionless WAP Push방식으로 DM Notification메시지를 가입자 장치로 전송한다.DM Notification 메시지는 장치 관리 서버의 전자 서명이 포함된 메시지이며 보통 장치 관리 클라이언트에 의해 처리되고 장치 관리 클라이언트가 서버에게 장치 관리 세션을 요청하도록 한다. 장치 관리 세션이 만들어 지면 장치 관리 서버는 응용 프로그램을 장치 관리 명령을 통해 주어진 응용 프로그램을 장치로 다운로드 한 뒤 그 응용 프로그램이 정상적으로 동작할 수 있도록 사용자 계정, 비밀 번호 등 서비스에 필요한 설정값을 구성하여 사용자가 요구한 대로 동작할 수 있도록 한다.마지막으로, 장치 관리 서버는 역시 장치 관리 명령을 통해 장치의 화면에 앞서 일어난 과정에 대해 설명하는 문구를 나타내어 사용자에게 알려 준다. 사용자는 설치된 응용 프로그램을 이용하여 서비스를 이용한다. OMA-DM의 ACLOMA Device Management 프로토콜은 하나의 장치에 대해 여러 장치 관리 서버가 접근할 수 있도록 설계되었다. 예를 들어, 회사 업무용 소프트웨어를 설치한 단말기의 경우 그 회사의 장치 관리 서버를 구축하여 그 소프트웨어에 대한 사용자명, 비밀 번호, 게이트웨이 등 을 설정하여 회사 내 기밀 자원에 접근할 수 있도록 설정할 수 있으며, 다른 일반 서비스 즉, MMS 서비스 등의 관리를 위해선 외부 통신 사업자의 장치 관리 서버를 통해 장치에 접근하도록 하는 경우를 생각할 수 있다. 이를 위해 OMA Device management 프로토콜은 장치 내부에 존재하는 객체에 대한 관리 권한을 Access Control List(ACL)를 통해 제한하고 있다. ACL를 통해 클라이언트는 어떤 장치 관리 서버가 요청한 장치 관리 명령에 대한 수행 여부를 판단할 수 있다. 이러한 판단 기준은 특정 서버의 특정 장치 관리 명령에 대해 명시할 수가 있다. 참고자료OMA 표준화 동향 - OMA Device Management [LG전자 이동통신기술연구소 김 태 현]TTA저널 제 96호","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"IOT","slug":"CS/IOT","permalink":"http://KKimSangHeon.github.io/categories/CS/IOT/"}],"tags":[]},{"title":"oneM2M","slug":"onem2m","date":"2019-02-07T11:46:50.000Z","updated":"2019-02-09T06:51:54.249Z","comments":true,"path":"2019/02/07/onem2m/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/07/onem2m/","excerpt":"","text":"M2M(Machine to Machine) 사물 또는 지능화된 기기들이 사람을 대신해 통신의 양쪽 모두를 맡고 있는 기술을 의미 센서 등을 통해 전달, 수집, 가공된 위치, 시각, 날씨 등의 데이터를 다른 장비나 기기 등에 전달하기 위한 통신을 의미 M2M은 개별 장치들에 대한 연결성을 제공하는 것이 기본 목적 oneM2M기구 설명1.에너지, 교통, 국방, 공공서비스 등 산업별로 종속적이고 폐쇄적으로 운영되는, 파편화된 서비스 플랫폼 개발 구조를 벗어나 응용서비스 인프라(플랫폼) 환경을 통합하고 공유하기위한 사물인터넷 공동서비스 플랫폼 개발을 위해 발족된 사실상 표준화 단체임 2.oneM2M의 기술 워킹그룹(6개)은 요구사항을 다루는 Requirement(WG1), 시스템 구조를 다루는 Architecture(WG2), 프로토콜과 관련한 Protocols(WG3), 보안관련 Security(WG4), 장치관리 및 추상화, 시멘틱과 관련된 Management, Abstraction and Semantics(WG5), 테스킹 규격을 위한 Test(WG6)로 구성되어 있음 oneM2M Release 115.01월 Minimum Deployeable Solution을 모토로 Release 1 규격을 공개하여 다양한 IoT 서비스에서 필요한 공통 기능을 oneM2M 플랫폼의 RESTful API로 지원 oneM2M 플랫폼이 제공하는 기능을 공통 서비스 기능(CSF, Common Services Function) 으로 정의함 공통 기능은 사물인터넷 서비스 애플리케이션에서 자주 사용되는 기능을 정의한 것으로 데이터 저장/공유, 장치 관리, 그룹 관리, 구독/통지(Subscription/Notification), 위치 정보, 과금 등의 기능을 포함하며, 보안 기능은 기본적인 인증, 접근 제어 등의 기능을 제공 또한, oneM2M 코어 프로토콜 메시지(Primitive)는 CoAP, HTTP 및 MQTT 프로토콜 메시지를 통해 전송됨. oneM2M의 코어 프로토콜은 향후 추가 프로토콜 바인딩(Binding)을 지원할 수 있도록 특정 메시지 프로토콜에 종속성을 가지지 않도록 개발되었음 oneM2M Release 216.07월 다양한 IoT 기술과의 연동성을 강조하여 Release 2 규격을 공개하여 OCF, AllJoyn, LwM2M, 3GPP Rel-13 등의 기술과의 연동성을 제공하고 가전 기기에 대한 정보 모델 표준을 제공 및 다양한 추가 기능을 제공 다양한 인더스트리 사물인터넷 플랫폼 및 네트워크 연동이 주 목적 사물인터넷 연동으로는 AllJoyn, OCF(Open Connectivity Foundation) 및 Lightweight M2M 기술과의 연동 규격을 제공함 네트워크 연동으로는 3GPP Rel-13 네트워크와 연동을 위한 트래픽 패턴 설정(Traffic Pattern Configuration) 기능을 정의하고 있으며 릴리즈 3에 모니터링 등의 연동 기능을 추가하기 위한 기술 보고서를 작업을 지속하고 있음 높은 디바이스 및 애플리케이션의 호환성을 보장하기 위해 우선적으로 가전 디바이스에 대한 데이터 모델을 정의함 릴리즈 1에서는 가전 제어 및 센싱 정보를 교환하기 위해 사전에 애플리케이션 간 정의한 데이터 모델을 container 및 contentInstance 자원 타입을 이용했다. 이에 비해 릴리즈 2에서는 oneM2M 플랫폼을 이용하는 모든 애플리케이션이 표준에 정의된 가전 디바이스 데이터 모델을 사용함으로써 가전 제조사 및 애플리케이션 개발자 간에 별도의 데이터 모델을 정의하는 번거로움을 없애고 제품과 애플리케이션 간의 호환성을 보장한다. 프로토콜 바인딩은 동시 송수신(Full-duplex)을 지원하는 WebSocket이 추가됨 oneM2M Release 3Release 3 표준은 기존 연동, 시맨틱, 보안 등의 기능을 향상하고, oneM2M 시장 확대를 위한 개발자 가이드, Product Profile을 추가 개발 1.3GPP Rel-13/14 네트워크 연동 UE Reachability Schedule, Location Update, Roaming, Schedule sync 지원 등 2.Interworking 추가된 Proximal IoT 연동 규격(TS-0033)에서 oneM2M 시스템이 아닌 디바이스나 서비스를 연동하기 위한 범용적인 연동 기술을 정의 OSGi, Modbud, DDS, OPC-UA에 대한 연동 기술 스터디 진행 3.Transaction 지원 어플리케이션의 다중 리소스 엑세스(Create, Retrieve,Update, Delete)에 대한 oneM2M 플랫폼의 트랜잭션 관리(Execute, Commit, Abort, Lock) 기능 제공 4.Semantics 지원 기능 향상 시맨틱 매쉬업, 트리플(Triple) 쿼리, 트리플 데이터 검증 기능 추가 5.멀티캐스트 기반 그룹 관리 기존 그룹 관리 기능을 IP 멀티캐스트 및 3GPP MBMS (Multimedia Broadcast Multicast Service)를 활용할 수 있도록 기능 확장 6.기타 추가 기능 멀티미디어 스트리밍, 다중 리소스 구독(Cross-resource Subscription),AE Reachability Management, Distributed Authorization 등 개발자 가이드 추가 HTTP, CoAP, MQTT 프로토콜 바인딩, Long polling, device managment, semantics 기능 구현 개발자 가이드 작성 완료 보안 기능 개발자 가이드 작성 중 7.Product Profile oneM2M 플랫폼 기능을 요약한 Feature Catalogue (TS-0031) 과 연계하여 oneM2M 제품 개발 시 구현할 기능을 프로파일 화로 정의하고 해당 기능들은 시험인증 규격에 반영됨 oneM2M 공통 플랫폼 기능 모델 Application Entity (AE) : M2M 서비스를 제공하기 위한 어플리케이션 기능 로직을 포함하는 논리적인 엔티티를 의미하며 각각의 AE는 유일한 AE 식별자인 AE-ID로 구별된다. AE에 대한 예로서는 관제 시스템, 스마트그리드 시스템, 헬스케어 시스템을 위한 어플리케이션 등이 고려되어질 수 있다. Common Service Entity (CSE) : oneM2M 서비스 플랫폼에서 공통적으로 제공되어야 하는 공통 서비스 기능을 제공하는 부분으로서, oneM2M 에서 정의한 CSE에는 총 12개의 Common Service Function (CSF) 공통 서비스 기능을 포함하고 있다. CSF는 CSE에서 제공되어져야 하는 기능들 중 비슷한 기능들을 그룹화 한 논리적인 그룹으로, 각각의 CSF 들은 이후에 설명되어질 리소스를 통해서 외부에 노출되어 서비스를 제공할 수 있다. 해당 CSE는 AE를 구별하는 방식과 마찬가지로 CSE의 식별자인 CSE-ID를 통해서 유일하게 식별 가능하다. Network Service Entity (NSE) : CSE가 위치한 미들웨어의 하부 네트워크 서비스에 대한 추상화 영역으로 CSE에게 네트워크 서비스를 제공한다. 제공 가능한 네트워크 서비스의 예로서는 디바이스 관리, 위치관리, 3GPP 이동통신망에 연결되어있는 IoT 디바이스 트리거링 서비스 등이며 해당 서비스를 위해서는 네트워크 서비스가 관여되어진다. Mca (M2M Communication with AE) 참조 포인트 : AE 와 CSE 간의 포인트를 가리키며, 해당 AE가 CSE에서 제공하는 공통 서비스 기능을 이용하기 위한 API 의 연결 포인트이고, CSE 와 AE간의 통신을 위한 연결 포인트이다. Mcc (M2M Communication with CSE) 참조 포인트 : 두 개의 CSE간의 포인트를 가리키며, CSE와 다른 CSE간의 서비스 공개 및 통신을 가능하게 하는 연결 포인트이다. Mcn (M2M Communication with NSE) 참조 포인트 :CSE와 NSE간의 포인트를 가리키며, CSE가 NSE에서 제공되는 네트워크 서비스 기능을 이용할 수 있는 연결 포인트이면서 네트워크 망으로의 데이터 전달 연결 포인트이다. Mcc’(M2M Commmunication with CSE of different M2M Service Provider) 참조 포인트 : 서로 다른 서비스 프로바이더에 종속적인 CSE간의 포인트를 가리키며, 서비스 프로바이더 간 CSE사이의 서비스 공개 및 통신을 지원하는 연결 포인트이다. oneM2M 노드 구성모델 아키텍처 oneM2M의 노드 구성모델은 다음과 같다. Infrastructure Node (IN) : 인프라스트럭쳐 도메인에 위치하고 있는 IN-CSE를 포함하는 서버단에 위치하는 기기를 의미한다. 해당 IN은 서비스 프로바이더 당 한 개의 IN을 지원하는 것으로 정의되며 IN은 한 개의 CSE로만 구성이 되거나 1개 이상의 AE를 포함하는 형태로 구성되어질 수 있다. 논리적 기기인 IN에 매칭되는 물리적 기기로는 서버를 예로 들 수 있다. IN은 Mcc 참조 포인트를 통해서 한 개 이상의 MN과 한 개 이상의 ASN과 연동되며 Mca 참조 포인트를 통해서 한 개 이상의 ADN과 연동될 수 있다. Mcc’을 통한 연동은 다른 서비스 프로바이더 영역에 위치한 IN노드와 연동된다. Middle Node (MN) : 필드 도메인에 위치한 MN-CSE를 포함하는 논리적 기기로 일반적으로 여러 센서나 엑추에이터들이 연결되는 게이트웨이가 이에 해당한다고 보면 된다. MN은 한 개의 CSE로 구성이 되거나, 하나의 CSE에 1개 이상의 AE 를 포함하는 형태로 구성되어질 수 있다. MN은 Mcc참조 포인트를 통해서 적어도 하나의 IN 또는 MN과 연동되며 Mcc 참조 포인트를 통해서 ASN과 연동 및 Mca 참조 포인트를 통한 ADN과 연동될 수 있다. Application Service Node (ASN) : 필드 도메인에 위치한 ASN-CSE와 ASN-AE를 포함하고 있는 논리적 기기이다. 해당 ASN은 한 개의 CSE와 1개 이상의 AE를 포함하는 형태로 구성되며 논리적 ASN에 매칭되는 물리적 기기로는 M2M 디바이스를 예로 들 수 있다. ASN 은 Mcc 참조 포인트를 통해서 한 개의 MN 또는 한 개의 IN에 연동된다. Application Dedicated Node (ADN) : 필드 도메인에 위치한 ADN-AE를 포함하고 CSE를 포함하지 않는 논리적 기기이다. 즉 해당 ADN는 CSE가 없고, 1개 이상의 AE를 포함한다. 논리적 ADN에 매칭되는 물리적 기기로는 센서 및 액츄에이터와 같은 자원제약적인 M2M 디바이스를 예로 들 수 있다. ADN은 Mca 참조 포인트를 통해서 MN 또는 IN과 연동되는 구조를 갖는다. oneM2M 공통 서비스 기능oneM2M 공통 서비스 플랫폼 개발과 관련하여 아키텍처 표준 문서에서 다루고 있는 부분은 Common Service Entity (CSE)에 대한 기능들을 표준화하는 것이다. 그리고 해당 기능들은 oneM2M이 지향하고 있는 리소스 기반 아키텍처 구조를 기반으로 각각의 리소스 타입으로 해당 공통 서비스 기능들이 표현되고 있다. oneM2M 표준화 작업 진행방식은 전체적으로 유스케이스 및 요구사항을 다루고, 이를 통해 필요한 기능들을 도출해 내어 시스템 아키텍처를 디자인하고, 상세 프로토콜을 개발하는 3GPP 표준화 방식에서 취한 Stage 기반의 접근 방식으로 표준 개발을 진행하였다. 각각의 기능은 리소스 타입으로 표현되고 Mcc, Mca, Mcn 참조 포인트를 통해서 서비스가 제공된다. Common Service Function (CSF) : 기능설명Registration (REG) : REG CSF는 AE와 CSE 또는 CSE와 CSE간의 등록을 담당하며, 이러한 등록 관계를 통해서 oneM2M 엔티티간의 접속 및 접근이 가능하며 oneM2M 엔티티간의 데이터 전달을 통한 oneM2M 서비스 구성이 가능해진다Discovery (DIS) : DIS CSF는 기본적으로 oneM2M 리소스 및 어트리뷰트에 담긴 서비스 정보에 대한 검색 기능을 제공한다. 기본적으로 텍스트 기반의 검색이 제공 되어지며, 그 이외에도 특징 기반의 검색 등이 제공되어질 수 있다.Security (SEC) : SEC CSF는 oneM2M 공통 서비스 플랫폼의 공통 기능으로서 접근권한, 키 관리와 같은 보안 메커니즘을 제공하는 기능을 담당한다.Group Management (GMG) : GMG CSF는 리소스들을 그룹으로 관리할 수 있도록 하는 기능을 담당한다. 이를 통해, 비슷한 역할을 하거나, 공동으로 관리되어져야 하는 리소스들을 그룹으로 관리할 수 있다.Data Management &amp; Repository (DMR) :DMR CSF는 기본적으로 데이터 저장소의 기능을 제공하는 것이다. 또한 데이터의 타입, 시맨틱 정보, 시간, 위치와 관련한 데이터의 분류 및 데이터 포맷의 변경 및 데이터 처리 기능을 제공한다.Subscription &amp; Notification (SUB) : SUB CSF는 리소스에 대한 구독정보를 관리하고 리소스 및 어트리뷰트에 대한 업데이트 발생, Child 리소스의 생성, 삭제 등 해당 리소스에 대한 트랙킹 및 관련된 변화 정보를 통지하는 역할을 담당한다.Device Management (DMG) : DMG CSF는 디바이스 관리 기능을 제공하는 공통 서비스 기능이다. 디바이스 관리라고 함은 디바이스에 설치된 펌웨어에 대한 관리, 디바이스 하드웨어 리소스 관리, 디바이스 동작 설정 관리, 진단을 포함한다.Application &amp; Service Management (ASM) : ASM CSF는 ADN, ASN, MN, IN에 위치한 AE와 CSE 소프트웨어에 대한 관리 기능을 담당한다. 해당 기능은 AE와 CSE의 재설치, 업데이트, 고장탐지, 설정에 관한 기능을 제공한다.Communication Management &amp; Delivery Handling (CMDH) : CSE간, AE와 CSE간, 데이터 전달 시에 NSE를 통한 데이터 전달 서비스를 제공하는 기능을 담당한다. CMDH CSF는 메시지 전달을 위해서 언제 보낼건지, 어떤 네트워크 연결을 활용하여 보낼지를 결정한다.Network Service Exposure, Service Execution &amp; Triggering (NSSE) :NSSE CSF는 기저 네트워크와 관련된 통신을 관리하며 Mcn 참조 포인트를 통한 네트워크 접근 서비스를 제공한다.Location (LOC): LOC CSF는 AE의 위치 정보 요청에 대해서 ASN, MN과 관련된 위치정보를 획득하기 위한 방법을 제공하는 CSF이다.Service Charging &amp; Accounting (SCA) : SCA CSF는 oneM2M 공통 서비스 플랫폼을 통해서 제공되는 서비스에 대한 과금 체계 및 방법에 대한 기능을 제공한다. oneM2M의 장치관리 표준oneM2M의 장치관리 표준은 ETSI TC M2M 규약에서 정한 BBF TR-069와 OMA(Open Mobile Alli-ance)-DM(Device Management) 표준을 그대로 승계하였고, 더 나아가 제약 많은 IoT 장치를 위한 OMA LWM2M까지 포함한다. OMA-DM, TR-069는 다음 포스트에서 다룬다 나만의 요약oneM2M에서는 CSE가 핵심이다.별첨LwM2M(Lightweight M2M)LwM2M(Lightweight M2M)은 M2M 또는 IoT 장치 관리를 위하여 LwM2M 서버와 LwM2M 장치에 있는 LwM2M 클라이언트 간의 응용 프로그램 계층 통신 프로토콜을 정의함. 소형기기를 포함하여 다양한 사물인터넷 기기를 지원하기 위한 기기 관리 표준임.1)센서 또는 셀룰러 네트워크를 통한 장치 관리 기능 제공2)네트워크에서 장치로 서비스 데이터 전송3)대부분의 모든 응용 프로그램의 요구사항을 충족하도록 확장 을 위하여 설계됨. 자원이 제한된 LwM2M 디바이스를 감안하여 효율적인 리소스 데이터 모델을 기반으로 가볍고 간결한 프로토콜로 IETF CoAP을 사용하고 있음 REST(Representational State Transfer)웹 상의 자료를 HTTP위에서 별도의 전송 계층 없이 전송하기 위한 아주 간단한 인터페이스이다. URI는 자원을 표현하는 데에 집중하고 행위에 대한 정의는 HTTP METHOD를 통해 하는 것이 REST한 API를 설계하는 중심 규칙이다. CoAP Internet에서 IoT device처럼 제한된 computing 성능을 갖는 device들의 통신을 위해 IETF의 CoRE(Constrained RESTful Environment) working-group에서 표준화한 protocol 신뢰성 있는 동기 수송 방식의 TCP와 그 위의 HTTP는 많은 resource제약을 가진 IoT 환경에서는 적합하지 않아 비동기 수송 방식의 UDP상에서 UDP의 단점을 보완하는 개념을 포함한 통신 protocol OCF사물인터넷 구현 시 REST 구조 기반으로 경량형 CoAP 프로토콜로 사물인터넷 장치들을 연결하고 장치에 존재하는 자원들을 상호제어 할 수 있게 하는 표준 플랫폼 기술 OCF 아키텍처는 클라이언트-서버의 방식으로 RESTful 아키텍처를 기반으로 리소스를 관리하는 모델 사물인터넷 디바이스의 제한된 성능을 고려하여 CoAP(Constrained Application Protocol)을 활용하여 경량 기기에서의 동작도 고려함 MQTTMQTT(Message Queue for Telemetry Transport)는 M2M 또는 IoT 기기와 G/W의 연동을 위해 정의된 프로토콜입니다. 경량 프로토콜로 저전력 장비에서도 운용 가능하며 network bandwidth가 작은 곳에서도 충분히 운용 가능하도록 설계된 프로토콜입니다. 참고자료http://www.iotocean.org/common/download.asp?pach=/upload/Board/&amp;file=6VXFR20174271377.pdf(IoT 표준/기술 동향 2017-9호) 2017-9호_oneM2M Release 3 표준http://www.iotforum.kr/board1/read.asp?bdNum=101&amp;sc_field=&amp;sc_word=&amp;bdCode=13350http://woowabros.github.io/experience/2017/08/11/ost_mqtt_broker.html","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"IOT","slug":"CS/IOT","permalink":"http://KKimSangHeon.github.io/categories/CS/IOT/"}],"tags":[]},{"title":"1.1 테이블과 인덱스의 분리","slug":"db","date":"2019-02-07T11:29:44.000Z","updated":"2019-02-07T11:31:59.183Z","comments":true,"path":"2019/02/07/db/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/07/db/","excerpt":"","text":"1.1 테이블과 인덱스의 분리테이블과 인덱스가 분리되어 있는것은 관계형 DB의 일반적인 형태이다.과거엔 키와 데이터가 붙어있었다면 현재는 키를 통해 데이터를 한번 더 찾아가야한다. 1.1.1 분리형 테이블의 구조 7p활용가능한 블록을 Free List에 기록했다가 데이터를 저장할 때 제공한다.로우가 끊어지게 될 경우 Free Space를 활용하여 재배치를 하도록 한다. 테이블스페이스 : 논리적인 저장공간을 의미하며 이는 물리적인 데이터 파일로 구성된다.세그먼트 : 테이블 스페이스를 용도별로 나눈것오브젝트 : 세그먼트에 들어올 수 있는것.단위 오브젝트 : 테이블이나 인덱스의 파티션들 파티션된 테이블의 각 파티션이 서로 다른 테이블 스페이스에 존재할 수 있다.ROW ID : 해당값을 통해 물리적인 저장 위치를 찾아낼 수 있다. 이는 논리적인 값으로서 블록 내에서 로우의 위치가 이동하더라도 변하지 않는다.로우의 이주(Migration) : 블록 밖으로 로우가 이동할 경우 이전 블록에 옮긴 주소를 넣어놓는 방법이 있는데 이에 따른 오버헤드를 감수해야한다. 이를 로우의 이주라 한다.체인 : 로우의 길이가 블록을 넘을 때 블록을 연결해서 저장해야하는데 이를 체인이 발생했다라고 한다. 1.1.2 클러스터링 팩터클러스터링 팩터 : 인덱스 로우의 순서와 테이블에 저장되어있는 데이터 로우의 위치가 얼마나 비슷한 순서로 저장되어 있느냐에 대한 정도를 의미.클러스터링 팩터는 액세스 효율에 직접적인 영향 : 클러스터링 팩터가 좋은 인덱스로 액세스를 하면 적은 블록을 액세스 하게 되므로클러스터링 팩터를 향상시키는 방법 임의의 위치에 저장하는 방식. 주기적으로 테이블 재생성. 1.1.3 분리형 테이블의 액세스 영향 요소가) 넓은 범위의 액세스 처리에 대한 대처방안이는 임의의 영역에 데이터가 저장되는 형태로서 액세스할 경우 대가가 크다. 소형테이블의 경우 : 임의로 저장해도 액세스 할 때도 큰 영향이 없다. 중형테이블의 경우 : 어느컬럼에 맞추어 저장할것인지 결정 대형테이블의 경우 : 단순 저장형(ex: log) : 신속한 저장이 요구되므로 분리형이 가장 적절하다. 또한 데이터의 양이 많으므로 파티션과 같은 조치 필요 주로 랜덤액세스이며 다양하지 않은 액세스 형태(ex: 고객): 분리형 구조가 적당. 한번에 대량의 급격히 들어오는 경우가 드물고 범위처리를 자주 하지도 않음. 데이터가 지속적으로 증가 및 다양하 형태의 액세스(ex: 매출) : 파티션을 진행하고 인덱스를 전략적으로 구성하고 SQL 실행계획 최적화. 나) 클러스터링 팩터 향상 전략주기적으로 테이블을 재성성시켜주는 방법이 최고! (이때는 관련 인덱스를 모두 제거하거나 비활성화 할것- 저장속도 저하유발 및 인덱스 분할로 인한 저장밀도가 나빠짐)이를 위해 가장 유리한 형태로 저장되도록 하고 자주 범위처리를 하는 컬럼들로 정렬하자!","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Data Base","slug":"CS/Data-Base","permalink":"http://KKimSangHeon.github.io/categories/CS/Data-Base/"}],"tags":[]},{"title":"hexo command not found 에러 발생시","slug":"hexoerr","date":"2019-01-21T15:12:31.000Z","updated":"2019-01-21T15:14:38.104Z","comments":true,"path":"2019/01/22/hexoerr/","link":"","permalink":"http://KKimSangHeon.github.io/2019/01/22/hexoerr/","excerpt":"","text":"npm이 global로 설치한 것을 찾지 못할 때 발생한다. 환경변수에 아래의 경로를 추가해 주도록 하자 C:\\Users\\SangHeon\\AppData\\Roaming\\npm","categories":[],"tags":[]},{"title":"StringBuffer, StringBuilder","slug":"java4","date":"2018-11-20T00:37:37.000Z","updated":"2018-11-20T00:43:28.993Z","comments":true,"path":"2018/11/20/java4/","link":"","permalink":"http://KKimSangHeon.github.io/2018/11/20/java4/","excerpt":"","text":"String 클래스String은 내부의 문자열을 수정할 수 없다. StringBuffer()메소드는 내부의 문자를 대치하는 것이 아니라, 대치된 새로운 문자열을 리턴한다.문자열을 결합하는 + 연산을 많이 사용하면 할수록 그만큼 String 객체의 수가 ㅇ늘어나기 때문에 프로그램 성능을 느리게 한다. 문자열을 변경하는 작업이 많을 경우 StringBuffer, StringBuilder클래스를 사용하는것이 좋다. 이 두 클래스는 내부 버퍼에 문자열을 저장해두고 그 안에서 추가, 수정, 삭제 작업을 할 수 있도록 설계되어 있기 때문이다.StringBuffer는 멀티 스레드 환경에서 사용할 수 있도록 동기화가 적용되어 있어 스레드에 안전하지만 StringBuilder는 단일 스레드 환경에서만 사용하도록 설계되어 있다.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"리플렉션","slug":"java3","date":"2018-11-20T00:37:34.000Z","updated":"2018-11-20T00:43:01.888Z","comments":true,"path":"2018/11/20/java3/","link":"","permalink":"http://KKimSangHeon.github.io/2018/11/20/java3/","excerpt":"","text":"리플렉션java.lang.reflect 패키지에 소속되어있는 메소드들로 getDeclaredConstructors(), getDeclaredFields(), getDeclaredMethods()가 있다.getDeclaredFields(), getDeclaredMethods()는 클래스에 선언된 멤버만 가져오고 상속된 멤버는 가져오지 않는다. 상속된 멤버도 얻고 싶다면 getFields(), getMethods()를 이용해야 한다.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"익명클래스","slug":"java2","date":"2018-11-20T00:37:31.000Z","updated":"2018-11-20T00:42:29.017Z","comments":true,"path":"2018/11/20/java2/","link":"","permalink":"http://KKimSangHeon.github.io/2018/11/20/java2/","excerpt":"","text":"익명클래스익명객체는 이름이 없는 객체를 말한다. 이는 단독으로 생성할 수 없고 클래스를 상속하거나 인터페이스를 구현해야만 생성할 수 있다. UI 이벤트 처리 객체나 스레드 객체를 간편하게 생성할 목적으로 많이 활용된다.익명클래스는 생성자를 선언할 수 없다는 특징이 있으며 클래스가 재사용되지 않을 때 사용하는것이 좋다.익명 자식 객체에 새롭게 정의된 필드와 메소드는 익명자식 객체 내부에서만 사용되고, 외부에서는 필드와 메소드에 접근할 수 없다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Person &#123; void wake( ) &#123; System.out.println(\"7시 인남\"); &#125;&#125;public class Annoymous &#123; //필드 초기값으로 대입 Person field = new Person() &#123; void work( ) &#123; System.out.println(\"출근~\"); &#125; @Override void wake( ) &#123; System.out.println(\"6시 인남\"); work( ); &#125; &#125;; void method1( ) &#123; //로컬 변수값으로 대입 Person localVar = new Person( ) &#123; void walk( ) &#123; System.out.println(\"산책 고고\"); &#125; @Override void wake( ) &#123; System.out.println(\"7시에 인남\"); walk( ); &#125; &#125;; //로컬변수 사용 localVar.wake( ); &#125; void method2(Person person) &#123; person.wake(); &#125;&#125; 위에 정의한 클래스를 활용해보자 123456789101112131415161718192021222324252627282930public class AnonymousExample &#123; public static void main(String[] args) &#123; Anoymous anony = new Anonymous(); //익명객체 필드 사용 anony.field.wake(); //anony.filed.walk(); 는 에러가 발생한다. 이유가 뭘까? //익명자식 객체는 부모 타입 변수에 대입되므로 부모타입에 선언된 것만 사용할 수 있기 때문인다. //익명 객체 로컬변수 사용 anony.method1(); //익명 객체 매개값 사용 anony.method2( new Person( ) &#123; void study( ) &#123; System.out.println(\"공부~\"); &#125; @Override void wake( ) &#123; System.out.println(\"8시에인남\"); study( ); &#125; &#125; ); &#125;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"중첩클래스의 접근제한","slug":"java1","date":"2018-11-20T00:37:20.000Z","updated":"2018-11-20T00:48:18.343Z","comments":true,"path":"2018/11/20/java1/","link":"","permalink":"http://KKimSangHeon.github.io/2018/11/20/java1/","excerpt":"","text":"중첩클래스의 접근 제한1234567891011121314151617181920212223242526272829public class A &#123; int field1; void method1( ) &#123; &#125; static int field2; static void method2( ) &#123; &#125; class B &#123; void method ( ) &#123; field1 = 10; method1( ); field2 = 10; method2( ); &#125; &#125; static class C &#123; void method( ) &#123; //filed1 = 10; //접근 불가 //method1( ); //접근 불가 field2 = 10; method2( ); &#125; &#125;&#125; 로컬클래스(메소드 안에 클래스 생성)에서 사용 가능한 것은 final로 선언된 매개 변수와 로컬 변수뿐이다. 자바 7 이전에는 final이 붙어있지 않은 매개변수 혹은 변수를 로컬 클래스안에서 사용하고자 하면 컴파일 에러가 발생하였다. 하지만 자바 8부터는 컴파일 에러가 발생하지 않는다. 즉 내부적으로는 final의 특성(값을 변경할 수 없는)을 갖으며 final의 유무로 로컬클래스 내 복사 위치가 결정된다.(복사위치에 대해선 아래 설명)다음은 7,8버전의 final 유무에 따른 접근관련 이슈이다.123456789101112131415161718192021222324252627public class Outter &#123; //자바7 이전 public void method1(final int arg) &#123; final int localVariable = 1; //arg = 100; //불가능 //localVariable = 100 //불가능 class Inner &#123; public void method( ) &#123; int result = arg + localVariable; &#125; &#125; &#125; //자바8 이후 public void method2(int arg) &#123; int localVariable = 1; //arg = 100; //불가능 //localVariable = 100 //불가능 class Inner &#123; public void method( ) &#123; int result = arg + localVariable; &#125; &#125; &#125;&#125; 위의 코드와 같이 final이 없더라도 값 변경은 허용하지 않는다는것이다. ※ final의 유무로 로컬클래스 내 복사 위치가 결정된다?먼저 다음과 같은 코드가 있다고 가정하자.123456789101112void outMethod(final int arg1, int arg2) &#123; final int var1 = 1; int var2 = 2; class LocalClass &#123; void method() &#123; int result = arg1+arg2+var1+var2; &#125; &#125;&#125;위의 LocalClass에 복사된 변수를 보면 다음과 같다.1234567891011class LocalClass &#123; int arg2 = 매개값; //final이 붙지 않아 필드로 복사 int var2 = 2; //final이 붙지 않아 필드로 복사 void method( ) &#123; int arg1 = 매개값; //final이 붙은것은 로컬 변수로 복사 int var1 = 1; //final이 붙은것은 로컬 변수로 복사 int result = arg1 + arg2+ var1+ var2; &#125;&#125;복사된 영역을 신경쓸 필요는 없으나 알고 있는것이 좋겠다! 중첩클래스에서 바깥 클래스 참조 얻기중첩 클래스 내부에서 this키워드를 사용하면 어떻게 될까? 말 그대로 중첩클래스가 this가 되게된다. 그렇다면 바깥 클래스를 가르키기 위해선 어떻게 해야될까.정답은 바깥클래스.this 를 활용하면 된다. 아래를 참고하자 1234567891011121314151617181920212223242526272829303132public class Outter &#123; String field = \"Outter-filed\"; void method( ) &#123; System.out.println(\"Outter-method\"); &#125; class Nested &#123; String field = \"Nested-field\"; void method() &#123; System.out.println(\"Nested-method\"); &#125; &#125; void print( ) &#123; System.out.println(this.field); //중첩객체 참조 this.method( ); //중첩객체 참조 System.out.println(Outter.this.field); //바깥객체 참조 Outter.this.method( ); //바깥객체 참조 &#125; &#125;&#125;public class OutterExample &#123; public static void main(String[] args) &#123; Outter outter = new Outter( ); outter.Nested nested = outter.new Nested( ); nested.print( ); &#125;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"비트 빅데이터 전문가 양성과정 면접","slug":"interview5","date":"2018-10-22T03:36:14.000Z","updated":"2018-10-24T00:07:41.658Z","comments":true,"path":"2018/10/22/interview5/","link":"","permalink":"http://KKimSangHeon.github.io/2018/10/22/interview5/","excerpt":"","text":"시기2017년 6월 국비지원 교육을 받기위해 필기시험, 면접을 진행한다. 보통 다른과정은 면접이 없지만 전문가 과정이라 회장님과의 면접이 있다고 들었다. 필기시험자바 필기시험을 진행하였으며 난이도는 쉬운편이었다. 오버라이딩, 인터페이스 수준정도의 개념까지만 잘 이해하고 있다면 쉽게 풀 수 있다. 1차면접비트컴퓨터 회장님과 지원자들과 면접을 진행한다.많은 지원자를 대상으로 면접을 진행하기 때문에 자신이 진행했던 프로젝트가 뭐가있는지 물어보고 기술력을 판단하신다. 당락은 그 자리에서 결정되는데 합격률이 생각보다 많이 낮았던 것이 인상깊었다. 후기합격하여 국비지원을 받으며 교육을 수강할 수 있었다. 강사님께서 정말 고수라 많은것을 배울 수 있었고 실무에서 인턴경험 이상으로 값진 경험이었다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"면접","slug":"Etc/면접","permalink":"http://KKimSangHeon.github.io/categories/Etc/면접/"}],"tags":[{"name":"면접","slug":"면접","permalink":"http://KKimSangHeon.github.io/tags/면접/"},{"name":"비트","slug":"비트","permalink":"http://KKimSangHeon.github.io/tags/비트/"},{"name":"국비지원","slug":"국비지원","permalink":"http://KKimSangHeon.github.io/tags/국비지원/"}]},{"title":"알지피코리아(요기요,배달통) 면접","slug":"interview","date":"2018-10-22T03:36:14.000Z","updated":"2018-10-23T23:17:48.376Z","comments":true,"path":"2018/10/22/interview/","link":"","permalink":"http://KKimSangHeon.github.io/2018/10/22/interview/","excerpt":"","text":"시기2018년 7월 사실 서류자체는 무난하게 복붙이 가능할 정도로 간단했다. 자소서를 작성하면서 정말 감사했던 기억이 난다. 1차면접편안한 분위기속에서 면접관 두분과 면접을 진행했다. 난이도가 높은 면접은 아니었던걸로 기억한다.질문내용은 다음과 같다. 인터페이스 추상클래스 차이가장인상깊었던 문제개발하다 막히면 어떻게하나비동기로 처리하는 방법jap hibernate 차이 소감평범한 회사였고 자유로운 분위기를 느낄 수 있었다. 면접 후 신세계 상품권과 요기요 할인쿠폰을 잘 이용했다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"면접","slug":"Etc/면접","permalink":"http://KKimSangHeon.github.io/categories/Etc/면접/"}],"tags":[{"name":"면접","slug":"면접","permalink":"http://KKimSangHeon.github.io/tags/면접/"},{"name":"알지피코리아","slug":"알지피코리아","permalink":"http://KKimSangHeon.github.io/tags/알지피코리아/"},{"name":"요기요 배달통","slug":"요기요-배달통","permalink":"http://KKimSangHeon.github.io/tags/요기요-배달통/"}]},{"title":"KT SW개발직무 면접","slug":"interview4","date":"2018-10-22T03:36:14.000Z","updated":"2018-10-23T23:37:44.676Z","comments":true,"path":"2018/10/22/interview4/","link":"","permalink":"http://KKimSangHeon.github.io/2018/10/22/interview4/","excerpt":"","text":"시기2018년 8월 ~ 2018년 10월 채용공고 필기시험적성이 아닌 전공, 인성검사로서 진성여중에서 시험을 치뤘었다. 정말 많은사람들이 왔었고 문제의 난이도는 평소 CS에 대한 공부만 충실했다면 무난한 난이도였다. 1차면접면접관 3분과 지원자 1명의 면접형태로서 면접 전 간단한 코딩 테스트를 본다. 푼 문제를 복사하여 면접관분들께 설명드리면서 면접이 시작된다. 이후엔 자기소개서 위주의 프로젝트, 경력관련 질문들이 주를 이뤘다. 여기서 자신감을 갖고 대답했던것이 좋게 작용했던것 같다. 2차면접마찬가지로 면접관 3분과 면접을 본다. 정말 많이 떨렸지만 충분히 준비하고 또 준비했기에 떨지않고 잘 대답할 수 있었다. 주로 경력에 관한 질문이 많았으며 인성질문도 있었다. 건강검진건강검진 이틀전 술을 마신탓에 약간 걱정은 됐으나 다행히 별 탈 없이 통과할 수 있었다. 합격두달간의 긴 여정을 잘 마무리 짓고 최종합격할 수 있었다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"면접","slug":"Etc/면접","permalink":"http://KKimSangHeon.github.io/categories/Etc/면접/"}],"tags":[{"name":"면접","slug":"면접","permalink":"http://KKimSangHeon.github.io/tags/면접/"},{"name":"KT","slug":"KT","permalink":"http://KKimSangHeon.github.io/tags/KT/"}]},{"title":"알티캐스트 면접","slug":"interview2","date":"2018-10-22T03:36:14.000Z","updated":"2018-10-23T23:25:27.959Z","comments":true,"path":"2018/10/22/interview2/","link":"","permalink":"http://KKimSangHeon.github.io/2018/10/22/interview2/","excerpt":"","text":"시기2018년 6월 1차면접면접관 두분과 지원자 두명 다대다 면접으로 진행된다.경력에 대한 질문, 프로젝트에 대한 질문이 주를 이루며 자기소개서 내용이 거짓이 아니라면 충분히 대답이 가능한 수준이었다. 후기2차면접은 따로 없이 최종 합격통보를 받았다.편안한 분위기속에서 진행되었으며 사옥을 이전한지 얼마되지 않아 깨끗한 느낌을 많이받았다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"면접","slug":"Etc/면접","permalink":"http://KKimSangHeon.github.io/categories/Etc/면접/"}],"tags":[{"name":"면접","slug":"면접","permalink":"http://KKimSangHeon.github.io/tags/면접/"},{"name":"알티캐스트","slug":"알티캐스트","permalink":"http://KKimSangHeon.github.io/tags/알티캐스트/"}]},{"title":"줌인터넷 면접","slug":"interview3","date":"2018-10-22T03:36:14.000Z","updated":"2018-10-24T00:02:11.674Z","comments":true,"path":"2018/10/22/interview3/","link":"","permalink":"http://KKimSangHeon.github.io/2018/10/22/interview3/","excerpt":"","text":"시기2018년 7월 코딩시험문제의 난이도는 크게 어렵지 않은수준이었다. 1차면접면접 때 코딩시험 내용을 질문한다는 후기를 많이 봐 와서 작성했던 코드를 철저하게 분석하여 갔지만 관련 내용은 질문하지 않으셨다.면접관 다섯분과 지원자 한명 다대일 방식으로 면접이 진행되었다. 면접 질문은 다음과 같다. 자바8자바 몇까지 써봄프로미스프로토타입http 송신 수신시 헤더diaop쿠키 세션rest api?예외의 종류 Error에 대한질문stringbuffer stringbuilder 차이인터페이스 staitc defaultresultful api설계해본적암호화기법양방향 단방향 후기정말 많이많이 어려웠던 면접이었던것 같다. 지금까지 봤던 면접 중 가장 어려웠고 많은것을 다시한번 생각해볼 수 있었던 기회였다. 면접관 분들은 친절하셨지만 내 실력이 불친절했던것 같다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"면접","slug":"Etc/면접","permalink":"http://KKimSangHeon.github.io/categories/Etc/면접/"}],"tags":[{"name":"면접","slug":"면접","permalink":"http://KKimSangHeon.github.io/tags/면접/"},{"name":"줌인터넷","slug":"줌인터넷","permalink":"http://KKimSangHeon.github.io/tags/줌인터넷/"}]},{"title":"웍스모바일 인턴 면접","slug":"interview","date":"2018-10-22T03:36:14.000Z","updated":"2018-10-23T23:25:14.117Z","comments":true,"path":"2018/10/22/interview/","link":"","permalink":"http://KKimSangHeon.github.io/2018/10/22/interview/","excerpt":"","text":"시기2018년 3월 1차면접면접은 한번뿐이었으며 기본적인 전공지식 그리고 경험에 대한 질문이 다수였다. ide뭐 쓰는지asyn서치정렬되지않은 데이터 접근http https차이블로킹 논블로킹 차이트랜잭션데드락dns설계패턴동기비동기 차이string stringbuffer차이 소감합격해서 인턴까지 잘 마무리 지을 수 있었고 그린팩토리에서 일한다는 자부심을 느낄 수 있었다. 좋은분들과 함께 근무했던것 같아 좋았었다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"면접","slug":"Etc/면접","permalink":"http://KKimSangHeon.github.io/categories/Etc/면접/"}],"tags":[{"name":"면접","slug":"면접","permalink":"http://KKimSangHeon.github.io/tags/면접/"},{"name":"웍스모바일","slug":"웍스모바일","permalink":"http://KKimSangHeon.github.io/tags/웍스모바일/"}]},{"title":"프로토타입 디자인 패턴","slug":"Prototype-Pattern","date":"2018-09-22T06:26:34.000Z","updated":"2018-10-22T01:47:04.323Z","comments":true,"path":"2018/09/22/Prototype-Pattern/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/22/Prototype-Pattern/","excerpt":"","text":"프로토타입 디자인 패턴프로토타입 패턴은 객체를 복사품을 만드는것을 의미하는 것이다. 복제된 객체는 호출되는 객체의 현재 상태를 갖고 초기화 되는데 이는 얕은복사 혹은 깊은복사에 기반하여 이뤄진다. 얕은복사 vs 깊은복사얕은복사는 단지 참조의 사본을 만든다고 볼 수 있다.깊은복사는 사본을 새로 생성하여 복사대상이 변경되어도 복사한 데이터는 변경되지 않는다. Prototype12345678910111213141516class Quotation&#123; protected: string type; int value; public: virtual Quotation* clone() = 0; string getType() &#123; return type; &#125; int getValue() &#123; return value; &#125; &#125;; CarQuotation, BikeQuotation 는 Quotation클래스를 상속한다.Prototype12345678910111213141516171819202122class CarQuotation: public Quotation &#123; public: CarQuotation(int number) &#123; type = \"Car\"; value = number; &#125; Quotation* clone() &#123; return new CarQuotation(*this); &#125;&#125;;class BikeQuotation : public Quotation &#123; public: BikeQuotation(int number) &#123; type = \"Bike\"; value = number; &#125; Quotation* clone()&#123; return new BikeQuotation(*this); &#125;&#125; 사용예Prototype12345678910111213141516171819202122232425262728293031323334353637 class QuotationFactory &#123; private : Quotation *carQuotation; Quotation *bikeQuotation; public : QuotationFacory() &#123; carQuotation = new CarQuotation(10); bikeQuotation = new BikeQuotation(20); &#125; ~QuotationFactory() &#123; delete bikeQuotation; delete carQuotation; &#125; Quotation* createQuotation(int typeId) &#123; if( typeID ==1 ) return carQuotation-&gt;clone(); else return bikeQuotation-&gt;clone(); &#125; &#125;int main() &#123; QuotationFacory* qf = new QuotationFactory(); Quotation* q; q = qf-&gt;createQuotation(1); delete q; q = qf-&gt;createQuotation(2); delete q; delete qf; return 0;&#125; 프로토타입 패턴에서 복사한다는 것이 무슨뜻인지 이해가 잘 안됐지만 이젠 이해가 간다. 미리 특정형태(프로토타입)을 만들어 놓고 팩토리패턴으로 호출할 때 그 프로토타입을 반환하여 활용할 수 있도록 하는 패턴인것이다. 자바에서의 프로토타입 패턴C++같은 경우엔 위와같이 코드를 작성해야 되지만 Java의 경우 최상위 클래스 Object가 clone() 메소드가 정의되어 있으므로 이를 오버라이딩해서 활용하면 된다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Design Pattern","slug":"CS/Design-Pattern","permalink":"http://KKimSangHeon.github.io/categories/CS/Design-Pattern/"}],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://KKimSangHeon.github.io/tags/Design-Pattern/"}]},{"title":"팩토리 메서드 디자인 패턴","slug":"factory-method","date":"2018-09-22T04:25:51.000Z","updated":"2018-09-27T17:40:56.718Z","comments":true,"path":"2018/09/22/factory-method/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/22/factory-method/","excerpt":"","text":"팩토리 메서드 패턴공장처럼 팩토리 메서드의 일은 객체를 생성하는것이다. 이는 생성패턴으로 클래스들 중 하나의 객체를 인스턴스화 하는데 사용된다. 생성자에 비해 많은장점을 갖으며 상황에 따라 생성자 대신 혹은 기존의 생성자에 덧붙여 제공하는것이 좋다. Factory123456789101112131415161718192021222324252627282930313233343536373839// 팩토리 메서드 패턴으로 인스턴스화될 형으로 제공될 기본 클래스class Pet &#123; public : virtual void petSound() = 0;&#125;;// 팩토리 메서드 패턴에 의해 인스턴스를 얻게 될 첫 번째 파생 클래스class Dog: public Pet&#123; public : void petSound( ) &#123; cout&lt;&lt;\"Bow Bow...\"; &#125;&#125;;// 팩토리 메서드 패턴에 의해 인스턴스를 얻게 될 두번째 파생 클래스class Cat : public Pet &#123; public : void petSound() &#123; cout&lt;&lt; \"Meaw Meaw...\"; &#125;&#125;;// 로직에 기반해서 객체들을 인스턴스화하는 팩토리 메서드 패턴 구현class PetFactory &#123; public : Pet* getPet(int petType) &#123; Pet pet = NULL; // 비즈니스 로직에 기반한 객체의 인스턴스화 if (petType == 1) pet = new Dog(); else if(petType ==2) pet = new Cat(); return pet; &#125;&#125; 다음은 생성한 팩토리메소드를 활용하여 인스턴스를 생성하는 방식이다. Factory123456789int main() &#123; PetFactory *PetFactory = new PetFactory(); Pet pet = petFactory-&gt;getPet(2); cout&lt;&lt; \"Pet Sound\"; pet-&gt;petSound();&#125;","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Design Pattern","slug":"CS/Design-Pattern","permalink":"http://KKimSangHeon.github.io/categories/CS/Design-Pattern/"}],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://KKimSangHeon.github.io/tags/Design-Pattern/"}]},{"title":"제주도 여행","slug":"travel","date":"2018-09-18T08:18:54.000Z","updated":"2018-09-21T10:59:58.254Z","comments":true,"path":"2018/09/18/travel/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/18/travel/","excerpt":"","text":"9.13 ~ 9.17 제주도 여행휴식을 취하고자 웅상 파트너인 웅형과 제주도를 다녀왔다. 사진을 조금밖에 못찍어 아쉽지만 있는대로 올려본다. 거의 10여년만에 비행기를 타는거라 비행기를 타기까지 너무 오래걸렸던것 같다. 체크인, 수화물.. 너무 헷갈렸지만 어떻게 어떻게 비행기에 탑승하긴 했다.창가자리에 앉아 밖을 구경하는데 좋긴 좋았던것 같다. 날씨가 좋지 않았던 탓에 흔들렸던것만 빼고는…. 도착 첫날 스즈라는 초밥집에 가서 점식특선을 먹었다. 사진에 보이는것 외에도 호박죽, 야채 샐러드가 나왔는데 맛있었다. 제주도에서 먹은 음식중 Top3안에 들어간다. 사려니숲길유명한 숲길이 있대서 방문해봤다. 정말 나무가 많고 조용한 숲이었다. 이쁘기도 많이 이뻣던것 같다.카메라를 하늘로 향해 찍어보았다. 이유는 모르겠는데 많은 돌탑이 있었다. 그중 신기하게 쌓여진 돌탑이 있어 내가 쌓은척을 해봤다. 웅형이 우연찮게 찍어준 사진이 저렇게 나왔다. 여행하다 만난 사진전공하시는 분도 놀라워 해주셔서 만족스러웠다. 둘째날 묵은 빨간지붕게스트하우스라는 곳인데 3개월된 강아지가 정말 귀여웠다. 가만히 있는 사진을 찍기가 힘들정도로 활발했던것 같다. 다음에 또 제주도를 간다면 한번 더 방문해보고 싶다. 산굼부리라는 곳을 갔는데 비가 올듯 말듯 한 날씨였다. 구름또한 반은 어둡고 반은 밝은걸 느낄 수 있다. 우도여행을 하며 만난 사진전공하시는 분과 함께 우도를 갔다. 나는 전기자전거를 탔고 면허가 있는 두 사람은 2인오토바이 비슷한걸 빌렸다.우도가는 배를 타기 전 기다리는 중.. 혹시 비가 올까 걱정이 되는 날씨였다. 우도에 도착할때 쯤 하늘이 맑아지기 시작했다. 사진을 전공하시는 분이 찍어주신 사진이다. 사진알못이라 잘은 모르겠지만 뭔가 다른거같긴하다. 전공자라 다르긴한거같다. 넥슨 컴퓨터방물관그래도 개발잔데… 라며 방문해봤던 넥슨 박물관이다.신기한 물건도 많고 체험해볼것도 다양했다. 하지만 많은 초중고등학교의 현장학습과 겹친나머지 제대로 이용해보진 못했던게 아쉽다.입구에서부터 넥슨이라는걸 느낄 수 있었다. 사진엔 보이진 않지만 캐릭터 풍선부터 사진찍을만한 요소가 많았지만 비가와서 얼른 들어갔다. 얼굴을 트래킹하며 표정을 따라하는 여우다. 후기정말 많이먹고 좋은사람들을 많이 만날 수 있었던 좋은 여행이었다.날씨도 좋았고 사람도 좋았고 분위기도 좋았다. 아무생각 없이 편히 쉴 수 있었던것같아 좋았다.일상으로 돌아온게 아쉽진 하지만 다음 여행을 기약해야겠다.","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"Travel","slug":"About-Me/Travel","permalink":"http://KKimSangHeon.github.io/categories/About-Me/Travel/"}],"tags":[{"name":"여행","slug":"여행","permalink":"http://KKimSangHeon.github.io/tags/여행/"}]},{"title":"Singleton 디자인패턴","slug":"pattern2","date":"2018-09-11T07:42:21.000Z","updated":"2018-09-27T19:05:02.359Z","comments":true,"path":"2018/09/11/pattern2/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/11/pattern2/","excerpt":"","text":"싱글톤패턴클래스에 대한 오직 하나의 인스턴스 만이 허용되는 패턴이다.이를위해 생성자를 private로 선언하여 외부에서 인스턴스를 생성하는것을 방지한다.싱글톤 패턴을 사용할땐 다중 스레드에 주의해야 한다. 스레드에 안전한 코드는 다음과 같다. Singleton12345678910111213141516class Singleton &#123; public: static Singleton* getInstance() &#123; if (instance == 0) &#123; Lock lock; if (instance == 0 )&#123; instance = new Singleton; &#125; &#125; return instance; &#125; private: Singleton() &#123;&#125; static Singleton* instance;&#125;; 클래스가 적재되는순간 즉 더 빠르게 인스턴스화를 하기 위해서는 아래와 같이 코드를 작성하면 된다. 이 또한 스레드에 주의해서 작성해야 한다는것을 잊지말자. Singleton12345678class Singleton &#123; static Singleton instance = new Singleton(); Singleton() &#123;&#125; public: static Singleton getInstance() &#123; return instance; &#125;&#125;;","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Design Pattern","slug":"CS/Design-Pattern","permalink":"http://KKimSangHeon.github.io/categories/CS/Design-Pattern/"}],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://KKimSangHeon.github.io/tags/Design-Pattern/"}]},{"title":"디자인패턴","slug":"pattern1","date":"2018-09-07T09:31:43.000Z","updated":"2018-09-27T19:05:00.128Z","comments":true,"path":"2018/09/07/pattern1/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/07/pattern1/","excerpt":"","text":"디자인패턴소프트웨어 설계에서 공통적으로 발생하는 문제를 다루는 보편적이고 반복해서 사용할 수 있는 방법. 문제를 해결하기 위한 설명이나 템플릿으로 보면 된다. 디자인패턴을 사용할 때 장점개발 절차의 속도를 높일 수 있다.재사용 가능한 구조적 개념으로 구성되어 있기 때문에 믿을 수 있다. 디자인 패턴을 사용하기 위한 조건 주어진 문제를 명확, 세밀하게 이해한다. 디자인 패턴이 문제에 일치하는지 다시한번 확인해본다. 다른 패턴들 사이에서 관계성을 찾고 변경해야할 사항을 결정한다. 패턴 여러가지의 디자인 패턴은 3가지의 범주로 분류된다.범주는 아래와 같다. 생성패턴 : 객체생성 메커니즘을 다룬다. 객체의 생성을 다루는 객체 생성 패턴, 클래스 인스턴스 생성을 다루는 클래스 생성 패턴으로 분류된다.ex: Factory, Abstract Factory, Builder, Protype, Singleton 패턴. 구조패턴: 객체들과 클래스들이 커다란 구조를 형성하기 위해 결합될 수 있는 방법을 설명한다. 클래스패턴은 상속의 도움을 받아 추상화를 설명하고 어떻게 프로그램에 더 유용한 인터페이스를 제공할 수 있는지 설명하는것이고, 객체 패턴은 객체들이 크고 더 복잡한 구조를 형성하기 위해 연결되고 구성되는지 설명한다.ex: Adapter, Bridge, Composite, Decorator, Flyweight, Proxy 패턴 행위패턴: 객체 사이의 상호 작용과 관련된 것들이다. 이들은 객체간에 공통의 통신 패턴을 파악하고 이러한 패턴을 실현한다.ex: Chain of Responsibility, Command, Interpreter, iterator, Mediator, Memento, Observer, State, Strategy,Template, Vistor 패턴","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Design Pattern","slug":"CS/Design-Pattern","permalink":"http://KKimSangHeon.github.io/categories/CS/Design-Pattern/"}],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://KKimSangHeon.github.io/tags/Design-Pattern/"}]},{"title":"중첩 클래스, 중첩 인터페이스","slug":"java4","date":"2018-09-05T07:08:43.000Z","updated":"2018-09-05T09:04:56.154Z","comments":true,"path":"2018/09/05/java4/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/05/java4/","excerpt":"","text":"한 클래스가 여러 클래스와 관계를 갖을 땐 독립적으로 선언하는것이 좋다. 하지만 특정 클래스와 관계를 맺을 땐 내부에 선언하여 불필요한 관계 클래스를 감추고 코드의 복잡성을 감출 수 있게된다. 중첩클래스중첩클래스는 크게 두가지로 나뉘는데 다음과 같다.멤버클래스 - 클래스의 멤버로서 선언되는 중첩클래스. 멤버클래스는 static 여부에 따라 인스턴스 멤버클래스, 정적 멤버클래스로 나뉜다. 클래스나 객체가 사용중이면 언제나 재사용 가능.로컬클래스 - 메소드 내부에서 선언되는 중첩클래스. 메소드 실행 시에만 사용되고 종료되면 없어진다. 다음은 인스턴스 멤버 클래스 사용예시이다.NestedClass123456789101112131415class A&#123; class B&#123; B() &#123; &#125; int filed; //static int filed2; //static는 안되는데 그 이유를 생각해보자 void mehtod1()&#123;&#125; //static void method2()&#123;&#125; //역시 static은 안된다. &#125;&#125;// 사용방벙A a = new A();A.B b = a.new B();b.field1 = 3;b.method1(); 다음은 인스턴스 정적 멤버 클래스 사용예시이다.static변수에 대한 이해가 필요하다.NestedClass123456789101112131415class A&#123; static class C&#123; B() &#123; &#125; int filed; static int filed2; //static 가능 void mehtod1()&#123;&#125; static void method2()&#123;&#125; //static 가능 &#125;&#125;A.C c = new A.C();c.file1 = 3;c.method1();A.C.filed2 = 3;A.C.method2(); 다음은 로컬 클래스 사용예시이다.주로 비동기 처리를 위해 스레드 객체를 만들 때 사용한다.NestedClass1234567891011121314void method() &#123; class D &#123; D() &#123;&#125; int filed1; //static int filed2; //static 안된다. void method1() &#123;&#125; //static void method2() &#123;&#125; //static 안된다. &#125; D d = new D(); d.field1 = 3; d.method1();&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"자바8","slug":"java3","date":"2018-09-04T22:49:23.000Z","updated":"2018-09-04T23:25:52.655Z","comments":true,"path":"2018/09/05/java3/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/05/java3/","excerpt":"","text":"자바 개발자 면접을 보며 듣는 질문이 있다.. 자바8의 특징을 아시나요? 자바8에서 추가된 기능은요? 말씀하신 기능에 대해 좀더 자세히 설명해주세요. 그 외적인 부분은 없을까요? 등등 꼬리에 꼬리를 물다보면 항상 바닥을 드러냈던것 같다.사실 자바를 공부하면서 딱히 버전에 대해 신경쓰지 않았던터라 많이 당황스러웠던 질문이었던것 같다.기회가 되면 정리해야지 했는데 나와 비슷한 고민을 했던 분이 계셔서 링크를 남겨놓는다.https://johanneslee.github.io/articles/page7/ http://blog.eomdev.com/java/2016/03/30/default-method.html나 또한 빠른 시일내에 공부해서 게시할 수 있도록 해야겠다.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"인터페이스의 디폴트 메소드","slug":"java2","date":"2018-09-04T22:43:01.000Z","updated":"2019-04-21T10:50:35.327Z","comments":true,"path":"2018/09/05/java2/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/05/java2/","excerpt":"","text":"인터페이스의 디폴트 메소드는 자바8부터 나왔다고 한다.. 알아두자.선언은 인터페이스에 하고 사용은 구현객체에서 한다. 왜 이걸 만들었을까?기존 인터페이스를 확장해서 새로운 기능을 추가하기 위해서 특징?디폴트 메소드는 정의된 형태이므로 implemets했을 때 해당 메소드의 구현을 강제하지 않는다. 디폴트 메소드는 다음과 같이 정의할 수 있다.default12345678910public interface MyInterface&#123; public void method1(); public default void method2()&#123; System.out.println(\"method2\"); &#125; //디폴트 메소드&#125; 디폴트 메소드를 갖는 인터페이스를 인터페이스가 상속했을 때?디폴트 메소드를 처리하기 위해 다음 3가지중 선택가능 디폴트 메소드를 단순히 상속만 받는다. 디폴트 메소드를 오버라이딩 해서 내용 변경 디폴트 메소드를 추상메소드로 재선언","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"어노테이션 그리고 리플렉션","slug":"java","date":"2018-09-04T21:25:09.000Z","updated":"2018-11-20T00:43:05.194Z","comments":true,"path":"2018/09/05/java/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/05/java/","excerpt":"","text":"어노테이션어노테이션은 컴파일 과정과 실행 과정에서 코드를 어떻게 컴파일하고 처리할 것인지를 알려주는 정보이다.@가 붙는 형태로 정의된다. 어노테이션은 다음의 용도로 사용된다.123컴파일러에게 문법에러 체크 ex(@Override)개발 툴이 코드를 자동 생성할 수 있도록 정보제공실행시 특정기능을 실행하도록 정보제공 어노테이션 정의 및 사용법어노테이션 정의는 다음과 같이 할 수 있다.Annotation1234public @interface SHAnnotation &#123; String feature(); int age() default 0;&#125; 위에 정의한 어노테이션을 사용하기 위해서는 다음과 같이 사용할 수 있다.Annotation1234@SHAnnotation(feature=\"개발자\", age=27);혹은@SHAnnotation(feature=\"개발자\");//아래의 경우 디폴트로 되어있는 age값을 세팅하지 않았다. 어노테이션을 적용할 수 있는 대상은 java.lang.annotation.ElementType에 정의 되어있다.해당 열거형을 보면 아래와 같이 다양하게 존재한다.즉 어노테이션을 적용할 수 있는 대상은 다음과 같다.1234567891011121314151617181920212223242526272829// Field descriptor #37 Ljava/lang/annotation/ElementType;public static final enum java.lang.annotation.ElementType TYPE;// Field descriptor #37 Ljava/lang/annotation/ElementType;public static final enum java.lang.annotation.ElementType FIELD;// Field descriptor #37 Ljava/lang/annotation/ElementType;public static final enum java.lang.annotation.ElementType METHOD;// Field descriptor #37 Ljava/lang/annotation/ElementType;public static final enum java.lang.annotation.ElementType PARAMETER;// Field descriptor #37 Ljava/lang/annotation/ElementType;public static final enum java.lang.annotation.ElementType CONSTRUCTOR;// Field descriptor #37 Ljava/lang/annotation/ElementType;public static final enum java.lang.annotation.ElementType LOCAL_VARIABLE;// Field descriptor #37 Ljava/lang/annotation/ElementType;public static final enum java.lang.annotation.ElementType ANNOTATION_TYPE;// Field descriptor #37 Ljava/lang/annotation/ElementType;public static final enum java.lang.annotation.ElementType PACKAGE;// Field descriptor #37 Ljava/lang/annotation/ElementType;public static final enum java.lang.annotation.ElementType TYPE_PARAMETER;// Field descriptor #37 Ljava/lang/annotation/ElementType;public static final enum java.lang.annotation.ElementType TYPE_USE; 어노테이션이 적용될 대상을 지정할 땐 @Target를 활용한다. Annotation12345678910import java.lang.annotation.Target;import java.lang.annotation.ElementType;@Target(&#123;ElementType.TYPE, ElementType.FIELD, ElementType.METHOD&#125;)public @interface SHAnnotation &#123; String feature(); int age() default 0;&#125;// 적용 대상을 TYPE(클래스, 인터페이스, 열거타입), FILED로 설정하였다. 그럼 아래와 같이 어노테이션 적용이 가능해진다.Annotation12345678910111213@SHAnnotation(feature=\"개발자\", age=27)public class AnnotationTest &#123; @SHAnnotation(feature=\"디자이너\") public void method1() &#123; System.out.println(\"메소드1\"); &#125; @SHAnnotation(feature=\"기획자\", age=30) public void method2() &#123; System.out.println(\"메소드2\"); &#125;&#125; 어노테이션 유지 정책어노테이션은 용도에 따라 어느 범위까지 유지할 것인지 지정 가능하다. 세가지로 나뉘는데 다음과 같다.123SOURCE - 소스상에서만 유지CLASS - 바이트 코드 까지 유지RUNTIME - 바이트 코드까지 유지하며 리플렉션을 이용해 런타임 시 어노테이션 정보를 얻을 수 있다. 리플렉션?위에 리플렉션에 대해 설명하자면 런타임 시에 클래스의 메타 정보를 얻는 기능을 의미한다. 클래스의 필드, 생성자, 메소드, 적용된 어노테이션 등을 런타임 시에 알아낼 수 있다. 다시 돌아와서 어노테이션의 유지는 @Retention으로 지정할 수 있다. 대부분 어노테이션은 런타임시에 유지되도록 하는경우가 많다.다음은 어노테이션이 런타임시에 유지되도록 하는 코드이다.Annotation123456789101112import java.lang.annotation.Target;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;@Target(&#123;ElementType.TYPE, ElementType.FIELD, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface SHAnnotation &#123; String feature(); int age() default 0;&#125; 런타임 중 어노테이션 정보 사용어노테이션을 만들었으면 사용방법 또한 알아야 할 것이다. 이에 대해 자세히 알아보자클래스에 적용된 어노테이션 정보를 얻으려면 Class 클래스를 이용하면 되지만 필드, 생성자, 메소드에 적용된 어노테이션 정보를 얻으려면 Class 클래스의 메소드를 통해 리플렉션 과정이 필요하다. 이 말이 이해가 안되면 코드를 보고 이해하자. 위 까지 모든 과정을 거쳤으면 아래 실습이 문제없을것이다. Annotation12345678910111213141516171819202122232425262728293031323334353637import java.lang.reflect.Method;public class PrintAnnotation &#123; public static void main(String[] args) &#123; SHAnnotation shAnnotation; // 클래스의 어노테이션 정보 가져오기 shAnnotation = AnnotationTest.class.getAnnotation(SHAnnotation.class); System.out.println(AnnotationTest.class.getName()); System.out.println(shAnnotation.feature()); System.out.println(); // 리플렉션을 통해 선언된 메소드 정보 가져오기 Method[] declaredMethods = AnnotationTest.class.getDeclaredMethods(); for(Method method:declaredMethods) &#123; //SHAnnotation 객체 얻기 shAnnotation = method.getAnnotation(SHAnnotation.class); //어노테이션이 적용되었는지 체크 if(method.isAnnotationPresent(SHAnnotation.class)) &#123; System.out.println(method.getName()); System.out.println(shAnnotation.feature()); &#125; try &#123; //메소드 호출부 method.invoke(new AnnotationTest()); System.out.println(); &#125;catch(Exception e) &#123; System.out.println(e.getStackTrace()); &#125; &#125; &#125;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"CS 공부","slug":"myStudy","date":"2018-09-04T12:28:35.000Z","updated":"2018-09-21T10:38:11.078Z","comments":true,"path":"2018/09/04/myStudy/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/04/myStudy/","excerpt":"","text":"대부분의 자료는 http://www.comcbt.com/cbt/ 의 정보처리기사 필기 문제를 참고하여 작성하였다. 데이터베이스기수(Cardinality) : 튜플의 수차수(Degree) : 열의 수 색인 순차 파일은 순차 파일과 직접 파일에서 지원하는 편성 방법이 결합된 형태다.색인 순차 접근 방식 (ISAM, Index Sequential Access Method)색인 순차 파일은 기본영역, 색인 영역, 오버플로 영역으로 구성된다. 병행 제어의 목적 데이터베이스의 공류를 최대화한다. 시스템의 활용도를 최대화한다. 사용자에 대한 응답 시간을 최소화한다. 단위 시간당 트랜잭션 처리 건수를 최대화한다. 데이터베이스의 일관성을 유지한다.[해설작성자 : 출처: http://androphil.tistory.com/335 [소림사의 홍반장!]] 중위표기법 - &gt; 후위표기법스택에 모든 연산자를 넣으면서 형님이 아우 위에 올라오면 그대로 넣고 그 역이면 모두 pop 후위표기법계산연산자의 앞에 등장하는 두개의 숫자가 피연산자이다.차례대로 앞에서부터 계산해 나가자 관계대수1)관계대수-관계형 데이터베이스에서 원하는 정보와 그정보를 검색하기 위해서 ‘어떻게’ 유도하는가를 기술하는 절차적언어(절차 중심)-기존의 릴레이션으로부터 새로운 릴레이션을 생성한다-릴레이션을 처리하기 위해 연산자와 연산 규칙을 제공 연산자 종류 : 순수관계연산자 , 일반집합연산자 관계해석2)관계해석-원하는 정보가 ‘무엇’이라는 것만 정의하는 비절차적언어(결과 중심)-질의어 이용한 표현-관계해석으로 표현한식은 관계대수로 표현 가능-프레디킷해석에 기반-관계 데이터 모델 제안자인 코드가 관계 데이터베이스에 적용할수 있도록 설계하여 제안종류 : 튜플관계해석 , 도메인관계해석 출처 - http://unius.tistory.com/entry/관계대수-vs-관계해석 카르노맵사용되는 알파벳이 4개일 때 블로그와 반대로하자https://m.blog.naver.com/PostView.nhn?blogId=leeyunghuk1&amp;logNo=220958708825&amp;proxyReferer=https%3A%2F%2Fwww.google.co.kr%2F CPU 사용방식멀티 프로그래밍: 한대의 CPU로 여러 개의 프로그램을 동시에 처리 분산처리 프로그래밍: 지역적으로 분산된 여러 대 컴퓨터 연결. 작업분담처리일괄처리 프로그래밍: 처리할 데이터를 모았다가 한번에 처리. EX) 급여계산, 공공요금계산리얼타임(실시간처리) 프로그래밍: 처리 데이터 발생시 바로 처리. EX) 좌석예약, 은행업무[해설작성자 : ʕ • ᴥ •メʔ 북극곰사냥꾼] 플립플롭http://vision.kongju.ac.kr/DigitalMain/dvlec/textbook/chap08/digital08_2.htm 참고 JK 는 SR에 11일때 토글만 추가로 지원하는것 같다. RAM4x2 RAM을 이용하여 16x4 메모리를 구성하고자 할 경우에 필요한 4x2 RAM의 수는?8개(42) 8 = (16*4)[해설작성자 : wg] 문자 데이터 표현표준 ASCⅡ 코드는 7비트 사용, 영문 대소문자, 숫자, 문장 부호, 특수 제어 문자 표현3개의 존 비트, 4개의 디지트 비트로 구성 문자데이터의 표현BCD코드 : 6비트 구성(존 2, 숫자 4)ASCII코드 : 7비트 구성(존 3, 숫자 4)EBICIC코드: 8비트 구성(존4, 숫자4)UNICODE: 16비트 구성 - 전 세계의 문자를 표현 할 수 있는 국제 표준 문자 코드[해설작성자 : 석영호] CPU 스케줄링http://raisonde.tistory.com/entry/CPU-스케줄링-알고리즘 비선점형 스케줄링 : FCFS(FIFO), SJF, HRN, 비선점형 우선순위, 기한부SRT 스케줄링은 수행 시간이 가장 작은 작업을 선점형으로 처리합니다.[해설작성자 : 46200] 커널커널의 기능은 프로세스 생성, 종료/ 기억 장치 할당, 회수/ 파일 시스템 관리 등이 있다 유닉스의 i-nodei-node에 저장되는 정보로는 파일의 소유자에 대한 정보(소유자id, 그룹id), 파일에 대한 정보(크기, 유형, 생성된 시간,링크된 참조 갯수), 시간에 대한 정보(최근 사용시간, 최근 변경시간), 파일 접근 권한, 파일이 저장된 데이터블록 주소가 있다[해설작성자 : 희굴이] 삽입정렬1~n까지 정렬해 나감 1~2 정렬 12묶음 3정렬 13묶음 4정렬첫 번째 데이터는 정렬이 되어있다고 봄. 그래서 i=0이아닌 1부터 시작.시간복잡도는 O(n^2) 이다. 뷰 가상테이블(물리적으로 구현되는 테이블이 아니다) 시스템 검색은 일반 테이블과 동일 논리적 데이터 독립성을 제공 하나의 뷰를 삭제하면 그 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제 접근 제한을 통한 보안 제공 실제 테이터가 저장되지 않는다. 독자적인 인덱스를 가질 수 없다. 뷰를 이용한 또 다른 뷰의 생성이 가능하다. 필요한 데이터만 뷰로 정의해서 처리하여 사용자의 관리가 용이 뷰는 변경이 안되어 지우고 다시 만들어야 함. &lt;- 전위식, 후위식1-/*A+BCDE 를 후위식으로 쉬운 변환방법 설명1.연산자에 따라 묶는다. (이거 못하시면 이론 다시 ㄱㄱ)( - ( / ( * A ( + B C ) ) D ) E ) 2.연산자를 각 괄호 뒤로 뺀다. (중위식으로 할때는 연산자를 문자 사이로 하시면 됩니다.)( ( ( A ( B C ) + ) * D ) / E ) - 3.괄호를 제거한다.A B C + * D / E - [해설작성자 : 쀼쀼] 관계대수, 관계해석관계대수 : 절차적 언어 / 순수 관계 연산(select, project, join, division)과 일반 집합연산(union, intersection, difference, cartesian product)관계해석 : 비절차적 언어 / Predicate Calculus에 기반을 둠 / 튜플 및 도메인 관계해석[해설작성자 : sdk] 관계대수(릴레이션 조작을 위한 연산의집합.기술적인특성)의 순수관계 연산자 릴레이션을 처리하기 위한 연산의 집합으로 피연산자가 릴레이션이고 결과도 릴레이션이다. Select : 수평적 부분집합. 시그마를 사용 Project : 수직적 부분집합. 파이를 이용 Join Division : 두 릴레이션 A,B에 대해 릴레이션의 모든 조건을 만족하는 튜플들을 릴레이션 A에서 분리해 내어 프로젝션 함. 스레싱스레싱(Thrasing):하나의 프로세스가 작업 수행 과정에서 수행하는 기억장치 접근에서 지나치게 페이지 폴트가 발생하여 프로세스 수행에 소요되는 시간보다 페이지 이동에 소요되는 시간이 더 커지는 현상..오류율이 클수록 스레싱이 많이 발생한 것이고.스래싱으로 인해 전체 시스템의 성능 및 처리율은 저하된다.다중 프로그래밍의 어느 시점을 넘어서면 스레싱의 빈도가 높아진다.[해설작성자 : 김은희] [추가해설]Thrashing 현상 방지 방법 다중 프로그래밍의 정도를 적정수준으로 유지 부족한 자원 증설 일부 프로세스 중단 페이지 부재 빈도 조절 워킹 셋 유지 적정프레임 수 제공[해설작성자 : 네비자동실행 앱 : haewon.tistory.com] 메모리 할당기법가변분할 할당 : 다중분할 할당의 한 방법으로, 프로그램을 주기억장치에 적재할 때 함수 등 필요한 크기로 영역을 분할하는 기법고정분할 할당 : 다중분할 할당의 한 방법으로, 주기억장치의 사용자 영역을 일정 수의 고정크기로 분할하여 사용하는 기법오버레이 기법 : 프로그램의 크기가 주기억장치보다 클 때, 프로그램을 여러 조각으로 분할한 후 필요한 조각 순서대로 주기억장치에 적재한다. 실행중 주기억장치의 메모리가 부족하면 이미 존재하는 조각에 새로운 조각을 중첩하여 적재한다.[해설작성자 : ck] 프로세서 상태전이① dispatch (준비상태→실행상태)준비 상태의 프로세스들 중에서 우선 순위가 가장 높은 프로세스를 선정하여 CPU를 할당함으로써 실행상태로 전환한다.② timerrunout (실행상태→준비상태)CPU의 지정된 할당 시간을 모두 사용한 프로세스는 다른 프로세스를 위해 다시 준비 상태로 되돌아간다.③ block (실행상태→대기상태)실행중인 프로세스가 입출력 명령을 만나면 인터럽트가 발생하여 입출력 전용 프로세서에게 CPU를 양도하고 자신은 대기 상태로 전환한다.④ wake-up (대기상태→준비상태)입출력 완료를 기다리다가 입출력 완료 신호가 들어오면 대기중인 프로세스는 준비 상태로 전환한다.[해설작성자 : ㅁㄴㅇㄹ] 페이지 교체기법&lt;문제 해설&gt;NUR (Not Used Recently) 최근 사용하지 않은 페이지 교체 최근 사용여부를 확인하기 위해(시간 오버헤드를 줄이기 위해), 각 페이지마다 참조/변형비트 사용 교체순서 : 00 - 01 - 10 - 11 (0 : 참조비트, 1 : 변형비트)[해설작성자 : 비슷한문제 해설에서 따옴] 페이지 교체 기법 - 새 데이터를 주기억장치에 등록할 때공간이 부족할 경우 먼저 있던 데이터를 빼고 넣는 행위를 말함. FIFO - 제일 오래된 데이터 제거LFU - 가장 적게 사용 되었던 데이터 제거LRU,NUR - ‘최근’ 가장 적게 사용되었던 데이터 제거OPT - 앞으로 가장 적게 사용될 것 같은 데이터를 예측하여 제거(신뢰성 떨어짐) 브룩스 법칙브룩스(Brooks)의 법칙 : 소프트웨어 개발 일정이 지연된다고 해서 말기에 새로운 인원을 투입하면 작업 적응 기간과 부작용으로 인해 일정은 더욱 지연된다는 법칙이다.[해설작성자 : strawsoojin] 결합도의 약한 순서데이터 -&gt; 스템프 -&gt; 제어 -&gt; 공통 -&gt; 컨텐츠 결합도 순서[해설작성자 : 원동민] 전송제어 문자 SOH(Start Of Heding) : 헤딩 시작 STX(Start of Text) : 본문 시작, 전송할 데이터 그룹의 시작 SYN(Synchronous idle) : 동기 문자 DLE(Data Link Escape) : 데이터 투과성을 위해 삽입(전송 제어 문자와 전송 데이터 구분을 위해 사용)[해설작성자 : 실기도 화이팅!]","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"}],"tags":[]},{"title":"7.Firebase 호스팅","slug":"firebase7","date":"2018-09-04T10:01:11.000Z","updated":"2018-09-04T10:12:55.152Z","comments":true,"path":"2018/09/04/firebase7/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/04/firebase7/","excerpt":"","text":"firebase deploy를 입력해 배포를 하자명령어를 입력하고 성공하면 위와같은 화면이 출력된다.Hosting URL 이라고 표현된 부분을 통해 접속 가능하다.","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Firebase","slug":"Web-App/Firebase","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Firebase/"}],"tags":[]},{"title":"6.Firebase DB수정 삭제","slug":"firebase6","date":"2018-09-03T15:54:01.000Z","updated":"2018-09-04T07:12:47.996Z","comments":true,"path":"2018/09/04/firebase6/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/04/firebase6/","excerpt":"","text":"DB 수정selectedKey라는 전역변수를 만들고 아래의 두 함수를 추가하면 데이터는 수정이 가능하다. 이때 수정하는 부분의 ref함수의 인자에 selectedKey가 삽입된 것을 확인할 수 있다.Firebase123456789101112131415161718192021222324252627282930313233function fn_get_data_one(key) &#123; selectedKey = key; var memoRef = database.ref('memos/' + userInfo.uid + '/' + key).once('value').then(function(snapshot)&#123; var txt = $(\".textarea\").val(snapshot.val().txt); &#125;);&#125;function save_data() &#123; var memoRef = database.ref('memos/' + userInfo.uid); var txt = $(\".textarea\").val(); // 유효성 검사 if ( txt == '') &#123; return; &#125; if ( selectedKey ) &#123; // 전역변수 selectedKey가 있으면 update memoRef = database.ref('memos/' + userInfo.uid + '/' + selectedKey); memoRef.update(&#123; txt : txt, createDate : new Date().getTime(), updateDate : new Date().getTime(), &#125;) &#125;else&#123; memoRef.push(&#123; txt : txt, createDate : new Date().getTime() &#125;) &#125;&#125; title이 문장의 맨윗줄만 나오도록 하기 위해 on_child_added의 title변수에 txt.substr(0, txt.indexOf(‘\\n’));을 대입하자Firebase12345function on_child_added(data)&#123; ... var title = txt.substr(0, txt.indexOf('\\n')); ...&#125; 이번에는 + 버튼을 눌러 메모를 추가할 수 있도록 확인해보자버튼에 onClick = ‘initMemo();’ 를 추가하고 다음의 함수를 추가하자.Firebase1234function initMemo() &#123; $('.textarea').val(''); selectedKey = null;&#125;이제 + 버튼을 누르면 새로운 메모를 입력할 수 있게된다. 이제 데이터가 변경되었을 때 왼쪽 리스트가 변경되도록 해보자get_momo_list 함수에 아래의 코드를 추가하여 변경에 대한 처리를 추가한다.Firebase1234567memoRef.on('child_changed', function(data)&#123; var key = data.key; var txt = data.val().txt; var title = txt.substr(0, txt.indexOf('\\n')); $(\"#\"+ key + \"&gt; .title\").text(title); $(\"#\"+ key + \"&gt; .txt\").text(txt);&#125;) 이제 삭제기능을 구현해보자HTML에 다음을 추가하자Firebase1\"&lt;a href=\\\"#!\\\" onclick=\\\"fn_delete_data('\"+key+\"')\\\" class=\\\"secondary-content\\\"&gt;&lt;i class=\\\"material-icons\\\"&gt;grade&lt;/i&gt;&lt;/a&gt;\"그리고 다음 함수를 추가하여 삭제기능 구현하자 Firebase123456789function fn_delete_data(key) &#123; if(!confirm('삭제하시겠습니까')) &#123; return; &#125; var memoRef = database.ref('memos/' + userInfo.uid + '/' + key); memoRef.remove(); $(\"#\"+key).remove();&#125;","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Firebase","slug":"Web-App/Firebase","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Firebase/"}],"tags":[]},{"title":"5.Firebase DB 읽고 쓰기","slug":"firebase5","date":"2018-09-03T13:32:28.000Z","updated":"2018-09-04T10:10:57.627Z","comments":true,"path":"2018/09/03/firebase5/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/03/firebase5/","excerpt":"","text":"포커스가 사라지면 데이터베이스에 input하도록 설정아래의 코드를 추가하면 textarea가 포커스를 잃을 때 마다 데이터를 저장하게 된다.Firebase1234567891011121314151617181920function save_data() &#123; var memoRef = database.ref('memos/' + userInfo.uid); var txt = $(\".textarea\").val(); // 유효성 검사 if ( txt == '') &#123; return; &#125; memoRef.push(&#123; txt : txt, createDate : new Date().getTime() &#125;)&#125;$(function()&#123; $(\".textarea\").blur(function()&#123; save_data(); &#125;);&#125;); 그리고 아래의 코드를 추가하면 왼쪽중 하나를 선택하면 textArea에 내용이 출력된다. Firebase12345function fn_get_data_one(key) &#123; var memoRef = database.ref('memos/' + userInfo.uid + '/' + key).once('value').then(function(snapshot)&#123; var txt = $(\".textarea\").val(snapshot.val().txt); &#125;);&#125; 위에서 once() 함수는 프로미스를 반환한다.","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Firebase","slug":"Web-App/Firebase","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Firebase/"}],"tags":[]},{"title":"4.Firebase DB읽어오기","slug":"firebase4","date":"2018-09-03T09:11:06.000Z","updated":"2018-09-04T10:08:00.528Z","comments":true,"path":"2018/09/03/firebase4/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/03/firebase4/","excerpt":"","text":"DB를 읽고 쓰기 위해 리얼타임 데이터베이스의 규칙에 아래로 수정하자Firebase123456&#123; \"rules\": &#123; \".read\": true, \".write\": \"auth != null\" &#125;&#125; 이전 코드에 다음 코드를 추가하자.Firebase1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;script&gt; var auth, database, userInfo; // Initialize Firebase var config = &#123; apiKey: \"AIzaSyCuXqUy4sOBUh0FBJyqkOde_20s1f6gffs\", authDomain: \"memowebapp-b6255.firebaseapp.com\", databaseURL: \"https://memowebapp-b6255.firebaseio.com\", projectId: \"memowebapp-b6255\", storageBucket: \"memowebapp-b6255.appspot.com\", messagingSenderId: \"582035498309\" &#125;; firebase.initializeApp(config); auth = firebase.auth(); database = firebase.database(); var authProvider = new firebase.auth.GoogleAuthProvider(); auth.onAuthStateChanged(function(user)&#123; if ( user) &#123; // 인증 성공 console.log(\"success\"); console.log(user); userInfo = user; get_momo_list(); &#125;else &#123; // 인증 실패 auth.signInWithPopup(authProvider); &#125; &#125;); function get_momo_list() &#123; var memoRef = database.ref('memos/' + userInfo.uid); memoRef.on('child_added', on_child_added); &#125; function on_child_added(data)&#123; var key = data.key; var memoData = data.val(); var txt = memoData.txt; var title = memoData.title; var firstTxt = txt.substr(0,1); var html = \"&lt;li id='\"+key+\"' class=\\\"collection-item avatar\\\" onclick=\\\"fn_get_data_one(this.id);\\\" &gt;\" + \"&lt;i class=\\\"material-icons circle red\\\"&gt;\" + firstTxt + \"&lt;/i&gt;\" + \"&lt;span class=\\\"title\\\"&gt;\" + title + \"&lt;/span&gt;\" + \"&lt;p class='txt'&gt;\" + txt + \"&lt;br&gt;\" + \"&lt;/p&gt;\" + \"&lt;/li&gt;\"; $(\".collection\").append(html); &#125;&lt;/script&gt;위의 코드는 DB에서 데이터를 읽어온 후 왼쪽 리스트에 추가하는 상황인데 데이터는 다음 그림처럼 생성되어 있어야 한다. “SF9uVrBjLKPRVVKZOCw7x2VKWT22” 이것이 나의 UID이다. 즉 위의코드는 memos라는 DB에 내 UID로 접근해서 데이터를 가져오고 그 데이터들을 append하는것으로 볼 수 있다. 다음 그림은 출력된 화면이다","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Firebase","slug":"Web-App/Firebase","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Firebase/"}],"tags":[]},{"title":"3.Firebase Google Auth 연동","slug":"firebase3","date":"2018-09-03T05:41:11.000Z","updated":"2018-09-03T09:35:07.082Z","comments":true,"path":"2018/09/03/firebase3/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/03/firebase3/","excerpt":"","text":"Firebase1234567891011121314151617&lt;script&gt; var auth; // Initialize Firebase var config = &#123; apiKey: \"xxx\", authDomain: \"xxx\", databaseURL: \"xxx\", projectId: \"xxx\", storageBucket: \"xxx\", messagingSenderId: \"xxx\" &#125;; firebase.initializeApp(config); auth = firebase.auth(); var authProvider = new firebase.auth.GoogleAuthProvider(); auth.signInWithPopup(authProvider);&lt;/script&gt; 위의 코드를 추가한 후 서버를 껏다 켜고 localhost:5000으로 접속하면 팝업이 뜬다. Firebase12345678auth.onAuthStateChanged(function(user)&#123; if ( user) &#123; // 인증 성공 console.log(\"success\"); console.log(user); &#125;else &#123; // 인증 실패 &#125; 위의 코드를 추가해서 인증이 되었을 때 로그를 확인해보자. Firebase12345678910111213141516171819202122232425262728&lt;script&gt; var auth; // Initialize Firebase var config = &#123; apiKey: \"xxx\", authDomain: \"xxx\", databaseURL: \"xxx\", projectId: \"xxx\", storageBucket: \"xxx\", messagingSenderId: \"xxx\" &#125;; firebase.initializeApp(config); auth = firebase.auth(); var authProvider = new firebase.auth.GoogleAuthProvider(); auth.onAuthStateChanged(function(user)&#123; if ( user) &#123; // 인증 성공 console.log(\"success\"); console.log(user); &#125;else &#123; // 인증 실패 auth.signInWithPopup(authProvider); &#125; &#125;);&lt;/script&gt; 로그를 확인 했으면 위와같이 코드를 수정해서 인증을 실패 했을 때 팝업창이 뜨도록 설정해놓자","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Firebase","slug":"Web-App/Firebase","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Firebase/"}],"tags":[{"name":"firebase","slug":"firebase","permalink":"http://KKimSangHeon.github.io/tags/firebase/"}]},{"title":"2.Firebase 프로젝트 스크립트 적용","slug":"firebase2","date":"2018-09-03T05:35:06.000Z","updated":"2018-09-03T09:35:04.040Z","comments":true,"path":"2018/09/03/firebase2/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/03/firebase2/","excerpt":"","text":"index.html파일을 내려받아 자신의 프로젝트 public 폴더에 붙여넣자 파이어베이스 콘솔창에서 웹 앱 선택 후 스크립트 복사 후 index.html의 스크립트 부분에 복붙 앞으로 구현 할 기능 인증기능을 이용한 구글 호출 구글인증 성공시 메모리스트 출력 실패시 구글창 다시 호출 메모 저장기능 메모 한건 출력기능 메모 수정기능 메모 삭제기능","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Firebase","slug":"Web-App/Firebase","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Firebase/"}],"tags":[{"name":"firebase","slug":"firebase","permalink":"http://KKimSangHeon.github.io/tags/firebase/"}]},{"title":"여행 동영상 기반 SNS개발_2(기술명세)","slug":"hex","date":"2018-09-03T05:29:34.000Z","updated":"2018-09-07T09:32:07.865Z","comments":true,"path":"2018/09/03/hex/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/03/hex/","excerpt":"","text":"개발 내용Part 1. - 현석, 상헌서버 개발서버 &lt;-&gt; 안드로이드(클라이언트) 간 데이터 통신(동영상 전송)서버 &lt;-&gt; 안드로이드 간 동영상 스트리밍 제공 안드로이드(클라이언트) 개발전체 UI 개발안드로이드 &lt;-&gt; 서버 통신 개발안드로이드 킷캣 버전이후로 동작하도록 개발안드로이드 크기와 상관없이 깔끔한 UI가 되도록 개발 DB 개발SNS 기능을 고려, 친구(팔로워) 관리사용자가 좋아요 누른 것들 관리동영상 관리동영상 썸네일 관리 서버기술은 Firebase 기반으로 하되 Android는 자바, 코틀린 중 어느것으로 할지 18/09/08까지 결정 Part 2. - 용호, 웅섭안드로이드(클라이언트) 개발NDK 연동동영상 플레이어 관련 UI 개발 동영상 플레이어 개발동영상 플레이어 라이브러리 활용, 개발기본적인 재생기능되감기 기능카메라로 촬영된 동영상을 읽어와 이미지를 덧씌우는 기능촬영된 동영상을 읽어와 특정 구간으로 끊어서 저장하는 기능 Part 3. - 호인(용호/현석)안드로이드 UI 설계Part 1과 협력하여 안드로이드 전체 UI 설계(카카오 오븐 등으로 구체적인 이미지로 설계할 것, Part 1과 기술적으로 가능한지 검토하면서 진행)간단한 이미지 편집(포토샵 사용 가능하면 좋고, 아니면 무료 이미지 검색) 진행상황 관리프로젝트 일정관리(개별로 한주동안 할 업무량을 측정, 관리)우리 팀 활동 내역 및 진행상황을 블로그/구글드라이브/SNS 등으로 그 내용을 간단하게나마 기록하고 공유하면 좋겠음 -&gt; 추후 기업연계가 가능했으면…돈 관리(모임/책 구매/간식 등)동기부여 및 잔소리(분명 나태해지고…놀다 안함)모임 관리(특정 시간, 장소 등 조사)","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"HEX Team","slug":"Etc/HEX-Team","permalink":"http://KKimSangHeon.github.io/categories/Etc/HEX-Team/"}],"tags":[]},{"title":"1.Firebase 환경설정","slug":"firebase1","date":"2018-09-03T04:31:40.000Z","updated":"2018-09-03T09:35:00.569Z","comments":true,"path":"2018/09/03/firebase1/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/03/firebase1/","excerpt":"","text":"공부내용https://www.inflearn.com/course/파이어베이스-강좌-웹-어플리케이션 의 강좌를 수강하며 나름대로 정리해본것이다. 파이어베이스웹과 모바일 개발에 필요한 기능을 제공하는 백엔드 서비스이다. 보안, 인증, DB설계, API설계등을 프론트 개발자에게 편리하게 제공하는것. firebase.google.com 에 간 후 로그인을 하고 새 프로젝트를 생성한다. Firebase 설치과정12345678910111213141516171819202122232425262728Node.js 설치npm install firebase-tools -g 를 콘솔창에서 입력하여 설치firebase loginY 입력구글로그인하고 승인firebase list 를 입력해서 확인mkdir memoWebcd memoWebfirebase init //firebase 프로젝트 생성스페이스바 누르고 엔터를 입력해 데이터베이스 선택아까 만들어놓았던 프로젝트 선택데이터 베이스 파일이름 입력firebase initHosting 선택public 입력y 입력2018-09-03 오후 02:21 161 database.rule.json2018-09-03 오후 02:22 291 firebase.json2018-09-03 오후 02:22 &lt;DIR&gt; public위의 세개 파일이 생성된것을 확인firebase servehttp://localhost:5000/ 으로 입력이 가능해진다. 개인적인 생각Firebase를 이용하면 많은것을 편리하게 구성하고 쉽게 만들수 있다는 생각이 든다.구글이 왜 구글인지 알 수 있을것같다..","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Firebase","slug":"Web-App/Firebase","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Firebase/"}],"tags":[{"name":"firebase","slug":"firebase","permalink":"http://KKimSangHeon.github.io/tags/firebase/"}]},{"title":"여행 동영상 기반 SNS개발_1(요구사항 분석)","slug":"hex","date":"2018-08-21T17:21:20.000Z","updated":"2018-09-07T09:32:01.424Z","comments":true,"path":"2018/08/22/hex/","link":"","permalink":"http://KKimSangHeon.github.io/2018/08/22/hex/","excerpt":"","text":"A. 주요 Concept여행에 특화된 소셜 네트워크 서비스 짧은 순간순간의 여행. 길고 오래도록 추억하세요. 1분 영상을 통해 현재 여행지를 자랑하고 Best Traveller가 되어보세요. B. 주요 서비스 내용 / 구성도 (Service Flow) 나만의 여행 동영상 갤러리 편리한 영상 편집기능 BEST여행지 추천 및 공유 여행 실시간 현지 분위기 살펴보기 C. 주요 Target 고객 더욱 완벽한 여행을 준비하는, 여행을 공유하고 싶은, 여행을 추억하고 싶은 모든 낭만적인 여행가 여행지의 분위기를 간접 경험하고 싶은 현대인들 D. 서비스 Business Model1.가치a.추억 남기기b.여행 정보 공유c.관광산업 활성화 2.수익 모델a.관광산업(여행사 여행상품, 관광지) 및 비관광산업 광고대행b.인앱(BGM, 재생시간 연장, 워터마크 제거, 고화질 영상 제공, 저장공간 제한) E. 상품 확장 계획 여행경로 공유 네비게이션 길찾기 제공 관광상품과 연계하여 관광지 홍보 (관광이 활성화되지 않은 지역 인지도 향상 효과) 추천 관광지 등에서 다양한 미션 이벤트를 통해 여행지 특화 콘텐츠 제공(ex. 이동 점프샷, 먹방 여행코스 등) Flow chart","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"HEX Team","slug":"Etc/HEX-Team","permalink":"http://KKimSangHeon.github.io/categories/Etc/HEX-Team/"}],"tags":[{"name":"Social Media","slug":"Social-Media","permalink":"http://KKimSangHeon.github.io/tags/Social-Media/"}]},{"title":"학생 등하차 알림 시스템","slug":"project","date":"2018-07-27T14:25:25.000Z","updated":"2018-09-03T05:45:52.539Z","comments":true,"path":"2018/07/27/project/","link":"","permalink":"http://KKimSangHeon.github.io/2018/07/27/project/","excerpt":"","text":"개발배경최근 유아 및 아동들의 등 하차시 발생하는 문제들로 인해 다양한 사회문제들이 발생하고 있다.이를 App을 통해 극복해보고자 개발하였으며 해당 시스템은 NFC칩을 이용하여 학생들의 등하차를 관리하는 시스템이다. 개발현황NFC 등록NFC 인식내부 DB(SQLite)를 활용한 승하차 인원관리 시스템 구축완료태그 리스트 확인화면 구현완료 To Do버스 위치 실시간수신 위한 서버10초 단위로 현재위치 갱신 및 SMS전송 테스트 해당앱은 성능테스트, 기능테스트만 완료하면 되지만 GPS, SNS테스트를 할 폰이 없어서 일단 프로젝트 중단..지금까지 작성한 코드는 아래에서 확인 가능GitHub","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"안드로이드, 등하차시스템","slug":"안드로이드-등하차시스템","permalink":"http://KKimSangHeon.github.io/tags/안드로이드-등하차시스템/"}]},{"title":"임베디드 2","slug":"embedded","date":"2018-07-11T04:46:52.000Z","updated":"2018-09-03T06:02:20.807Z","comments":true,"path":"2018/07/11/embedded/","link":"","permalink":"http://KKimSangHeon.github.io/2018/07/11/embedded/","excerpt":"","text":"캐쉬는 동작방식에 따라Direct Mapping Cache, Associative Mapping Chche, Set Associative Mapping Chche로 나뉜다.세번째가 주로 쓰이는데 세번째는 첫번째 두번째의 혼합형이다. Direct Mapping Cache사용하기 편하고 이해하기 편하다낭비가 심함 Associative Mapping ChcheDirect Mapping Cache의 개선형태DMC보다 Hit rate가 높다.victim선택에 대해 자유롭다.tag를 다 뒤져봐야 한다는점이 단점. 즉 개수가 많을수록 복잡. Set Associative Mapping Chchestatic지역 변수에 static을 사용하면, 전역 변수와 유사하게 변수에 대한 영구적인 저장 공간을 할당한다.static 지역 변수와 전역변수의 차이: static 지역 변수는 해당 블록 안에서만 사용할 수 있다. volatile해당 변수에 대해 컴파일러의 최적화를 막는다.임베디드 프로그래밍이나 멀티쓰레드 프로그래밍에 사용한다. 최적화는 비용절감의 목적으로, 사용하는 메모리의 사용량을 최소화 하면서 성능을 최대화 하고자함.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Embeded C","slug":"Language/Embeded-C","permalink":"http://KKimSangHeon.github.io/categories/Language/Embeded-C/"}],"tags":[]},{"title":"임베디드 1","slug":"embedded","date":"2018-07-09T03:29:07.000Z","updated":"2018-09-03T06:02:18.054Z","comments":true,"path":"2018/07/09/embedded/","link":"","permalink":"http://KKimSangHeon.github.io/2018/07/09/embedded/","excerpt":"","text":"volatile - 최적화 하지마라 ( 어차피 날라갈 값이니까) READ APRINT AREAD APRINT A라는 코드가 있을 때 옵티마이저가 이를 최적화하여READ APRINT APRINT A로 변경하는데 A가 휘발성일경우 문제가 된다. 그래서 위에 VOLATILE를 추가해줘 최적화를 못하도록 명시한다.VOLATILE AREAD APRINT AREAD APRINT A외부의 센서(온도계)등에서 데이터를 가져올 때 같은 경우 사용. 즉 내가 가져오는 시점의 데이터를 활용하고자 할 경우 사용한다. restrict - 최적화 해라 unit8x8_t SIMD를 사용하면 사용할 수 있다. GPU - 일반 프로세서와 구분하기 위해 GPU라 불리는데 주로 그래픽처리에 사용됨(작은 코어가 많다..)SOC - 계산보다는 주변 여러장치를 같이 갖고있다.DSP - 멀티미디어 수식처리의 식을 하나로 만드는것 하드웨어 - Hypervisor - OS RTOS , Resal time Operating System실시간 시스템을 구현 가능한 운영체제우선 순위 기반 스케줄링충분한 개수의 인터럽트 레벨 text data bss dec hex filename8024 32 6072 14128 3730 image text - 기계어로 변경된것들data는 초기화된 전역변수bss는 초기화되지않은 전역변수","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Embeded C","slug":"Language/Embeded-C","permalink":"http://KKimSangHeon.github.io/categories/Language/Embeded-C/"}],"tags":[]},{"title":"std::stringstream aa 불완전한 형식은 사용할 수 없습니다.","slug":"cpperr","date":"2018-06-22T05:21:23.000Z","updated":"2018-09-03T06:02:12.176Z","comments":true,"path":"2018/06/22/cpperr/","link":"","permalink":"http://KKimSangHeon.github.io/2018/06/22/cpperr/","excerpt":"","text":"std::stringstream aa 불완전한 형식은 사용할 수 없습니다.라는 에러 발생할 경우 해당에러의 경우 sstream 을 include 하지 않았을 확률이 높다.1#include &lt;sstream&gt; 을 추가하여 다시 확인해보자","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"C++","slug":"Language/C","permalink":"http://KKimSangHeon.github.io/categories/Language/C/"}],"tags":[{"name":"c++, 에러","slug":"c-에러","permalink":"http://KKimSangHeon.github.io/tags/c-에러/"}]},{"title":"임베디드를 배우기 전 간략한 C 이론 6","slug":"embedded6","date":"2018-06-19T08:20:21.000Z","updated":"2018-09-03T06:02:05.132Z","comments":true,"path":"2018/06/19/embedded6/","link":"","permalink":"http://KKimSangHeon.github.io/2018/06/19/embedded6/","excerpt":"","text":"임베디드를 배우기 전 간략한 C 이론 5 함수포인터를 만들 때 괄호를 추가하는것을 잊지말자.int (*pf)(double, int); 123int temp = 5;void* ptr = &amp;temp; // void 형 포인터: 어떤 변수의 주소값도 저장이 가능한 변수((int*)ptr) = 7; Data 영역 - 전역, staticHeap영역 - 동적할당영역Stack영역- 지역변수, 매개변수 정적할당(배열) - 컴파일 타임에 할당, 접근속도가 빠르다. 코드 유지보수성 낮다(데이터 추가, 삭제)동적할당 - run time(실행타임), 접근속도가 느리다.코드유지보수성이 높다.(데이터 추가 삭제 쉽다.), 메모리 낭비 x, 메모리 자동 해제(x) -&gt;직접해제할것 void *malloc(size_t size);여기서 size_t는 typedef unsigned int size_t 로 보면된다.헤더는 stdlib.h을 불러오면 된다. void pNew = malloc(40); 이 있다고 했을 때 pNew는 힙영역에 할당되는 변수가 아니다. ((int))pNew) = 5; //좋지 않은코드 ((int*)pNew+1) = 7; //좋지 않은코드 int pt = (int)pNew;pt = 5; 또는 pt[0]=5//권장 (pt+1) = 7; 또는 pt[1]=7 //권장 int pNew = (int)malloc(40); 구조체1234struct person&#123; int name[30]; int age;&#125;; 위와 같이 쓸수도 있지만 12345typedef struct &#123; int name[30]; int age;&#125;PER; 보통 이렇게 쓴다.그럼 다음과같이 선언이 가능하다,.PER p1; p1.name =”kim”; //안된다. 문자열 상수이므로. 이해가 안될경우 잘생각해보자. 구조체 멤버변수는 디폴트로 public 구조체에서 “.” 은 구조체 멤버 직접접근연산자12-&gt; 간접접근연산자. 직접접근연산자 구조체는 멤버변수간 패딩바이트를 둬서 구조체의 사이즈를 측정하면 더 크게 나올 수 있다. 구조체 + 포인터변수 구조체 변수를 참조하는 포인터 포인터 변수를 구조체 멤버변수로 포함 (*ptr).age == ptr-&gt;age PER arr[3]; //구조체 배열","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Embeded C","slug":"Language/Embeded-C","permalink":"http://KKimSangHeon.github.io/categories/Language/Embeded-C/"}],"tags":[]},{"title":"임베디드를 배우기 전 간략한 C 이론 5","slug":"embedded4","date":"2018-06-18T08:59:01.000Z","updated":"2018-09-03T06:02:02.084Z","comments":true,"path":"2018/06/18/embedded4/","link":"","permalink":"http://KKimSangHeon.github.io/2018/06/18/embedded4/","excerpt":"","text":"*(pa+0) == pa[0] 포인터 배열 - 포인터를 묶어놓은 배열이다. 더블포인터 - 싱글포인터의 주소를 저장하는 용도로써 사용된다. 12345678910111213int arr_m[3][4] = &#123; &#123;5,6,7,8&#125;, &#123;9,10,11,12&#125;, &#123;13,14,15,16&#125;&#125; //2차원 배열 선언과 동시 초기화int row,col;for (row = 0;row&lt;3; row++)&#123; for(col = 0;col&lt;4;col++) printf(&quot;arr_m[%d][%d]:%d&quot;, row, col, arr_m[row][col]);&#125; 위의 경우에서 arr_m[2] == arr_m+2 == arr_m[2][0] int (pa)[3]; //길이가 3인 int형 2차원 배열을 가르키는 포인터 변수(배열포인터)int pa[3]; //포인터 배열 포인터배열 배열포인터를 헷갈리지 말자배열 포인터는 - 2차원 배열을 가르키는 포인터포인터 배열을 - 포인터를 배열로 만들어 놓은것. char *(str)[50]; 일 때str[0]+1 != str+1좌측은 50만큼 증가하고 우측은 1바이트씩 증가 자료형 앞에 register 을 넣으면 변수가 register 변수에 저장이 된다. 빠르다! static의 생존기간은 전역변수와 같지만 메모리 존재범위은 블록 내에서만! 함수포인터함수명은 함수의 시작주소이다. 함수 포인터를 만드려고 하니int ptr(int a, int b); 와같은 형태가 나왔다,이는 리턴타입이 int 이라는 함수선언과 같으므로괄호를 씌워 int (*ptr)(int a, int b); 로 함수포인터를 만든다. 배열포인터와 유사한 형태로 만들어졌다.배열 포인터 또한 int arr[3] 으로 만들라 했으나 이는 포인터 배열과 일치하므로 괄호를 추가해 int (arr)[3]으로 처리했다.123int Add(int a, int b);int (*ptr)(int a, int b) = Add; 위와같이 사용한다. ptr(2,3) // 간접호출Add(2,3) //직접호출 123456int temp = 5;int * ptr = &amp;temp;void* pv = &amp;temp; //가능하다.*pv = 8; //불가능하다(시작부터 몇바이트를 읽을지는 pv의 자료형으로 판단하는데 몇바이트로 접근해야할지 알 수 없다)*((int*)pv) = 8 //가능 void형 포인터는 모든 변수의 주소값을 저장할 수 있다. 주소값을 표현할 땐 다음과 같이((volatile unsigned int)0x80000000) = 0xFF000000; //나중에 다시한번 배운다. volatile 은 주소값의 데이터가 변경되는것을 막는다.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Embeded C","slug":"Language/Embeded-C","permalink":"http://KKimSangHeon.github.io/categories/Language/Embeded-C/"}],"tags":[]},{"title":"임베디드를 배우기 전 간략한 C 이론 3","slug":"embedded3","date":"2018-06-15T04:19:26.000Z","updated":"2018-09-03T06:01:59.028Z","comments":true,"path":"2018/06/15/embedded3/","link":"","permalink":"http://KKimSangHeon.github.io/2018/06/15/embedded3/","excerpt":"","text":"변수와 상수는 다른것이다.연산자는 사칙연산, 비트연산, 논리연산, 비교연산이 있다.자료형은 char short int float double가 있다. 배열명은 배열의 시작주소를 의미한다.&amp;data[0] == data 배열명은 주소를 바꿀 수 없는 포인터 상수이다. 조건부 컴파일12345#if(0) 1번로직#else 2번로직#endif 2번로직이 실행된다. C 라이브러리 모음http://www.soen.kr/ LR 복귀주소를 저장(함수가 종료되고 다시 시작되어야할 주소)LR들은 스택에 저장되게 되는데 최근 이동해야 할 곳을 가르키고 있는 포인터를 스택 포인터라함.보통 스택이 4단계 이상 쌓이면 설계를 다시해보는것을 고려해 봐야 한다. 1234int Add(int a)&#123; return tmp;&#125; 함수 명 Add가 함수의 시작주소이다. ISR 인터럽트 서비스 루틴 - 특정인터럽트가 발생했을 때 처리해라. 폴링 인터럽트 둘다 이벤트가 발생했을 때 ISR로 가서 처리하고 메인으로 돌아온다.폴링은 함수를 호출해야하고 인터럽트는 호출 없이 서비스 로직이 실행된다. 0 == false == off == 0v == clear == low1 == true == on == 5v == set == high 워치독 타이머 : 컴퓨터의 오작동을 탐지하고 복구하기 위해 쓰이는 전자 타이머이다. 정상 작동 중의 컴퓨터는 시간이 경과하거나 “타임아웃”이 되는 것을 막기 위해, 정기적으로 워치독 타이머를 재가동 시킨다.(내부적으로 소프트웨어를 리셋시키는 타이머) 지역변수 - 해당 함수안에서만 접근, 해당함수 시작과 동시에 메모리에 올라갔다 함수 종료시 소멸된다. 지역변수는 m_를 붙여서 처리하기도 한다. call by value - 복사대입에 의한 호출call by address (pointer) - 포인터를 이용하여 호출call by reference - 참조자를 이용하는것 모든 포인터 변수는 32비트 시스템에서 4바이트로 동일하다","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Embeded C","slug":"Language/Embeded-C","permalink":"http://KKimSangHeon.github.io/categories/Language/Embeded-C/"}],"tags":[]},{"title":"임베디드를 배우기 전 간략한 C 이론 2","slug":"embeded2","date":"2018-06-13T06:54:56.000Z","updated":"2018-09-03T06:01:56.639Z","comments":true,"path":"2018/06/13/embeded2/","link":"","permalink":"http://KKimSangHeon.github.io/2018/06/13/embeded2/","excerpt":"","text":"변수선언-&gt; 자료형 변수명;변수사용-&gt; 변수명오버플러우 : 할당할 수 있는 범위를 넘어선 입력 빅 앤디안 : 낮은 어드레스에 높은 바이트를 넣는다리틀 앤디안 : 낮은 어드레스에 낮은 바이트를 넣는다(ARM, Intel이 사용한다) 내 컴퓨터가 리틀앤디안인지 빅앤디안인지 알아봐라포인터로 한바이트만 읽어서 체크해보자 팬아웃 : 신호가 변질되는것 방지하는것 . 버퍼를 달아서 구현할 수 있다. Not-G (inverter) : 역으로 변경X-Or Gate : 다를 때 참3-State Buffer : B에 신호가 1이여야 A에서 X로 출력됨. B 신호가 0이면 A에서 X로 아무것도 출력되지 않는 고저항상태가 된다. char의 범위 -127~128 비트연산| : 비트 or&amp; : 비트 And~ : 비트 Not&lt;&lt; : 비트 왼쪽시프트 : 비트 오른쪽시프트^ : 비트 xor MSB만 역으로 만들기 위한방법res&amp; = ~(0x01&lt;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Embeded C","slug":"Language/Embeded-C","permalink":"http://KKimSangHeon.github.io/categories/Language/Embeded-C/"}],"tags":[{"name":"c, embedded","slug":"c-embedded","permalink":"http://KKimSangHeon.github.io/tags/c-embedded/"}]},{"title":"임베디드를 배우기 전 간략한 C 이론 1","slug":"embeded","date":"2018-06-11T14:53:29.000Z","updated":"2018-09-03T06:03:44.366Z","comments":true,"path":"2018/06/11/embeded/","link":"","permalink":"http://KKimSangHeon.github.io/2018/06/11/embeded/","excerpt":"","text":"컴파일 : 컴퓨터가 아는 언어로 변경하는것 원시코드를 오브젝트로 (syntax에러 확인)컴파일러 : 이를 실행시켜주는것링커 : 라이브러리를 묶어주고 실행파일을 만든다. 전처리기 : 컴파일 전에 처리 함수는 라이브러리, 사용자 정의 함수로 나뉜다. 함수는 함수원형, 호출, 정의부로 나뉘는데 원형은 함수의 뼈대라고 보면 되고 , 정의는 함수의 동작을 정의한는 부분으로 보면된다. int main(int argc, char * argv[])argc는 - arg counter 로 생각하자두번째 포인터 배열이지만 더블포인터로 볼 수 있다. 메인함수의 경우 vs에서 return을 하지 않을경우 에러가 발생하지 않는데 이는 잘못된것이다.리턴타입이 int인데 return이 없는것은 잘못된것을 알고있자. 반환형이 void인 함수의 return은 함수의 종료를 의미한다. return은 함수의 값 반환, 함수의 종료역할을 한다. ARM 프로세서에는byte(1byte) / half-word(2byte) / word(4byte) 이란게 있다. 일단 알아만 두자123if ( temp = 5) &#123; ...&#125; 위와같은 코드는 절대 짜지말자. if문이 뭐 저래 헷갈릴수 있는 개념더블 포인터 - 포인터의 주소를 저장하는 변수포인터배열 - 포인터를 모아놓은 포인터배열포인터 - 2차원 배열의 조소를 저장해놓은 변수함수포인터 - 함수의 주소를 저장해 놓은 변수구조체 - 다른 형태의 변수를 배열처럼 저장하기 위해 만들었다. 서식문자%d - 정수%c - 문자%s - 문자열%f - float 자료형%lf - double형 자료형%u - unsigned%x - hex","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Embeded C","slug":"Language/Embeded-C","permalink":"http://KKimSangHeon.github.io/categories/Language/Embeded-C/"}],"tags":[{"name":"c, embedded","slug":"c-embedded","permalink":"http://KKimSangHeon.github.io/tags/c-embedded/"}]},{"title":"string does not name a type","slug":"cpperror6","date":"2018-05-07T05:22:47.000Z","updated":"2018-09-03T06:01:29.738Z","comments":true,"path":"2018/05/07/cpperror6/","link":"","permalink":"http://KKimSangHeon.github.io/2018/05/07/cpperror6/","excerpt":"","text":"12분명히 string을 include 했을때도 발생한다면 namespace를 붙여줬는지 확인해보자아니면 using namespace std; 을 선언하자","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"C++","slug":"Language/C","permalink":"http://KKimSangHeon.github.io/categories/Language/C/"}],"tags":[{"name":"c++, 에러","slug":"c-에러","permalink":"http://KKimSangHeon.github.io/tags/c-에러/"}]},{"title":"conflicting declaration ‘std::string tempJsonData’","slug":"cpperror5","date":"2018-05-07T05:22:17.000Z","updated":"2018-09-03T06:01:25.043Z","comments":true,"path":"2018/05/07/cpperror5/","link":"","permalink":"http://KKimSangHeon.github.io/2018/05/07/cpperror5/","excerpt":"","text":"1변수명이 겹치는것이 존재하는경우 발생하는 에러이다.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"C++","slug":"Language/C","permalink":"http://KKimSangHeon.github.io/categories/Language/C/"}],"tags":[{"name":"c++, 에러","slug":"c-에러","permalink":"http://KKimSangHeon.github.io/tags/c-에러/"}]},{"title":"분명히 inlcude를 했는데  was not declared in this scope 라고 뜨는경우","slug":"cpperror4","date":"2018-05-07T05:20:20.000Z","updated":"2018-09-03T06:01:26.170Z","comments":true,"path":"2018/05/07/cpperror4/","link":"","permalink":"http://KKimSangHeon.github.io/2018/05/07/cpperror4/","excerpt":"","text":"12345이 경우 다른 파일의 헤더와 겹치는 경우일 수 있다.#ifndef _AA_H#define _AA_H 라고 헤더를 정의했을 때 다른파일도 헤더를 AA로 선언했을 가능성이 높다.무분별한 복붙을 지양하자..","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"C++","slug":"Language/C","permalink":"http://KKimSangHeon.github.io/categories/Language/C/"}],"tags":[{"name":"c++, 에러","slug":"c-에러","permalink":"http://KKimSangHeon.github.io/tags/c-에러/"}]},{"title":"no matching function for call to ‘~~~, <unresolved overloaded function type>, ~~~)’","slug":"cpperror3","date":"2018-05-07T05:20:12.000Z","updated":"2018-09-03T06:01:19.306Z","comments":true,"path":"2018/05/07/cpperror3/","link":"","permalink":"http://KKimSangHeon.github.io/2018/05/07/cpperror3/","excerpt":"","text":"함수 호출부의 2번째 인자를 확인해보자 대표적으로 값을 반환하는 함수를 호출하는데 ()를 붙이지 않았을 경우 발생","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"C++","slug":"Language/C","permalink":"http://KKimSangHeon.github.io/categories/Language/C/"}],"tags":[{"name":"c++, 에러","slug":"c-에러","permalink":"http://KKimSangHeon.github.io/tags/c-에러/"}]},{"title":"definition of implicitly-declared ‘DataBuffer::DataBuffer()’ 에러","slug":"cpperror2","date":"2018-05-06T13:47:39.000Z","updated":"2018-09-03T06:01:16.928Z","comments":true,"path":"2018/05/06/cpperror2/","link":"","permalink":"http://KKimSangHeon.github.io/2018/05/06/cpperror2/","excerpt":"","text":"헤더파일에 해당 생성자를 선언하지 않았을 경우 발생 생성자를 다시한번 살펴보자","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"C++","slug":"Language/C","permalink":"http://KKimSangHeon.github.io/categories/Language/C/"}],"tags":[{"name":"c++, 에러","slug":"c-에러","permalink":"http://KKimSangHeon.github.io/tags/c-에러/"}]},{"title":"‘size_t’ does not name a type 에러가 발생했을 때","slug":"cpperror","date":"2018-05-05T13:19:09.000Z","updated":"2018-09-03T06:01:11.099Z","comments":true,"path":"2018/05/05/cpperror/","link":"","permalink":"http://KKimSangHeon.github.io/2018/05/05/cpperror/","excerpt":"","text":"123456다음중 아무거나 include하자Defined in header &lt;cstddef&gt; Defined in header &lt;cstdio&gt; Defined in header &lt;cstring&gt; Defined in header &lt;ctime&gt; Defined in header &lt;cwchar&gt;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"C++","slug":"Language/C","permalink":"http://KKimSangHeon.github.io/categories/Language/C/"}],"tags":[{"name":"c++, 에러","slug":"c-에러","permalink":"http://KKimSangHeon.github.io/tags/c-에러/"}]},{"title":"터미널을 종료해도 서버가 켜져있도록 유지","slug":"angular","date":"2018-05-01T08:46:42.000Z","updated":"2018-09-03T06:01:02.191Z","comments":true,"path":"2018/05/01/angular/","link":"","permalink":"http://KKimSangHeon.github.io/2018/05/01/angular/","excerpt":"","text":"터미널을 종료해도 서벼가 켜져있도록 유지하는 방법 npm으로 forever을 설치 후12forever start node_modules/@angular/cli/bin/ng serve --host=0.0.0.0forever stopall","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Angular2","slug":"Web-App/Angular2","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Angular2/"}],"tags":[{"name":"Angular2","slug":"Angular2","permalink":"http://KKimSangHeon.github.io/tags/Angular2/"},{"name":"Web","slug":"Web","permalink":"http://KKimSangHeon.github.io/tags/Web/"}]},{"title":"C++ 함수에서의 참조자의 활용","slug":"cpp1","date":"2018-04-15T23:19:55.000Z","updated":"2018-09-03T06:03:06.648Z","comments":true,"path":"2018/04/16/cpp1/","link":"","permalink":"http://KKimSangHeon.github.io/2018/04/16/cpp1/","excerpt":"","text":"","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"C++","slug":"Language/C","permalink":"http://KKimSangHeon.github.io/categories/Language/C/"}],"tags":[{"name":"c++, 참조자","slug":"c-참조자","permalink":"http://KKimSangHeon.github.io/tags/c-참조자/"}]},{"title":"OpenCV 설치","slug":"opencv-exam1","date":"2018-04-04T23:23:32.000Z","updated":"2018-09-03T06:00:42.038Z","comments":true,"path":"2018/04/05/opencv-exam1/","link":"","permalink":"http://KKimSangHeon.github.io/2018/04/05/opencv-exam1/","excerpt":"","text":"http://webnautes.tistory.com/1030참고로 나는 마지막 pkg_config 관련해서 vi ~/.bash_profile을 입력후export PKG_CONFIG_PATH=”$LIB_DIR/opencv/lib64/pkgconfig” 을 입력했다 컴파일 방법g++ -o facedetect facedetect.cpp $(pkg-config –libs –cflags opencv)g++ -o facedetect facedetect.cpp ‘pkg-config –libs –cflags opencv’ 참고할만한 예제http://hanmin-dev.tistory.com/13 (이미지의 픽셀 RGB 구하는법 알려줌 Makefile 구성방법 알려줌)http://eehoeskrap.tistory.com/34?category=537364 ( 픽셀 소금뿌리기)","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"}],"tags":[]},{"title":"리눅스 개인폴더에 설치된 디렉토리 사용하기","slug":"linux-bash-profile","date":"2018-03-29T23:29:17.000Z","updated":"2018-09-03T06:00:55.200Z","comments":true,"path":"2018/03/30/linux-bash-profile/","link":"","permalink":"http://KKimSangHeon.github.io/2018/03/30/linux-bash-profile/","excerpt":"","text":"서버에 curl이 설치되어 있고 내 로컬에도 curl이 설치되어 있을 때 내 curl을 사용하기 위한 방법 vi ~/.bash_profile을 열고 아래를 입력하고 export CURL_DIR=”$HOME/apps/usr/curl/bin”export PATH=$CURL_DIR:$PATH source ~/.bash_profile을 입력 curl -V를 통해 잘 적용되었나 확인","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"}]},{"title":"아파치 모듈추가","slug":"apache-add-module","date":"2018-03-23T11:39:06.000Z","updated":"2018-09-03T06:00:26.880Z","comments":true,"path":"2018/03/23/apache-add-module/","link":"","permalink":"http://KKimSangHeon.github.io/2018/03/23/apache-add-module/","excerpt":"","text":"아파치 모듈 추가/home/sangheon/apps/apache 이라는 경로에 아파치가 설치되어있다고 가정. ./apxs -n modulename -g 로 모듈추가. 그럼 현재 위치(bin)에 modulename디렉토리가 생성된다. /home/sangheon/apps/apache/conf 경로로 이동하여 httpd.conf를 열자 약 150라인 정도 다음을 추가하자.LoadModule modulename_module modules/mod_modulename.so &lt;Location /modulename&gt; SetHandler modulename &lt;/Location&gt;위의 내용은 mod_modulename.c 파일을 참고하여 작성가능 /home/sangheon/apps/apache/bin 디렉토리에 이동하여 ./apxs -c -i /home/sangheon/apps/apache/bin/modulename/mod_modulename.c 를 입력하자. 여기서 특정 라이브러리를 이용할 경우 뒤에 -l라이브러리 이름을 입력하자. curl을 이용할 경우 -lcurl을 입력 bin 디렉토리에서./apachectl restart 입력 만약 c 파일을 수정했을 경우엔 4번 5번을 다시 실행하면 된다.권한문제(sudo permission)로 서버를 실행시킬 수 없을 때 다음과 같이 입력하자.sudo /bin/chown root.sangheon /home/sangheon/apps/apache/bin/httpd sudo /bin/chmod 4755 /home/sangheon/apps/apache/bin/httpd","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"}],"tags":[{"name":"아파치 모듈추가","slug":"아파치-모듈추가","permalink":"http://KKimSangHeon.github.io/tags/아파치-모듈추가/"}]},{"title":"","slug":"mytip","date":"2018-03-19T15:00:00.000Z","updated":"2018-04-10T23:50:46.417Z","comments":true,"path":"2018/03/20/mytip/","link":"","permalink":"http://KKimSangHeon.github.io/2018/03/20/mytip/","excerpt":"","text":"vi 관련 코드 정렬하기ggvG=gg는 파일 처음으로이동하고v는 비쥬얼 모드로 전환하고G는 끝까지 드래그=는 정렬 함수 정의를 찾아가고싶을 때ctag 를 사용하자http://bowbowbow.tistory.com/15 ~/.vimrcset hlsearchset nuset autoindentset scrolloff=2set wildmode=longest,listset ts=4set sts=4set sw=1set autowriteset autoreadset cindentset bs=eol,start,indentset history=256set laststatus=2set shiftwidth=4set showmatchset smartcaseset smarttabset smartindentset softtabstop=4set tabstop=4set rulerset incsearchhighlight Comment term=bold cterm=bold ctermfg=4set tags=/home1/irteam/sangheon/getimage/tags","categories":[],"tags":[]},{"title":"2장. 규칙3 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계해라","slug":"effectiveJava4","date":"2018-03-18T23:00:36.000Z","updated":"2018-09-03T06:00:13.303Z","comments":true,"path":"2018/03/19/effectiveJava4/","link":"","permalink":"http://KKimSangHeon.github.io/2018/03/19/effectiveJava4/","excerpt":"","text":"규칙3 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계해라싱글턴 : 객체를 하나만 만들 수 있는 클래스. 창관리자, 파일 시스템 같은 것들이 그 예다. 싱글턴을 구현하는 방법은 두가지인데 두 방법 다 생성자는 private로 선언하고, 싱글턴 객체는 정적(static)멤버를 이용한다. 첫번째 방법의 경우 정적멤버는 final로 선언한다. 두 번째 방법은 public으로 선언된 정적 팩터리 메서드를 이용하는 것이다. 두 방법 다 리플렉션 기능을 통해 private 생성자를 호출할 수 있다는 점에 주의해야 한다. 싱글턴을 구현하는 또다른 한가지의 방법은 원소가 하나뿐인 enum 자료형을 정의하는 것이다. 이는 좀 더 간결하며, 직렬화가 자동으로 처리된다. 또한 직렬화가 복잡하게 이루어져도 여러 객체가 생길일이 없으며 리플렉션을 통한 공격에도 안전하다. 책에서는 이 방법이 싱글턴을 구현하는 가장 좋은 방법이라 추천한다. 참고 URL직렬화 : http://woowabros.github.io/experience/2017/10/17/java-serialize.html","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"2장. 규칙2 생성자 인자가 많을 때는 Builder 패턴 적용을 고려하라.","slug":"effectiveJava3","date":"2018-03-15T10:27:56.000Z","updated":"2018-09-03T06:00:10.984Z","comments":true,"path":"2018/03/15/effectiveJava3/","link":"","permalink":"http://KKimSangHeon.github.io/2018/03/15/effectiveJava3/","excerpt":"","text":"규칙2. 생성자 인자가 많을 때는 Builder 패턴 적용을 고려하라.보통 생성자의 인자 혹은 정적팩터리의 인자가 많을 땐 점층적 생성자 패턴(telescping constructor pattern)을 적용한다. 17p점층적 생성자 패턴 : 필수인자만 받는 생성자를 하나 정의하고, 선택적 인자를 하나 받는 생성자를 추가하고, 거기에 두 개의 선택적 인자를 받는 생성자를 추가하는 식으로 생성자들을 쌓아 올리듯 추가하는 것. 하지만 점층적 생성자 패턴은 설정할 필요가 없는 필드에도 인자를 전달해야하는 경우가 생긴다. 즉 인자수가 늘어나면 클라이언트 코드를 작성하기 어려워지고 읽기 어려워진다. 생성자의 인자가 많을 때 사용할 수 있는 두번째 방법은 자바빈(JavaBeans) 패턴이다. 18p자바빈 패턴: 인자없는 생성자를 호출하여 객체부터 만든 다음, 설정메서드(setter)들을 호출하여 필수 필드뿐아니라 선택적 필드값 까지 채우는 것이다. 자바빈 패턴은 1회의 함수 호출로 객체 생성을 끝낼 수 없으므로 객체 일관성이 일시적으로 깨질 수 있다. 또한 변경 불가능(immutable)클래스를 만들 수 없다는점, 스레드 안정성을 제공하기 위해 해야할 일도 많아진다. 점층적 생성적 생성자 패턴의 안정성 , 자바빈 패턴의 가독성을 결합한 것이 바로 빌더(Builder)패턴이다.필요한 객체를 직접 생성하는 대신 클라이언트는 먼저 필수인자들을 생성자 또는 정적 팩터리 메서드에 전부 전달하여 빌더객체(Builder object)를 만든다. 그런 다음 빌더 객체에 정의된 설정 메서드들을 호출하여 선택적 인자들을 추가 해 나간다. 그리고 마지막으로 아무런 인자 없이 build 메서드를 호출하여 변경 불가능 객체를 만든다. 빌더패턴의 장점 작성하기 쉽고, 읽기 쉽다. 인자에 불변식(invariant)을 적용할 수 있다. 여러개의 varargs 인자(가변인자)를 받을수 있다. 하나의 빌더 객체로 여러 객체를 만들 수 있어 유연하다. 빌더패턴의 단점 객체를 생성하기 위해 빌더 객체를 생성해야한다. 오버헤드의 문제가 될 소지는 적지만 성능이 중요한 상황에서는 문제가 될 수 있다. 요약하자면대부분의 인자가 선택적 인자이거나 인자가 많은 생성자나 정적 팩터리가 필요한 클래스를 설계할 때 유용하다. 가독성은 점층적 생성자 패턴보다 향상되며 자바빈을 사용할 때 보다 안전하다.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"2장. 규칙1 생성자 대신 정적 팩터리 메서드를 사용할 수 없는지 생각해보자.","slug":"effectiveJava2","date":"2018-03-13T22:53:39.000Z","updated":"2019-03-24T04:04:49.459Z","comments":true,"path":"2018/03/14/effectiveJava2/","link":"","permalink":"http://KKimSangHeon.github.io/2018/03/14/effectiveJava2/","excerpt":"","text":"규칙 1. 생성자 대신 정적 팩터리 메서드를 사용할 수 없는지 생각해보자.프로그래머가 알아야하는 또다른 객체생성 방법은 클래스에 public로 선언된 팩토리 메서드를 추가하는 것이다. 이러한 방법의 장점은 다음과 같다.1.생성자와 달리 정적 팩토리 메소드에는 이름이 있다. (가독성 향상) 2.호출할 때마다 새로운 객체를 생성할 필요 없다.(객체생성 비용이 클 때 효율적, 개체 통제 클래스로의 역할)개체 통제 클래스(instance-controlled class) : 어떤 시점에 어떤 객체가 얼마나 존재할지 제어가능한 클래스. 이를 통해 싱글턴 패턴을 따르도록 할수 있고, 객체생성이 불가능한 클래스를 만들 수 도 있다. 변경이 불가능한 클래스의 경우 두개의 같은 객체가 존재하지 못하도록 할 수 있다. 3.생성자와 달리 반환값 자료형의 하위 자료형 객체를 반환할 수 있다. (반환되는 객체의 클래스를 유연하게 결정 가능. EnumSet이 그 예시)이를 통해 public으로 선언되지 않은 클래스의 객체를 반환하는 API를 만들 수 있다. 4.형인자 자료형(parameterized type) 객체를 만들 때 편하다.(자바 1.7부터는 자료형 유추가 가능해졌다 14p)즉123public static &lt;K,V&gt; HashMap&lt;K, V&gt; newInstance() &#123; return new HashMap&lt;K,V&gt;();&#125;newInstance() 메소드를 통해 Map","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"Effective Java","slug":"effectiveJava1","date":"2018-03-12T13:49:17.000Z","updated":"2018-09-03T06:03:44.367Z","comments":true,"path":"2018/03/12/effectiveJava1/","link":"","permalink":"http://KKimSangHeon.github.io/2018/03/12/effectiveJava1/","excerpt":"","text":"워낙 유명한 이책을 한번쯤 보고싶다는 생각을 했었고 이제서야 이 책을 읽으며 스스로 정리한 내용을 잊지 않기위해 블로그에 올려 공유하고자 한다.다음은 이 책을 읽기위해 알아두자. 1. 자바는 네 가지 유형의 자료형을 지원한다. 인터페이스(어노테이션 포함) 클래스(enum 포함) 배열 기본 자료형(primitive)여기서 위의 3개는 참조 자료형(reference type)으로 알려져있으며 모든 개체(instance)와 배열은 객체(object)이다. 하지만 기본 자료형은 객체가 아니다. 클래스의 멤버로는 필드(field), 메서드(method), 멤버 클래스(member class), 그리고 멤버 인터페이스(member interface) 등이 있다. 메서드의 시그니처(signature)는 그 이름과 형식 인자 자료형들로 구성된다. 시그니처에는 메서드의 반환값 자료형은 포함되지 않는다.메소드 시그니처란 : 메소드의 이름과 매개변수 목록 2. 자바 언어 명세서의 정의를 따르지 않는 것들 계승(inheritance)라는 용어를 하위 클래스 정의(subclassing)와 같은 뜻으로 사용한다. 인터페이스에는 계승이라는 용어 대신, 클래스가 인터페이스를 구현(implements)한다고 하거나, 한 인터페이스가 다른 인터페이스를 확장(extends)한다고 표현한다. 접근권한을 명시하지 않았을 때 가능한 접근 수준을 표현할 때는 기본 접근 권한 (default access)대신 의미가 분명한 package-private라는 용어를 사용한다. 3. API 관련 API를 사용해 프로그램을 작성하려는 프로그래머는 API의 사용자(user)라고 지칭한다. 어떤 API를 사용해 구현된 클래스는 API의 클라이언트(client)라고 부른다.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"리눅스마스터 2급","slug":"linuxmaster","date":"2018-03-07T14:51:28.000Z","updated":"2018-09-03T05:59:56.927Z","comments":true,"path":"2018/03/07/linuxmaster/","link":"","permalink":"http://KKimSangHeon.github.io/2018/03/07/linuxmaster/","excerpt":"","text":"취득시기2018년 03월 내용데비안, 레드햇 계열 리눅스의 기본적인 역사 그리고 간단한 명령어 정도만 알고있을 경우 일주일 정도면 취득가능하다. www.comcbt.com/ 에서 연도별 문제를 제공하며 총 5회분의 문제(약 400문제)정도를 풀어보고 시험을 봤었다. 용산공업고등학교에서 시험을 봤으며 학교의 정문을 찾는데 애를 먹었던것 말고는 불편했던점은 없다. 하루 2시간씩 약 일주일동안 공부하였으며 시험 3일 후엔 가답안이 나와 가채점이 가능하다는 것이 다른 자격증에 비해 좋았던것 같다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"자격증","slug":"Etc/자격증","permalink":"http://KKimSangHeon.github.io/categories/Etc/자격증/"}],"tags":[{"name":"자격증","slug":"자격증","permalink":"http://KKimSangHeon.github.io/tags/자격증/"},{"name":"리눅스마스터 2급","slug":"리눅스마스터-2급","permalink":"http://KKimSangHeon.github.io/tags/리눅스마스터-2급/"}]},{"title":"6장. 모듈","slug":"angular2-1","date":"2018-01-28T12:03:56.000Z","updated":"2018-09-03T05:59:49.550Z","comments":true,"path":"2018/01/28/angular2-1/","link":"","permalink":"http://KKimSangHeon.github.io/2018/01/28/angular2-1/","excerpt":"","text":"6장. 모듈앵귤러 애플리케이션을 구성하는 뼈대와 같은 역할. @NgModule 장식자를 이용한다import {Component} from ‘@angular/core’;와 같이 이용하는데 Component는 사용할 모듈이고, @angular/core는 패키지이다. 라이브러리 모듈 147p앵귤러가 제공하는 모듈. ex) 지시자, 파이프, 장식자, 클래스, 인터페이스, 함수, Enum, 타입 별칭(type alias), 상수 사용자 정의 모듈 147p컴포넌트나 지시자와 같이 장식자를 이용한 모듈과 서비스와 함수 값과 같이 장식자가 없는 모듈로 구분됨.외부로 공개할 모듈은 export를 이용해 선언(ES6부터 지원) 애플리케이션 루트 모듈 149p앵귤러는 애플리케이션 루트 모듈이라는 최상위 모듈을 통행 애플리케이션 모듈을 구성한다. 하지만 이 안에 모든 모듈을 구성할 수 없기 떄문에 의미론적으로 - 특징모듈 (개별 컴포넌트 단위가 아닌 단위 애플리케이션을 구성하는 모듈) 공유모듈 (다른 모듈에 포함되어 동작하는 모듈 (반복적으로 선언되는 모듈)) 핵심모듈 (애플리케이션에서 항상 동작할 필요가 있거나 애플리케이션의 전체적인 동작에 핵심적인 역할을 하는 모듈(ex) 타이틀 컴포넌트)로 나눔. 애플리케이션 루트 모듈은 @Ngmodule 장식자를 이용해 정의한다.123456@Ngmodule(&#123; imports : [BrowserModule, CommonModule, FormsModule ...] , providers : [] , declarations : [AppComponent, ...] bootstrap : [AppComponent] &#125;) @Ngmodule내 import영역브라우저 모듈(BrowserModule) 151p브라우저 모듈은 앵귤러가 브라우저에서 동작한다면 반드시 포함되어야함. 지시자, 파이프 같은 구성요소를 템플릿에 나타나게 하는 역할을 함.브라우저 모듈은 공통 모듈을 재노출(re-exports) 한다는 것이다. 이 때문에 브라우저 모듈을 이미 선언했다면 공통 모듈을 선언하지 않아도 된다. 공통모듈(CommonModule) 151p템플릿에서 사용하는 ngIf나 ngFor와 관련된 기능을 포함하고 있는 모듈이다. 폼모듈(FormsModule) 152p템플릿에서 자주 사용하는 NgModel지시자나 내장 검증기 지시자 등을 포함하고 있다. 그래서 폼 모듈을 포함하면 NgModel과 같이 자주 사용하는 지시자를 별도로 추가하지 않아도 된다. AppRoutingModule 152p사용자가 정의할 수 있는 라우팅 모듈이다. 애플리케이션 루트 모듈에 추가한 라우팅모듈은 애플리케이션 수준에서 라우팅을 수행한다. @Ngmodule내 provider영역애플리케이션 전역에서 사용할 서비스를 등록. @Ngmodule내 declarations영역애플리케이션 레벨에서 사용하고자 하는 컴포넌트, 지시자 파이프를 선언한다. @Ngmodule내 bootstrap영역최상위 컴포넌트인 애플리케이션 컴포넌트를 등록 router-outlet 152p하위 특정 컴포넌트로 라우팅 후 하위 컴포넌ㅌ를 표시할 목적으로 라우터 아룰렛 지시자를 포함한다. 라우터 아울렛에 표시할 컴포넌트가 있다면 애플리케이션 라우팅 모듈 설정에 등록한다. 12345678910const appRoutes:Routes = [ &#123; path: &apos;&apos;, component: IntroComponet&#125;, &#123; path: &apos;hello&apos;, component: HelloComponent&#125;, ...];@NgModule(&#123; imports: [RouterModule.forRoot(appRoutes)], exports:[RouterModule] &#125;) appRoutes 변수는 라우팅 설정을 담고 있으며 입력 URL에 대응하는 컴포넌트로 라우팅 되게 한다. appRoutes변수는 forRoot() 메소드를 이용해 등록한다. 유의할 점은 애플리케이션 라우팅 모듈에서만 한 번만 사용돼야 하고 특징 모듈에서는 사용하면 안된다. 애플리케이션 루트모듈에서는 다음과 같이 inports를 해줘야 한다.12@Ngmodule(&#123; imports : [AppRoutingModule ...] , 핵심모듈 155p앵귤러 어플리케이션 관점에서 핵심이 되는 모듈로 애플리케이션 루트 모듈에 한번 설정함을써 애플리케이션 레벨에서 사용할 수 있는 모듈을 말한다. 루트 모듈에 등록됐다는 것은 애플리케이션이 시작될 때 처음 한 번만 호출해서 전역으로 사용하겠다는 의미이다. 대표 예로 타이틀 컴포넌트가 있다. 보통 핵심 모듈은 /app/core에 위치시킨다. 특징모듈 161p모듈이 많아지면 모듈 구성이 복잡해지며 지시자의 이름충돌 등의 문제가 발생할 수 있다. 이를 방지하기 위해 애플리케이션 루트 모듈에서 하위 모듈로 분리하는 것을 특징 모듈이라 한다. 특징 모듈에 선언한 모듈은 다른 모듈에 노출하거나 숨길수도 있다. 추가예정..","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Angular2","slug":"Web-App/Angular2","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Angular2/"}],"tags":[{"name":"Angular2","slug":"Angular2","permalink":"http://KKimSangHeon.github.io/tags/Angular2/"},{"name":"Web","slug":"Web","permalink":"http://KKimSangHeon.github.io/tags/Web/"}]},{"title":"5장. 서비스","slug":"angular2","date":"2018-01-28T12:02:55.000Z","updated":"2018-09-03T05:59:52.611Z","comments":true,"path":"2018/01/28/angular2/","link":"","permalink":"http://KKimSangHeon.github.io/2018/01/28/angular2/","excerpt":"","text":"5장. 서비스앵귤러JS(앵귤러2아님)에서는 기능을 컨트롤러에서 분리하기 위해 서비스 메소드를 써야할지 팩토리 메소드를 써야할지 혼란이 있었으나 2에서는 팩토리와 서비스를 서비스로 단일화 하였고 메소드에서 클래스로 변경하였다.서비스는 공통관심사를 묶어놓았다.provider제공자 그리고 @Injectable() 장식자 이용 서비스 특징 서비스는 의존성 주입이 가능하다. 132p 객체지향적으로 이용가능 목 객체 서비스로 이용가능(서버,외부의 의존성없이 테스트 코드 작성할 때 유용) 135p 프로미스 서비스 (콜백헬과같은 비정상적인 호출형태를 개선하기 위해 나옴) 138p 서비스를 이용한 데이터 교환 가능(부모는 provider 설정을 해줘야하지만 자식은 안한다)","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Angular2","slug":"Web-App/Angular2","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Angular2/"}],"tags":[{"name":"Angular2","slug":"Angular2","permalink":"http://KKimSangHeon.github.io/tags/Angular2/"},{"name":"Web","slug":"Web","permalink":"http://KKimSangHeon.github.io/tags/Web/"}]},{"title":"유용한 사이트 모음","slug":"usefulsite","date":"2018-01-27T13:41:25.000Z","updated":"2018-02-12T23:34:32.218Z","comments":true,"path":"2018/01/27/usefulsite/","link":"","permalink":"http://KKimSangHeon.github.io/2018/01/27/usefulsite/","excerpt":"","text":"알고리즘, 코딩관련https://app.codility.com/programmers/lessons/1-iterations/ 트렌드 분석https://trends.google.com/trends/?hl=ko검색어를 입력하여 해당검색어에 대한 연관이슈 등에 대해 알 수 있다.. IT 관련http://www.itfind.or.kr/IT 관련 이슈를 접할 수 있으며 정기간행물또한 유용하다. 면접","categories":[],"tags":[]},{"title":"4장. 컴포넌트","slug":"angular2","date":"2018-01-15T14:22:50.000Z","updated":"2018-09-03T05:59:39.137Z","comments":true,"path":"2018/01/15/angular2/","link":"","permalink":"http://KKimSangHeon.github.io/2018/01/15/angular2/","excerpt":"","text":"4장. 컴포넌트컴포넌트앵귤러에서 화면하는 구성하는 중요한 구성요소이다. 웹 컴포넌트HTML , CSS, 자바스크립트를 하나의 단위로 묶어주는 기술이다. 웹 컴포넌트 기술은 하나의 기능이 아니라 여러가지 기술들이 합쳐져 하나의 웹 컴포넌트를 구성 웹 컴포넌트는 앵귤러2 컴포넌트의 기반기술이다 앵귤러 2 컴포넌트는 웹 컴포넌트의 기술요소를 기반으로 하므로 웹 컴포넌트를 이해하면 앵귤러 컴포넌트를 이해하는 데 도움된다. HTML 템플릿 템플릿 호출 쉐도우 DOM 커스텀 엘리먼트 중첩컴포넌트 85p부모 컴포넌트가 여러 자식컴포넌트를 포함하는 경우 컴포넌트 트리 86p평면적으로 나열된 컴포넌트가 어떤 포함 관계를 가지는지 알수있게 해줌 컴포넌트 기반 개발 87p컴포넌트를 개발의 중심에 두고 개발하는것. 컴포넌트 89p컴포넌트 내부는 크게 import 영역, @Component 장식자(selector, template, styles로 구성됨), 컴포넌트 클래스 영역으로 나뉜다. 부모가 자식한테 값 전달부모가 속성바인드를 통해 값을 전달하면 자식이 값을 받는 방법은 2가지가 있다. @input 장식자 99p외부에서 전달된 값을 받기 위해 사용하는 장식자 inputs 102p부모가 name1, name2 속성으로 어떠한 값을 전달하면 자식은 @Component장식자 안에 inputs:[‘name1’,’name2’]로 값을 받을 수 있다. 자식의 클래스에서도 name1, name2를 지정해줘야함 자식이 부모한테 값 전달 103p@Output 장식자로 선언한 변수를 EventEmitter로 초기화한다. 그리고 부모에게 보낼 시점이 되면 emit()메소드를 사용해 부모로 이벤트를 전달한다. @ViewChild 장식자 107p화면 DOM에 접근해 첫 번째로 위치한 지시자의 내부 상태(지시자의 속성값)나 정보(컴포넌트 지시자의 경우 내부 메서드)를 가져온다 @ViewChildren 장식자 109p@ViewChild는 하나의 엘리먼트 상태를 갖고왔지만 @ViewChildren 장식자는 여러 지시자의 상태를 한번에 취할 수 있다. @ContentChild 장식자 112p콘텐츠 DOM을 탐색해 지시자 엘리먼트의 상태를 QueryList에 담는 역할을 한다. @ContentChildren 장식자 114p컴포넌트 내부에 위치한 엘리먼트나 지시자에 정보를 담고 있는 쿼리리스트를 얻는다. 쉐도우 DOM의 선택자 118p그냥 styles:[‘span{font-style}’] 이런식으로 하면 해당 컴포넌트의 span만 적용된다. 이를 범위를 넓히거나 좁힐때 사용하는것이 쉐도우 DOM의 선택자이다.1.:host 선택자2.:host-context 선택자3.:deep 선택자","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Angular2","slug":"Web-App/Angular2","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Angular2/"}],"tags":[{"name":"Angular2","slug":"Angular2","permalink":"http://KKimSangHeon.github.io/tags/Angular2/"},{"name":"Web","slug":"Web","permalink":"http://KKimSangHeon.github.io/tags/Web/"}]},{"title":"마인즈랩","slug":"interview6","date":"2018-01-13T13:31:35.000Z","updated":"2018-09-03T05:59:32.994Z","comments":true,"path":"2018/01/13/interview6/","link":"","permalink":"http://KKimSangHeon.github.io/2018/01/13/interview6/","excerpt":"","text":"시기2017년 9월 면접내용판교에서 열린 취업박람회에 참가하여 처음면접을 진행했으며 개발팀이 아닌 분들과 면접을 진행했습니다. 진행했던 프로젝트 그리고 어필하고 싶은 분야에 대한 프로젝트에 대해 설명했습니다. 2차면접은 사무실 내 회의실에서 진행하였으며 각팀의 개발팀 팀장님들 그리고 전무님과 면접을 진행했습니다. 면접 질문은 다음과 같습니다. 자기소개 영업시키면 어떻게 할 지낼것인지 진행했던 프로젝트에 대한 설명 지원동기 자신있는 언어 그 언어의 특징 및 장점 자기소개서 기반 질문 소감면접의 난이도는 높은편은 아니나 자신이 진행했던 프로젝트 그리고 자신있는 언어가 한개이상은 있어야 되는것 같습니다. 직무는 면접 후 결정되었으며 전무님의 질문이 개발을 좋아하시는 분이란걸 느낄수 있게 했습니다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"면접","slug":"Etc/면접","permalink":"http://KKimSangHeon.github.io/categories/Etc/면접/"}],"tags":[{"name":"면접","slug":"면접","permalink":"http://KKimSangHeon.github.io/tags/면접/"},{"name":"minds lab","slug":"minds-lab","permalink":"http://KKimSangHeon.github.io/tags/minds-lab/"},{"name":"마인즈랩","slug":"마인즈랩","permalink":"http://KKimSangHeon.github.io/tags/마인즈랩/"}]},{"title":"아이티센 정보시스템 개발","slug":"interview5","date":"2018-01-13T13:23:16.000Z","updated":"2018-09-03T05:59:29.677Z","comments":true,"path":"2018/01/13/interview5/","link":"","permalink":"http://KKimSangHeon.github.io/2018/01/13/interview5/","excerpt":"","text":"시기2016년 11월 면접내용1차면접은 인사팀, 개발팀 총 3분이 면접관으로 들어오십니다. 지원자는 2명이 면접에 참가합니다.주로 인성위주의 질문이며 진행했던 프로젝트에 대한 질문또한 주십니다.2차면접은 대표님, 인사팀 등등 총 5분정도의 분들이 면접관으로 들어오시며 지원자는 3명이 면접에 참가했습니다. 1차 2차 모두 인성위주, 진행했던 프로젝트에 대한 질문이 주를 이뤘으며 좋은분위기속에서 면접을 마쳤습니다.기억나는 면접질문은 다음과 같습니다. 자기소개 자기소개서 위주의 질문 핵심가치에 대한 질문 팀장으로서 팀원을 이끌어본 경험 3가지 가치와 경험에 대한 설명 포부 지방으로 파견가도 괜찮은지 소감좋은분위기속에서 면접진행되었으며 사옥이 우주선 비슷하게 생겨 신기하다는 생각이 들었습니다. 인턴활동을 진행하면서 들었는데 다른팀의 면접분위기는 무서웠다고 합니다. 면접관에 따라 분위기가 좌우되는것 같습니다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"면접","slug":"Etc/면접","permalink":"http://KKimSangHeon.github.io/categories/Etc/면접/"}],"tags":[{"name":"면접","slug":"면접","permalink":"http://KKimSangHeon.github.io/tags/면접/"},{"name":"itcen","slug":"itcen","permalink":"http://KKimSangHeon.github.io/tags/itcen/"},{"name":"정보시스템 개발","slug":"정보시스템-개발","permalink":"http://KKimSangHeon.github.io/tags/정보시스템-개발/"},{"name":"아이티센","slug":"아이티센","permalink":"http://KKimSangHeon.github.io/tags/아이티센/"}]},{"title":"휴맥스 웹개발","slug":"interview3","date":"2018-01-13T13:06:26.000Z","updated":"2018-09-03T05:59:11.218Z","comments":true,"path":"2018/01/13/interview3/","link":"","permalink":"http://KKimSangHeon.github.io/2018/01/13/interview3/","excerpt":"","text":"시기2017년 10월 면접내용휴맥스 사옥에서 면접 진행하였으며 사옥이 엄청 좋았던 기억이 납니다..총 네분의 면접관분들(실무진 3분 인사팀 1분)과 두명의 지원자가 면접을 진행합니다.면접 질문은 다음과 같습니다. 자기소개 영어로 자기소개 html, css, dom의 역할 oop의 특징 반응형 웹이란 소프트웨어 방법론 질문 관심있는 기술 궁금한점 할수있는 언어 소감영어자기소개는 꼭 준비하는게 좋을것 같습니다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"면접","slug":"Etc/면접","permalink":"http://KKimSangHeon.github.io/categories/Etc/면접/"}],"tags":[{"name":"면접","slug":"면접","permalink":"http://KKimSangHeon.github.io/tags/면접/"},{"name":"웹개발","slug":"웹개발","permalink":"http://KKimSangHeon.github.io/tags/웹개발/"},{"name":"휴맥스","slug":"휴맥스","permalink":"http://KKimSangHeon.github.io/tags/휴맥스/"}]},{"title":"사조시스템즈 전산","slug":"interview2","date":"2018-01-13T13:06:20.000Z","updated":"2018-09-03T05:59:18.303Z","comments":true,"path":"2018/01/13/interview2/","link":"","permalink":"http://KKimSangHeon.github.io/2018/01/13/interview2/","excerpt":"","text":"시기2016년 10월 면접내용 1차면접1차면접은 면접관 3분과 봤습니다. 기억나는 질문은 아래와 같습니다. 자기소개 설날같은 때 지인에게 참치를 팔아줘야 하는데 어떻게 팔 것인가 집이 어디인지 진행했던 프로젝트에 대한 질문. 주량은 얼마나 되는지 흡연여부 지원동기 우리회사, 그룹사가 무슨 일을하는지 1차면접의 합격여부는 당일 알려줬습니다. 2차면접 2차면접은 회장님? 대표님? 과 진행됩니다. 이미 뭐 합격자는 결정되어있던것 같으며 인성위주로 질문하시고 더 멀리보기위해서는 더 높게 올라가라라고 말씀해주신게 인상깊었습니다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"면접","slug":"Etc/면접","permalink":"http://KKimSangHeon.github.io/categories/Etc/면접/"}],"tags":[{"name":"면접","slug":"면접","permalink":"http://KKimSangHeon.github.io/tags/면접/"},{"name":"전산","slug":"전산","permalink":"http://KKimSangHeon.github.io/tags/전산/"}]},{"title":"SQLD, SQL개발자","slug":"certificate4","date":"2018-01-13T11:50:17.000Z","updated":"2018-09-03T06:05:21.232Z","comments":true,"path":"2018/01/13/certificate4/","link":"","permalink":"http://KKimSangHeon.github.io/2018/01/13/certificate4/","excerpt":"","text":"취득시기2017년 11월 내용총 한번의 시험이 있으며 앞부분의 이론적인 부분은 배점이 낮지만 절대 무시하면 안됩니다. 그 말이 이 말같고 이 말이 저 말같은 문제에 낚여 과락이라는 결과가 나올 수 있습니다. 공식교재와 풀이문제집을 구매해서 공부하였으며 책이 잘 읽히는 부분도 있지만 그렇지 않은 부분도 있었습니다. 총 한달정도 기간동안 천천히 공부했으며 공부내용은 개발자로서 살아가는데 많은 도움이 될 것 같으며 DB에 대한 상식 또한 넓어진것 같습니다. 개발자로서 따면 좋은 자격증이라 생각합니다. 하지만 시험당시가 조금 당황스러웠습니다. 문제에 오탈자가 한 두개가 아니라 집중할만하면 계속되는 감독관의 오타수정 알림으로 인해 시험이 5번넘게 중단되었습니다. 대놓고 짜증내는 사람도 있었으며 시험 종료 후 추가시간은 제공되지 않았습니다. 책의 내용, 문제는 개발자로서 알아야 할 상식이 많은것은 분명하나 문제 출제에 조금더 신경써주면 좋을것 같습니다. 전 이제 시험볼일은 없겠지만요 ㅋㅋ","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"자격증","slug":"Etc/자격증","permalink":"http://KKimSangHeon.github.io/categories/Etc/자격증/"}],"tags":[{"name":"자격증","slug":"자격증","permalink":"http://KKimSangHeon.github.io/tags/자격증/"},{"name":"SQLD","slug":"SQLD","permalink":"http://KKimSangHeon.github.io/tags/SQLD/"},{"name":"SQL 개발자","slug":"SQL-개발자","permalink":"http://KKimSangHeon.github.io/tags/SQL-개발자/"}]},{"title":"정보처리기사","slug":"certificate3","date":"2018-01-13T11:50:03.000Z","updated":"2018-09-03T05:58:50.749Z","comments":true,"path":"2018/01/13/certificate3/","link":"","permalink":"http://KKimSangHeon.github.io/2018/01/13/certificate3/","excerpt":"","text":"취득시기2016년 12월 내용필기의 경우 기출문제만 풀어본다면 합격할 수 있는 수준입니다. 전자계산기의 경우 반복해서 숙달해서 풀이법을 익히는게 중요하며 네트워크는 그냥 암기해야하는것 같습니다… 실기의 경우 16년 3회차부터 주관식으로 변경되어 어려워졌다는 말이 많은데 제가 봤던 16년 3회의 경우 그렇게 어렵지만은 않았습니다. 5년치의 실기 문제를 모두 풀어보고 시험에 임했으나 DB과목은 6년전의 문제와 비슷한 유형으로 나와 아차싶었지만 다행이 좋은 점수를 받을 수 있었습니다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"자격증","slug":"Etc/자격증","permalink":"http://KKimSangHeon.github.io/categories/Etc/자격증/"}],"tags":[{"name":"자격증","slug":"자격증","permalink":"http://KKimSangHeon.github.io/tags/자격증/"},{"name":"정보처리기사","slug":"정보처리기사","permalink":"http://KKimSangHeon.github.io/tags/정보처리기사/"}]},{"title":"컴퓨터활용능력 1급","slug":"certificate2","date":"2018-01-13T11:49:58.000Z","updated":"2018-09-03T05:58:55.510Z","comments":true,"path":"2018/01/13/certificate2/","link":"","permalink":"http://KKimSangHeon.github.io/2018/01/13/certificate2/","excerpt":"","text":"취득시기2013년 7월 내용필기는 워드프로세서와 겹치는 부분이 있으며 조금 더 확자된 부분이 있어 그부분만 조금 더 공부하고 쉽게 합격했습니다. 하지만 실기의 경우 생각만큼 쉽지만은 않았습니다. 11년 10월 입대전에 컴활이나 따고 가자해서 시작해서 11년 8월에 필기를 취득하고 13년 7월 전역후 한달동안 빡세게 공부해서 필기시험 만료를 눈앞에두고 취득할 수 있었습니다.전역하고 보니 필기시험 합격의 만료 전까지 실기시험이 3번밖에 없던터라 무작정 이번에 딴다는 각오로 3번 다 시험을 신청했습니다. 첫 시험은 어려웠음에도 불구하고 1점차이로 떨어졌고 두번째 시험에서 합격했습니다. 시험지마다 난이도도 조금씩 차이가 있는것 같으며 운도 어느정도 따라주었던거 같습니다. 실기의 경우 프로시저의 어려운 부분은 과감하게 포기하고 쉬운영역만 공부하였으며 엑셀, 엑세스는 사용방법을 빠삭하게 익혔으며 단축키의 사용법 또한 완벽하게 익혔습니다.컴활을 취득하기 위해 공부했던 내용은 일상생활속에서 생각보다 많은 도움을 주며 단순 취업용 뿐만아니라 엑셀실력 향상에도 많은 도움을 주었습니다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"자격증","slug":"Etc/자격증","permalink":"http://KKimSangHeon.github.io/categories/Etc/자격증/"}],"tags":[{"name":"자격증","slug":"자격증","permalink":"http://KKimSangHeon.github.io/tags/자격증/"},{"name":"컴퓨터활용능력 1급","slug":"컴퓨터활용능력-1급","permalink":"http://KKimSangHeon.github.io/tags/컴퓨터활용능력-1급/"}]},{"title":"워드프로세서 1급","slug":"certificate","date":"2018-01-13T03:40:20.000Z","updated":"2018-09-03T05:58:44.411Z","comments":true,"path":"2018/01/13/certificate/","link":"","permalink":"http://KKimSangHeon.github.io/2018/01/13/certificate/","excerpt":"","text":"취득시기2012년 8월 내용필기의 경우 기출문제만 풀어본다면 가볍게 합격할 수 있는 수준이며 실기도 마찬가지로 한달만 준비하면 딸 수 있는수준입니다. 실기시험을 볼 때 한타는 500타, 영타는 200타 나왔었으며 합격에 무리없을 적당한 속도였습니다. 교재를 보고 숙달하면 실력이 금방 향상되며 오타만 주의하면 쉽게 취득 가능합니다. 워드프로세서의 경우 군대에서 자격증을 취득할 만큼 쉬웠으며 취득했던 자격증 중에 가장 쉬웠던 자격증이었습니다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"자격증","slug":"Etc/자격증","permalink":"http://KKimSangHeon.github.io/categories/Etc/자격증/"}],"tags":[{"name":"워드프로세서","slug":"워드프로세서","permalink":"http://KKimSangHeon.github.io/tags/워드프로세서/"},{"name":"자격증","slug":"자격증","permalink":"http://KKimSangHeon.github.io/tags/자격증/"}]},{"title":"SK 고용디딤돌 면접","slug":"interview","date":"2018-01-13T03:39:23.000Z","updated":"2018-09-03T05:59:01.785Z","comments":true,"path":"2018/01/13/interview/","link":"","permalink":"http://KKimSangHeon.github.io/2018/01/13/interview/","excerpt":"","text":"시기2016년 12월 면접내용모바일개발 직무로 지원해서 면접을 진행했었습니다. SK에서 나오신 면접관 한분 인턴활동을 진행할 기업에서 한분 총 두분의 면접관과 면접을 진행했습니다.질문내용은 SK에서 나오신분은 주로 인성관련 질문을 하시며 기업에서 나오신 면접관님은 전공관련 질문을 많이하십니다.아래는 받았던 질문으로서 기억나는대로 적었습니다 자기소개 스트레스 해소방법 참가했던 대외활동에 대한설명 관심있는 분야 휴학하고 한일 입사 후 어떻게 지낼것인지 DB에서 인덱스란 논클러스트 인덱스 클러스트 인덱스의 차이 기본키는 클러스트인가 논 클러스트인가 소프트공학에 대한 질문 소감면접관 두분 모두 친절하셨으며 잡플래닛에서 보고간 내용 그대로 면접질문이 나와 수월했었습니다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"면접","slug":"Etc/면접","permalink":"http://KKimSangHeon.github.io/categories/Etc/면접/"}],"tags":[{"name":"SK 고용디딤돌","slug":"SK-고용디딤돌","permalink":"http://KKimSangHeon.github.io/tags/SK-고용디딤돌/"},{"name":"면접","slug":"면접","permalink":"http://KKimSangHeon.github.io/tags/면접/"},{"name":"모바일 개발","slug":"모바일-개발","permalink":"http://KKimSangHeon.github.io/tags/모바일-개발/"},{"name":"고용디딤돌","slug":"고용디딤돌","permalink":"http://KKimSangHeon.github.io/tags/고용디딤돌/"}]},{"title":"코인시세를 카카오톡으로 알아보기","slug":"coin","date":"2018-01-09T14:02:40.000Z","updated":"2018-09-03T05:58:40.072Z","comments":true,"path":"2018/01/09/coin/","link":"","permalink":"http://KKimSangHeon.github.io/2018/01/09/coin/","excerpt":"","text":"설명최근 비트코인과 더불어 다양한 코인들이 관심을 끌고있다..그 중 대표적인 거래소인 업비트의 실시간 코인 별 시세를 챗봇으로 확인할 수 있도록 만드는 포스트이다. 현재 확인할 수 있는 코인은 에이다, 리플, 퀀텀, 스텔라루멘, 스테이터스네트워크 이며 얼마든지 추가 가능하다. API업비트는 다른 거래소와는 다르게 공식적으로 API를 제공하지 않는다. 하지만 업비트에 접속 후 네트워크 창을 토대로 request주소를 알아낼 수 있었다.https://crix-api-endpoint.upbit.com/v1/crix/candles/minutes/1?code=CRIX.UPBIT.KRW-XXX위의 주소의 맨 마지막 XXX에 코인의 이름을 입력해 주면 현재 코인의 시세, 1분동안 최저가, 최고가를 알 수 있다. 위의 주소에서 제공하는 데이터는 1분단위로 갱신된다. 실시간으로 코인데이터를 읽어오는 모듈챗봇은 기존 개발된 Node.js 기반의 프로그램을 이용하였다. 소스코드는 아래의 주소에서 확인 가능하다.https://github.com/KKimSangHeon/Dg_Chat_Bot 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100exports.processCoin=function(res,commonFunction,request,async)&#123; var headers = &#123; 'User-Agent': 'Super Agent/0.0.1', 'Content-Type': 'application/x-www-form-urlencoded' &#125; var options = &#123; url: 'https://crix-api-endpoint.upbit.com/v1/crix/candles/minutes/1?code=CRIX.UPBIT.KRW-ADA', method: 'GET', headers: headers, &#125; const tasks = [ function(callback)&#123; var temp=''; request(options, function (error, response, body) &#123; if (!error &amp;&amp; response.statusCode == 200) &#123; // Print out the response body var jsonContent= JSON.parse(body); var resString='에이다: '+jsonContent[0].openingPrice+'\\n'; temp=resString; callback(null,temp); &#125; &#125;) &#125;, function(temp, callback) &#123; options.url = 'https://crix-api-endpoint.upbit.com/v1/crix/candles/minutes/1?code=CRIX.UPBIT.KRW-XRP' request(options, function (error, response, body) &#123; if (!error &amp;&amp; response.statusCode == 200) &#123; var jsonContent= JSON.parse(body); var resString ='리플: '+jsonContent[0].openingPrice+'\\n'; temp+=resString; callback(null,temp); &#125; &#125;) &#125;, function(temp, callback) &#123; options.url = 'https://crix-api-endpoint.upbit.com/v1/crix/candles/minutes/1?code=CRIX.UPBIT.KRW-QTUM' request(options, function (error, response, body) &#123; if (!error &amp;&amp; response.statusCode == 200) &#123; var jsonContent= JSON.parse(body); var resString ='퀀텀: '+jsonContent[0].openingPrice+'\\n'; temp+=resString; callback(null,temp); &#125; &#125;) &#125;, function(temp, callback) &#123; options.url = 'https://crix-api-endpoint.upbit.com/v1/crix/candles/minutes/1?code=CRIX.UPBIT.KRW-SNT' request(options, function (error, response, body) &#123; if (!error &amp;&amp; response.statusCode == 200) &#123; // Print out the response body var jsonContent= JSON.parse(body); var resString ='스테이터스네트워크: '+jsonContent[0].openingPrice+'\\n'; temp+=resString; callback(null,temp); &#125; &#125;) &#125;, function(temp, callback) &#123; options.url = 'https://crix-api-endpoint.upbit.com/v1/crix/candles/minutes/1?code=CRIX.UPBIT.KRW-XLM' request(options, function (error, response, body) &#123; if (!error &amp;&amp; response.statusCode == 200) &#123; // Print out the response body var jsonContent= JSON.parse(body); var resString ='스텔라루멘: '+jsonContent[0].openingPrice+'\\n'; temp+=resString; commonFunction.sendMessage(res,temp); callback(null); &#125; &#125;) &#125; ]; async.waterfall(tasks, function(err)&#123; if (!err) &#123; &#125; else &#123; console.error(err); &#125; &#125;);&#125; Node.js 는 동기방식이라 async 모듈을 이용하여 동기방식으로 각 코인들의 데이터를 읽어온 후 문자열 변수에 저장하였다.tasks 배열안에 함수들이 순차적으로 실행되며 callback 함수를 통해 축적된 문자열을 다음 함수로 넘겨준다.최종적으로 스텔라루멘에 대한 코인정보가 temp 변수에 저장되면 사용자에게 메세지를 전달하게 된다. 이렇게 위와같이 카카오톡으로 업비트에 들어가지 않고 코인들의 시세를 확인할 수 있다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"아무거나","slug":"Etc/아무거나","permalink":"http://KKimSangHeon.github.io/categories/Etc/아무거나/"}],"tags":[{"name":"업비트","slug":"업비트","permalink":"http://KKimSangHeon.github.io/tags/업비트/"},{"name":"API","slug":"API","permalink":"http://KKimSangHeon.github.io/tags/API/"},{"name":"에이다","slug":"에이다","permalink":"http://KKimSangHeon.github.io/tags/에이다/"},{"name":"퀀텀","slug":"퀀텀","permalink":"http://KKimSangHeon.github.io/tags/퀀텀/"},{"name":"스텔라루멘","slug":"스텔라루멘","permalink":"http://KKimSangHeon.github.io/tags/스텔라루멘/"},{"name":"리플","slug":"리플","permalink":"http://KKimSangHeon.github.io/tags/리플/"},{"name":"스테이터스네트워크","slug":"스테이터스네트워크","permalink":"http://KKimSangHeon.github.io/tags/스테이터스네트워크/"}]},{"title":"3장. 타입스크립트","slug":"angular2","date":"2018-01-07T05:05:28.000Z","updated":"2018-09-03T05:58:30.562Z","comments":true,"path":"2018/01/07/angular2/","link":"","permalink":"http://KKimSangHeon.github.io/2018/01/07/angular2/","excerpt":"","text":"위의 책을 공부하며 정리하는 포스트이다. AngularJS디렉티브HTML 태그나 어트리뷰트의 기능을 새롭게 만드는 개념. 애플리케이션의 요구 사항에 맞게 HTML 태그를 확장할 수 있다. ng-app&lt;div&gt;에 ng-app 어트리뷰트를 추가하면 그 &lt;div&gt;만 AngularJS의 영향을 받는다. 바인딩뷰와 모델이 서로를 갱신하는것. AngularJS는 모델이 갱신될 때마다 전체 애플리케이션에 영향을 미치는 $digest 함수를 실행하면서 데이터 바인딩을 점검하고 DOM 객체의 값을 갱신한다. socpe모델의 값은 $scope라는 스코프 안에 선언되며 AngularJS에서는 이 스코프를 여러 계층으로 구성한다. AngularNgModule모듈은 클래스에 @NgModule 어노테이션을 붙여서 지정하고 이 어노테이션 안에서 모듈 내용을 설정한다. SystemJS 모듈로더JS는 script 태그 안에서 로드하고 실행하지만 Angular도 이 방법을 사용할 수 있지만 SystemJS 라이브러리를 사용해서 불러오는것을 권장한다.why? 스크립트 태그를 삭제하지 않으면 이를 불러오려고 하고 불필요한 부하 발생 , 스크립트 태그의 실행순서를 보장하지 않기 때문에 문제가 될 수 있다. environment.ts 파일 -&gt; 빌드를 위한 개발환경 설정 정보들 빌드명령어Angular-CLI로 만들어진 프로젝트의 코드는 타입스크립트 기반이기 때문에 빌드를 통해 브라우저에서 동작 가능한 자바스크립트로 변환해야 한다. ng build 프로덕션용 빌드 명령어ng build –prod 3장 타입스크립트1.let을 이용한 변수선언ES 5 이하에서 호이스팅 문제가 발생하므로 이를 해결하기 위해 ES6의 좋은 특징인 let 선언자를 이용 타입스크립트는 변수명 뒤에 타입을 명시해야 한다. 타입스크립트를 타입 언어라고 하는 이유는 이와 같은 이유이다.let 변수명 : 타입;let emotion2:string=”happy”; 배열타입배열정의 형태1let fruits: string[] = [“a”,”b”]; let fruits2: string[] = [];fruits2.push(“a”); 배열정의 형태2let num:Array = [1,2,3]; 유니언 타입 56p유니언 타입은 2개 이상으로 입력된 타입에 대해 하나의 타입으로 정의하는것. 메소드의 파라미터로 사용가능.var unionX: string | number = 1;console.log(typeof unionX, unionX); // number 1 출력 문자열 표현 58p+와 \\n을 써서 줄바꿈이 가능하지만 다음과 같이 가능하다.let w: string =”world”;let one: number = 1;function hi(){ return “hi”;} let hello_message: string =hello ${w} 1 + ${one} = ${1+1} ${hi()}console.log(hello_message); 디스트럭처링 지원 60pES6에 포함된 특징으로 배열이나 객체에서 데이터를 선택적으로 추출할 수 있는 자바스크립트 할당식이다.var params2 = [‘happy 동물원’, 100];let[m_name2, m_num2] = params2;","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Angular2","slug":"Web-App/Angular2","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Angular2/"}],"tags":[{"name":"Angular2","slug":"Angular2","permalink":"http://KKimSangHeon.github.io/tags/Angular2/"}]},{"title":"ABLETHON 참가","slug":"ablethon","date":"2017-10-17T05:05:28.000Z","updated":"2017-11-12T12:48:28.999Z","comments":true,"path":"2017/10/17/ablethon/","link":"","permalink":"http://KKimSangHeon.github.io/2017/10/17/ablethon/","excerpt":"","text":"ABLETHON 참가 시각장애인의 App 사용에 관심이 많아 관련 공모전을 알아보던 중 에이블톤이 눈에 띄어 참가하게 되었다. 지도에서 붉은 부분은 저소득층 국가가 많으며 이에 해당하는 국가의 시각장애인은 안드로이드의 talkback 기능을 많이 이용하고 있으며, 상대적으로 소득이 높은 파랑색 국가의 시각장애인은 아이폰에서 제공하는 voiceover 기능을 많이 이용하고 있다. 안드로이드는 자체적으로 아이폰의 voiceover와 같은 기능을 제공하지 않기 때문에 아이폰에 비해 상대적으로 낮은 접근성을 갖는다. 우리팀은 이를 해결하고자 안드로이드 앱 개발을 하기로 결정하였다. 시연영상 날씨조회기능 버스도착정보 조회기능 전화기능 길 안내기능 길 안내 도움요청기능 수상 많은 분들이 좋게 봐준 덕분에 우수상을 받을 수 있었다. 소스코드 (Github Repository)-안드로이드 어플리케이션 소스코드","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"ABLETHON","slug":"ABLETHON","permalink":"http://KKimSangHeon.github.io/tags/ABLETHON/"},{"name":"시각장애인도 이용가능한 App","slug":"시각장애인도-이용가능한-App","permalink":"http://KKimSangHeon.github.io/tags/시각장애인도-이용가능한-App/"}]},{"title":"4.모듈","slug":"python4","date":"2017-10-10T06:11:53.000Z","updated":"2018-09-03T05:58:11.517Z","comments":true,"path":"2017/10/10/python4/","link":"","permalink":"http://KKimSangHeon.github.io/2017/10/10/python4/","excerpt":"","text":"파이썬 모듈이란? 1) 파이썬 프로그램 파일로 따로 함수나 변수를 정의한다.2) 모듈안에는 어떤 코드도 작성 가능하다.(함수, 클래스, 변수등)3) 다른 모듈에 의해서 호출되고 사용된다.4) 표준모듈, 사용자 생성 모듈, 서드 파티 모듈 등으로 나눌 수 있다. 추 후 추가예정…","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Python","slug":"Language/Python","permalink":"http://KKimSangHeon.github.io/categories/Language/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://KKimSangHeon.github.io/tags/Python/"}]},{"title":"인천~부산 국토종주","slug":"riding1","date":"2017-10-06T07:51:55.000Z","updated":"2017-10-06T11:14:44.985Z","comments":true,"path":"2017/10/06/riding1/","link":"","permalink":"http://KKimSangHeon.github.io/2017/10/06/riding1/","excerpt":"","text":"오래전부터 버킷리스트였던 국토종주를 완료하였다. 4박5일의 기간동안 혼자 고군분투하며 유일한 친구 네이버 지도와 함께했던 기억.. 잊지않기 위해 사진위주로 정리해본다. 출발전 필요한 짐만 챙겼는데도 불구하고 뒤의 가방의 무게가 상당하다.. 약 8kg정도 되는것 같다. 1일차 5월3일인천아라뱃길 ~ 여주보 오전 7시 부천에서 출발해서 아라뱃길로 가기위해서는 굴포천을 통과해야한다. 가는 도중에 만났던 2마리의 개님들.. 나를 반겨주길래 사진찍으려 하니 도망가버린다. 귀여워서 뒷모습이라도 찍었다.. 조금 더 가다보니 이번엔 오리?를 만나게 되었다. 꽥꽥거리는게 기여워서 한컷찍었다. 참새는 짹짹.. 부천, 인천을 거쳐 드디어 한강에 도착했다. 날씨가 좋아서 달리기 좋았는지 찍은사진은 이것뿐이다.. 꽉찬 헬멧이 보기좋다.. 한강을 달리고 달려 한강의 거의 끝지점인 팔당대교에 도착했다. 편의점에서 파워에이드와 스니커즈를 사먹었다.. 군대이후로 스니커즈가 이렇게 맛있는건 처음이었다.. 조금 더 가니 팔당댐에 도착하였다. 팔당댐 옆에는 터널이 있었다. 들어가면 추울정도로 시원했다. 터널을 나와 달리다 보니 철길이 등장하였다. 아직까진 힘들진 않았지만 어릴때부터 이유없이 철길을 좋아했던 나는 여기서 잠깐 쉬어갔다. 아무생각없이 달리다보니 양평에 도착하였다.! MT의 장소로서 기차로만 갈 수있다고 생각한 곳을 자전거타고 오니 새로웠다. 이제 폐 철길을 개조한 자전거길이 펼쳐졌다. 지나갈때마다 드르륵 거리는게 뭔가 듣기 좋았다. 철길을 지나니 아트터널이 등장하였다. 역시 용담 아트터널이다. 형형색색의화려한 불빛들이나를 반겨준다.. 갓트터널..4박5일간 일정중 여기가 제일 최고였던것 같다.이 후 양평을 지나 7시쯤 여주에 도착하여 인근 모텔에서 치킨을 먹고 기절했다. 친절한 모텔주인 아저씨는 익숙한듯이 자전거를 방까지 옮겨다 주셨던게 인상깊었다. 2일차 5월 4일강천보 ~ 문경 불정역 숙소에서 6시반에 출발하여 자전거 도로로 진입했을 때가 6시 50분쯤이었다. 해가 뜨기 시작하고 물안개가 이뻣었다. 상쾌한 공기가 좋긴했지만 전날의 휴유증으로 엉덩이, 허벅지, 등, 종아리 아프지 않은곳이 없었다. 비상용으로 사간 타이레놀을 먹을까 고민했지만 몸을 생각해서 몸을 혹사시켰다?. 많은 분들의 국토종주 후기를 보면 이 구간이 등장한다. 나 또한 사진을 찍어보았다. 자전거에 내려서 가라는 의미로 장애물을 설치해 두었을 것이다. 자전거를 끌고가도 자전거를 제어하기 힘든 경사구간이었다.. 사진을 찍은 부분이 경사진 구간이라 자전거에서 내려 걸어가고 있는데 뒤에서 50대 정도로 보이는 동호회분들께서 앞질러 나가셨다.. 그리고는 사진속의 경사진 구간도 낙오자 없이 통과하셨다.. 체력좀 많이 길러야겠다고 뼈저리게 느꼈다.(나는 가방무게 때문에 힘든거였을거야) 해가 뜨고 그림자가 진 모습이 이뻐보여서 찍었다. 문득 어제 먹은 양념반 후라이드 반의 치킨이 생각났다.. 열심히 달리다 보니 앞서나간 분들을 따라잡았지만 빠르게 멀어져갔다… 아침이라 그런지 힘들어서 그런지는 모르겠지만 많이 힘들어보인다. 조금 더 가니 아름다운 충북, 도민이 행복한 충북에 도착하였다. 출발 전 후기들을 통해 접했던 죽음의 구간인 백두대간이화령의 시작점이다. 이름부터가 “넌 못올라 올껄?” 이라는 느낌이 뿜어져 나온다. 역시나 나는 걸어서 올라가고 있고 외국인 커플이 가볍게 날 앞질러 나간다. 자전거에서 내려서 열심히 올라가던준 반사경이 있어 내모습을 담아봤다.. 많이 올라왔다. 금방끝나겠지 라는 생각으로 열심히 페달을.. 아니 걸었다. 금방 끝날것이라는 나의 경기도 오산 아래 경치를 잠깐 즐기며 사진을 찍었다. 역시 경기도 오산은 오산이었다. 이런 언덕이 끝도없이 펼쳐진다. 한시간이면 끝날줄 알았지만 끝이없다.. 정말 많이 올라왔다. 날씨가 선선해서 다행이었다.. 여름이였으면 큰일날 뻔 했다. 땀으로 머리가 다 젖었다.. 하루사이에 살이 빠졌는지 턱끈이 느슨해졌다..ㅋㅋㅋㅋㅋ 드디어 이화령을 정복했다.. 이틀차에 맛본 지옥이었다. 친구로 보이는 50대 아저씨 두분께 사진을 부탁하여 사진을 찍었다.. 국토종주를 하다보면 젊은사람보다 50대 60대 분들이 더 많은것 같다. 4시간 가량 걸어서 올라간 거리를 자전거 타고 15분만에 내려왔다. 뭔가 힘들게 완성한 도미노를 무너뜨리는것만큼 시원하고 쾌감이 넘쳤다. 자전거 도로를 따라 달리다 보니 폭포가 등장하였다. 처음보는 폭포가 신기해서 찍어보았다. 조금 더 가니 불정역에 도착하였다. 불정역에는 이화령에서 사진찍어주신 두분이 계셨다. 인사를 건네고 이런저런 이야기를 나누었다. 혼자온것에 대해 칭찬과 격려를 많이 해주셔서 힘이 많이 났었다. 불정역에는 저런 기차도 있었다. 도착시간이 늦어서 들어가보지는 못하였다. 불정역에서 숙소로 출발하여 도착 후 짐을 내팽겨치고 간단하게 밥을 먹고 8시쯤 잠에들었다. 3일차 5월5일문경불정역 ~ 강정 고령보 마찬가지로 6시쯤 출발하였다. 처음부터 만난 오르막에 당황하였지만 이번에는 끝까지 잘 타고 올라왔다. 오르막의 끝에선 지쳐 내가 올라온 오르막을 감상하며 휴식을 취해주었다. 반사경이 있어서 사진을 한번 더 찍어주었다. 반사경 작가미상의 벽화?가 눈에 띈다. 3일차는 지루했다고 느낀점이 자전거 도로는 좋으나 이런 길이 쭉 반복이다.. 이날은 오후3시부터 6시까지 비가 많이왔다.. 우비를 입을까 하다 걸리적거릴까 입지는 않고 살기위해 달렸다. 덕분에 덥지는 않았으나 많이 찝찝했던 기억이 난다. 비로인해 더이상 찍은 사진이 존재하지 않는다.. 근처 여관에 도착하여 이날도 7시쯤 일정을 마무리하고 잠에 들었다. 4일차 5월6일강정고령보 ~ 양산물문화관 갈대가 이뻐보여서 사진을 찍었다. 신세계의 이중구의 대사가 생각나기도 한 구간이었다.찍을때는 몰랐는데 허벅지가 많이 탄 것을 사진을 통해 알수있다.. 또 다시 길의 반복바로옆에 낙동강이 있는데 역풍으로 인해 페달밟기가 매우 힘들었다. 길을 반복하다 만나게된 고라니다.. 정말 빠르다.. 나도모르게 감탄사가 나왔다. 또 다시 길의 반복 이화령의 두려움이 채 가시기도 전에 산이 등장하였다. 그나마 이화령보다는 수월하고 구간도 그나마 짧았었다. 잠깐 휴식시간에 경치를 찍어보았다. 이번에는 소를 만났다.. 신기해서 찍어보았다.. 해가 점점 저물어간다. 사진을 찍은 시간이 6시반. 밀양이었다. 앞만 보다 위를 한번보니 구름이 신기했다. 두 마리의 새가 싸우는 형상을 하고 있었고 반대편에는 천사가 날개짓 하는 구름이 있었다.. 이건 약간 억지같긴 하다.. 길을 따라가다 만난 가족이다. 아버지, 딸(첫째),아들(둘째) 로 추정되는데 아버지는 킥보드 딸은 MTB, 아들은 미니벨로를 타고있었다. 아버지는 가벼운 몸을 이끌고 저 멀리가고있었고 남매는 옥신각신하며 달리고 있었다. 남매가 매우 귀여웠고 아버지가 남매를 강력하게 키우는 것이 인상깊었다. 간식이라도 줄걸그랬다.. 마지막 종점인 부산 낙동강 하굿둑까지 약 50KM남은 곳에서 휴식을 취했다. 5일차 5월 7일양산 물문화관 ~ 부산 낙동강 하굿둑대망의 마지막날 아침 7시에 출발하여 갈대밭을 지나 마지막이라 생각하니 페달이 더욱 무겁게 느껴졌다.. 혼자오신 아저씨께 사진을 부탁하고 여기서도 찍어야 된다며 강제로 한장을 더 찍어주셨다. 참 감사했다.역시나 인천에서 출발한점에 대해 칭찬을 많이해주셨다. 기념촬영 후 인증센터에 들어가 금뱃지를 받고 메달을 신청하였다.이로서 4박5일간의 국토종주는 끝났고 부산 터미널의 모텔에서 4시간 정도 휴식을 취하다 버스를 타고 부천으로 올라왔다. 그리고 얼마지나지 않아 어김없이 찾아온 국가의 부름 하하하하 또 얼마지나지 않아 인증메달과 인증서가 도착하였다. 인상깊었던점 맞은편에서 달려오는 사람들의 안녕하세요, 수고하세요 라는 인사말은 참 많은 힘이되었던것 같다. 가는 방향도 다른 1초의 인연이지만 서로 힘내자는 무언의 메세지가 느껴졌다. 4박5일의 짧은 기간이었지만 많은 사람들의 따듯함을 느낄수 있었다. 그 분들의 말 한마디 한마디가 힘을 낼 수있는 좋은 원동력이었고 그 덕분에 탈 없이 완주할 수 있었던것 같다. 그리고 가장 인상깊었던 사건이 하나 있다. 자전거 길이 쭉 나있는 저멀리서 내 또래로 보이는 사람이 휠체어를 끌고 걸어오고 있었다. 휠체어엔 그 누구도 타고있지 않아 멀리서부터 궁금증을 유발하였다. 멀쩡한 내 또래가 왜 휠체어를 끌고오지라는 궁금증을 갖고 점점 맞은편의 휠체어와 가까워 졌을 때 뭉클함을 느끼지 않을 수 없었다. 아버지로 추정되는 사진이 휠체어 위에 올려져있었다. 그 친구의 말못할 사정을 알지는 못하지만 정말 착하구나라는 생각과 동시에 나를 돌아볼 수 있었던 기회가 되었던것 같다. 후기 우선 내 오랜 버킷리스트를 완료한것에 대해 뿌듯했고 시간이 된다면 긴 기간동안 경치를 즐기며 다시한번 도전하고 싶다. 이번에는 완주를 목표로 주변 경치를 즐기지 못한것이 매우 아쉬웠다. 4박5일이라는 기간동안 많은 것을 배우고 느낄 수 있었던 좋은 기회였으며 나 자신에 대해 다시한번 평가할 수 있었던 좋은기회였던것 같다.","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"Travel","slug":"About-Me/Travel","permalink":"http://KKimSangHeon.github.io/categories/About-Me/Travel/"}],"tags":[{"name":"국토종주","slug":"국토종주","permalink":"http://KKimSangHeon.github.io/tags/국토종주/"}]},{"title":"Spring 기반 그룹웨어 개발","slug":"groupware","date":"2017-10-03T17:55:55.000Z","updated":"2017-11-09T02:45:23.750Z","comments":true,"path":"2017/10/04/groupware/","link":"","permalink":"http://KKimSangHeon.github.io/2017/10/04/groupware/","excerpt":"","text":"그룹웨어 개발그룹웨어는 회원가입, 로그인, 게시판, 일정관리, 사원조회, 쪽지, 마이페이지 기능을 갖고있다. ERD 그룹웨어에서 사용하는 ERD는 위과 같다. 보안그룹웨어 내의 모든 페이지이동은 INTERCEPTOR을 활용하여 페이지 이동 전 권한을 확인한다. 로그인하지 않은 회원이 URL로 페이지 이동을 할 경우 다음과 같은 화면이 출력된다. 회원가입그룹웨어를 이용하기 위해서는 회원가입을 거쳐야 한다. 회원가입 후 관리자의 승인 후 로그인이 가능하다.위의 화면에서 회원가입 버튼을 누르면 다음과 같은 폼이 출력된다. 정보를 입력하고 가입 요청하기 버튼을 클릭하자. 정상적으로 가입이 완료되면 다음과 같은 화면이 출력된다. 해당 아이디로 로그인이 불가능하나 관리자의 승인 후 로그인이 가능해진다. 승인되지 않은 아이디로 로그인 할 경우 위와 같은 화면이 출력된다. 관리자의 가입 승인사전에 지정해 놓은 아이디로 로그인 하여 관리자 화면에 접속하고 신규 가입한 회원에 한해 승인을 해줄 수 있다. 관리자 계정으로 로그인을 할 경우 우측 상단에 관리페이지가 출력된다. 이는 EMPLOYEE 테이블의 ROLE 컬럼값을 통해 판단한다. ROLE컬럼의 값은 USER, ADMIN으로 나뉜다. 관리자가 아님에도 불구하고 URL로 관리자 페이지로 접속할 경우 다음과 같은 화면이 출력된다. 다시 돌아와서 관리자가 로그인을 하고 우측상단의 관리페이지를 접속할 경우 다음과 같은 화면이 출력된다. 관지자는 가입 승인하기 버튼을 클릭하여 가입승인을 할 수 있다. 이후 해당 사용자는 로그인이 가능해진다. 가입승인 버튼을 누를 경우 alert창이 생성되며 가입이 승인된다. 로그인이전에 생성한 아이디로 로그인을 진행하자. 위와 같이 로그인이 되었다. 게시판게시판은 공지사항, 자유게시판, 팀 게시판이 존재한다.게시판 테이블(BOARD)에는 BOARD_AUTHORITY, IS_TEAM 컬럼이 존재하는데 BOARD_AUTHORITY는 글쓰기 권한을 의미한다. 해당 게시판의 BOARD_AUTHORITY가 3일경우 POSITION_ID가 3(전무) 이상인 회원만 게시물 작성이 가능하다.IS_TEAM 컬럼은 팀게시판 유무이며 TEAM_ID가 같은 즉 같은팀이 작성한 글만 볼 수 있도록 하는 역할이다. 조금전 가입한 에두는 직급이 사원(POSITION_ID = 10)이므로 공지사항 게시판에 글쓰기 버튼이 나타나지 않는다. 자유게시판에는 글씨기 버튼이 나타나며 글 작성이 가능하다.글 쓰기 버튼을 누를 경우 다음과 같은 화면이 출력된다. 위와 같이 글을 작성하는 폼을 통해 글작성이 가능하다. 글을 작성하게되면 게시판으로 돌아오며 위와같이 출력된다. 해당 글을 클릭하여 위와같이 자세히 볼 수 있으며 자신의 글인경우 삭제하기 버튼이 보인다. 일정관리자신의 일정을 추가하여 관리할 수 있는 페이지이다. full callendar 라는 오픈소스를 사용하여 구현하였다. 위와같이 일정등록이 가능하다 일정을 등록하게 되면 위와 같이 일정이 달력에 표시된다. 여러개의 일정을 등록할 경우 다음과같이 한눈에 파악이 가능하다. 사원조회모든 사원의 조회가 가능한 페이지이다. jqgrid라는 오픈소스를 활용하였다.디폴트로 전체 사원이 검색된다. 또한 메세지 보내기 버튼을 통해 메세지 전송이 가능하다. 팀명 또는 이름으로 조회가 가능하며 위는 팀명으로만 조회한 경우이다. 위는 김상헌을 조회한 경우이다. 메세지 보내기 버튼을 누르면 위와 같은 팝업창이 생성된다. 위와 같이 메세지를 입력후 전송하기 버튼을 누르면 메세지가 전송된다. 쪽지김상헌의 계정으로 로그인하여 쪽지 탭으로 들어갈 경우 다음과 같이 화면이 출력된다.글자수가 23자 이상일 경우 …이 붙게되며 내용이 생략된다.해당 메세지를 눌러 자세한 내용을 확인할 수 있으며 답장버튼을 눌러 답장할 수 있으며, 삭제 또한 가능하다. 위와 같이 쪽지의 내용이 자세히 보인다. 답장 버튼을 누를 경우 위와같이 화면이 출력되며 답장이 가능하다. 위와 같이 답장을 보내고 에두의 계정으로 로그인 할 경우 위와 같이 메세지가 온 것을 확인할 수 있다. 마이페이지개인정보를 수정할 수 있는 마이페이지이다.사번, 소속, 직급은 수정 불가능하며 비밀번호, 사진, 이름, 이메일이 수정가능하다.비밀번호를 제외한 모든 데이터는 마이페이지에 접속할 경우 입력되어 있다. 소스코드 (Github Repository)github Repository","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"Spring Framework","slug":"Spring-Framework","permalink":"http://KKimSangHeon.github.io/tags/Spring-Framework/"},{"name":"Java Script","slug":"Java-Script","permalink":"http://KKimSangHeon.github.io/tags/Java-Script/"},{"name":"JQgrid","slug":"JQgrid","permalink":"http://KKimSangHeon.github.io/tags/JQgrid/"},{"name":"fullcallendar","slug":"fullcallendar","permalink":"http://KKimSangHeon.github.io/tags/fullcallendar/"}]},{"title":"3. 리스트","slug":"python3","date":"2017-09-29T02:30:31.000Z","updated":"2018-09-03T05:58:04.920Z","comments":true,"path":"2017/09/29/python3/","link":"","permalink":"http://KKimSangHeon.github.io/2017/09/29/python3/","excerpt":"","text":"리스트순서를 가지는 객체들의 집합, 파이썬 자료형들 중에서 가장 많이 사용한다.시퀀스 자료형이기 때문에 시퀀스의 연산(인덱싱, 슬라이싱, 연결(+), 반복(*), len(), in, not in) 등의 연산이 가능하다. 특히, list는 del() 함수를 통한 삭제도 가능하다. PythonExam.pi12345678910111213141516171819202122232425262728293031323334l = [1, 2, 'python']print(l[-2], l[-1], l[0], l[1], l[2])print(l[1:3])print(l * 2)print(l + [3, 4, 5])print(len(l))print(2 in l)del l[0]print(l)리스트는 변경 가능(Mutable)한 자료형이다.a = ['apple', 'banana', 10, 20]a[2] = a[2] + 90print(a)슬라이스를 통한 치환a = [1, 12, 123, 1234]a[0:2] = [10, 20]print(a)a[0:2] = [10]print(a)a[1:2] = [20]print(a)a[2:3] = [30]print(a)","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Python","slug":"Language/Python","permalink":"http://KKimSangHeon.github.io/categories/Language/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://KKimSangHeon.github.io/tags/Python/"}]},{"title":"2. 제어문","slug":"python2","date":"2017-09-29T02:24:02.000Z","updated":"2018-09-03T05:58:01.829Z","comments":true,"path":"2017/09/29/python2/","link":"","permalink":"http://KKimSangHeon.github.io/2017/09/29/python2/","excerpt":"","text":"If문PythonExam.pi123456789101112131415161718192021222324252627a = 10if a &gt; 5: print(\"big\")else: print(\"small\")n = -2if n &gt; 0: print('양수')elif n &lt; 0: print('음수')else: print('0')order = 'spam'if order == 'spam': price = 1000elif order == 'egg': price = 500elif order == 'spagetti': price = 2000else: price = 0print(price) For문 PythonExam.pi123456789a = ['cat', 'cow', 'tiger']for animal in a: print(animal)for x in range(10): print(x, end=\" \") while문PythonExam.pi123456count = 1while count &lt; 11: print(count, end=' ') count += 1else: print('') break, continue, elsePythonExam.pi123456789101112131415161718192021i = 0while i &lt; 10: i += 1 if i &lt; 5: continue print(i, end=' ') if i &gt; 10: breakelse: print('else block')print('done')i = 0while True: print(i) if i &gt; 5: break i += 1","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Python","slug":"Language/Python","permalink":"http://KKimSangHeon.github.io/categories/Language/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://KKimSangHeon.github.io/tags/Python/"}]},{"title":"1. 변수명과 예약어","slug":"python","date":"2017-09-27T04:43:58.000Z","updated":"2018-09-03T05:57:58.015Z","comments":true,"path":"2017/09/27/python/","link":"","permalink":"http://KKimSangHeon.github.io/2017/09/27/python/","excerpt":"","text":"소개1991년 귀도 반 로섬( Guido van Rossum ) 이 발표한 인터프리터 언어귀도가 구글에 입사하고 구글의 3대 개발언어 중 하나로 채택되면서 유명세를 탔다. 특징대화 기능의 인터프리터 언어동적타이핑(동적인 데이터 타입 결정 지원)플랫폼 독립적 언어(Unix, Linux, Window9x/NT 계열, DOS, OS/2, Mac OS, Nokia 등) 간단하고 쉬운 문법가독성( 코드블러의 들여쓰기 구분 )비교적 짧은 개발 시간고수준의 내장 객체 자료형 제공(List, Dictionary, String, Turple 등의 자료구조)메모리 자동 관리무료(비영리의 파이썬 소프트웨어 재단이 관리하는 개방형, 공동체 기반 개발 모델)많은 수의 풍부한 라이브러리 제공높은 확장성(접착성, Glue Language)유니코드 파이선의 종류CpythonC로 작성된 파이썬 인터프리터 JythonJava로 작성된 파이썬 인터프리터 IronPython.Net 플랫폼 용 파이썬 인터프리터, C#으로 구현 PyPy파이썬으로 작성된 파이썬 인터프리터 PythonExam.pi12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364가장 바깥쪽에 있는 블록의 코드는 1열부터 시작해야 한다.&gt;&gt;&gt; a=1&gt;&gt;&gt; a=1SyntaxError: unexpected indent내부 블록은 같은 거리만큼 들여 쓰기를 해야 한다.&gt;&gt;&gt; if( a &gt; 1 ): print( \"big\" ) print( \"really?\" )SyntaxError: unexpected indentfrom __future__ import print_function# -*- coding: utf-8 -*-# 치환문의 예a = 1b = a + 1print(a , b, sep=',')# 여러 변수를 한번에 치환e, f =3, 7print(e ,f )# 하나의 값을 여러 변수에 할당x = y = z = 1# 값 교환f, e = e, fprint(e, f)# 동적 타이핑a = 1print(type(a))a = 'hell'print(type(a))# -*- coding: utf-8 -*-import keyword# 변수 이름은 문자, 숫자, _ 로 구성해야 한다.friend = 1a = 10my_name = '김상헌'_yourName = '둘리'member1 = '도우넛'# 에러# $friend = 2# a! = 1# 1abc = 10# 에러: 예약어는 사용할 수 없다.# def = 10print(keyword.kwlist)# 한글 이름의 변수도 가능하다.가격1 = 2000print(가격1 - 200) 파이썬 변수 이름 규칙1)문자(유니코드), 숫자, 밑줄(_)로 구성2)숫자는 처음에 올 수 없다.3)대소문자 구분4)예약어 사용 불가5)함수 이름, 클래스 이름도 같은 규칙이 적용된다.PythonExam.pi123456789101112131415161718192021222324252627282930313233343536373839# 참이나 거짓을 나타내는 True, False 두 상수를 갖는다a = 1b = a &lt; 10print(b,type(b),sep=\",\")b1 = Trueb2 = Falseprint(b1 + 10)print(b2 + 10)print(True + True )if a &lt; 10: print(a)a = 23print(type(a))print(isinstance(a,int))print(isinstance(a,bool))b = 0b1101c = 0o23d = 0x23print(a, b, c, d, sep=' ')# 3.x 에서는 int 와 long이 합쳐졌다# 따라서 표현 범위가 굉장히 크다e = 2 ** 1024print(e)print(type(e))# 변환 함수print(oct(38))print(hex(38))print(bin(38))","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Python","slug":"Language/Python","permalink":"http://KKimSangHeon.github.io/categories/Language/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://KKimSangHeon.github.io/tags/Python/"}]},{"title":"13. Logging, IoC / DI","slug":"spring5","date":"2017-09-18T00:26:03.000Z","updated":"2018-09-03T05:57:42.527Z","comments":true,"path":"2017/09/18/spring5/","link":"","permalink":"http://KKimSangHeon.github.io/2017/09/18/spring5/","excerpt":"","text":"로깅이란?-비 기능적 요구사항 ( Non Functional Requirement )하지만, 프로그램 개발 중 디버깅 및 개발완료 후 문제점 추적 및 분석을 위해 필수적으로 갖추어야 할 요구 조건,로그(Log) 는 프로그램 개발이나 운영 시 발생하는 문제점을 추적 하거나 운영 상태를 모니터링 하는 정보,로깅(logging)이란 로그(log)를 생성하도록 시스템을 작성하는 활동-얻을 수 있는 것1.재현하기 힘든 ( 테스트 환경이 아닌 개발 완료된 환경에서 발생하는 ) 버그에 대한 유용한 정보를 제공2.성능에 관한 통계와 정보를 제공할 수 있다. Inversion of Control( 제어역전 ) 이란 프로그램 코드 내에서 참조하려는 객체를 직접 생성 하지 않고 외부의 다른 존재가 생성하여 제공한다는 개념외부의 다른 존재(객체) 를 Container 라고 하며 IoC 오브젝트 또는 IoC Container 라고 한다","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Spring","slug":"Web-App/Spring","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://KKimSangHeon.github.io/tags/Spring/"}]},{"title":"12.AOP","slug":"spring4","date":"2017-09-15T00:11:03.000Z","updated":"2018-09-03T05:57:39.651Z","comments":true,"path":"2017/09/15/spring4/","link":"","permalink":"http://KKimSangHeon.github.io/2017/09/15/spring4/","excerpt":"","text":"AOP 개요(A)spect (O)riented (P)rogramming : 관점 지향 프로그래밍가장 기초가 되는 개념은 관심의 분리(Separation of Concern)AOP는 OOP를 수정하는 것이라 보면 된다.가장 기초가 되는 개념은 관심의 분리(Separation of Concern)1.핵심관심 : 시스템의 핵심 가치와 목적이 그대로 드러난 관심영역 2.횡단관심: 핵심관심 전반에 걸쳐 반복적으로 나오게 되는 로깅, 트랜잭션, 보안, 인증, 리소스 풀링, 에러체크 등의 관심영역 3.관심의 분리: 여러 핵심관심에 걸쳐 등장하는 횡단관심을 분리하여 독립적인 모듈로 만들고 핵심관심이 실행되는 동안 횡단관심을 호출하는 코드를 직접 명시하지 않고 선언적으로 처리 4.핵심관심 모듈의 중간중간에서 필요한 횡단관심 모듈을 직접 호출하지 않고 위빙(Weaving)이라 불리는 작업을 이용하여 횡단관심 코드가 삽입되도록 만든다. 5.핵심관심모듈에서는 횡단관심모듈이 무엇인지 조차 인식할 필요가 없음 AOP의 구성요소1) JoinPoint(언제)-횡단관심모듈은 코드의 아무 때나 삽입이 되는 건 아니다.-조인포인트라 불리는 특정 시점에서만 삽입이 가능하다. 2) PointCut (어디에서)-어느 조인포인트에 횡단관심모듈을 삽입할지를 결정하는 기능-횡단관심이 삽입될 특정 클래스의 특정 메소드를 선택하는 방법 정의 3) Advice(or Interceptor, 무엇을 )횡단관심모듈(로깅, 보안, 트랜잭션 등) 4) Weaving(위빙)-어드바이스(횡단관심)를 삽입하는 과정-위빙작업이 일어나는 시간컴파일 시 - 특별한 컴파일러 필요클래스 로딩시 - 특별한 클래스로더 필요런타임시 - 프록시를 이용한 방법(스프링) ####실습project 생성 - new maven project - 다음 - quick start 다음 - 그룹ID:com.bigdata2017 / 아티클아이디:aoptest 프로젝트 우클릭 - 프로퍼티스- 자바빌드패스 - JRE 수정프로젝트 우클릭 - 프로퍼티스- project facets - Runtimes탭 - jre 선택 후 어플라이 아래와 같이 수정pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.bigdata2017&lt;/groupId&gt; &lt;artifactId&gt;aoptest&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;aoptest&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;org.springframework-version&gt;4.1.1.RELEASE&lt;/org.springframework-version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- spring context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring aspect --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 프로젝트 우클릭- 뉴 - 소스폴더 -src/main/resource생성된 소스폴더안에 config패키지 추가패키지 안에 applicationContext.xml applicationContext.xml123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- AOP AutoProxy --&gt; &lt;aop:aspectj-autoproxy /&gt; &lt;context:annotation-config /&gt; &lt;context:component-scan base-package=\"com.bigdata2017.aoptest\"&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Repository\" /&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Service\" /&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Component\" /&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; App.java에 입력 App.java123456789101112131415161718package com.bigdata2017.aoptest;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123; public static void main( String[] args )&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(\"config/applicationContext.xml\"); ProductService ps = ac.getBean( ProductService.class ); ProductVo vo = ps.find( \"camera\" ); //System.out.println( vo ); &#125;&#125; ProductService.java 생성 pom.xml123456789101112131415161718package com.bigdata2017.aoptest;import org.springframework.stereotype.Service;@Servicepublic class ProductService &#123; public ProductVo find( String keyword ) &#123; System.out.println(\"finding....\");// if( 1 == 2-1 ) &#123;// throw new RuntimeException( \"exceptionoccrs\" );// &#125; return new ProductVo( keyword ); &#125;&#125; ProductVo생성 ProductVo.java123456789101112131415161718192021222324package com.bigdata2017.aoptest;public class ProductVo &#123; private String name; public ProductVo( String name ) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return \"ProductVo [name=\" + name + \"]\"; &#125;&#125; MyAspect생성MyAspect.java123456789101112131415161718192021222324252627282930313233343536package com.bigdata2017.aoptest;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.AfterThrowing;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.springframework.stereotype.Component;@Aspect@Componentpublic class MyAspect &#123; @Before( \"execution(public ProductVo com.bigdata2017.aoptest.ProductService.find(..))\" ) public void beforeAdvice() &#123; System.out.println( \"beforeAdvice() called\" ); &#125; @After( \"execution(* com.bigdata2017.aoptest.*.find(..))\" ) public void afterAdvice() &#123; System.out.println( \"afterAdvice() called\" ); &#125; @AfterReturning( \"execution(* *..ProductService.find(..))\" ) public void afterReturning() &#123; System.out.println( \"afterReturning() called\" ); &#125; @AfterThrowing( value=\"execution(* *..*.*(..))\", throwing=\"ex\" ) public void afterThrowing( Throwable ex ) &#123; System.out.println( \"afterThrowing() called:\" + ex ); &#125;&#125;","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Spring","slug":"Web-App/Spring","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://KKimSangHeon.github.io/tags/Spring/"}]},{"title":"11.Spring. annotation의 활용","slug":"spring3","date":"2017-09-11T00:15:08.000Z","updated":"2018-09-03T05:57:32.943Z","comments":true,"path":"2017/09/11/spring3/","link":"","permalink":"http://KKimSangHeon.github.io/2017/09/11/spring3/","excerpt":"","text":"-JDBC를 통해 DB를 사용하려면, Connection 타입의 DB 연결 객체가 필요하다.-엔터프라이즈 환경에서는 각 요청마다 Connection을 새롭게 만들고 종료시킨다.-애플리케이션과 DB사이의 실제 커넥션을 매번 새롭게 만드는 것은 비효율적이고 성능저하-풀링(pooling) 기법 사용 정해진 개수의 DB Connection Pool에 준비하고 애플리케이션 요청때 마다 꺼내서 할당하고 돌려받아 pool에 저장. -Spring에서는 DataSource를 하나의 독립된 빈으로 등록하도록 강력하게 권장. -엔터프라이즈 시스템에서는 반드시 DB 연결 풀 기능을 지원하는 DataSource를 사용해야 한다. 요약쿼리를 보내는것보다 연결하는데 더 많은 자원이 사용된다. 그래서 사용한는것이 Connection Pool이다. 이는 커넥션을 만들어 놓고 요청이 있을 때 마다 하나 빼서 쓰고 반납하고 쓰고 반납하고 하는 방식이다. 이를 통해 성능이 좋아진다.여기서 Connection Pool을 Datasource라 한다. JREBEL의 활용소스코드가 변경되면 서버를 다시시작해야되는 번거로움이 존재하지만 JREBEL로 극복 가능하다https://my.jrebel.com/ 에 접속하여 가입하고 라이센스키를 받아서 활용하자 Window-Preferences-JRebel에 접속해서 설정하자! 인터셉터스피링에서 서블릿 디스패처와 컨트롤러 사이에 존재하여 가로채는 역할을 한다. Servlet의 앞과 뒤에서 HTTP Request와 HTTP Response를 가로채는 필터와 유사하며 Interceptor를 구현하기 위해서는 HandlerInterceptor 인터페이스를 구현하여야 한다.","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Spring","slug":"Web-App/Spring","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://KKimSangHeon.github.io/tags/Spring/"}]},{"title":"10.Spring. annotation의 활용","slug":"spring2","date":"2017-09-07T02:29:09.000Z","updated":"2018-09-03T05:57:30.725Z","comments":true,"path":"2017/09/07/spring2/","link":"","permalink":"http://KKimSangHeon.github.io/2017/09/07/spring2/","excerpt":"","text":"리턴 은 주로 String, ModelActivew, Object로 한다.메소드 단독매핑MainController.java12345678910111213141516171819202122232425262728package com.bigdata2017.springex.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class MainController &#123; // request mapping (method 단독 매핑) // 접속시 MainController:main 출력됨 @ResponseBody @RequestMapping(\"/main\") public String main() &#123; return \"MainController:main\"; &#125; @ResponseBody @RequestMapping(\"/main2/a/b/c\") public String main2() &#123; return sendMessage(\"main2\"); &#125; private String sendMessage( String message) &#123; return \"MainController:\"+message; &#125;&#125;타입+ 메소드 메핑UserController.java1234567891011121314151617181920212223242526272829303132333435363738394041package com.bigdata2017.springex.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;/* request mapping( type + method) */@Controller@RequestMapping(\"/user\")public class UserController &#123; @ResponseBody @RequestMapping(\"/joinform\") public String joinform() &#123; return \"UserController:joinfrom\"; &#125; @ResponseBody @RequestMapping(&#123;\"/join\",\"/doJoin\"&#125;) public String join() &#123; return \"UserController:join\"; &#125; @ResponseBody @RequestMapping( value = \"/loginform\", method=RequestMethod.GET) public String loginform() &#123; return \"UserController:loginform\"; &#125; @ResponseBody @RequestMapping( value = \"/login\", method=RequestMethod.GET) public String login() &#123; return \"UserController:login\"; &#125;&#125; 타입단독 메핑GuestbookController.java12345678910111213141516171819202122232425package com.bigdata2017.springex.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;//Request Mapping (type 단독 매핑)@Controller@RequestMapping(\"/guestbook/*\")public class GuestbookController &#123; @ResponseBody @RequestMapping public String list() &#123; return \"GuestbookController:list\"; &#125; @ResponseBody @RequestMapping public String insert() &#123; return \"GuestbookController:insert\"; &#125;&#125; 정리타입+메소드 매핑이 가장 많이 쓰인다.!","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Spring","slug":"Web-App/Spring","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://KKimSangHeon.github.io/tags/Spring/"}]},{"title":"9.Spring이란? helloSpring실습","slug":"spring","date":"2017-09-06T05:01:31.000Z","updated":"2018-09-03T05:57:27.834Z","comments":true,"path":"2017/09/06/spring/","link":"","permalink":"http://KKimSangHeon.github.io/2017/09/06/spring/","excerpt":"","text":"스프링이란?자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크 프레임워크?소프트웨어를 만드는 데 기본이 되는 골격 코드반제품완전한 애플리케이션 소프트웨어가 아니다.문제 영역(도메인)을 해결하기 위한 잘 설계된 재사용 가능한 모듈확장하여 비즈니스 요구사항에 맞는 완전한 애플리케이션으로 완성이 요구된다. 스프링을 이용하여 웹을 만들면 Spring MVC를 사용DB어플리케이션 프레임 워크는 MyBatis,Spring DAO가 존재기타(지원) 프레임워크로는 로깅(Log4J), 빌드/배포(Ant), 단위테스트(JUnit)가 존재 객체에 대한 의존성,생성,소멸 등에 대한 것을 스프링 컨테이너에게 넘긴다. 이로 인해 개발자는 비즈니스만 잘 만들면 된다. 이로인해 생산성이 향상된다. EJBEnterprise Java Bean의 약자.자바 빈즈 스펙에 맞게 구현된 자바코드를 웹에서 쉽게 이용하기 위해 JSP 표준액션 태그 지원인터페이스 구현 등 불편한 점이 많았다. POJO(Plain Old Java Object)EJB를 대체하여 특정클래스를 상속하거나 인터페이스를 구현하지 않는 평범한 자바 클래스(느슨한 Java Bean, Spring Bean)를 이용하며 단순하지만 EJB에서 제공하는 고급 기술을 제공한다.-자바 언어와 꼭 필요한 API외에는 특정 규약에 종속되지 않는다.-특정 환경에 종속되지 않는다. (기술과 비즈니스 분리)(서블릿은 서블릿 컨테이너에 종속적이였음)-스프링에서는 스프링에 특화된 인터페이스 구현을 요구하지 않음-스프링 자체에 의존성이 높은 클래스 확장을 거의 요구 하지 않음 Spring1.POJO를 이용한 가볍고(lightweight) 비침투적(non-invasive) 개발2.DI와 인터페이스 지향을 통한 느슨한 결합도(loose coupling)3.Aspect와 공통 규약을 통한 선언적(declarative) 프로그래밍4.Aspect와 템플릿(template)을 통한 반복적이고 상투적인(boilerplate) 코드 제거 AOP는 OOP를 더 OOP답게 쓰는것 3.1 IoC( 제어역전 ,Inverse of Control (Object) ) 과 DI( 의존관계 주입)Spring Container = IoC(DI) Container = Bean Container = Application Contextnew를 하지 않아도 컨테이너가 알아서 만들고 소멸해주고 다한다!! AOP (Aspect Oriented Programming)클래스의 관심에 따라 클래스를 구성하게되는데(ex:DAO는 DB접근에 관심) 횡단관심: 여러곳에서 공통으로 필요한 모듈횡단관심은 클래스로 빼내서 모듈로 만든다.관심의 분리 ( Separation of Concern )횡단 관심( Crosscutting Concern )과 핵심관심( Core Concern )핵심관심 모듈과 횡단 관심 모듈이 긴밀하게 결합 ( 핵심 모듈이 필요한 시점에..)OOP 문제점 : 중복코드, 지저분한 코드, 생산성 저하, 재활용성의 문제점필요한 시점에 횡단 관심 모듈을 삽입하여 동작하게 하는 기술. EJB AOP, JDK Dynamic Proxy, AspectJ, Spring AOP 실습다이나믹 웹 프로젝트를 생성해서 메이븐으로 바꿔줄것이다.1.dynamic web project - next - src를 remove 하고 src/main/java 추가 -next - directory를 webapp로 변경하고 체크하고 finish2.프로젝트 우클릭 configure- convert to maven project -그룹 id에 com.bigdata2017입력작업이 끝나고 나면 프로젝트 옆 이미지에 m이 생긴다. 라이브러리 의존성을 추가하자1.pom.xml을 열자. 다음과 같이 수정하자 pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.bigdata.2017&lt;/groupId&gt; &lt;artifactId&gt;springex&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;org.springframework-version&gt;4.1.1.RELEASE&lt;/org.springframework-version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Spring Core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring Web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring MVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jstl --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.6.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;configuration&gt; &lt;warSourceDirectory&gt;webapp&lt;/warSourceDirectory&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; web.xml을 수정하자webapp/WEB-INF/web.xml pom.xml1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" id=\"WebApp_ID\" version=\"3.0\"&gt; &lt;display-name&gt;springex&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; spring-servlet.xml 생성WEB-INF 폴더내에 생성하자spring-servlet.xml1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns=\"http://www.springframework.org/schema/beans\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:annotation-config /&gt; &lt;context:component-scan base-package=\"com.bigdata2017.springex.controller\" /&gt;&lt;/beans&gt; javaResource에 com.bigdata2017.springex.controller 패키지 추가패키지에 다음 파일 추가HelloController.java123456789101112package com.bigdata2017.springex.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class HelloController &#123; @RequestMapping(\"/hello\") public String hello() &#123; return \"/WEB-INF/views/hello.jsp\"; &#125;&#125; WEB-INF에 views폴더 추가 후 hello.jsp 추가hello.jsp123456789101112&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello Spring&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 추가적으로 해준 것들1) pom.xml 구성 2) DispatcherServlet 등록( web.xml ) 3) 서블릿 애플리케이션 컨텍스트 설정 (spring-servlet.xml) 4) Controller 작성 생략된 것들1) 서블릿 작성 2) 파라미터 처리 request.getParameter() 3) forwarding","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Spring","slug":"Web-App/Spring","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://KKimSangHeon.github.io/tags/Spring/"}]},{"title":"8.Ajax","slug":"ajax","date":"2017-09-06T00:10:29.000Z","updated":"2018-09-03T05:57:24.900Z","comments":true,"path":"2017/09/06/ajax/","link":"","permalink":"http://KKimSangHeon.github.io/2017/09/06/ajax/","excerpt":"","text":"Asynchronous Javascript XML AJAX는 비동기 통신이다. 동기클라이언트가 리퀘스트를 보내면 그에 대한 리스폰스가 와야 다른 리퀘스트를 보낼 수 있다.서버에서 리퀘스트에 대한 응답이 오지 않으면 block상태에 빠진다는 단점 존재. 비동기리퀘스트에 대한 응답을 기다리지 않고 다른 동작을 처리할 수 있다.단점은 어느 요청이 어느 요청에 대한 응답인지 알기 어려울 수 있다. 도착순서도 정해져있지 않고 많은 응답이 있기 때문에..ajax를 이용하지 않고 통신1234567891011121314151617181920212223242526272829303132333435363738394041424344454647$(function()&#123; $(\"button\").click(function()&#123; //1.XMLHttpRequest 객체 생성 var xhr = new XMLHttpRequest(); //2. 통신 상태 변화에 따른 콜백함수 정의 xhr.onreadystatechange = function()&#123; if( this.readyState == 0 )&#123; //open() 호출 전 console.log( \"readyState(0) - unset\" ); &#125;else if(this.readyState ==1)&#123; //open() 호출 후 console.log( \"readyState(1) - set\" ); &#125;else if(this.readyState ==2)&#123; //send() 호출 후 console.log( \"readyState(2) - sent\" ); &#125;else if(this.readyState ==3)&#123; //loading... console.log( \"readyState(3) - loading\" ); &#125;else if(this.readyState ==4)&#123; //done console.log( \"readyState(4) - done\" ); console.log( xhr.responseText); var response = eval(xhr.responseText); console.log(response); $.each(response,function(index,vo)&#123; console.log( index +\":\" + vo.name) &#125;) &#125; &#125;; //3. open xhr.open(\"GET\",\"/wp_js2/sample.json\") //4. send request xhr.send(); &#125;);&#125;)ajax를 이용하여 통신1234567891011121314151617181920$(function()&#123; $(\"button\").click(function()&#123; $.ajax( &#123; async: true, url : \"/wp_js2/sample.json\", type: \"get\", dataType: \"json\", data: \"\", contentType: 'application/json', success: function(response)&#123; $.each (response,function(index,vo)&#123; console.log(vo.name) &#125;) &#125;, error: function( jqXHR, status, e )&#123; alert( status + \" : \" + e ); &#125; &#125;); &#125;);&#125;);","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Spring","slug":"Web-App/Spring","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Spring/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://KKimSangHeon.github.io/tags/Ajax/"}]},{"title":"7.jquery","slug":"jquery1","date":"2017-09-05T00:09:56.000Z","updated":"2018-09-03T05:57:34.824Z","comments":true,"path":"2017/09/05/jquery1/","link":"","permalink":"http://KKimSangHeon.github.io/2017/09/05/jquery1/","excerpt":"","text":"2006년 Mozila의 자바스크립트 에반젤리스 Jhon Resig에 의해 개발 / 공개여러 자바스크립트 라이브러리 ( prototype.js, Mootool.js 등) 중에 가장 주목 받고 있다.jQuery로 코딩하면 자바스크립트 코드가 간결해 진다.가볍다 ( 90KB)IE6.0 이상, Firefox2.0 이상, Safari 3 이상, Opera 9이상, Google Chrome등의 주요 브라우저를 지원하여 클로스브라우징을 가능케 한다. 엘리먼트를 골라야 하는 시점들123456789101112131415161718//엘리먼트를 골라야 하는 시점 1(Vanilla JS)window.onload = function()&#123; console.log(document.getElementBy(\"my-p\"));&#125;//엘리먼트를 골라야 하는 시점 2 (jQuery)jQuery( document ).ready( function()&#123; console.log( document.getElementById(\"my-p\"));//엘리먼트를 골라야 하는 시점 3 (jQuery)$( document ).ready( function()&#123; console.log(document.getElementById(\"my-p\"));&#125;)//엘리먼트를 골라야 하는 시점 4 (jQuery)$(function()&#123; console.log(document.getElementById(\"my-p\"));&#125;); jQuery 함수를 이용한 색 변경12345678910111213141516171819202122232425$(function()&#123; setTimeout( function()&#123; var $li = $(\"li\"); $li.css(\"color\",\"#f00\" ); //jQuery Object 뭐냐? console.log($li.length); console.log($li[0]); //HTMLElement Object //에러유발 //$li[0].css(\"font-weigth\",\"bold\") $li[0].style.fontWeight = \"bold\"; //jQuery API를 호출 하고 싶으면 //jQuery 함수(=$)로 매핑한다 $($li[0]).css(\"text-decoration\",\"underline\") //get api함수를 사용해서 HTMLElement 가져오기 $($li.get(1)).css(\"backgroundColor\",\"#ccc\"); &#125;,2000)&#125;); jQuery 활용방법123456789101112131415161718$(\"#first\").css(\"color\",\"red\");$(\"#secnod\").css(\"color\",\"blue\");$(\"#second\").css(\"fontWeight\",\"bold\");var $li3 = $(\"#third\");$li3.css(\"color\",\"blue\");$li3.css(\"fontWeigth\",\"bold\");//메소드 체인$(\"#third\").css(\"color\",\"blue\").css(\"fontWeight\",\"bold\");// 파라미터로 JSON을 사용하는 방법$(\"#fifth\").css(&#123; \"color\":\"blue\", \"fontWeight\":\"bold\"&#125;); 다양한 선택방법12345678910111213$(\".red strong\").css(\"color\",\"red\").text(\"text\");$(\".blue #s1\").css(\"color\",\"blue\"); //자손 선택$(\".blue &gt; #s2\").css(\"color\",\"red\"); //자식선택 (바로아래)$(\"#second + li\").css(\"color\",\"red\"); //인접선택$(\"li:first-child\").css(\"color\",\"red\"); //첫번째 자식$(\"li:last-child\").css(\"color\",\"red\"); //마지막 자식$(\"li[id]\").css(\"color\",\"red\"); //id 속성이 있는 애만$(\"li[class]\").css(\"color\",\"red\"); //class속성이 있는애만","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Spring","slug":"Web-App/Spring","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Spring/"}],"tags":[{"name":"JQuery","slug":"JQuery","permalink":"http://KKimSangHeon.github.io/tags/JQuery/"}]},{"title":"6.웹표준","slug":"servlet6","date":"2017-08-30T00:00:10.000Z","updated":"2018-09-03T05:57:05.810Z","comments":true,"path":"2017/08/30/servlet6/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/30/servlet6/","excerpt":"","text":"초창기 웹은 넷스케이프가 독주하는 상황이었지만, 윈도우98 부터 IE브라우저가 기본 탑재되어 IE6.0는 브라우저 시장의 90%를 점유 했었다. IE의 ActiveX (자사 기술 독점)에 따른 웹 환경의 폐해MS는 COM(Component Object Model)이라는 기술 제공한다. 이 중 UI가 있는 컴포넌트를 ActiveX라 한다. IE이외의 사파리, 크롬, 파이어폭스, 오페라 등 다양한 브라우저가 데스트탑 환경에서 영향력이 커졌다특히, 모바일 환경에서는 사파리, 크롬, 파이어폭스가 주도권을 잡았다.특정 웹 브라우저에 종속되는 웹 페이지는 더 이상 설 자리가 없음을 의미웹 페이지 제작 기술에 표준의 필요성이 대두 웹 표준을 주도하는 W3C( World Wide Web Consortium )-http://www.w3.org-웹 기술의 표준화를 담당하는 기구-HTML, CSS, XML 등 웹과 관련된 다양한 기술에 대해 논의하며 관련기술 표준 재정-웹 표준은 W3C의 목표와 비전에 따라 연구한 결과를 웹에 반영시키기 위한 권고 사항 웹 접근성어떤 장비, 어떤 브라우저를 사용하던지 해당 사이트를 얼마나 볼 수 있는냐를 의미일반인이건 장애인이건 어떤 사용자도 해당 사이트 사용에 어려움이 없어야 한다는 의미웹 표준을 지켜 작성한 HTML 문서는 웹 접근성을 준수하는 데 비표준 문서들 보다 쉽다.표현을 CSS로 분리 시킨 HTML 문서는 웹 접근성을 준수하는 데 표현과 정보가 섞여 있는 문서들 보다 쉽다. 웹 2.0의 개념-웹2.0이란 이용자가 적극적으로 참여하여 정보/지식을 만들고 공유하는 열린 인터넷을 의미한다-웹 2.0은 웹과 관련된 새로운 기술, 문화, 그리고 경제 현상의 복합적인 변화를 포함하는 개념이다. 즉, 사용자 편의성을 강화한 새로운 기술의 활용, 정보의 생성 및 개방/ 공유를 통한 직접적 가치 창출, 이를 통해 만들어진 새로운 문화 및 경제 현상을 통틀어 웹2.0으로 이해할 수 있다 웹 2.0의 목표앞서 웹2.0의 개념을 살펴보았습니다. 그렇다면 웹2.0은 어떤 배경에서 등장하게 되었고, 이 새로운 패러다임으로 이루고자하는 것은 무엇일까요? 웹2.0의 기본적인 목적은 ‘사람들을 다양하고 새로운 방식으로 연결하고 연결 된 사람들의 집단지성을 활용하는 것’입니다. 웹 2.0 출처 : http://visualize.tistory.com/267 웹언어 ( = HTML )-웹페이지를 만들기 위해 HTML(Hyper Text Markup Language)를 사용하여 파일을 생성하고, 웹 서버에 그 파일을 올려 놓아야 한다. -HTML은 페이지를 보여주기 위해서 알아야 할 필요가 있는 모든 것을 브라우저에게 알려준다. 하이퍼텍스트 (HTML)-웹 전체의 기초가 되는 것-단일 페이지에서 벗어나 다른 페이지와 연결할 수 있게 해주는 것- 엘리멘트에 의해 구현-콘텐츠 이런 식으로 링크가 걸리며, href 속성은 목적지를 명시 DOMDocument Object Model로 웹페이지를 자바스크립트로 제어하기 위한 객체 모델을 의미한다. window 객체의 document 프로퍼티를 통해서 사용할 수 있다. Window 객체가 창을 의미한다면 Document 객체는 윈도우에 로드된 문서를 의미한다고 할 수 있다. DOM의 하위 수업에서는 문서를 제어하는 방법에 대한 내용을 다룬다. DOM 출처 : https://opentutorials.org/course/1375/6655 시맨틱 검색시맨틱 검색은 검색로봇이 검색어 의미를 스스로 분석하고 추리해 원하는 정보를 더 정교하게 찾아주는 검색방식 시맨틱 마크업시맨틱 마크업이란 HTML의 태그를 사용하여 문서 안의 내용이 담고 있는 의미가 무엇인지 표현할 수 있도록 구조를 작성하는 것을 말함 http://www.greeneclipse.com/eclipsepalette.html 에 접속해서 설치하면 DOCTYPE-DOCTYPE은 html의 태그는 아니지만 웹페이지에서 맨 처음에 선언되어 어떤 종류의 html을 사용할지 웹브라우저에게 알려줄 목적으로 사용-브라우저는 DOCTYPE 선언을 확인하고 브라우저 모드를 결정한다.-브라우저 모드는 표준 호환 모드, 비표준 호환 모드-웹 표준에서는 웹 페이지를 제대로 표현하기 위해서는 올바른 문서 형태를 정의해주어야 한다.-가장 많이 사용되고 있는 HTML 버전은 HTML4.01 과 XHTML1.0-최신 버전인 HTML5를 문서형식으로 사용하는 웹사이트도 증가 추세 CSS ( Cascading Style Sheet ) 이해-워드프로세스의 스타일 적용과 유사-cascading : ‘계단형’ 의 의미로 스타일 적용에 특정도, 또는 우선순위가 있고 우선 순위가 정해지는 것이 계단식 스타일 시트라는 의미무조건 맨 아래 있는게 적용되는게 아니라 P{…} body P{….} body P.aaa{…} 일 경우 가장 길이가 긴 body P.aaa{…} 가 적용됨","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Servlet/JSP","slug":"Web-App/Servlet-JSP","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Servlet-JSP/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://KKimSangHeon.github.io/tags/Servlet/"}]},{"title":"5. EL, JSTL","slug":"servlet5","date":"2017-08-28T05:13:23.000Z","updated":"2018-09-03T05:57:03.003Z","comments":true,"path":"2017/08/28/servlet5/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/28/servlet5/","excerpt":"","text":"EL기존에 사용하는 스크립트릿을 &lt;%= %&gt;를 대체할 수 있따.&lt;%= vo.getName %&gt;를 $ { vo.name } 으로 대체 가능하다 이를 EL(Expression Language)이라 한다.웹 페이지에 값을 표시(표현),하는 데 사용되는 태그JSP의 출력 문법을 보완하는 역할${} 를 사용한다.표현언어의 식을 계산해서 출력한다.null 는 공백으로 출력한다. 스클릿틀릿 사용예시1234567&lt;% if( null == session.getAttribute( \"authUser\" ) ) &#123;%&gt; &lt;p&gt;로그인을 하지 않았습니다.&lt;/p&gt;&lt;% &#125;%&gt; 위의 코드는 다음과 같다EL의 사용예시123&lt;c:if test=\"$&#123; empty authUser &#125;\"&gt; &lt;p&gt;로그인을 하지 않았습니다.&lt;/p&gt;&lt;/c:if&gt;EL로 내장객체 접근하기-pageScope : 페이지 범위에 빈을 저장-requestScope : 요청 범위에서 빈을 저장-sessionScope : 세션 범위에서 빈을 저장-applicationScope : 어플리케이션 범위에서 빈을 저장 JSTLJSP에서 사용 가능한 표준 태그 라이브러리JSP 코드가 깔끔해지고 가독성이 좋아진다.JSTL 라이브러리 -기본기능 ( core ) -형식화(format) -데이터베이스(sql) -XML 처리(xml) -함수처리(function) jstl.jar 파일을 구해서 프로젝트 우클릭 후 자바빌드패스의 라이브러리탭에서 추가하고 deployment assembly에 추가 아래 3개는 추가해놓고 사용하여야 한다.-기본기능 ( core ) :&lt;%@ taglib uri=”http://java.sun.com/jsp/jstl/core“ prefix=”c”%&gt; -형식화(format) :&lt;%@ taglib uri=”http://java.sun.com/jsp/jstl/fmt“ prefix=”fmt”%&gt; -함수처리(function) :&lt;%@ taglib uri=”http://java.sun.com/jsp/jstl/functions“ prefix=”fn”%&gt; JSTL은 if문을 제공하나 else if , else를 제공하지 않는다. 이를 대체하여 사용할 수 있는것이 choose이다. choose사용예시1234567891011121314151617&lt;c:choose&gt; &lt;c:when test=\"$&#123;param.color == 1&#125;\"&gt; &lt;span style=\"color: red\"&gt;빨강&lt;/span&gt; &lt;/c:when&gt; &lt;c:when test=\"$&#123;param.color == 2&#125;\"&gt; &lt;span style=\"color: green\"&gt;초록&lt;/span&gt; &lt;/c:when&gt; &lt;c:when test=\"$&#123;param.color == 3&#125;\"&gt; &lt;span style=\"color: blue\"&gt;파랑&lt;/span&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;span style=\"color: black\"&gt;검정&lt;/span&gt; &lt;/c:otherwise&gt;&lt;/c:choose&gt; -변수에 값을 설정한다.","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Servlet/JSP","slug":"Web-App/Servlet-JSP","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Servlet-JSP/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://KKimSangHeon.github.io/tags/Servlet/"}]},{"title":"4. 서블릿의 Life Cicle, MVC, Model1","slug":"servlet4","date":"2017-08-25T00:07:35.000Z","updated":"2018-09-03T05:56:59.562Z","comments":true,"path":"2017/08/25/servlet4/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/25/servlet4/","excerpt":"","text":"첫번째 호출 때는init() calledservice() calleddoGet() called순으로 이어진다. 두번 째 호출때는service() calleddoGet() called순으로 이어진다 즉 변수를 선언 할 때는 init() 메소드 안에 선언해주는것이 좋으나 동기화를 잘 해줘야하는단점이 있다. MVC아키텍쳐 패턴 중에 하나로 GUI 기반 Application 설계, 패턴클라이언트 요청을 받아 처리하여 응답하는 로직을 Model, View, Controller 로 나누어 설계하고 구현 Model애플리케이션 정보(데이터) 또는 정보를 처리하는 모듈(객체)ex) DAO View텍스트, 체크박스, 입력창 등과 같은 사용자 인터페이스 요소를 나타냄ex) HTML Controller클라이언트 요청, Model, View 사이의 상호동작을 관리 한다. 라우팅만 한다고 생각하자ex) java로직 Model1M + VC 이라고 생각하면 된다.※모델1은 컨트롤 뷰가 하나로 이루어짐. 모델1은 요청마다 서블릿이 만들어져 관리해야할 jsp가 많아진다. Model2M(DAO) + V(JSP) + C(Servlet)주로 복잡한 요구사항을 처리하는 웹 애플리케이션에서 MVC(Model-View-Controller pattern) 패턴을 사용한다. MVC 패턴은 코딩과 유지보수를 쉽게 하고, Model 2 아키텍처라고도 불린다.","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Servlet/JSP","slug":"Web-App/Servlet-JSP","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Servlet-JSP/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://KKimSangHeon.github.io/tags/Servlet/"}]},{"title":"3. Servlet & JSP 응용실습","slug":"servlet3","date":"2017-08-24T02:07:50.000Z","updated":"2018-09-03T05:56:49.513Z","comments":true,"path":"2017/08/24/servlet3/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/24/servlet3/","excerpt":"","text":"JSPjsp파일은 내부적으로 서블릿으로 변환 된다는 점을 잊지말자.톰캣이 자동으로 해준다. 리다이렉트 포워드의 차이포워드 - 새로운 페이지는 이전 페이지에서 처리하던 것과 같은 요청을 처리하게 하고 응답하여 브라우저는 하나 이상의 페이지가 연관 된 것을 알 수 없다. 리다렉트 - 첫번째 페이지는 브라우저에게 새로운 페이지로 다시 요청해야 한다는 내용의 응답을 보낸다. 브라우저는 이 응답을 받으면 즉시 새로운 페이지로 다시 요청을 보낸다. 실습다이나믹 웹 프로젝트 생성-서버우클릭 add and remove 프로젝트 추가 프로젝트 우클릭 후 - 프로퍼티스 -JAVA BUILD PATH - add library 후 ojdbc 추가프로젝트 우클릭 후 - 프로퍼티스 -deployment assembly - add -jdbc 추가 후 apply JSTLjsp standard tag library EmailListDao.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127package com.bigdata2017.emaillist.dao;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.ArrayList;import java.util.List;import com.bigdata2017.emaillist.vo.EmailListVo;public class EmailListDao &#123; public int insert( EmailListVo vo) &#123; int count = 0; Connection conn= null; PreparedStatement pstmt = null; try &#123; conn = getConnection(); String sql = \"INSERT \" +\"INTO EMAILLIST \" + \"VALUES (SEQ_EMAILLIST.NEXTVAL,?,?,?)\"; pstmt = conn.prepareStatement(sql); pstmt.setString(1, vo.getFirstName()); pstmt.setString(2, vo.getLastName()); pstmt.setString(3, vo.getEmail()); count = pstmt.executeUpdate(); &#125; catch (SQLException e) &#123; System.out.println( \"error\" + e ); &#125; finally &#123; //3. 자원정리 try &#123; if( pstmt != null ) &#123; pstmt.close(); &#125; if( conn != null ) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return count; &#125; public List&lt;EmailListVo&gt; getList()&#123; List&lt;EmailListVo&gt; list = new ArrayList&lt;EmailListVo&gt;(); Connection conn = null ; Statement stmt = null; ResultSet rs = null; try &#123; conn = getConnection(); //3. Statement 객체 생성 stmt = conn.createStatement(); //4. SQL문 실행 String sql =\"SELECT NO,FIRST_NAME,LAST_NAME,EMAIL\\r\\n\" + \"FROM EMAILLIST ORDER BY NO DESC\"; rs = stmt.executeQuery(sql); System.out.println(\"connection 성공\"); //5. 결과 사용하기 while( rs.next() ) &#123; Long no = rs.getLong( 1 ); String firstName = rs.getString(2); String lastName = rs.getString(3); String email = rs.getString(4); EmailListVo vo = new EmailListVo(); vo.setNo(no); vo.setFirstName(firstName); vo.setLastName(lastName); vo.setEmail(email); list.add(vo); &#125; &#125; catch (SQLException e) &#123; System.out.println( \"error\" + e ); &#125; finally &#123; //3. 자원정리 try &#123; if( rs != null ) &#123; rs.close(); &#125; if( stmt != null ) &#123; stmt.close(); &#125; if( conn != null ) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return list; &#125; private Connection getConnection() throws SQLException &#123; Connection conn = null ; //1. JDBC 드라이버 로딩 try &#123; Class.forName( \"oracle.jdbc.driver.OracleDriver\" ); //2. Connection 얻어오기 String url = \"jdbc:oracle:thin:@localhost:1521:xe\"; conn = DriverManager.getConnection(url, \"webdb\", \"webdb\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return conn; &#125;&#125; form.jsp12345678910111213141516171819202122232425&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;메일 리스트 가입&lt;/h1&gt; &lt;p&gt; 메일 리스트에 가입하려면,&lt;br&gt; 아래 항목을 기입하고 등록 버튼을 클릭하세요. &lt;/p&gt; &lt;form method=\"post\" action=\"&lt;%=request.getContextPath() %&gt;/insert.jsp\" &gt; First name: &lt;input type=\"text\" name=\"fn\" value=\"\" /&gt;&lt;br&gt; Last name: &lt;input type=\"text\" name=\"ln\" value=\"\" /&gt;&lt;br&gt; Email address: &lt;input type=\"text\" name=\"email\" value=\"\"/&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"submit\"&gt; &lt;/form&gt; &lt;br&gt; &lt;p&gt; &lt;a href = \"&lt;%=request.getContextPath()%&gt;\"&gt;리스트 바로가기&lt;/a&gt; &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; index.jsp123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;%@page import=\"com.bigdata2017.emaillist.vo.EmailListVo\"%&gt;&lt;%@page import=\"java.util.List\"%&gt;&lt;%@page import=\"com.bigdata2017.emaillist.dao.EmailListDao\"%&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;% EmailListDao dao = new EmailListDao(); List&lt;EmailListVo&gt; list = dao.getList();%&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;메일 리스트에 가입되었습니다.&lt;/h1&gt; &lt;p&gt;입력한 정보 내역입니다.&lt;/p&gt; &lt;!-- 메일정보 리스트 --&gt; &lt;%-- list에서 하나씩 빼서 테이블를 채운다--%&gt; &lt;% for(EmailListVo vo : list )&#123; %&gt; &lt;table border=\"1\" cellpadding=\"5\" cellspacing=\"2\"&gt; &lt;tr&gt; &lt;td align=right&gt;First name: &lt;/td&gt; &lt;td&gt;&lt;%=vo.getFirstName() %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=right width=\"110\"&gt;Last name: &lt;/td&gt; &lt;td width=\"110\"&gt;&lt;%=vo.getLastName()%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=right&gt;Email address: &lt;/td&gt; &lt;td&gt;&lt;%=vo.getEmail()%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br&gt; &lt;%&#125; %&gt; &lt;p&gt; &lt;a href=\"&lt;%=request.getContextPath() %&gt;/form.jsp\" &gt;추가메일 등록&lt;/a&gt; &lt;/p&gt; &lt;br&gt;&lt;/body&gt;&lt;/html&gt; insert.jsp123456789101112131415161718192021222324252627282930&lt;%@page import=\"com.bigdata2017.emaillist.dao.EmailListDao\"%&gt;&lt;%@page import=\"com.bigdata2017.emaillist.vo.EmailListVo\"%&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt; &lt;% request.setCharacterEncoding( \"utf-8\"); String firstName = request.getParameter( \"fn\" ); String lastName = request.getParameter( \"ln\" ); String email = request.getParameter(\"email\"); EmailListVo vo = new EmailListVo(); vo.setFirstName(firstName); vo.setLastName(lastName); vo.setEmail(email); new EmailListDao().insert(vo); response.sendRedirect( request.getContextPath() ); %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;성공적으로 등록되었습니다.&lt;/h1&gt; &lt;a href=\"index.jsp\"&gt;리스트 돌아가기&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Servlet/JSP","slug":"Web-App/Servlet-JSP","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Servlet-JSP/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://KKimSangHeon.github.io/tags/Servlet/"}]},{"title":"2. Servlet & JSP 기본실습","slug":"servlet2","date":"2017-08-24T00:02:51.000Z","updated":"2018-09-03T05:56:55.257Z","comments":true,"path":"2017/08/24/servlet2/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/24/servlet2/","excerpt":"","text":"JSP도 곧 서블릿임을 잊지말자. GET 방식 : http://naver.com?이름=shkim&amp;암호=1234 get방식으로 한글을 보낼경우 글이 깨지는데 이때는 server을 열고 server.xml을 열자. 65라인에 URIEncoding=”utf-8”을 추가해주자 WebContent에 form.jsp 생성form , 절대경로, 상대경로에 대해 알아보자form.jsp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- h1태그는 블록 태그라 아래로 내려감 --&gt; &lt;h1&gt;폼테스트&lt;/h1&gt; &lt;h2&gt;폼테스트&lt;/h2&gt; &lt;h3&gt;폼테스트&lt;/h3&gt; &lt;h4&gt;폼테스트&lt;/h4&gt; &lt;h5&gt;폼테스트&lt;/h5&gt; &lt;!-- 상대경로(form.jsp의 위치부터) --&gt; &lt;img src = \"images/java.png\"&gt; &lt;!-- 절대경로 --&gt; &lt;a href = \"/helloweb/index.jsp\"&gt;메인으로 가기&lt;/a&gt; &lt;!-- 절대경로를 처리하는 안정적인 방법 --&gt; &lt;a href = \"&lt;%=request.getContextPath() %&gt;/index.jsp\"&gt;메인으로 가기&lt;/a&gt; &lt;!-- form 태그는 디폴트로 겟방식으로 날린다. --&gt; &lt;form method=\"post\" action=\"&lt;%= request.getContextPath() %&gt;/join\"&gt; &lt;!-- input 태그는 인라인 태그라 옆으로간다. --&gt; &lt;input type=\"hidden\" name=\"type\" value=\"나쁜놈\"/&gt; 이메일: &lt;input type=\"text\" name=\"email\" value=\"\"&gt; &lt;br&gt;&lt;br&gt; 비밀번호: &lt;input type=\"password\" name=\"password\" value=\"\"&gt; &lt;br&gt;&lt;br&gt; 이름: &lt;input type=\"text\" name=\"name\" &gt; &lt;br&gt;&lt;br&gt; 성별: &lt;!-- radio는 name속성을 같게 해줘야 하나만 선택된다. --&gt; &lt;input type=\"radio\" name=\"gender\" value=\"female\"/&gt; 여 &lt;input type=\"radio\" name=\"gender\" value=\"male checked=checked\"/&gt; 남 &lt;br&gt;&lt;br&gt; 생년: &lt;select name = \"birth-year\"&gt; &lt;option value=\"1995\"&gt;1995&lt;/option&gt; &lt;option value=\"1994\"&gt;1994&lt;/option&gt; &lt;option value=\"1993\"&gt;1993&lt;/option&gt; &lt;option value=\"1992\"&gt;1992&lt;/option&gt; &lt;option value=\"1991\"&gt;1991&lt;/option&gt; &lt;option value=\"1990\" selected&gt;1990&lt;/option&gt; &lt;/select&gt; &lt;br&gt;&lt;br&gt; 취미: &lt;input type=\"checkbox\" name=\"hobby\" value=\"reading\"/&gt;독서 &lt;input type=\"checkbox\" name=\"hobby\" value=\"sleeping\"/&gt;잠자기 &lt;input type=\"checkbox\" name=\"hobby\" value=\"swimming\"/&gt;수영 &lt;input type=\"checkbox\" name=\"hobby\" value=\"coding\"/&gt;코딩 &lt;br&gt;&lt;br&gt; 자기소개: &lt;br&gt;&lt;br&gt; &lt;textarea rows=\"15\" cols=\"80\" name=\"self-intro\"&gt;123412341234&lt;/textarea&gt; &lt;br&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"가입\"&gt; &lt;br&gt;&lt;br&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; Java Resource에 서블릿 파일 생성join.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.bigdata2017.helloweb.servlet;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Servlet implementation class join */@WebServlet(\"/join\")public class join extends HttpServlet &#123; private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding( \"utf-8\"); //post 방식으로 데이터를 전달 받는 경우 //encoidng charset를 지정 String type = request.getParameter(\"type\"); System.out.println(type); String email = request.getParameter(\"email\"); System.out.println(email); String password = request.getParameter(\"password\"); System.out.println(password); String name = request.getParameter(\"name\"); System.out.println(name); String gender = request.getParameter(\"gender\"); System.out.println(gender); String birthYear = request.getParameter(\"birth-year\"); System.out.println(birthYear); String hobbies[] = request.getParameterValues( \"hobby\" ); if( hobbies != null) &#123; for( String hobby : hobbies) &#123; System.out.println( hobby ); &#125; &#125; String selfIntro = request.getParameter(\"self-intro\"); System.out.println(selfIntro); response.setContentType( \"text/html; charset=utf-8\" ); //setContentType() 메소드를 호출하고 getWriter()을 호출해야 글이 안꺠진다. PrintWriter out = response.getWriter(); out.println(\"&lt;h1&gt;성공적으로 가입되었습니다&lt;/h1&gt;\"); out.print(\"&lt;a href='/helloweb/form.jsp'&gt;폼으로가기&lt;/a&gt;\"); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125;","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Servlet/JSP","slug":"Web-App/Servlet-JSP","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Servlet-JSP/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://KKimSangHeon.github.io/tags/Servlet/"}]},{"title":"1. servlet이란? 실습","slug":"servlet1","date":"2017-08-23T04:05:38.000Z","updated":"2018-09-03T05:56:53.179Z","comments":true,"path":"2017/08/23/servlet1/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/23/servlet1/","excerpt":"","text":"톰켓을 서블릿 콘테이너, WAS라 부른다. JSP - HTML을 아는사람들이 쉽게 만들 수 있는것.결국 이도 서블릿 클래스로 변한다.톰캣은 web.xml파일의 매핑 정보를 보고 요청에 대한 응답을 날려준다. 서버 생성하고 - 프로젝트 익스플로러 탭에서 우클릭- web프로젝트 생성 - next-next-맨 아래 체크 - finish 이클립스가 프로젝트명.war파일을 올려놓으면 톰켓이 그것을 풀어서 활용한다. web-info는 찾아갈 수 없다. 실습 1서버 생성하고 - 프로젝트 익스플로러 탭에서 우클릭- web프로젝트 생성(이름:helloweb) - next-next-맨 아래 체크 - finish이미지파일을 Web-Content안에 넣는다.서버 우클릭add and remove 클릭서버실행 (에러난다 8080쓰고 있어서 에러남(오라클))서버패키지의 server.xml 파일을 찾아가 65라인의 8080을 8088로 수정http://localhost:8088/helloweb/java.png 접속해보자 WebContent 우클릭 후 jsp 파일생성하고 접속해보자hello.jsp 생성http://localhost:8088/helloweb/hello.jsp 접속해보자 WebContent 우클릭 후 images 폴더생성그안에 이미지 붙여넣자http://localhost:8088/helloweb/images/java.png 접속해보자 java Resource에 com.bigdata2017.helloweb.servlet패키지를 생성하자.패키지 선택하고 우클릭 서블릿 생성 HelloServlet로 하고 next - URL mapping에 add 선택- /hello 입력- next - doget , dopost 선택 후 finish HelloServlet.java12345678910111213141516171819202122232425262728293031323334package com.bigdata2017.helloweb.servlet;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Servlet implementation class HelloServlet */@WebServlet(&#123; \"/hello\" &#125;) //얘는 표준은 아니다. web.xml을 열어서 해야함!public class HelloServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html; charset=utf-8\"); PrintWriter pw = response.getWriter(); pw.println(\"&lt;h1&gt;Hello World&lt;/h1&gt;\"); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); // doPost를 doGet로 처리 &#125;&#125; http://localhost:8088/helloweb/hello 에 접속해보자 JSP 로만 짜는것 -모델1JSP - servlet 를 혼용해서 짜는것을 모델2 MVC라고 한다. 실습2HelloServlet.java의 @WebServlet({ “/hello” })을 지우고 해보자어노테이션을 이용한 것이 표준은 아니다.web.xml파일을 열자 web.xml12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" id=\"WebApp_ID\" version=\"3.0\"&gt; &lt;display-name&gt;helloweb&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.bigdata2017.helloweb.servlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 실습3jsp는 서블릿 코드가 내장되어있다고 생각하면 된다. WebContent의 우클릭 후 table.jsp 생성table.jsp1234567891011121314151617181920212223242526272829303132333435363738&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt; &lt;% String sRow = request.getParameter( \"r\" ); String sCol = request.getParameter( \"c\" ); int nRow = Integer.parseInt( sRow ); int nCol = Integer.parseInt( sCol ); %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=\"1px\" cellspacing=0 cellpadding=\"10px\"&gt; &lt;% for(int i = 0; i&lt; nRow; i++)&#123; %&gt; &lt;tr&gt; &lt;% for(int j=0; j&lt;nCol;j++) &#123; %&gt; &lt;td&gt;cell(&lt;%=j %&gt;,&lt;%=i %&gt;)&lt;/td&gt; &lt;td&gt;cell(&lt;%=j %&gt;,&lt;%=i %&gt;)&lt;/td&gt; &lt;td&gt;cell(&lt;%=j %&gt;,&lt;%=i %&gt;)&lt;/td&gt; &lt;% &#125; %&gt; &lt;/tr&gt; &lt;% &#125; %&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 실습4실습3과 동일한 코드를 서블릿으로 작성해보자TableServelt.java1234567891011121314151617181920212223242526272829303132333435363738394041package com.bigdata2017.helloweb.servlet;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(&#123; \"/table\" &#125;)public class TableServelt extends HttpServlet &#123; private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String sRow = request.getParameter( \"r\" ); String sCol = request.getParameter( \"c\" ); int nRow = Integer.parseInt( sRow ); int nCol = Integer.parseInt( sCol ); response.setContentType( \"text/html; charset=utf-8\" ); PrintWriter out = response.getWriter(); out.println(\"&lt;table border=\\\"1px\\\" cellspacing=0 cellpadding=\\\"10px\\\"&gt;\"); for(int i=0; i&lt; nRow; i++) &#123; out.println(\"&lt;tr&gt;\"); for(int j=0; j&lt;nCol; j++) &#123; out.println(\"&lt;td&gt;cell(\"+j+\",\"+ i + \")&lt;/td&gt;\"); &#125; out.println(\"&lt;/tr&gt;\"); &#125; out.println(\"&lt;/table&gt;\"); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125;","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Servlet/JSP","slug":"Web-App/Servlet-JSP","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Servlet-JSP/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://KKimSangHeon.github.io/tags/Servlet/"}]},{"title":"12. 정규화","slug":"database12","date":"2017-08-23T00:07:28.000Z","updated":"2018-09-03T05:54:21.163Z","comments":true,"path":"2017/08/23/database12/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/23/database12/","excerpt":"","text":"데이터 베이스 설계의 주된 목적중복성 제거, 정규화 데이터 모델데이터베이스 설계를 도식화한 도표로서 엔티티, 속성, 관계 3가지 요소로 구성 정규화갱신이상, 데이터의 중복성을 제거. 데이터 모델을 좀 더 구체적으로 해준다. 제 1 정규형(1NF)모든속성이 하나의 값을 가질 때 제 1 정규형이라 한다.(도메인이 원자값 임) 제 2 정규형(2NF)하나의 엔티티가 이미 1NF로 되어 있고 모든 식별되지 않은 속성들이 엔티티의 유일한 식별자에 종속적이면 “제 2 정규형(2nd Normal form)” 이라 한다.(부분적 함수 종속 제거 됨) 제 3 정규형(3NF)하나의 엔티티가 이미 2NF로 되어 있고 식별할 수 없는 어떠한 속성도 어떤 다른 식별할 수 없는 속성들에게 종속적이지 않으면 “제 3 정규형(3nd Normal form)” 이라 한다.(이행적 함수 종속 제거 됨)","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"SQL(Oracle)","slug":"Language/SQL-Oracle","permalink":"http://KKimSangHeon.github.io/categories/Language/SQL-Oracle/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"11. DAO","slug":"database11","date":"2017-08-22T04:48:18.000Z","updated":"2018-09-03T05:54:18.752Z","comments":true,"path":"2017/08/22/database11/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/22/database11/","excerpt":"","text":"DAOData Access Object데이터베이스 접근 부분을 캡슐화하여 메소드를 이용하여 데이터베이스에 접근한다. 이때 결과는 VO객체를 통해 얻는다.AuthorDao.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.ArrayList;import java.util.List;import com.bigdata2017.jdbc.bookshop.vo.AuthorVo;public class AuthorDao &#123; private Connection getConnection() throws SQLException &#123; Connection conn = null ; //1. JDBC 드라이버 로딩 try &#123; Class.forName( \"oracle.jdbc.driver.OracleDriver\" ); //2. Connection 얻어오기 String url = \"jdbc:oracle:thin:@localhost:1521:xe\"; conn = DriverManager.getConnection(url, \"hr\", \"hr\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return conn; &#125; public int delete( ) &#123; int count = 0 ; Connection conn = null ; Statement stmt = null; ResultSet rs = null; try &#123; conn = getConnection(); //3. Statement 객체 생성 stmt = conn.createStatement(); //4. SQL문 실행 String sql =\"DELETE FROM AUTHOR\"; count = stmt.executeUpdate(sql); &#125; catch (SQLException e) &#123; System.out.println( \"error\" + e ); &#125; finally &#123; //3. 자원정리 try &#123; if( rs != null ) &#123; rs.close(); &#125; if( stmt != null ) &#123; stmt.close(); &#125; if( conn != null ) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return count; &#125; public int insert( AuthorVo vo ) &#123; int count = 0; Connection conn = null; PreparedStatement pstmt = null; try &#123; conn = getConnection(); //3. Statement 준비 String sql = \" insert\" + \" into author\" + \" values (seq_author.nextval, ?, ?)\"; pstmt = conn.prepareStatement( sql ); //4. binding pstmt.setString( 1, vo.getName() ); pstmt.setString( 2, vo.getProfile() ); //5. SQL문 실행 count = pstmt.executeUpdate(); &#125; catch (SQLException e) &#123; System.out.println( \"error :\" + e ); &#125; finally &#123; //3.자원 정리 try &#123; if( pstmt != null ) &#123; pstmt.close(); &#125; if( conn != null ) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return count; &#125; public List&lt;AuthorVo&gt; getList()&#123; List&lt;AuthorVo&gt; list = new ArrayList&lt;AuthorVo&gt;(); Connection conn = null ; Statement stmt = null; ResultSet rs = null; try &#123; conn = getConnection(); //3. Statement 객체 생성 stmt = conn.createStatement(); //4. SQL문 실행 String sql =\"SELECT NO, NAME, PROFILE FROM AUTHOR ORDER BY NO\"; rs = stmt.executeQuery(sql); System.out.println(\"connection 성공\"); //5. 결과 사용하기 while( rs.next() ) &#123; Long no = rs.getLong( 1 ); String name = rs.getString( 2 ); String profile = rs.getString( 3 ); AuthorVo vo = new AuthorVo(); vo.setNo(no); vo.setName(name); vo.setProfile(profile); list.add(vo); &#125; &#125; catch (SQLException e) &#123; System.out.println( \"error\" + e ); &#125; finally &#123; //3. 자원정리 try &#123; if( rs != null ) &#123; rs.close(); &#125; if( stmt != null ) &#123; stmt.close(); &#125; if( conn != null ) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return list; &#125;&#125; AuthorDaoTest.java12345678910111213141516171819202122232425262728293031323334package com.bigdata2017.jdbc.test;import java.util.List;import com.bigdata2017.jdbc.bookshop.dao.AuthorDao;import com.bigdata2017.jdbc.bookshop.vo.AuthorVo;public class AuthorDaoTest &#123; public static void main(String[] args) &#123; testInsert(); testGetList(); &#125; public static void testGetList() &#123; AuthorDao dao = new AuthorDao(); List&lt;AuthorVo&gt; list = dao.getList(); for(AuthorVo vo: list) &#123; System.out.println(vo); &#125; &#125; public static void testInsert() &#123; AuthorDao dao = new AuthorDao(); AuthorVo vo = new AuthorVo(); vo.setName( \"공자\" ); vo.setProfile( \"....\" ); new AuthorDao().insert(vo); &#125;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"SQL(Oracle)","slug":"Language/SQL-Oracle","permalink":"http://KKimSangHeon.github.io/categories/Language/SQL-Oracle/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"10. JDBC","slug":"database10","date":"2017-08-22T00:08:22.000Z","updated":"2018-09-03T05:54:16.309Z","comments":true,"path":"2017/08/22/database10/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/22/database10/","excerpt":"","text":"JDBC-자바를 이용한 데이터베이스 접속과 SQL 문장의 실행, 그리고 실행 결과로 얻어진 데이터의 핸들링을 제공하는 방법과 절차에 관한 규약-자바 프로그램내에서 SQL문을 실행하기 위한 자바 API-SQL과 프로그래밍 언어의 통합 접근 중 한 형태 Class.forName메소드란?클래스를 로딩하는 메소드이다.//왜 new OralcDriver()을 하지 않고 forName() 메소드를 사용할 까?//new 를 이용할 경우 벤더별로 다를것이므로! MyDriver.java123456789101112131415161718192021222324252627282930313233343536package com.bigdata2017.jdbc;...public class MyDriver implements Driver&#123; static &#123; System.out.println( \"static code area\" ); //외부에서 드라이버 접근이 가능토록 드라이버 등록 try &#123; DriverManager.registerDriver(new MyDriver()); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; @Override public boolean acceptsURL(String arg0) throws SQLException &#123; // TODO Auto-generated method stub return false; &#125; @Override public Connection connect(String url, Properties info) throws SQLException &#123; System.out.println( url ); System.out.println( info ); //이작업은 DB마다 다를것이다. /*연결 작업*/ return new MyConnection(); &#125;...&#125; ConnectionTest.java123456789101112131415161718192021222324252627import java.sql.DriverManager;import java.sql.SQLException;public class ConnectionTest &#123; public static void main(String[] args) &#123; try &#123; //1. JDBC 드라이버 로딩// Class.forName( \"oracle.jdbc.driver.OracleDriver\" ); Class.forName( \"com.bigdata2017.jdbc.MyDriver\" ); //클래스를 강제 로딩 //왜 new OralcDriver()을 하지 않고 forName() 메소드를 사용할 까? //new 를 이용할 경우 벤더별로 다를것이므로! //2. Connection 얻어오기 String url = \"jdbc:oracle:thin:@localhost:1521:xe\"; DriverManager.getConnection(url, \"hr\", \"hr\"); &#125; catch (ClassNotFoundException e) &#123; System.out.println( \"드라이버 로딩 실패:\" + e ); &#125; catch (SQLException e) &#123; System.out.println( \"연결실패\" + e ); &#125; &#125;&#125; MyConnection.java1234567package com.bigdata2017.jdbc;public class MyConnection implements Connection&#123; ...&#125; 실습프로젝트 우클릭 - 자바 빌드 패스 - 라이브러리탭- add library - user library 선택 -new - jdbc(아무거나 가능) - add external jar - ojdbc 파일 찾기 - apply - finish SelectTestSelectTest.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class SelectTest &#123; public static void main(String[] args) &#123; Connection conn = null ; Statement stmt = null; ResultSet rs = null; try &#123; //1. JDBC 드라이버 로딩 Class.forName( \"oracle.jdbc.driver.OracleDriver\" ); //2. Connection 얻어오기 String url = \"jdbc:oracle:thin:@localhost:1521:xe\"; conn = DriverManager.getConnection(url, \"hr\", \"hr\"); //3. Statement 객체 생성 stmt = conn.createStatement(); //4. SQL문 실행 String sql = \"select EMPLOYEE_ID,\" + \" FIRST_NAME,\" + \" LAST_NAME,\" + \" SALARY \" + \" from employees\"; rs = stmt.executeQuery(sql); System.out.println(\"connection 성공\"); //5. 결과 사용하기 while( rs.next() ) &#123; Long employee_id = rs.getLong( 1 ); //rs.getLong( \"employee_id\" ) 도 가능 String first_Name = rs.getString( 2 ); String last_Name = rs.getString( 3 ); int salary = rs.getInt(4); System.out.println( employee_id+ first_Name + last_Name + salary); &#125; &#125; catch (ClassNotFoundException e) &#123; System.out.println( \"드라이버 로딩 실패:\" + e ); &#125; catch (SQLException e) &#123; System.out.println( \"error\" + e ); &#125; finally &#123; //3. 자원정리 try &#123; if( rs != null ) &#123; rs.close(); &#125; if( stmt != null ) &#123; stmt.close(); &#125; if( conn != null ) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; UpdateTestStatement를 사용함. 아래 Insert에서는 Prepared Statement를 사용 한다.비교해보자UpdateTest.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class UpdateTest &#123; public static void main(String[] args) &#123; Connection conn = null ; Statement stmt = null; try &#123; //1. JDBC 드라이버 로딩 Class.forName( \"oracle.jdbc.driver.OracleDriver\" ); //2. Connection 얻어오기 String url = \"jdbc:oracle:thin:@localhost:1521:xe\"; conn = DriverManager.getConnection(url, \"dev\", \"dev\"); //3. Statement 객체 생성 stmt = conn.createStatement(); //4. SQL문 실행 String name = \"도우넛\"; Long no = 12L; String sql = \"update author \" + \" set name = '\"+ name +\"'\" + \" where no = \"+ no; //쿼리문이 복잡한데 Prepared Statement를 통해 좀더 수월하게 할 수 있다. int count = stmt.executeUpdate(sql); //5. 성공유무 System.out.println( count == 1 ? \"성공\" : \"실패\"); &#125; catch (ClassNotFoundException e) &#123; System.out.println( \"드라이버 로딩 실패:\" + e ); &#125; catch (SQLException e) &#123; System.out.println( \"error\" + e ); &#125; finally &#123; //3. 자원정리 try &#123; if( stmt != null ) &#123; stmt.close(); &#125; if( conn != null ) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; InsertTest보통 PreparedStatement를 많이 쓴다.select의 경우 바인드만 안하면 되니까!InsertTest.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.SQLException;public class InsertTest &#123; public static void main(String[] args) &#123; Connection conn = null ; PreparedStatement pstmt = null; try &#123; //1. JDBC 드라이버 로딩 Class.forName( \"oracle.jdbc.driver.OracleDriver\" ); //2. Connection 얻어오기 String url = \"jdbc:oracle:thin:@localhost:1521:xe\"; conn = DriverManager.getConnection(url, \"dev\", \"dev\"); //3. Statement 준비 String sql = \"insert\" + \"into author\" + \"values(seq_author.nextval,?,?)\"; pstmt = conn.prepareStatement(sql); //4. 바인딩 pstmt.setString( 1, \"공자\"); pstmt.setString( 2, \"어쩌구저쩌구\"); //5. SQL문 실행 int count = pstmt.executeUpdate(); //파라미터로 sql이 들어가면 안된다. //5. 성공유무 System.out.println( count == 1 ? \"성공\" : \"실패\"); &#125; catch (ClassNotFoundException e) &#123; System.out.println( \"드라이버 로딩 실패:\" + e ); &#125; catch (SQLException e) &#123; System.out.println( \"error\" + e ); &#125; finally &#123; //3. 자원정리 try &#123; if( pstmt != null ) &#123; pstmt.close(); &#125; if( conn != null ) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"SQL(Oracle)","slug":"Language/SQL-Oracle","permalink":"http://KKimSangHeon.github.io/categories/Language/SQL-Oracle/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"9. Data Dictionary, DCL, ROLE","slug":"database9","date":"2017-08-21T05:17:43.000Z","updated":"2018-09-03T05:54:14.221Z","comments":true,"path":"2017/08/21/database9/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/21/database9/","excerpt":"","text":"Data Dictionary란?모든 스키마 객체 정보, 스키마 객체의 공간 정보, 컬럼의 기본값, 제약조건 정보, 오라클 사용자 정보, 권한 및 롤 정보, 기타 데이터베이스 정보 … SELECT * FROM DICTIONARY;–데이터 딕셔너리 조회 SELECT * FROM USER_OBJECTS; SELECT * FROM USER_OBJECTS WHERE OBJECT_TYPE = ‘TABLE’; SELECT * FROM DICTIONARY;–데이터 딕셔너리 조회 SELECT * FROM USER_OBJECTS; SELECT * FROM USER_OBJECTS WHERE OBJECT_TYPE = ‘TABLE’; SELECT * FROM USER_USERS;–로그인한 유저만 보여줌 SELECT * FROM ALL_USERS;–전체 유저 보여줌 SELECT * FROM DBA_USERS;–CONN /AS SYSDBA로 로그인 후 가능 SELECT *FROM USER_CONSTRAINTSWHERE TABLE_NAME = ‘BOOK’;–제약조건 조회 SELECT * FROM USER_USERS; DCL–사용자 생성CREATE USER SHKIM IDENTIFIED BY “SHKIM”; –접속권한GRANT CREATE SESSION TO SHKIM; –SELECT 권한 부여 (DEV에 있는 BOOK테이블에 SELECT 할수있는..)GRANT SELECT ON DEV.BOOK TO SHKIM; –접속권한 없애기REVOKE CREATE SESSION FROM SHKIM; –롤 단위이렇게만 해도 접속 가능GRANT CONNECT, RESOURCE TO SHKIM; REVOKE CONNECT RESOURCE FROM SHKIM; ROLE 생성여러개의 권한을 묶어놓은것!CONN /AS SYSDBACREATE ROLE VIEWER;GRANT CREATE SESSION TO VIEWER;GRANT SELECT ON DEV.BOOK TO VIEWER;GRANT VIEWER TO SHKIM;CONN SHKIN/SHKIM;SELECT * FROM DEV.BOOK; CONN /AS SYSDBA;REVOKE VIWER FROM SHKIM; transaction트랜잭션은 DML의 집합으로 이루어진다.논리적 작업단위, 일련의 연산 집합을 의미한다. –DML–암시적(컬럼 지정X) 인 경우에는 순서와 , 개수 정확해야 함INSERT INTO AUTHOR VALUES(SEQ_AUTHOR.NEXTVAL, ‘둘리’,NULL); –명시적(컬럼 지정O)인 경우 지정한 순서와 개수 대로 입력해야 한다.INSERT INTO AUTHOR(NAME, NO) VALUES(‘둘리’,SEQ_AUTHOR.NEXTVAL); 트랜잭션은 다음과 같은 특징을 가져야 한다.Atomicity: all or nothing. 하나의 단위로 처리되어야 함. (중간까지만 처리됨은 불가)Consistency: 데이터베이스의 일관성(무결성)을 깨지 않아야 함Isolation: 다른 transaction과 동시에 수행되더라도 독립적으로 영향을 받지 않아야 함Durability: 한번 수행 완료(commit)되면 영원히 반영되어 있어야 함 (시스템 crash에서라도) DDL이나 DCL은 한 문장이 트랜잭션으로 처리됨 DeadLock둘 이상의 트랜잭션이 서로 상대방의 Lock을 순환 대기하여 어떤 트랜잭션도 더 이상 진행할 수 없는 상태","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"SQL(Oracle)","slug":"Language/SQL-Oracle","permalink":"http://KKimSangHeon.github.io/categories/Language/SQL-Oracle/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"8. Commit, Transaction, Delete, Update, CONSTRAINT","slug":"database8","date":"2017-08-21T00:23:06.000Z","updated":"2018-09-03T05:54:10.984Z","comments":true,"path":"2017/08/21/database8/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/21/database8/","excerpt":"","text":"Commit일련의 과정을 거친 후 커밋을 해줘야 데이터베이스에 반영이 된다.오라클의 경우 DDL은 자동으로 커밋이 되며 DML은 직접 커밋을 해줘야 한다.커밋의 과정중 에러가 나면 롤백시킨다. Transaction여러개의 job를 묶어 놓은것을 Transaction이라 한다. DELETEDELETEFROM BOOKWHERE NO = 1; COMMIT; // 커밋한다.ROLLBACK; //다시 롤백한다. UPDATEUPDATE BOOKSET TITLE = ‘토지2’WHERE NO = 1; Subquery를 이용한 테이블 생성백업용 테스트용으로 많이 쓰인다. Subquery의 결과와 동일한 테이블 생성됨질의 결과 레코드들이 포함됨NOT NULL 제약 조건 만 상속됨 CREATE TABLE EMPLOYEES_BAK01AS ( SELECT * FROM EMPLOYEES WHERE JOB_ID = ‘FI_ACCOUNT’); char, varcharchar - 10바이트를 만들고 ‘ab’를 입력하면 10바이트 할당됨varchar - 10바이트를 만들고 ‘ab’를 입력하면 2바이트 할당됨 모든 데이터가 고정크기일 때 (ex 주민번호, 학번) - char모든 데이터가 고정크기가 아닐 때 (ex 이메일) - varchar varchar, varchar2기능상의 다른점은 없지만 varchar2에서 성능개선이 이뤄짐.varchar는 곧 없어질 것이라 예고를 하고있다. NUMBER(x,y)y는 실수부분을 의미한다. varchar2(5), nvarchar2(5)varchar2(5)는 5바이트를 할당nvarchar2(5) 는 5글자를 할당한글은 UTF-8을 사용하기 떄문에 문제가 된다. –NVARCHAR2 , VARCHAR2와 비교 CREATE TABLE BOOK( NO NUMBER(10), TITLE VARCHAR2(120), AUTHOR VARCHAR2(5), –MAX 4000 BYTE TEST NVARCHAR2(2000), –MAX 2000자( 내부적으로 6000 BYTE ) PUB_DTAE DATE); INSERT INTO BOOK VALUES(1, ‘토지’, ‘가나’, SYSDATE);– 가나가 6바이트라 에러가 발생.. INSERT INTO BOOK VALUES(1, ‘토지’, ‘가’, SYSDATE);– 정상적으로 INSERT 가능 ALTERALTER TABLE BOOK ADD(PUBS VARCHAR(120));–컬럼추가ALTER TABLE BOOK MODIFY(PUBS VARCHAR(200));–컬럼 변경ALTER TABLE BOOK RENAME COLUMN PUBS TO PUBLISHINGS;–컬럼명 변경ALTER TABLE BOOK DROP(PUBLISHINGS);–컬럼 제거ALTER TABLE BOOK MODIFY(AUTHOR VARCHAR(300) NOT NULL);–컬럼 변경ALTER TABLE BOOK SET UNUSED(AUTHOR);–컬럼을 보이지 않게 만듦ALTER TABLE BOOK DROP UNUSED COLUMNS;–보이지 않게 만든 컬럼을 삭제함 SEQUENCE값이 1씩 증가한다CREATE TABLE BOOK( NO NUMBER(10), TITLE VARCHAR2(200) NOT NULL, AUTHOR VARCHAR2(50) NOT NULL, –MAX 4000 BYTE PUB_DATE DATE, PRIMARY KEY(NO) ); CREATE SEQUENCE SEQ_BOOKSTART WITH 1 –1부터 시작INCREMENT BY 1 –1씩 증가MAXVALUE 999999999 –MAX가 다차면 1로 돌아감–PRIMARY KEY 자동증가 SELECT SEQ_BOOK.NEXTVAL FROM DUAL; –증가SELECT SEQ_BOOK.CURRVAL FROM DUAL; –최근값 INSERT INTO BOOK VALUES( SEQ_BOOK.NEXTVAL, ‘토지2’, ‘박경리’, SYSDATE);–INSERT 문에서의 시퀀스 활용 CHECKCREATE TABLE BOOK( NO NUMBER(10), TITLE VARCHAR2(200) NOT NULL, AUTHOR VARCHAR2(50) NOT NULL, –MAX 4000 BYTE PUB_DATE DATE, STATE VARCHAR2(12) NOT NULL, PRIMARY KEY(NO), CONSTRAINT C_BOOK_CHECK CHECK(STATE IN (‘대여중’, ‘대여가능’))); INSERT INTO BOOK VALUES( SEQ_BOOK.NEXTVAL, ‘토지2’, ‘박경리’, SYSDATE, ‘대여가능’ –대여중, 대여가능만 들어갈 수 있다. ); 외부키CREATE SEQUENCE SEQ_AUTHORSTART WITH 1INCREMENT BY 1MAXVALUE 999999999–시퀀스 생성 CREATE TABLE AUTHOR( NO NUMBER(10), NAME VARCHAR2(200) NOT NULL, PROFILE VARCHAR2(2000), PRIMARY KEY(NO)) CREATE TABLE BOOK( NO NUMBER(10), TITLE VARCHAR2(200) NOT NULL, AUTHOR_NO NUMBER(10) , –MAX 4000 BYTE STATE VARCHAR2(12) NOT NULL, PUB_DATE DATE, PRIMARY KEY(NO), CONSTRAINT C_BOOK_FK FOREIGN KEY (AUTHOR_NO) REFERENCES AUTHOR(NO) ON DELETE CASCADE , –AUTHOR 테이블의 박경리 데이터가 삭제도면 BOOK테이블의 토지 데이터도 삭제된다. ON DELETE SET NULL, –AUTHOR 테이블의 박경리 데이터가 삭제도면 BOOK테이블의 AUTHOR_NO는 NULL이 된다.. CONSTRAINT C_BOOK_CHECK CHECK(STATE IN (‘대여중’, ‘대여가능’))); INSERT INTO AUTHOR VALUES(SEQ_AUTHOR.NEXTVAL,‘박경리’,NULL); INSERT INTO BOOK VALUES(SEQ_BOOK.NEXTVAL,‘토지’,1,‘대여가능’,SYSDATE); CONSTRAINT제약조건은 보통 ALTER테이블을 통해 모아서 준다.아래와 같이..CREATE TABLE AUTHOR( NO NUMBER(10), NAME VARCHAR2(200) NOT NULL, PROFILE VARCHAR2(2000)) ALTER TABLE AUTHORADD CONSTRAINT C_AUTHOR_PKPRIMARY KEY(NO); CREATE TABLE BOOK( NO NUMBER(10), TITLE VARCHAR2(200) NOT NULL, AUTHOR_NO NUMBER(10) NOT NULL, –MAX 4000 BYTE STATE VARCHAR2(12) NOT NULL, PUB_DATE DATE); ALTER TABLE BOOKADD CONSTRAINT C_BOOK_PKPRIMARY KEY(NO); ALTER TABLE BOOKADD CONSTRAINT C_BOOK_CHECKCHECK(STATE IN (‘대여중’, ‘대여가능’)); ALTER TABLE BOOKADD CONSTRAINT C_BOOK_FKFOREIGN KEY (AUTHOR_NO) REFERENCES AUTHOR(NO) ON DELETE CASCADE ;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"SQL(Oracle)","slug":"Language/SQL-Oracle","permalink":"http://KKimSangHeon.github.io/categories/Language/SQL-Oracle/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"7. TOP - K","slug":"database7","date":"2017-08-18T04:04:24.000Z","updated":"2018-09-03T05:54:08.138Z","comments":true,"path":"2017/08/18/database7/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/18/database7/","excerpt":"","text":"– TOP -KSELECT ROWNUM,EMPLOYEE_ID, SALARY FROM EMPLOYEES WHERE HIRE_DATE LIKE ‘06%’ ORDER BY SALARY원하는대로 출력이 되지 않을 것이다. 이를 원하는대로 출력하기 위해서는 다음과 같이!SELECT ROWNUM, EMPLOYEE_ID, SALARYFROM ( SELECT EMPLOYEE_ID, SALARY FROM EMPLOYEES WHERE HIRE_DATE LIKE ‘06%’ ORDER BY SALARY ); SELECT ROWNUM, EMPLOYEE_ID, SALARYFROM ( SELECT EMPLOYEE_ID, SALARY FROM EMPLOYEES WHERE HIRE_DATE LIKE ‘06%’ ORDER BY SALARY ) WHERE ROWNUM &lt;= 3 ;–앞에서 3개 뽑는것 SELECT ROWNUM, EMPLOYEE_ID, SALARYFROM ( SELECT EMPLOYEE_ID, SALARY FROM EMPLOYEES WHERE HIRE_DATE LIKE ‘06%’ ORDER BY SALARY ) WHERE 6 &gt;= ROWNUM AND ROWNUM &lt;= 10;–이것은 원하는 결과가 나오지 않는다.1이 찍히지 않으므로 그렇다. 이로인해 ROWNUM이 증가하지 않음 SELECT * FROM ( SELECT ROWNUM AS RN, EMPLOYEE_ID, SALARY FROM ( SELECT EMPLOYEE_ID, SALARY FROM EMPLOYEES WHERE HIRE_DATE LIKE ‘06%’ ORDER BY SALARY ) ) WHERE RN &gt;=6 AND RN &lt;=10; – 위의 문제를 이렇게 해결함.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"SQL(Oracle)","slug":"Language/SQL-Oracle","permalink":"http://KKimSangHeon.github.io/categories/Language/SQL-Oracle/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"6. SUBQUERY","slug":"database6","date":"2017-08-18T01:22:43.000Z","updated":"2018-09-03T05:54:04.658Z","comments":true,"path":"2017/08/18/database6/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/18/database6/","excerpt":"","text":"서브쿼리Lex보다 많이 받는 사원 구하기 SELECT FIRST_NAME, SALARYFROM EMPLOYEESWHERE SALARY &gt; (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = ‘Lex’); SELECT A.FIRST_NAME, B.SALARYFROM EMPLOYEES A, (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = ‘Lex’) BWHERE A.SALARY &gt; B.SALARY;– 조인으로도 처리 가능 SELECT FIRST_NAME, SALARYFROM EMPLOYEESWHERE SALARY &gt; (SELECT AVG(SALARY) FROM EMPLOYEES ); –SINGLE LOW SUB QUERY – 문_ JOB_ID가 ‘IT_PROG’인 직원이 받는 월급보다 많이 받고 있는 직원의 이름과 월급 SELECT FIRST_NAME, SALARYFROM EMPLOYEESWHERE SALARY &gt; ALL (SELECT SALARY FROM EMPLOYEES WHERE JOB_ID = ‘IT_PROG’) – MULTI ROW SUB QUERY –문) 각 부서별로 최고 월급을 받는 직원의 이름과 직원의 이름과 월급 출력 WHERE을 활용 SELECT FIRST_NAMEFROM EMPLOYEESWHERE (SALARY,DEPARTMENT_ID) IN ( SELECT MAX(SALARY),DEPARTMENT_ID FROM EMPLOYEES GROUP BY DEPARTMENT_ID ); FROM을 활용SELECT A.DEPARTMENT_ID, FIRST_NAME, SALARYFROM EMPLOYEES A, ( SELECT DEPARTMENT_ID, MAX(SALARY) AS MAX_SALARY FROM EMPLOYEES GROUP BY DEPARTMENT_ID ) BWHERE A.DEPARTMENT_ID = B.DEPARTMENT_IDAND A.SALARY = B.MAX_SALARY; CORELATED 활용SELECT DEPARTMENT_ID, FIRST_NAME, SALARYFROM EMPLOYEES AWHERE SALARY = ( SELECT MAX(SALARY) FROM EMPLOYEES WHERE A.DEPARTMENT_ID = DEPARTMENT_ID); – CORELATED SUBQUERY 자기 부서의 평균월급 보다 적은 월급을 받는 사원을 구하라","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"SQL(Oracle)","slug":"Language/SQL-Oracle","permalink":"http://KKimSangHeon.github.io/categories/Language/SQL-Oracle/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"5. ROLLUP, CUBE","slug":"database5","date":"2017-08-18T00:05:47.000Z","updated":"2018-09-03T05:54:02.330Z","comments":true,"path":"2017/08/18/database5/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/18/database5/","excerpt":"","text":"ROWNUMSELECT ROWNUM, EMPLOYEE_IDFROM EMPLOYEES; 트리 형태 구조를 추출하기 위한 질의– START WITH ~ CONNECT BY 절SELECT LEVEL MANAGER_ID, EMPLOYEE_IDFROM EMPLOYEESSTART WITH MANAGER_ID IS NULLCONNECT BY PRIOR EMPLOYEE_ID = MANAGER_IDORDER BY LEVEL, MANAGER_ID, EMPLOYEE_ID; ROLLUP부서별 직책별 평균월급, 사원수 평균월급을 출력하시오ROLLUP (A, B): group by (A, B) &amp; group by (A) &amp; ALL SELECT CASE GROUPING(DEPARTMENT_ID) WHEN 1 THEN ‘모든 부서’ ELSE NVL(TO_CHAR(DEPARTMENT_ID),’없음’) END AS “부서”, CASE GROUPING(JOB_ID) WHEN 1 THEN &apos;모든 직업&apos; ELSE NVL(TO_CHAR(JOB_ID),&apos;없음&apos;) END AS &quot;직업&quot; ,COUNT(*),ROUND(AVG(SALARY),0) FROM EMPLOYEESGROUP BY ROLLUP(DEPARTMENT_ID, JOB_ID)ORDER BY DEPARTMENT_ID, JOB_ID GROUPINGSELECT CASE GROUPING(DEPARTMENT_ID) WHEN 1 THEN ‘모든 부서’ ELSE NVL(TO_CHAR(DEPARTMENT_ID),’없음’) END AS “부서”, CASE GROUPING(JOB_ID) WHEN 1 THEN &apos;모든 직업&apos; ELSE NVL(TO_CHAR(JOB_ID),&apos;없음&apos;) END AS &quot;직업&quot; ,COUNT(*),ROUND(AVG(SALARY),0) FROM EMPLOYEESGROUP BY CUBE(DEPARTMENT_ID, JOB_ID)ORDER BY DEPARTMENT_ID, JOB_ID CUBEgroup by (A,B) &amp; group by (A) &amp; group by (B) &amp; ALLSELECT CASE GROUPING(DEPARTMENT_ID) WHEN 1 THEN ‘모든 부서’ ELSE NVL(TO_CHAR(DEPARTMENT_ID),’없음’) END AS “부서”, CASE GROUPING(JOB_ID) WHEN 1 THEN &apos;모든 직업&apos; ELSE NVL(TO_CHAR(JOB_ID),&apos;없음&apos;) END AS &quot;직업&quot; ,COUNT(*),ROUND(AVG(SALARY),0) FROM EMPLOYEESGROUP BY CUBE(DEPARTMENT_ID, JOB_ID)ORDER BY DEPARTMENT_ID, JOB_ID","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"SQL(Oracle)","slug":"Language/SQL-Oracle","permalink":"http://KKimSangHeon.github.io/categories/Language/SQL-Oracle/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"4. CASE, DECODE, GROUP BY","slug":"database4","date":"2017-08-17T01:59:31.000Z","updated":"2018-09-03T05:53:58.816Z","comments":true,"path":"2017/08/17/database4/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/17/database4/","excerpt":"","text":"CASESELECT EMPLOYEE_ID, SALARY, JOB_ID, CASE JOB_ID WHEN ‘AC_ACCOUNT’ THEN SALARY + SALARY 0.5 WHEN ‘AC_MGR’ THEN SALARY + SALARY 0.3 WHEN ‘AD_VP’ THEN SALARY + SALARY * 0.2 ELSE SALARY END AS SALARYFROM EMPLOYEES; DECODESELECT EMPLOYEE_ID, SALARY, JOB_ID, DECODE( JOB_ID , ‘AC_ACCOUNT’ , SALARY + SALARY 0.5 , ‘AC_MGR’ ,SALARY + SALARY 0.3 , ‘AD_VP’ , SALARY + SALARY * 0.2 , SALARY) AS “이번달 월급”FROM EMPLOYEES; SELECT EMPLOYEE_ID,AVG(SALARY) , MAX(SALARY)FROM EMPLOYEES;– ERROR– 집계함수 이외의 칼럼은 프로젝션 될 수 없다 GROUP BYSELECT JOB_ID,AVG(SALARY), MAX(SALARY)FROM EMPLOYEESWHERE MANAGER_ID IS NOT NULLGROUP BY JOB_ID;– GROUP BY 절에 참여하고 있는 컬럼은 프로젝션 할 수 있다.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"SQL(Oracle)","slug":"Language/SQL-Oracle","permalink":"http://KKimSangHeon.github.io/categories/Language/SQL-Oracle/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"3. 함수 NVL,SYSDATE,IN,BETWEEN,IS NULL,LIKE,LOWER,INITCAP,LPAD,TRIM,REPLACE,CEIL,FLOOR,ROUND,TRUNC,MOD,POWER,SIGN,ADD_MONTHS,TO_CHAR","slug":"database3","date":"2017-08-16T04:19:24.000Z","updated":"2018-09-03T05:53:55.752Z","comments":true,"path":"2017/08/16/database3/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/16/database3/","excerpt":"","text":"SELECT FIRST_NAME || ‘ ‘ || LAST_NAME AS NAME FROM EMPLOYEES; ||은 CONCAT SELECT SALARY AS “본봉”, SALARY + SALARY * 0.3 AS “보너스”FROM EMPLOYEES; SELECT -SALARY FROM EMPLOYEES; NVL, NVL2SELECT EMPLOYEE_ID, NVL(MANAGER_ID,’0’)FROM EMPLOYEES; NVL함수 내의 두 형태는 같아야함 SELECT NVL(NULL, ‘0’) FROM DUAL; SELECT NVL2(NULL,10, 20) FROM DUAL;–NULL이면 10 SELECT NVL2(0, 10, 20) FROM DUAL;–NULL이 아니면 20 SELECT SALARY AS “본봉”, SALARY + SALARY * NVL(COMMISSION_PCT,0) AS “보너스”FROM EMPLOYEES; SELECT SALARY AS “본봉”, NVL2(COMMISSION_PCT,SALARY + SALARY * COMMISSION_PCT, SALARY) AS “보너스”FROM EMPLOYEES; NULLIFSELECT NULLIF( 10 , 5 + 5 ) FROM DUAL; COALESCESELECT COALESCE(NULL, NULL,1,2,3) FROM DUAL;– 1출력 SYSDATESELECT SYSDATE FROM DUAL; SELECT JOB_IDFROM EMPLOYEESWHERE JOB_ID = ‘AD_PRES’ OR JOB_ID = ‘AD_VP’; INSELECT JOB_IDFROM EMPLOYEESWHERE JOB_ID IN(‘AD_PRES’,’AD_VP’); BETWEENSELECT EMPLOYEE_ID, SALARYFROM EMPLOYEESWHERE SALARY BETWEEN 10000 AND SALARY ; IS NULLSELECT EMPLOYEE_ID, COMMISSION_PCTFROM EMPLOYEESWHERE COMMISSION_PCT IS NULL; LIKESELECT FIRST_NAMEFROM EMPLOYEESWHERE FIRST_NAME LIKE ‘A%’;–A로 시작하는 문자열에 대해서 SELECT FIRST_NAMEFROM EMPLOYEESWHERE FIRSTNAME LIKE ‘A‘;–A로시작하는 두글자 검색 SELECT EMPLOYEE_ID, FIRST_NAMEFROM EMPLOYEESORDER BY FIRST_NAME DESC; SELECT EMPLOYEE_ID, HIRE_DATEFROM EMPLOYEES; LOWERSELECT FIRST_NAMEFROM EMPLOYEESWHERE LOWER(FIRST_NAME) LIKE ‘al%’; INITCAPSELECT INITCAP(‘database managemaent system’) from dual;–맨앞만 대문자로 SELECT INSTR( ‘DATABASE MANAGEMENT SYSTEM’ , ‘BASE’ ) FROM DUAL;– BASE의 위치 찾기 (DB는 대부분 시작 인덱스가 1이다. )SELECT CEIL( 4.99) FROM DUAL;SELECT CEIL( 4.01) FROM DUAL;– 해당 수보다 큰 정수값 (5 출력됨) SELECT FLOOR( 4.99 ) FROM DUAL;SELECT FLOOR( 4.00001) FROM DUAL;– 해당 수보다 작은 정수값 SELECT ROUND(3.3364,3) FROM DUAL;– 넷째자리에서 반올림함(3.336 출력됨) SELECT MOD (9999,6) FROM DUAL;– 나머지SELECT POWER ( 2,10) FROM DUAL;–2의 10승 LPADSELECT EMPLOYEE_ID, LPAD(SALARY, 10 , ‘‘) FROM EMPLOYEES;– 10칸을만들되 왼쪽 나머지는 로 채울것 TRIMSELECT TRIM( ‘#’ FROM ‘####DATA#BASE####’) FROM DUAL;– 앞뒤 특정문자 제거 SELECT TRIM( ‘ ‘ FROM ‘ DATA BASE ‘) FROM DUAL;– 앞뒤 공백 제거 SELECT LTRIM(‘ DATA BASE ‘,’ ‘) FROM DUAL;– 왼쪽 공백 제거 REPLACESELECT REPLACE(‘ DATA BASE ‘, ‘ ‘ ,’’) FROM DUAL;– 공백 제거 CEILSELECT CEIL( 4.99) FROM DUAL;SELECT CEIL( 4.01) FROM DUAL;– 해당 수보다 큰 정수값 (5 출력됨) FLOORSELECT FLOOR( 4.99 ) FROM DUAL;SELECT FLOOR( 4.00001) FROM DUAL;– 해당 수보다 작은 정수값 ROUNDSELECT ROUND(3.3364,3) FROM DUAL;– 넷째자리에서 반올림함(3.336 출력됨) TRUNCSELECT TRUNC( 3.3864,1) FROM DUAL;– 1자리만 남기고 버림(3.3나옴) MODSELECT MOD (9999,6) FROM DUAL;– 나머지 POWERSELECT POWER ( 2,10) FROM DUAL;–2의 10승 SIGNSELECT SIGN(9999) FROM DUAL;– 1나옴 SELECT SIGN(-9999) FROM DUAL;– -1나옴 SELECT SIGN(0) FROM DUAL;– 0나옴 ADD_MONTHSSELECT ADD_MONTHS( SYSDATE, 3 ) FROM DUAL;SELECT ADD_MONTHS( ‘15/01/01’,3 ) FROM DUAL; SELECT LAST_DAY( SYSDATE ) FROM DUAL;–해당월에 마지막 일 SELECT MONTHS_BETWEEN( ADD_MONTHS(SYSDATE,3), SYSDATE) FROM DUAL; SELECT EMPLOYEE_ID, JOB_ID, ROUND(MONTHS_BETWEEN( END_DATE, START_DATE))FROM JOB_HISTORY; SELECT NEXT_DAY( SYSDATE, 7) FROM DUAL;– 1-&gt;SUN 7-&gt;SAT TO_CHARSELECT EMPLOYEE_ID, TO_CHAR(SALARY, ‘99999’ )FROM EMPLOYEES;– 숫자 &lt;-&gt; 문자– 5자리가 넘어가면 #####으로 표시된다. SELECT EMPLOYEE_ID, TO_CHAR(SALARY, ‘000099999’ )FROM EMPLOYEES;– 숫자 &lt;-&gt; 문자–앞에 0000으로 채운다. SELECT EMPLOYEE_ID, TO_CHAR(SALARY, ‘999,999’ )FROM EMPLOYEES;– 숫자 &lt;-&gt; 문자 SELECT TO_CHAR( 3.141592, ‘9.99’) FROM DUAL;– 3.14 나옴 SELECT TO_CHAR( 3.141592, ‘9999.9999’) FROM DUAL;– 3.1416 나옴 SELECT EMPLOYEE_ID, TO_CHAR(SALARY,’FM99999999’)FROM EMPLOYEES;– 왼쪽으로 다 땡겨준다 SELECT EMPLOYEE_ID, TO_CHAR(SALARY,’FM$99999999’)FROM EMPLOYEES;– 왼쪽으로 다 땡겨준다 SELECT EMPLOYEE_ID, TO_CHAR(SALARY,’FML99999999’)FROM EMPLOYEES;– 왼쪽으로 다 땡기고 원화를 넣어준다. SELECT TO_CHAR(-12345,’99999MI’) FROM DUAL;– 12345- SELECT TO_CHAR(-12345,’S99999’) FROM DUAL;– -12345 출력 SELECT TO_CHAR(12345,’S99999’) FROM DUAL;– +12345 출력 SELECT TO_CHAR(-12345,’99999PR’) FROM DUAL;– 출력 SELECT TO_CHAR(12345,’99999PR’) FROM DUAL; SELECT TO_CHAR( 1234, ‘RN’) FROM DUAL;–로마자로 표기 SELECT TO_CHAR( 1234, ‘XXXX’ ) FROM DUAL;–16진수 대문자로 표기 SELECT TO_CHAR( 1234, ‘xxxx’ ) FROM DUAL;–16진수 소문자로 표기 SELECT TO_NUMBER( ‘1234567’,’99999999’) FROM DUAL; SELECT EMPLOYEE_ID,TO_CHAR(HIRE_DATE, ‘yyyy-mm-dd’)FROM EMPLOYEES; SELECT EMPLOYEE_ID,TO_CHAR(HIRE_DATE, ‘yyyy”년”-mm”월”-dd”일”‘)FROM EMPLOYEES; SELECT EMPLOYEE_ID,TO_CHAR(HIRE_DATE, ‘yyyy”년”-mm”월”-dd”일” hh24”시”:mi:ss’)FROM EMPLOYEES; SELECT EMPLOYEE_ID,TO_CHAR(HIRE_DATE, ‘yyyy”년”-mm”월”-dd”일” day pm hh:mi:ss’)FROM EMPLOYEES; SELECTTO_CHAR(SYSDATE, ‘yyyy”년”-mm”월”-dd”일” ddd”일째 되는날”‘)FROM DUAL; SELECT TO_CHAR(SYSDATE, ‘RR’)FROM DUAL; SELECT TO_CHAR(TO_DATE(‘30’,’RR’), ‘YYYY’) FROM DUAL;– 현재 세기 SELECT TO_CHAR(TO_DATE(‘60’,’RR’), ‘YYYY’) FROM DUAL;– 이전 세기","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"SQL(Oracle)","slug":"Language/SQL-Oracle","permalink":"http://KKimSangHeon.github.io/categories/Language/SQL-Oracle/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"2. 데이터베이스 기본","slug":"database2","date":"2017-08-16T00:05:42.000Z","updated":"2018-09-03T05:53:52.738Z","comments":true,"path":"2017/08/16/database2/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/16/database2/","excerpt":"","text":"데이터베이스의 기본개념 (정의)-데이터의 집합 ( a Set of Data )-여러 응용 시스템(프로그램)들의 통합된 정보들을 저장하여 운영할 수 있는 공용(share) 데이터의 집합-효율적으로 저장, 검색, 갱신할 수 있도록 데이터 집합들끼리 연관시키고 조직화되어야 한다. DBMS가 하는일데이터 통합, 저장, 운영, 공유 기능 담당. 이를 위해 조직화 되어있어야 함. 데이터베이스의 특성-실시간 접근성(Real-time Accessability) 사용자의 요구를 즉시 처리할 수 있다.-계속적인 변화(Continuous Evolution) 정확한 값을 유지하려고 삽입·삭제·수정 작업 등을 이용해 데이터를 지속적으로 갱신할 수 있다.-동시 공유성(Concurrent Sharing) 사용자마다 서로 다른 목적으로 사용하므로 동시에 여러 사람이 동일한 데이터에 접근하고 이용할 수 있다.-내용 참조(Content Reference) 저장한 데이터 레코드의 위치나 주소가 아닌 사용자가 요구하는 데이터의 내용, 즉 데이터 값에 따라 참조할 수 있어야 한다. 데이터베이스 관리 시스템 장점데이터 중복이 최소화데이터의 일관성 및 무결성 유지데이터 보안 보장 데이터 베이스의 종류객체 관계형 데이터베이스 ( Object Relation DataBase = ORDB ) -관계형 데이터베이스에서 사용하는 데이터를 확장 -관계형 데이터베이스를 객체 지향 모델링과 데이터를 관리하는 기능을 갖도록 확장한 것NoSQL(Not Only SQL - SQL문 만을 이용하지 않아도 된다.) -대용량 데이터의 웹 서비스와 SNS, 클라우드 컴퓨팅의 확대 보급과 대중화로 최근 주목 받는 데이터베이스 기술 PK다른 행과 구분하기 위해 필요.PK를 설정할 땐 비즈니스와 상관없는 컬럼을 지정하는것이 좋다.(비즈니스 변경시 귀찮아 질 수 있다.)PK는 인덱싱이 자동으로 잡혀 빠르다.릴레이션에서 튜플(행)을 구분하기 위하여 사용하는 기본 키하나의 애트리뷰트, 또는 애트리뷰트의 집합(복합키) 가능관리자에 의해 릴레이션 생성시 정의됨 (자동으로 Index생성됨)동일한 PK를 지닌 레코드가 존재할 수 없음 기타Candidate Key (후보키): 튜플을 식별할 수 있는 최소한의 애트리뷰트 집합하나의 릴레이션에는 PK가 될 수 있는 키가 여러 개 있을 수 있음유일성과 최소성이 있으면 candidate key가 될 수 있음.Alternative Key (대체키): 후보키 중 기본키가 아닌것Composite key (복합키): 둘 이상의 애트리뷰트가 하나의 Key를 이루는 경우","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"SQL(Oracle)","slug":"Language/SQL-Oracle","permalink":"http://KKimSangHeon.github.io/categories/Language/SQL-Oracle/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"Whole in 밴드","slug":"wholin","date":"2017-08-11T06:55:24.000Z","updated":"2017-08-11T07:13:18.046Z","comments":true,"path":"2017/08/11/wholin/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/11/wholin/","excerpt":"","text":"App 소개 및 개발배경-GIF 2016 에 참가하면서 개발하였던 어플리케이션 입니다. 주제는 성공적인 개최를 위한 IOT 서비스 활용방안이였으며 저희팀은 NFC를 이용하여 국적별 다용도로 활용할 수 있는 팔찌(Wholin 밴드)를 제작하였습니다.프로토 타입 어플리케이션이므로 밴드를 통한 국적별 메뉴판 조회, 음식주문 기능을 구현하였습니다. 밴드소개 밴드 속에는 NFC칩이 존재하며 메뉴주문 및 결제, 사각지대 VR 생중계 등의 기능을 제공하며 프로토 타입이므로 국적별 메뉴판 조회기능만 제공합니다. 작동화면 처음 언어를 설정하고 자신의 기본정보를 입력하고 추가정보를 입력후 밴드를 스마트폰에 갖다대면 밴드 등록이 완료됩니다. -시연영상github Repository","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://KKimSangHeon.github.io/tags/Android/"},{"name":"NFC","slug":"NFC","permalink":"http://KKimSangHeon.github.io/tags/NFC/"}]},{"title":"동국대학교 경주캠퍼스 채팅봇","slug":"dg-chat-bot","date":"2017-08-11T06:20:24.000Z","updated":"2019-05-12T04:10:36.532Z","comments":true,"path":"2017/08/11/dg-chat-bot/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/11/dg-chat-bot/","excerpt":"","text":"프로그램 개발배경-기숙사 외박계가 서비스 되지 않은점이 아쉬웠으며 유용하게 쓰일 수 있는 프로그램을 만들어 보고싶어 학교 채팅봇을 만들어보게 되었습니다. 프로그램 소개플러스 친구 추가 후 실시간 버스 도착정보, 도서관 좌석정보, 기숙사 식단조회, 통학버스 조회, 홈페이지 조회 기능을 사용할 수 있습니다.또한 AWS EC2인스턴스를 활용하여 서비스하며 동국대학교 경주캠퍼스 채팅봇을 검색 후 친구추가가 가능합니다. 2018-06-02 부터 EC2 인스턴스의 프리티어가 만료되어 GCP로 변경하였습니다.2019-06-01 부터 GCP의 사용기한이 종료됨에 따라 서비스가 종료되었습니다. 프로그램 동작화면 카카오톡 내 친구검색기능을 활용하여 “동국대학교 경주캠퍼스 채팅봇”을 검색하면 위와같이 출력됩니다. 해당 봇과 채팅을 시도하게 되면 화면에 보이는 기능(버스 도착정보, 도서관 좌석정보, 기숙사 식단조회, 통학버스 조회, 홈페이지 조회)을 제공합니다. 초기 화면에서 버스도착정보 버튼을 선택하고 조회할 정류장의 숫자를 입력하게 되면 위와같이 버스도착정보를 실시간으로 조회 가능합니다. 초기 화면에서 도서관 좌석정보 버튼을 선택하면 다음과 같이 실시간 잔여석을 확인 가능합니다. 초기화면에서 기숙사 식단조회 버튼을 선택하고 아침, 점심, 저녁, 야식 메뉴중 한가지를 선택할 경우 당일의 식단 메뉴를 확인할 수 있습니다. 초기화면에서 통학버스 조회 버튼을 선택하고 지역(부산, 양산, 대구, 울산, 포항)을 선택하게 되면 해당 지역의 통학버스 정보를 조회할 수 있습니다. 초기화면에서 홈페이지 조회 버튼을 선택하고 일반, 학사, 장학 중 하나를 선택하게 되면 최근 등록된 10개의 게시물을 조회할 수 있습니다. 교내신문에 관련 기사가 실리기도 하였습니다. 서버2018-06-02기존 AWS를 사용했지만 무료이용기간이 만료되어 구글클라우드 플랫폿을 이용. github Repository","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://KKimSangHeon.github.io/tags/Node-js/"},{"name":"Kakao talk open API","slug":"Kakao-talk-open-API","permalink":"http://KKimSangHeon.github.io/tags/Kakao-talk-open-API/"},{"name":"챗봇","slug":"챗봇","permalink":"http://KKimSangHeon.github.io/tags/챗봇/"},{"name":"MySQL","slug":"MySQL","permalink":"http://KKimSangHeon.github.io/tags/MySQL/"},{"name":"CentOS","slug":"CentOS","permalink":"http://KKimSangHeon.github.io/tags/CentOS/"}]},{"title":"데이터 프리 기프티콘","slug":"defcon","date":"2017-08-11T06:07:04.000Z","updated":"2017-08-11T06:15:14.135Z","comments":true,"path":"2017/08/11/defcon/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/11/defcon/","excerpt":"","text":"참가배경-두 번째 참가한 해커톤 입니다. 첫 해커톤에 흥미를 느껴 다시한번 참가하게 되었습니다. IdeaVPN을 이용하여 스마트폰 데이터 사용량을 감소시키는 어플리케이션입니다.데이터 사용량을 감소시키기 위해 서버에 데이터를 전송하기 전 압축하여 보내고 서버에서 클라이언트로 데이터를 보낼때도 압축을 진행하게 됩니다.서버, 클라이언트는 toyVPN이라는 오픈소스를 활용하였습니다. 동작화면 서버의 주소, 포트, 암호를 입력하고 데.프.콘 바로가기 버튼을 누르면 VPN서버에 접속하게됩니다. github Repository","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"ID 해커톤","slug":"ID-해커톤","permalink":"http://KKimSangHeon.github.io/tags/ID-해커톤/"}]},{"title":"엄마가 보고있다","slug":"Mother-Is-Looking","date":"2017-08-11T05:53:02.000Z","updated":"2017-08-11T06:06:16.469Z","comments":true,"path":"2017/08/11/Mother-Is-Looking/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/11/Mother-Is-Looking/","excerpt":"","text":"참가배경-해커톤을 통해 다양한 사람을 만나고 해커톤이라는 콘테스트에 한번쯤 참가 해 보고싶었습니다. Idea에너톡 플러그인을 사용하여 현재 문제가 되는 청소년 인터넷 중독문제를 해결하고자 하였습니다. 또한 실시간 전력량을 확인할 수 있는 기능또한 추가하였습니다. 동작화면 어플리케이션을 실행시켜면 다음과 같이 “우리 집 PC 확인”, “우리집 전력 확인”을 선택할 수 있습니다. 우리 집 PC 확인 버튼을 눌러 현재 PC의 사용유무를 확인할 수 있으며 전원버튼을 눌러 컴퓨터를 종료할 수 있습니다. 우리 집 전력 확인 버튼을 누르면 실시간 전력량을 확인할 수 있습니다. github Repository","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"에너지 해커톤","slug":"에너지-해커톤","permalink":"http://KKimSangHeon.github.io/tags/에너지-해커톤/"}]},{"title":"1. 오라클 설치","slug":"database1","date":"2017-08-11T04:39:31.000Z","updated":"2018-09-03T05:53:44.025Z","comments":true,"path":"2017/08/11/database1/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/11/database1/","excerpt":"","text":"run sql command line을 켜고 conn system/manager 입력 // manager가 비번 conn /as sysdba //관리자로 로그인 mysql은 데이터베이스를 각각 생성하지만오라클을 테이블 스페이스가 존재하며 자신의 테이블스페이스에 테이블 생성 alter user hr account unlock; //hr계정을 언락함(사용하기 위해)alter user hr identified by “hr”; //비번을 hr로함 conn hr/hr //hr 계정으로 로그인 이클립스 - help - market place - toad 설치 자바가 데이터베이스에 접근하기 위해서는 jdbc가 필요. Connections탭에가서 new connection선택 User에 hr입력비번에 hr입력 OK클릭","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"SQL(Oracle)","slug":"Language/SQL-Oracle","permalink":"http://KKimSangHeon.github.io/categories/Language/SQL-Oracle/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"12. UDP 소켓","slug":"bigdata13","date":"2017-08-11T00:08:02.000Z","updated":"2018-09-03T05:53:18.980Z","comments":true,"path":"2017/08/11/bigdata13/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/11/bigdata13/","excerpt":"","text":"UDP1.비 연결 지향 프로그래밍2.TCP와 달리 연결되지 않은 상태로 데이터 통신을 하기 때문에 패킷이 유실될 가능성이 있다3.속도 면에서는 큰 장점이 있다. ( 처음 반응속도가 빠르다 ) TCP 서버 포트 6000 / UDP 서버 포트 6000 일 때 충돌이 날까?나지않는다. 다른 프로토콜이라서 그렇다. UDP Echo ServerUDPEchoServer.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class UDPEchoServer &#123; private static final int PORT = 6000; private static final int BUFFER_SIZE = 1000; public static void main(String[] args) &#123; DatagramSocket socket = null; try &#123; //1. Socket 생성 socket = new DatagramSocket(PORT); //2. 데이터 수신 DatagramPacket receivePacket = new DatagramPacket(new byte[BUFFER_SIZE], BUFFER_SIZE); while( true ) &#123; //3. 데이터 수신 대기 socket.receive( receivePacket ); //block //4. 수신 String message = new String( receivePacket.getData(), 0, receivePacket.getLength(), \"UTF-8\"); System.out.println( message ); //5. 데이터 송신 byte[] sendData = message.getBytes( \"UTF-8\" ); DatagramPacket sendPacket = new DatagramPacket( sendData, sendData.length, receivePacket.getAddress(), receivePacket.getPort() ); socket.send( sendPacket ); &#125; &#125; catch (SocketException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if( socket != null &amp;&amp; socket.isClosed() == false) &#123; socket.close(); &#125; &#125; &#125;&#125;UDP Echo ClientUDPEchoClient.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class UDPEchoClient &#123; private static final String SERVER_IP = \"192.168.111.1\"; private static final int SERVER_PORT = 6000; private static final int BUFFER_SIZE = 1024; public static void main(String[] args) &#123; DatagramSocket socket = null; Scanner scanner = null; try &#123; // 0. 키보드 연결 scanner = new Scanner(System.in); // 1. 소켓생성 socket = new DatagramSocket(); while (true) &#123; System.out.print(\"&gt;&gt;\"); String message = scanner.nextLine(); if( \"\".equals(message)) &#123; continue; &#125; if( \"quit\".equals( message )) &#123; break; &#125; //2. 전송패킷 생성 byte[] sendData = message.getBytes(\"utf-8\"); DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, new InetSocketAddress(SERVER_IP, SERVER_PORT)); //3. 전송 socket.send(sendPacket); //4. 메세지 수신 DatagramPacket receivePacket = new DatagramPacket( new byte[ BUFFER_SIZE], BUFFER_SIZE); socket.receive(receivePacket); message = new String( receivePacket.getData(), 0, receivePacket.getLength(), \"UTF-8\") ; System.out.println(\"&lt;&lt;\"+message); &#125; &#125; catch (SocketException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (socket != null &amp;&amp; socket.isClosed() == false) &#123; socket.close(); &#125; scanner.close(); &#125; &#125;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"11.소켓과 스레드의 결합","slug":"bigdata12","date":"2017-08-09T04:15:08.000Z","updated":"2018-09-03T05:53:16.051Z","comments":true,"path":"2017/08/09/bigdata12/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/09/bigdata12/","excerpt":"","text":"여러 클라이언트가 접속가능한 서버EchoServerReceiveThread.java123456789101112131415161718192021222324252627282930313233343536373839public class EchoServer &#123; private static final int SERVER_PORT = 5000; public static void main(String[] args) &#123; ServerSocket serverSocket = null; try &#123; // 1. 서버 소켓 생성 serverSocket = new ServerSocket(); // 2. 바인딩( Binding ) InetAddress inetAddress = InetAddress.getLocalHost(); String localhostAddress = inetAddress.getHostAddress(); serverSocket.bind(new InetSocketAddress(localhostAddress, SERVER_PORT)); System.out.println(\"[Server] binding \" + localhostAddress); while(true) &#123; // 3. 연결 요청 기다림( accept) Socket socket = serverSocket.accept(); // 반복문 내에서 blocking이 되기떄문에 CPU를 많이먹지 않는다. new EchoServerReceiveThread( socket ).start(); &#125; &#125; catch (IOException e) &#123; // 서버소켓과 관련된 캐치 e.printStackTrace(); &#125; finally &#123; try &#123; if (serverSocket != null &amp;&amp; serverSocket.isClosed() == false) &#123; serverSocket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private static void consoLog( String log ) &#123; System.out.println( \"[server:\" ); &#125;&#125; EchoServerReceiveThread.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class EchoServerReceiveThread extends Thread &#123; private Socket socket; public EchoServerReceiveThread( Socket socket ) &#123; this.socket = socket; &#125; @Override public void run() &#123; // 4. 연결성공 InetSocketAddress remoteSocketAddress = (InetSocketAddress) socket.getRemoteSocketAddress(); int remoteHostPort = remoteSocketAddress.getPort(); String remoteHostAddress = remoteSocketAddress.getAddress().getHostAddress(); consoleLog(\"connected from \"+ remoteHostAddress); try &#123; // 5. I/O Stream 받아오기 InputStream is = socket.getInputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(is, \"UTF-8\")); PrintWriter pw = new PrintWriter(socket.getOutputStream(), true); // auto flush를 true로 한다. true로 안하면 // 버퍼가 다찬다음 나가기 때문에 늦게나간다. while (true) &#123; // 6. 데이터 읽기 String message = br.readLine(); if (message == null) &#123; // 정상종료 consoleLog(\"disconnection by client\"); break; &#125; consoleLog(\" received : \" + message); // 7. 데이터 쓰기 pw.println(message); &#125; &#125; catch (SocketException e) &#123; // 상대편이 소켓을 정상적으로 닫지 않고 종료한 경우 consoleLog(\"sudden closed by client\"); &#125; catch (IOException e) &#123; // 소켓과 관련된 캐치 e.printStackTrace(); &#125; finally &#123; try &#123; if (socket != null &amp;&amp; socket.isClosed() == false) &#123; socket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private void consoleLog(String log) &#123; System.out.println(\"[Server: \"+getId() + \"]\" + log); &#125;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"10.쓰레드","slug":"bigdata11","date":"2017-08-09T02:42:34.000Z","updated":"2018-09-03T05:53:13.935Z","comments":true,"path":"2017/08/09/bigdata11/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/09/bigdata11/","excerpt":"","text":"MultiThreadEx.java12345678910111213141516171819202122232425public class MultiThreadEx &#123; public static void main(String[] args) &#123; Thread thread1 = new AlphabetThread(); //쓰레드 생성방법1 Thread thread2 = new Thread( new DigitThread()); //쓰레드 생성방법2 //매개변수로 Runnable이 구현된 객체를 받음 new Thread( new Runnable() &#123; //쓰레드 생성방법3 @Override public void run() &#123; for( char c = 'A'; c&lt;= 'z'; c++) &#123; System.out.print( c ); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start();; thread1.start(); thread2.start(); &#125;&#125; DigitThread.java12345678910111213public class DigitThread implements Runnable&#123; public void run() &#123; for(int i = 0; i &lt; 10; i++) &#123; System.out.print( i ); try &#123; Thread.sleep( 1000 ); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; AlphabetThread.java1234567891011121314public class AlphabetThread extends Thread&#123; @Override public void run() &#123; for( char c = 'a'; c &lt;= 'z'; c++) &#123; System.out.print( c ); try &#123; Thread.sleep( 1000 ); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"9. TCP 소켓 프로그래밍1","slug":"bigdata10","date":"2017-08-09T00:05:06.000Z","updated":"2018-09-03T05:53:11.577Z","comments":true,"path":"2017/08/09/bigdata10/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/09/bigdata10/","excerpt":"","text":"TCPTCP : 스트림(stream) 통신 프로토콜양쪽의 소켓이 연결된 상태에서 통신이 가능하다. (연결지향 프로토콜)신뢰성 있는 데이터 통신한 번 연결이 되면 연결이 끊어 질 때까지 송신한 데이터는 차례대로 목적지의 소켓에 전달자바는 java.net 패키지에 TCP 소켓 프로그래밍을 쉽게 하도록 관련 클래스를 제공하고 있다.라이브러리의 사용법과 동작순서를 정확하게 이해하고 있어야 한다.ServerSocket과 Socket 클래스를 사용하게 된다. TCPServer.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class TCPSever &#123; private static final int SERVER_PORT = 5000; public static void main(String[] args) &#123; ServerSocket serverSocket = null; try &#123; // 1. 서버 소켓 생성 serverSocket = new ServerSocket(); // 2. 바인딩( Binding ) InetAddress inetAddress = InetAddress.getLocalHost(); String localhostAddress = inetAddress.getHostAddress(); serverSocket.bind(new InetSocketAddress(localhostAddress, SERVER_PORT)); System.out.println(\"[Server] binding \" + localhostAddress); // 3. 연결 요청 기다림( accept) Socket socket = serverSocket.accept(); // blocking // 4. 연결성공 InetSocketAddress remoteSocketAddress = (InetSocketAddress) socket.getRemoteSocketAddress(); int remoteHostPort = remoteSocketAddress.getPort(); String remoteHostAddress = remoteSocketAddress.getAddress().getHostAddress(); System.out.println(\"[server] connected from \" + remoteHostAddress + remoteHostPort); try &#123; // 5. I/O Stream 받아오기 InputStream is = socket.getInputStream(); OutputStream os = socket.getOutputStream(); while (true) &#123; // 6. 데이터 읽기 byte[] buffer = new byte[256]; int readByteCount = is.read(buffer); // block if (readByteCount &lt;= -1) &#123; //정상종료 System.out.println(\"[server] disconnection by client\"); break; &#125; String data = new String(buffer, 0, readByteCount, \"utf-8\"); System.out.println(\"[server] received : \" + data); // 7. 데이터 쓰기 os.write(data.getBytes(\"utf-8\")); &#125; &#125; catch(SocketException e) &#123; // 상대편이 소켓을 정상적으로 닫지 않고 종료한 경우 System.out.println(\"[server] sudden closed by client\"); &#125;catch (IOException e) &#123; // 소켓과 관련된 캐치 e.printStackTrace(); &#125; finally &#123; try &#123; if (socket != null &amp;&amp; socket.isClosed() == false) &#123; socket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; catch (IOException e) &#123; // 서버소켓과 관련된 캐치 e.printStackTrace(); &#125; finally &#123; try &#123; if (serverSocket != null &amp;&amp; serverSocket.isClosed() == false) &#123; serverSocket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; TCPClient.java123456789101112131415161718192021222324252627282930313233343536373839404142434445public class TCPClient &#123; private static final String SERVER_IP = \"192.168.111.1\"; private static final int SERVER_PORT = 5000; public static void main(String[] args) &#123; Socket socket = null; try &#123; // 1. Socket 생성 socket = new Socket(); // 2. 서버 연결 socket.connect(new InetSocketAddress(SERVER_IP, SERVER_PORT)); // 3. I/O 받아오기 InputStream is = socket.getInputStream(); OutputStream os = socket.getOutputStream(); // 4. 쓰기 / 읽기 String data = \"hello\"; os.write( data.getBytes( \"utf-8\" )); byte[] buffer = new byte[256]; int readByteCount = is.read( buffer ); if( readByteCount &lt;= -1) &#123; System.out.println( \"[client] disconnection by server\"); return; &#125; data = new String( buffer, 0, readByteCount, \"utf-8\"); System.out.println(\"[client] received:\"+ data); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (socket != null &amp;&amp; socket.isClosed() == false) &#123; socket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 에코서버, 클라이언트 만들기 EchoServer.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class EchoServer &#123; private static final int SERVER_PORT = 5000; public static void main(String[] args) &#123; ServerSocket serverSocket = null; try &#123; // 1. 서버 소켓 생성 serverSocket = new ServerSocket(); // 2. 바인딩( Binding ) InetAddress inetAddress = InetAddress.getLocalHost(); String localhostAddress = inetAddress.getHostAddress(); serverSocket.bind(new InetSocketAddress(localhostAddress, SERVER_PORT)); System.out.println(\"[Server] binding \" + localhostAddress); // 3. 연결 요청 기다림( accept) Socket socket = serverSocket.accept(); // blocking // 4. 연결성공 InetSocketAddress remoteSocketAddress = (InetSocketAddress) socket.getRemoteSocketAddress(); int remoteHostPort = remoteSocketAddress.getPort(); String remoteHostAddress = remoteSocketAddress.getAddress().getHostAddress(); System.out.println(\"[server] connected from \" + remoteHostAddress + remoteHostPort); try &#123; // 5. I/O Stream 받아오기 InputStream is = socket.getInputStream(); BufferedReader br = new BufferedReader( new InputStreamReader( is, \"UTF-8\" )); PrintWriter pw = new PrintWriter(socket.getOutputStream(), true); // auto flush를 true로 한다. true로 안하면 //버퍼가 다찬다음 나가기 때문에 늦게나간다. while (true) &#123; // 6. 데이터 읽기 String message = br.readLine(); if ( message == null ) &#123; //정상종료 System.out.println(\"[server] disconnection by client\"); break; &#125; System.out.println(\"[server] received : \" + message); // 7. 데이터 쓰기 pw.println(message); &#125; &#125; catch(SocketException e) &#123; // 상대편이 소켓을 정상적으로 닫지 않고 종료한 경우 System.out.println(\"[server] sudden closed by client\"); &#125;catch (IOException e) &#123; // 소켓과 관련된 캐치 e.printStackTrace(); &#125; finally &#123; try &#123; if (socket != null &amp;&amp; socket.isClosed() == false) &#123; socket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; catch (IOException e) &#123; // 서버소켓과 관련된 캐치 e.printStackTrace(); &#125; finally &#123; try &#123; if (serverSocket != null &amp;&amp; serverSocket.isClosed() == false) &#123; serverSocket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; EchoClient.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class EchoClient &#123; private static final String SERVER_IP = \"192.168.111.1\"; private static final int SERVER_PORT = 5000; static Scanner scanner; public static void main(String[] args) &#123; Socket socket = null; try &#123; // 1. Socket 생성 socket = new Socket(); // 2. 서버 연결 socket.connect(new InetSocketAddress(SERVER_IP, SERVER_PORT)); // 3. I/O 받아오기 BufferedReader br = new BufferedReader( new InputStreamReader(socket.getInputStream())); PrintWriter pw = new PrintWriter( new OutputStreamWriter(socket.getOutputStream(),\"UTF-8\"),true); // 4. 쓰기 / 읽기 scanner = new Scanner(System.in); while(true) &#123; System.out.print( \"&gt;&gt;\" ); String message = scanner.nextLine(); if(\"exit\".equals(message)) &#123; break; &#125; //메세지 보내기 pw.println( message ); //에코 메시지 받기 String echoMessage = br.readLine(); if( echoMessage == null) &#123; System.out.println(\"[client] Disconnection by Server\"); &#125; //출력 System.out.println( \"&lt;&lt;\" + echoMessage ); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (socket != null &amp;&amp; socket.isClosed() == false) &#123; socket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; scanner.close(); &#125; &#125;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"8. 네트워크와 소켓의 이해","slug":"bigdata9","date":"2017-08-07T05:01:36.000Z","updated":"2018-09-03T05:53:09.107Z","comments":true,"path":"2017/08/07/bigdata9/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/07/bigdata9/","excerpt":"","text":"네트워크란?“유/무선 으로 연결되어 있는 Device들의 집합 ” 네트워킹?디바이스들 간에 미리 정의된 프로토콜을 사용하여 데이터를 교환 하는것.이를위해서는 프로토콜이 필요하다. 클라이언트 서버구조Client -&gt; Serverrequest Server -&gt; Clientresponse(ACK) 서버 : 서버프로그램이 돌고있는 장비 프로토콜디바이스간 데이터 통신을 위해 필요한 규약Hyper Text Transfer ProtocolFile Transfer ProtocolSMTP 등등. 패킷패킷은 Header, Body부분으로 나뉜다.Header은 Address, checksum 등 으로 구성되고Body는 Data로 구성된다. 소켓소켓?TCP / IP 프로토콜의 프로그래머 인터페이스를 의미네트워크 프로그래밍에서 개발자에게 네트워크에 접근할 수 있는 인터페이스 제공 포트?프로세스를 구분할 수 있는 주소16비트 정수를 사용한다. Address =&gt; IP Address Socket Address =&gt; IP Address + Port LocalHost.java123456789101112131415161718192021222324public class LocalHost &#123; public static void main(String[] args) &#123; try &#123; InetAddress inetAddress = InetAddress.getLocalHost(); String hostName = inetAddress.getHostName(); String hostAddress = inetAddress.getHostAddress(); byte[] addresses = inetAddress.getAddress(); //byte배열로 ip 받아오는 함수 System.out.println(hostName); //컴퓨터이름 System.out.println(hostAddress); //ipconfig의 결과와 같음 for( int i = 0 ; i &lt; addresses.length ; i++) &#123; System.out.print( addresses[i] &amp; 0x000000ff); //MSB로 인해 음수가 나와 마스킹을 해주는것. if( i &lt; 3 ) &#123; System.out.print(\".\"); &#125; &#125; &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; &#125;&#125; NSLookup기능을 구현해보자. NSLookup.java12345678910111213141516171819202122232425262728public class NSLookup &#123; public static void main(String[] args) &#123; String host = \"\"; Scanner sc = new Scanner(System.in); while (!(host.equals(\"exit\"))) &#123; try &#123; System.out.print(\"&gt;\"); host = sc.nextLine(); InetAddress[] inetAddresses = InetAddress.getAllByName(host); for (InetAddress inetAddress : inetAddresses) &#123; System.out.println(inetAddress.getHostAddress()); &#125; &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; System.out.println(); &#125; &#125;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"7. 스트림","slug":"bigdata8","date":"2017-08-07T00:17:29.000Z","updated":"2018-09-03T05:53:02.245Z","comments":true,"path":"2017/08/07/bigdata8/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/07/bigdata8/","excerpt":"","text":"InputStream - 1 byte 단위로 읽는놈ByteInputStreamFileInputStream FilterInputStream(보조스트림) OutputStream - 1 byte 단위로 쓰는놈ByteOutputStreamFileOutputStream FilterOutputStream(보조스트림) Reader - char(2byte, 자바에서는 3byte(UTF-8)) 단위로 읽는놈FileReader(InputStreamReader을 상속)BufferedReader Writer - char(2byte, 자바에서는 3byte(UTF-8)) 단위로 쓰는놈FileWriterBufferedWriter 사용방법1.주 스트림을 소스에 꽂는다.2.보조스트림은 주 스트림에 꽂는다.3.프로그램에서 보조스트림을 사용해서 읽는다. IOExample.java12345678910111213141516171819202122232425public class IOExample &#123; public static void main(String[] args) &#123; byte[] src = &#123;0, 1, 2, 3&#125;; byte[] dest = null; try &#123; InputStream is = new ByteArrayInputStream( src ); OutputStream os = new ByteArrayOutputStream(); int data = -1; while( (data = is.read()) != -1 ) &#123; //data에 1바이트식 저장됨 os.write(data); &#125; dest = ((ByteArrayOutputStream)os).toByteArray(); System.out.println( Arrays.toString( src )); System.out.println( Arrays.toString( dest )); &#125; catch( IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; FileCopy.java1234567891011121314151617181920212223242526272829303132public class FileCopy &#123; public static void main(String[] args) &#123; InputStream is = null; OutputStream os = null; try &#123; is = new FileInputStream( \"./dooly.png\" ); os = new FileOutputStream( \"./dooly2.png \"); int data = 1; while( (data = is.read()) !=-1 ) &#123; os.write( data ); &#125; &#125; catch (FileNotFoundException e) &#123; System.out.println(\"파일없음\" + e); &#125; catch (IOException e) &#123; System.out.println(\"I/O 에러\" + e); &#125; finally &#123; try&#123; if( is != null) &#123; is.close(); &#125; if( os != null) os.close(); &#125;catch(IOException e) &#123; &#125; &#125; &#125;&#125; 123.txt를 UTF-8로 만들고(직접만들자)FileReader로 1바이트씩 읽어보고FileInputStream으로 3(UTF-8이므로..) 바이트씩 읽어보자 FileReaderTest.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class FileReaderTest &#123; public static void main(String[] args) &#123; Reader reader = null; InputStream is = null; try &#123; //비교를 위해서 두개를 만들었다. reader = new FileReader( \"./hello.txt\" ); //char 기반 is = new FileInputStream( \"./hello.txt \"); //바이트기반 int count = 0; int data = -1; while( (data = reader.read()) != -1 ) &#123; count++; System.out.println( (char)data ); &#125; System.out.println( \"\\n읽은 회수: \" + count ); System.out.println(\"=========\"); count = 0; data = -1; while( (data = is.read() )!= -1) &#123; count++; System.out.println( (char) data); &#125; &#125; catch (FileNotFoundException e) &#123; System.out.println( \"파일 없음 \" + e ); &#125; catch (IOException e) &#123; System.out.println(\"I/O 에러:\" + e); &#125; finally &#123; try &#123; if( reader != null) &#123; reader.close(); &#125; if( is != null) &#123; is.close(); &#125; &#125;catch(IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 보조스트림을 사용하여 보자 BufferedOutputStreamTest.java12345678910111213141516171819202122232425262728public class BufferedOutputStreamTest &#123; public static void main(String[] args) &#123; BufferedOutputStream bos = null; try &#123; bos = new BufferedOutputStream( new FileOutputStream( \"./123.txt\" ), 5 ); //버퍼가 5의 크기를 갖는다 5만큼 차면 flush(비우기)가 발생함 for(int i='1' ; i &lt;= '9' ; i++) &#123; bos.write( i ); //bos.flush(); //한번쓰고 플러시하고를 반복.(버퍼를 5로 설정한 의미가 없어짐..) &#125; &#125; catch (FileNotFoundException e) &#123; System.out.println(\"파일 없음: \" + e); &#125; catch (IOException e) &#123; System.out.println(\"I/O 에러\" + e); &#125; finally &#123; try &#123; if( bos!= null) &#123; bos.close(); &#125; &#125; catch( IOException e) &#123; &#125; &#125; &#125;&#125; 주스트림 FileReader을 꽂고보조스트림 BufferedReader을 꽂음. BufferedOutputStreamTest.java123456789101112131415161718192021222324252627282930public class BufferedReaderTest &#123; public static void main(String[] args) &#123; BufferedReader br = null; try &#123; br = new BufferedReader( new FileReader(\"./src/io/BufferedReaderTest.java\")); int index = 0; String line = null; while((line = br.readLine())!= null) &#123; System.out.println(++index + \" : \" + line); &#125; &#125; catch( FileNotFoundException e) &#123; System.out.println(\"파일없음: \" + e); &#125; catch( IOException e) &#123; System.out.println(\"I/O 에러\" + e); &#125; finally &#123; try &#123; if(br != null) &#123; br.close(); &#125; &#125;catch(IOException e) &#123; System.out.println(\"파일없음\"+e); &#125; &#125; &#125;&#125; MS 949로 텍스트 파일을 하나만들자.FileInputStream 주 스트림을 바이트단위로 꽂고 InputStreamReaderTest.java12345678910111213141516171819202122232425262728293031public class InputStreamReaderTest &#123; public static void main(String[] args) &#123; Reader reader = null; try &#123; reader = new InputStreamReader( new FileInputStream(\"./ms949.txt\"), \"MS949\" ); int data = -1; while( ( data = reader.read()) != -1 ) &#123; System.out.println( (char)data ); &#125; &#125; catch (UnsupportedEncodingException e) &#123; System.out.println(\"지원하지 않는 charset\"); &#125; catch (FileNotFoundException e) &#123; System.out.println(\"파일이 없음:\" + e); &#125; catch (IOException e) &#123; System.out.println(\"IOException:\"+e); &#125; finally &#123; try &#123; if( reader!=null) &#123; reader.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; System.in으로 부터 스트림을 생성해보자KeyboardTest.java12345678910111213141516171819202122232425262728293031323334353637383940public class KeyboardTest &#123; public static void main(String[] args) &#123; BufferedReader br = null; try &#123; br = new BufferedReader(new InputStreamReader(System.in, \"UTF-8\")); //키보드에서 라인 단위로 읽기 위해 br사용 //readLine() 메소드를 쓰기위해 while(true) &#123; System.out.print( \"&gt;&gt;\" ); String line = br.readLine(); if (line == null ) &#123; break; &#125; if( \"exit\".equals( line )) &#123; break; &#125; System.out.println(line); &#125; &#125; catch (UnsupportedEncodingException e) &#123; System.out.println(\"지원하지 않는 charset : \"+e); &#125; catch (IOException e) &#123; System.out.println(\"I/O 에러\" + e); &#125; finally &#123; try &#123; if(br != null) &#123; br.close(); &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 파일 객체사용해보자.tokenizer도 사용해보자PhoneList01.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class PhoneList01 &#123; public static void main(String[] args) &#123; BufferedReader br = null; try &#123; File file = new File( \"./phone.txt\" ); if( file.exists() == false ) &#123; System.out.println( \"파일이 존재하지 않습니다\" ); return; &#125; System.out.println( \"========== 파일정보 =========\" ); System.out.println( \"경로\" + file.getAbsolutePath() ); System.out.println( \"크기: \"+ file.length()+\"Bytes\" ); Date date = new Date( file.lastModified() ); SimpleDateFormat sdf = new SimpleDateFormat (\"yyyy-MM-dd hh:mm:ss\"); System.out.println( \"마지막 수정일:\" + sdf.format(date)); System.out.println( \"전화번호\"); br = new BufferedReader( new InputStreamReader( new FileInputStream(file),\"UTF-8\") ); String line = null; while((line = br.readLine())!=null) &#123; //System.out.println(line); StringTokenizer st = new StringTokenizer(line, \"\\t \"); int index = 0; while( st.hasMoreTokens() ) &#123; String s = st.nextToken(); if(index == 0 ) &#123; System.out.print( s + \":\"); &#125; else if( index ==1 ) &#123; System.out.print( s+ \"-\"); &#125; else if( index == 2) &#123; System.out.print( s+ \"-\"); &#125; else &#123; System.out.print( s); &#125; index++; &#125; System.out.print(\"\\n\"); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch ( UnsupportedEncodingException e) &#123; System.out.println(\"지원하지 않는 charset\"); &#125; catch(IOException e) &#123; &#125; finally &#123; if( br !=null) &#123; try &#123; br.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;위에서 했던 작업을 Scanner로 간편하게 해보자PhoneList02.java1234567891011121314151617181920212223242526272829303132333435363738394041424344public class PhoneList02 &#123; public static void main(String[] args) &#123; Scanner scanner = null; try &#123; File file = new File(\"./phone.txt\"); if (file.exists() == false) &#123; System.out.println(\"파일이 존재하지 않습니다\"); return; &#125; System.out.println(\"========== 파일정보 =========\"); System.out.println(\"경로\" + file.getAbsolutePath()); System.out.println(\"크기: \" + file.length() + \"Bytes\"); Date date = new Date(file.lastModified()); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\"); System.out.println(\"마지막 수정일:\" + sdf.format(date)); System.out.println(\"전화번호\"); // 여기까지는 PhoneList01과 같다 scanner = new Scanner(file); while( scanner.hasNext() ) &#123; String name = scanner.next(); String phone1 = scanner.next(); String phone2 = scanner.next(); String phone3 = scanner.next(); System.out.println(name + \":\" + phone1 + \"-\" + phone2 + \"-\" + phone3); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if ( scanner != null ) &#123; scanner.close(); &#125; &#125; &#125;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"6. 제네릭, 가변변수, 익명클래스, Collection프레임워크","slug":"bigdata7","date":"2017-08-07T00:04:17.000Z","updated":"2018-09-03T05:52:59.798Z","comments":true,"path":"2017/08/07/bigdata7/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/07/bigdata7/","excerpt":"","text":"제네릭오버로딩을 대체할 수 있으며 유용하다. 메소드에 제네릭을 적용12345678public &lt;T,P,Q,R&gt; void println( T t ) &#123; System.out.println(t);&#125;public static void main(String args[]) &#123; println( 10 ); println( true );&#125; 메소드 반환형에 제네릭 적용1234567public &lt;T, P&gt; List&lt;P&gt; println( T t ) &#123; System.out.println( t ); List&lt;P&gt; list = new ArrayList&lt;P&gt;(); return list;&#125; 제네릭 배열을 어떻게 동적으로 생성하느냐12345678910111213public MyStack( E[] objects, int capacity ) &#123; //buffer = new E[ capacity ]; 오류발생 //방법1. buffer = ( E[] ) Array.newInstance(objects.getClass(), capacity); //방법2. 방법2가 더 선호된다. 객체를 생성하지 않아도 된다는점 때문에 buffer = ( E[] )Array.newInstance(Object.class, capacity); //방법3. 방법 2와 일치하는방식이다. buffer = ( E[] )new Object[capacity]; //방법 3을 제일 많이 쓴다. this.capacity = capacity; currentIndex = 0;&#125; 제네릭 호출 방식123456789101112131415public static void main(String[] args) &#123; MyStack&lt;String&gt; stack = new MyStack&lt;String&gt;(3); //String의 스택을 생성한다. MyStack&lt;?&gt; stack = new MyStack&lt;String&gt;(3); //모든 타입의 객체를 생성하겠다.&#125;public .... f(List&lt;? extends Shape&gt;)&#123; // Shape를 상속한 것들의 리스트를 파라미터로 받음 //와일드 카드를 사용해서 제네릭 타입 제한하기. ...&#125; 가변변수가변변수를 배우기 전에는 파라미터에 배열을 넣을 생각을 할 것이다. 하지만 이를 대체할 수 있는것이 가변변수이다. 1234567891011121314public static void main(String args[]) &#123; println2( \"둘리\" ); println2( \"둘리\", \"마이콜\" ); println2( \"둘리\", \"마이콜\", \"또치\"); //println3( new String[]&#123;\"둘리\", \"마이콜\", \"또치\"&#125;); 배열사용 &#125; public static void println2(String ... params) &#123; for( String s : params)&#123; System.out.println(s); &#125; &#125; 아래의 경우 Object를 파라미터로 주면 캐스팅을 계속 해줘야한다.1234567public &lt;T&gt; void println( T t) &#123; System.out.println(t);&#125;public void println(Object o ) &#123; System.out.println(o);&#125; 익명클래스파라미터를 전달하는 부분에서 객체를 생성하여 메소드를 호출.객체를 생성하지 않고 메소드 호출부분에서 객체를 생성함.123456789//anonymous class objectdraw( new Drawable() &#123; @Override public void draw() &#123; // TODO Auto-generated method stub System.out.println(\"한 번만 만들고 버릴 도형을 그렸습니다\"); &#125; &#125;); CollectionCollection인터페이스는 inteator() 메소드를 갖고 있다.List, Set 클래스는 Collection클래스를 구현하며 List는 중복허용, 순서를 갖는다. 그러나 Set는 중복을 허용하지 않으며 순서를 갖지 않는다.List인터페이스는 add, get, remove를 갖는다.LinkedList, ArrayList가 List 인터페이스를 구현한다. ArrayList는 빈번한 삽입,삭제가 일어나는 경우 사용하면 안된다. 그 과정이 길기 떄문에.LinkedList는 삽입삭제가 유용하나 10000번째 놈이면 10000번을 next해야한다. 멀티스레드에서 ArrayList, LinkedList의 add를 사용할 때는 동기화 처리를 해줘야한다. 하지만 Vector은 멀티스레드 환경에서 동기화를 해주지 않아도 된다. ArrayList , LinkedList, VectorTest21234567891011121314151617181920212223242526272829303132333435public class ArrayListTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); LinkedList&lt;String&gt;(); Vector&lt;String&gt;(); //삽입 list.add( \"둘리\" ); list.add( \"마이콜\" ); list.add( \"도우넛\" ); //순회1 int count = list.size(); for( int i = 0; i &lt; count ; i++) &#123; String s = list.get( i ); System.out.println(i); &#125; //제거 list.remove( 1 ); //순회2 Iterator&lt;String&gt; it = list.iterator(); while( it.hasNext() ) &#123; String s = it.next(); System.out.println( s ); &#125; //순회3 for( String s : list) &#123; System.out.println( s ); &#125; &#125;&#125; Vector1.2 시대의 Vector인터페이스는 addElement, elementAt, removeElement, elements메소드를 갖고 있다. 그 후 1.2이후에 생긴 List를 구현하여 List의 메소드를 갖는다. Vector를 사용하려면 Vector 메소드를 사용하거나 List 인터페이스 내부의 메소드만 사용하든가 해야 복잡해지지 않는다. 과거 Vector을 사용하는 방식. 호환성 때문에 존재할뿐.. 사용일 지양하자.VectorTest.java123456789101112131415161718192021222324252627public class VectorTest &#123; public static void main(String[] args) &#123; Vector&lt;String&gt; v = new Vector&lt;String&gt;(); v.addElement( \"둘리\" ); v.addElement( \"마이콜\" ); v.addElement( \"도우넛\" ); //순회1 Enumeration&lt;String&gt; e = v.elements(); while( e.hasMoreElements() ) &#123; String s = e.nextElement(); System.out.println( s ); &#125; //삭제 v.removeElementAt( 1 ); System.out.println(\"=====================\"); //순회2 int count = v.size(); for( int i=0; i&lt; count; i++) &#123; String s = v.elementAt( i ); System.out.println( s ); &#125; &#125;&#125; SetSet 인터페이스는 key, value로 구성된다. key를 통해 value에 접근할 수 있다.HashSet, TreeSet가 Map인터페이스를 구현한다.hashCode를 오버라이드 하여 사용하여야 한다. 123456789101112131415161718192021222324252627282930public class HashSetTest &#123; public static void main(String[] args) &#123; Set&lt;Value&gt; set = new HashSet&lt;Value&gt;(); Value v1 =new Value(10); Value v2 =new Value(5); Value v3 =new Value(10); Value v4 =new Value(20); set.add(v1); set.add(v2); set.add(v3); set.add(v4); //존재여부 확인 System.out.println(set.contains(new Value(10))); //삭제 set.remove( new Value(10) ); //순회 Iterator&lt;Value&gt; it = set.iterator(); while( it.hasNext() )&#123; Value v = it.next(); System.out.println(v); &#125; &#125;&#125; 성능향상을 위해 hash를 오버라이드 한다.12345678910111213141516171819202122232425262728293031323334public class Value &#123; private int value; public Value( int value ) &#123; this.value = value; &#125; @Override public String toString() &#123; return \"Value [value=\" + value + \"]\"; &#125; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + value; return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Value other = (Value) obj; if (value != other.value) return false; return true; &#125; Stack12345678910111213141516171819202122public class StackTest &#123; public static void main(String[] args) &#123; Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); stack.push(\"둘리\"); stack.push(\"마이콜\"); stack.push(\"도우넛\"); stack.push(\"길동\"); System.out.println( stack.isEmpty() ); System.out.println( stack.pop() ); System.out.println( stack.pop() ); System.out.println( stack.peek() ); //pop을 하지않고 확인만 System.out.println( stack.pop() ); System.out.println( stack.pop() ); //스택은 비어있는 경우 pop호출 시 예외가 발생한다. System.out.println( stack.pop() ); &#125;&#125; Queue123456789101112131415161718192021222324public class QueueTest &#123; public static void main(String[] args) &#123; Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); queue.offer(\"둘리\"); queue.offer(\"마이콜\"); queue.offer(\"도우너\"); queue.offer(\"길동\"); System.out.println( queue.isEmpty() ); System.out.println( queue.poll() ); System.out.println( queue.poll() ); System.out.println( queue.peek() ); System.out.println( queue.poll() ); System.out.println( queue.poll() ); System.out.println( queue.isEmpty() ); System.out.println( queue.poll() ); //스택은 예외가 발생했지만 큐는 null이 리턴된다. &#125;&#125; MapMap 인터페이스가 존재하는데 HashMap, HashTable가 이를 구현한다. 1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); map.put(\"둘리\", 100); map.put(\"마이콜\", 50); map.put(\"도우넛\", 80); map.put(\"길동\", 90); //중복 map.put( \"둘리\" , 0); //덮어쓴다. //auto unboxing int score = map.get( \"둘리\" ); System.out.println(score); map.remove( \"둘리\" ); //평균 ( 키를 모르는데 어떻게할까?) int sum = 0; Set&lt;String&gt; keySet = map.keySet(); Iterator&lt;String&gt; it = keySet.iterator(); while( it.hasNext() ) &#123; String key = it.next(); System.out.println( key ); int s = map.get( key ); sum += s; &#125; System.out.println( \"평균 : \"+ sum / keySet.size() );&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"5.자바기본API(유틸리티API)","slug":"bigdata6","date":"2017-08-04T05:10:31.000Z","updated":"2018-09-03T05:52:57.347Z","comments":true,"path":"2017/08/04/bigdata6/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/04/bigdata6/","excerpt":"","text":"날짜date 보다는 calendar을 쓰라고 권고한다. DateWrapperClassTest.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class DateTest &#123; public static void main(String[] args) &#123; Date now = new Date(); System.out.println( now ); printDate1(now); printDate2(now); // 특정시간 세팅(200/08/04) Date d1 = new Date(100, 7, 4, 14, 30, 30); printDate2( d1 ); //1970년 1월 1일 00:00:00 기준 //milliseconds 값을 세팅 Date d3 = new Date( 24L * 60 * 60 * 1000 * 365 * 30); printDate2(d3); &#125; private static void printDate1( Date date ) &#123; SimpleDateFormat sdf = new SimpleDateFormat( \"YYYY년 MM월 dd일 hh시 mm분 ss초\" ); System.out.println(sdf.format(date)); &#125; private static void printDate2( Date date) &#123; //년도 (+1900) int year = date.getYear(); //월(0~11) int month = date.getMonth(); //일 int day = date.getDay(); //시 int hour = date.getHours(); //분 int minutes = date.getMinutes(); //초 int seconds = date.getSeconds(); System.out.println( (year + 1900) + \"년 \" + (month + 1)+ \"월 \" + day + \"일 \" + hour + \"시 \" + minutes + \"분\" + seconds + \"초\" ); &#125;&#125; 싱글톤어플리케이션에서 객체 하나만 유지하고 싶을 떄 이 방법을 쓴다.Singleton.java123456789101112131415public class Singleton &#123; private static Singleton instance; public static Singleton getInstance() &#123; if(instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; private Singleton() &#123; //생성자를 private로 하여 객체 생성을 외부에서 불가능하도록 &#125;&#125;싱글톤 클래스를 활용해보자SingletonTest.java123456789101112public class SingletonTest &#123; public static void main(String[] args) &#123; Singleton s1 = Singleton.getInstance(); Singleton s2 = Singleton.getInstance(); Singleton s3 = Singleton.getInstance(); System.out.println(s1 == s2); System.out.println(s2 == s3); &#125;&#125; CalendarCalendar클래스는 추상클래스이다.(객체생성 불가능)WrapperClassTest.java12345678910111213141516171819202122232425262728293031323334public class CalendarTest &#123; public static void main(String[] args) &#123;// Calendar cal = new Calendar(); //추상클래스라 객체생성 불가능 Calendar cal = Calendar.getInstance(); //어플리케이션에서 이 객체 하나만 유지하고 싶을 떄 이 방법을 쓴다. 싱글톤 패턴이라함 printDate( cal ); &#125; public static void printDate( Calendar cal ) &#123; String[] days = &#123;\"일\",\"월\",\"화\",\"수\",\"목\",\"금\",\"토\"&#125;; int year = cal.get( Calendar.YEAR ); int month = cal.get( Calendar.MONTH ); int date = cal.get( Calendar.DATE ); //1(일요일) ~ 7(토요일) int day = cal.get( Calendar.DAY_OF_WEEK); int hour = cal.get( Calendar.HOUR ); int minute = cal.get( Calendar.MINUTE ); int seconds = cal.get( Calendar.SECOND ); System.out.println( (year) + \"년 \" + (month + 1)+ \"월 \" + date + \"일 \" + \"(\" + days[day-1] + \")\" + hour + \"시 \" + minute + \"분\" + seconds + \"초\" ); &#125;&#125; WrapperClassTest.java1","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"4. 자바기본 API(equals, wrapper클래스)","slug":"bigdata5","date":"2017-08-03T02:25:31.000Z","updated":"2018-09-03T05:52:53.412Z","comments":true,"path":"2017/08/03/bigdata5/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/03/bigdata5/","excerpt":"","text":"StringString 인스턴스 안에는 char 배열이 존재하는것이다.String은 toString를 오버라이딩 하여 안에 내용이 출력된다.toString를 오버라이딩 하여 인스턴스에 대한 정보를 확인할 수 있게 만드는 것은 좋은 습관이다. 디버깅할때 편하다는 장점이 있다. equals결과를 예측해보자12345678910111213141516171819202122232425262728293031public class EqualsTest &#123; public static void main(String[] args) &#123; Point point1 = new Point(10, 20); Point point2 = new Point(10, 20); Point point3 = point2; // ==연산자에서 두 개의 항이 객체 참조 변수 인 경우 // 두 개체의 동일 여부(동일성) System.out.println( point1 == point2 ); //false System.out.println( point2 == point3 ); //true //equals는 오버라이딩이 되지 않았을 경우 참조값 비교를 함.(동질성 비교) //해쉬코드를 갖고와서 비교를함(해쉬코드==참조값) System.out.println( point1.equals(point2) ); //false System.out.println( point2.equals(point3) ); //true System.out.println(\"================\"); //String 객체와 비교 //String는 equals가 오버라이딩 되어있다. String s1 = new String( \"hello\" ); String s2 = new String( \"hello\" ); String s3 = s2; System.out.println( s1 == s2 ); //false System.out.println( s2 == s3 ); //true System.out.println( s1.equals(s2) ); //true System.out.println( s2.equals(s3) ); //true &#125; equals를 오버라이딩 해보자hashCode()메소드도 오버라이딩이 필요하다.자바에서는 hashCode() equal() 메소드를 동시에 오버라이드 해야한다.equals 조건을 제곱으로 한다면 hashCode도 제곱으로 변경해주어야 한다.그렇지 않으면 해쉬맵 해쉬 셋을 쓸 때 어려워진다.Point.java123456789101112131415161718192021222324252627282930public class Point &#123; private int x; private int y;.. @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + x; result = prime * result + y; return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Point other = (Point) obj; if (x != other.x) return false; if (y != other.y) return false; return true; &#125; 결과를 예측해보자12345678910// String Literal // 문자열 상수 Pool에 있는것을 재사용함// 문자열 상수 Pool을 공유하기 때문에 문자열의 수정이 불가능하다.// str1의 변경은 가능하나 문자열 상수인 hello의 값이 변경 불가능하다는것.String str1 = \"hello\";String str2 = \"hello\";String str3 = str2;System.out.println( str1 == str2 ); //trueSystem.out.println( str2 == str3 ); //true new String(“문자열”) “문자열”의 차이는?위의 결과를 보고 잘 생각해 보자문자열은 변경되지 않는다는점을 잘 생각하자.변한다면 참고하고 있는 다른 참조변수들이 피해를 본다.. 잘생각해보자12345678910111213141516171819202122public static void main(String[] args) &#123; String str1 = \"abc\"; String str2 = \"cde\"; String str3 = str2; str2 = str3.toUpperCase(); System.out.println(str1); System.out.println(str2); System.out.println(str3); String str4 = str2.concat(\"??\"); System.out.println(str2); System.out.println(str4);// String s = \"!\";// String str5 = s.concat(str2);// Method chain String str5 = \"!\".concat(str2); //위의 코드와 별다른 차이가 없다. System.out.println(str5);&#125; String 메소드의 사용법 및 활용123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class StringTest03 &#123; public static void main(String[] args) &#123; String s= \"abcAbcabcABC\"; //charAt char c = s.charAt( 2 ); System.out.println( c ); //indexOf System.out.println( s.indexOf( \"Abc\" ) ); //3 System.out.println( s.indexOf(\"ab\") ); //0 System.out.println( s.lastIndexOf(\"ab\") ); //6 System.out.println( s.indexOf( \"XYZ\" )); //-1 반환 //replace System.out.println( s.replace(\"bc\", \"12\") ); //s가 바뀌지는 않음 System.out.println( s.replaceAll(\"bc\", \"12\") ); //s가 바뀌지는 않음 //substring System.out.println( s.substring( 3, 7) ); //3~6까지 나온다 //case System.out.println( s.toLowerCase() ); System.out.println( s.toUpperCase() ); //concat String str1 = \" ab cd \"; String str2 = \",efg\"; str1 = str1.concat(str2); //trim System.out.println( \"---\" + str1 + \"---\" ); //--- ab cd ,efg--- System.out.println( \"---\" + str1.trim() + \"---\" );//---ab cd ,efg--- //split String[] tokens = str1.split(\",\"); for( String token : tokens) &#123; // ab cd System.out.println( token ); // efg &#125; //split 예외 tokens = \"abcdefg\".split( \",\" ); for( String token : tokens) &#123; System.out.println( token ); //abcdefg &#125; tokens = \"\".split( \",\" ); System.out.println( tokens.length ); // 1 &#125;&#125; StringBufferStringBuffer는 가변크기의 버퍼를 가짐.“abc” + “cde” (String) 보다는 StringBuffer를 쓰는게 낫다.전자의 경우 런타임 때 “abc”를 스트링 버퍼로 만들고 append(“cde”)후 toString()를 통해 값을 반환한다.String를 사용해도 되지만 append의 작업이 많을 경우 StringBuffer사용하는것이 빠르다.123456789101112131415161718192021222324252627282930313233public static void main(String[] args) &#123;//생성StringBuffer sb = new StringBuffer( \"this\" );System.out.println(sb.length() + \":\" + sb.capacity()); //4:20//버퍼의 크기를 문자의 크기보다 크게 생성함(append를 염두)//문자열추가sb.append(\" is pencil\");System.out.println( sb );//삽입sb.insert(7, \" my\");System.out.println( sb ); //this is my pencil//치환sb.replace( 8, 10, \"your\" );System.out.println( sb );//버퍼 크기sb.setLength( 3 );System.out.println( sb );//문자열 + 연산은 내부적으로 StringBuffer 객체로 변환String s1 = \"Hello\" + \" World\" + 10 +true;System.out.println(s1); //Hello World10true//다음과 코드가 같은것.String s2 = new StringBuffer( \"Hello\" ).append( \" World\" ).append( 10 ).append( true ).toString();System.out.println(s1); //Hello World10trueSystem.out.println(s2); //Hello World10true&#125; Wrapper 클래스기본형 보다는 Wrapper 클래스를 쓰고자하는 움직임이 많이 발생하고 있다. WrapperClassTest.java1234567891011121314151617181920public class WrapperClassTest &#123; public static void main(String[] args) &#123; Integer i = new Integer(10); Character c = new Character( 'c' ); Float f = new Float ( 3.14 ); Boolean b = new Boolean( true ); //Auto Boxing Integer j = 10; //int k = 20 + j.intValue(); //Auto Unboxing int k = 20 + j; &#125; public static void swap( Integer a, Integer b ) &#123; // 상수풀 운영원칙 때문에 객체이지만 내부를 수정할 수 없다. &#125;&#125; 정규식을활용하여 정수인지 확인WrapperClassTest2.java12345678910111213141516171819202122public class WrapperClassTest2 &#123; public static void main(String[] args) &#123; System.out.println( Character.toLowerCase( 'a' )); System.out.println( Character.isDigit( '1' )); System.out.println( Character.isDigit( '@' )); //String는 isdigit가 존재하지 않는다. String s = \"1234\"; if(s.matches(\"-?\\\\d+\") == false ) &#123; System.out.println(\"숫자가 아닙니다\"); &#125; else &#123; int i = Integer.parseInt(s); &#125; // 프로그램 로직(변수 검증) 할 때는 // try - catch 문으로 하지 말것. // 비용이 많이든다. //정규식을 활용하자 &#125;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"3. 패키지, 예외","slug":"bigdata4","date":"2017-08-03T01:41:54.000Z","updated":"2018-09-03T05:52:48.248Z","comments":true,"path":"2017/08/03/bigdata4/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/03/bigdata4/","excerpt":"","text":"LinkedList탐색의 경우 O(n) / 삽입 삭제의 경우 간단. ArrayList탐색의 경우 O(1) / 삽입 삭제의 경우 쭉~ 밀려남 패키지java.lang.* - 명시적으로 지정하지 않아도 자동으로 import 되는 패키지.자바 프로그램이 기본적으로 필요로 하는 클래스와 인터페이스 포함 java.io.* - 데이터를 입력받고 출력할 수 있도록 하는 클래스 포함 java.net.* - 네트워크를 통하여 통신할 수 있도록 해주는 클래스 포함 java.util.* - 날짜/시간 조작, 난수 발생 등 각종 유틸리티 클래스와 인터페이스 포함 예외처리예외프로그램이 실행되는 동안 발생할 수 있는 비정상적인 조건번역시의 에러가 아닌 실행시의 에러를 예외라 함 자바에서의 예외처리예외처리를 위한 Exception 클래스 정의기본적인 예외는 자바에 미리 정의된 예외를 통해 처리 가능사용자가 필요한 예외를 직접 정의할 수 있음예상되는 예외는 미리 처리해주면 무조건적인 프로그램의 종료를 피할 수 있음예외처리의 사용은 프로그램의 신뢰성을 높여줌 try catch 문catch문에서 예외가 발생하면 복구시키는게 목표이다. 하지만 그게 말이 쉽지 복구라는건 불가능한 경우가 많이있다.try catch는 가독성을 떨어뜨린다는 단점이 있다.ex) 상대방이 랜선을 뽑아서 캐치에 왔다면 어쩔래 finally는 옵션이다.주로 자원정리가 목적이다. 예외가 발생하던 안하던 들어감.심지어 try에서 return 을 해도 finally가 실행된다. 123456789101112int result=0;int a = 1;try &#123; result = 1000 / a; return;&#125;catch(ArithmeticException e) &#123; System.out.println(\"예외발생\"); return;&#125; finally &#123; System.out.println(\"자원정리\"); //실행된다.&#125; checked Exception메소드를 사용하기 위해서는 반드시 예외를 처리해 줘야함 (ex&gt; FileInputStream) 실습1.1234567891011121314public static void main(String[] args) &#123; FileInputStream fis = null; try &#123; fis = new FileInputStream( \"./hello.txt\" ); int data = fis.read(); &#125; catch(FileNotFoundException|NullPointerException e) &#123; /*여러개의 예외를 처리*/ &#125; catch (Exception e) &#123; /*모든예외를 처리하고 싶을 때*/ &#125; 실습2. 나의 Exception 정의MyException 정의MyException.java12345678910public class MyException extends Exception&#123; public MyException() &#123; super( \"MyException Occurs\" ); &#125; public MyException( String message ) &#123; super( message ); &#125;&#125; MyClass 정의 MyClass.java123456789101112131415public class MyClass &#123; public void danger() throws MyException &#123; System.out.println( \"some code1\" ); System.out.println( \"some code2\" ); if( 1==1 ) &#123; throw new MyException(\"MyClass Exception 발행\"); &#125; System.out.println( \"some code3\" ); System.out.println( \"some code4\" ); &#125;&#125; MyClassTest 정의MyClassTest.java1234567891011public class MyClassTest &#123; public static void main(String[] args) &#123; try &#123; MyClass myClass = new MyClass(); myClass.danger(); &#125; catch (MyException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"2. 오버로드,오버로딩,추상클래스,인터페이스","slug":"bigdata3","date":"2017-08-03T00:27:12.000Z","updated":"2018-09-03T05:52:44.872Z","comments":true,"path":"2017/08/03/bigdata3/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/03/bigdata3/","excerpt":"","text":"오버로드아래는 다 다른 메소드이다.12345678void a (int a, int b)..void a (int a, float b)...void a (float a, int b)... 아규먼트 , 파라미터아규먼트는 int ,float 등 형을 의미파라미터는 실제적인 데이터 10, 0.5 등을 의미. 식별자클래스 이름, 변수이름, 메소드 이름을 식별자라 한다.대소문자 가능 숫자 가능 하지만 앞에는 안되고 특수문자는 $ _ 만 사용가능. 생성자기본으로 디폴트 생성자가 만들어지지만 생성자가 하나라도 정의되어 있으면 디폴트 생성자가 생성되지 않는다. 다형성외부에서 사용할 땐 일관되게 사용하는것.오버로딩, 오버라이딩을 통해 구현 thisthis 키워드는 메소드 호출을 받는 객체를 의미한다.현재 사용중인 객체 그 자체를 의미한다.this() 는 클래스의 한 생성자에서 다른 생성자를 호출 할 때 사용할 수 있다 오버로딩부모에있는 메소드와 시그니쳐가 동일(접근제어자 , 반환형, 메소드이름, 아규먼트) 생성자 관련 문제상속관계에서 자식 클래스의 인스턴스를 생성하면 부모 혹은 자식 생성자중 어떤것이 먼저 호출될까? 12345678910부모 생성자public Parent()&#123; syso(\"부모 호출됨\");&#125;자식 생성자public Child()&#123; syso(\"자식 호출됨\");&#125; 부모 생성자가 먼저 호출된다.즉 자식 메소드의 생성자 안에(8행) super(); (기본생성자 호출)가 자동으로 삽입된것이다. int형 매개변수가 존재하는 부모 생성자를 호출하려면 8행에 super(35); 를 넣어주면 된다. 캐스팅형은 높은데에서 낮은곳으로 가면 명시적으로 알려줘야 하지만 , 인스턴스는높은곳(부모) 낮은곳(자식) 으로 가려면 명시를 해줘야 한다.다운캐스팅의 예(Explicity Casting 명시적 캐스팅)123456//방법 1Person p = new Student();Student s1 = (Student)p;//방법 2((Student)p).set(); 업캐스팅의 예(Implicity Casting 암시적 캐스팅)1Person p2 = s1; 추상클래스추상화객체들이 가지고 있는 속성과 기능 중에 중요한 것들은 남기고 필요 없는 불필요한 것은 없애는것. 또는 공통된 것들을 그룹핑해서 한곳에다 모아놓는것. 추상클래스new를 통해 객체를 생성하지는 못한다.필드를 갖을 수 있고, 구현된 메소드를 갖을 수 있다.추상 클래스를 상속하는 클래스는 반드시 추상 클래스의 추상 메소드를 구현해야 함추상 클래스간의 상속에서는 추상클래스를 구현하지 않아도 됨추상 클래스의 활용여러 클래스들이 상당수 공통점을 가지고 있으나 부분적으로 그 처리 방식이 다를 경우 부모 클래스를 추상 클래스로 정의하여 자식 클래스들이 각각 해당 메소드를 구현 실습부모클래스Shape.java1234567891011abstract class Shape &#123; private String fillColor; private String lineColor;.. public abstract void draw(); public abstract int calcArea();&#125; Shape 클래스를 상속Rectangle.java12345678910111213141516public class Rectangle extends Shape &#123; private int x1; private int y1; private int x2; private int y2; @Override public void draw() &#123; System.out.println(\"사각형을 그렸습니다.\"); &#125; @Override public int calcArea() &#123; return ((x1+x2)*(y1+y2)); &#125;&#125; Shape 클래스를 상속Circle.java123456789101112131415161718192021222324public class Circle extends Shape&#123; private int x1; private int y1; private int radius; public Circle(int x1, int y1, int radius) &#123; this.x1 = x1; this.y1 = y1; this.radius = radius; &#125;.. @Override public void draw() &#123; System.out.println(\"원을 그렸습니다.\"); &#125; @Override public int calcArea() &#123; return (int)(Math.PI * radius * radius); &#125;&#125; main 메소드PaintApp.java1234567891011121314package paint;public class PaintApp &#123; public static void main(String[] args) &#123; drawShape( new Rectangle()); drawShape( new Circle(10, 20, 5)); &#125; private static void drawShape( Shape shape ) &#123; shape.draw(); &#125;&#125; 인터페이스객체를 사용할 수 있는 목록. 즉 메소드 목록이다.UML 에서는 &lt;&gt; 라고 하고 그림.기능의 명세이다. Drawable라는 인터페이스를 구현하여 draw 메소드를 오버라이딩하여 사용.Drawable 인터페이스를 구현하면 그릴수 있다는 것을 암시.서로 관계가 없는 물체들이 상호 작용을 하기 위해서 사용하는 장치나 시스템클래스 구조상의 관계와 상관 없이 클래스들에 의해 구현되어질 수 있는 규약인터페이스 안에서는 인터페이스 끼리 다중상속이 된다.public interface Drivable extends A,B{…..} 실습인터페이스 정의Drawable.java123public interface Drawable &#123; public void draw(); //자동으로 abstract가 됨&#125; Point클래스가 Drawable 인터페이스를 구현함Paint.java123456789101112131415public class Point implements Drawable&#123; private int x; private int y; public Point() &#123; &#125; public void show() &#123; System.out.println( \"점[x=\" + x + \",y=\" + y +\"]을 그렸습니다.\"); &#125; ... public void draw() &#123; show(); &#125;&#125; ColorPoint가 Point클래스를 상속하여 Drawable를 구현한 효과를 갖음ColorPoint.java1234567891011121314151617181920package paint;public class ColorPoint extends Point &#123; private String color; public ColorPoint(int x, int y, String color) &#123; super(x, y); this.color = color; &#125;.. @Override public void show() &#123; //완전 super.show(); System.out.println( \"color \" + color); &#125;&#125; 메인메소드PaintApp.java12345678910public class PaintApp &#123; public static void main(String[] args) &#123; draw(new ColorPoint(200,200,\"yellow\")); &#125; private static void draw( Drawable drawable ) &#123;//Drawable를 구현하고 있으면 draw를 해줄게 drawable.draw(); &#125;&#125; 인터페이스 추상클래스 차이인터페이스는서로 관계가 없는 물체들이 상호 작용을 하기 위해서 사용하는 장치나 시스템클래스 구조상의 관계와 상관 없이 클래스들에 의해 구현되어질 수 있는 규약하나 또는 그 이상의 클래스들에서 똑같이 구현되어질 법한 메소드를 선언하는 경우 추상클래스는객체들이 가지고 있는 속성과 기능 중에 중요한 것들은 남기고 필요 없는 불필요한 것은 없애는것. 또는 공통된 것들을 그룹핑해서 한곳에다 모아놓는것. 정리일반클래스 : 모두 완결한 메소드 / 필드를 가질 수 있음 / 객체화 가능 추상클래스 : 완결한 메소드, 추상메소드 / 필드 가질 수 있음 / 객체화 불가 인터페이스 : 모든 추상 메소드 / 필드 가질 수 없음 / 객체화 불가 instanceof1234567891011// 객체가 Circle 클래스의 인스턴스 인가?System.out.println( c instanceof Circle );// 객체가 Drawable 인터페이스를 구현하였는가?System.out.println( c instanceof Drawable );// 객체가 Rectangle 클래스의 인스턴스 인가?System.out.println( c instanceof Rectangle );// 객체가 Shape 클래스의 인스턴스 인가?System.out.println( c instanceof Shape );","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"깃허브 사용","slug":"bigdata2","date":"2017-08-01T04:04:28.000Z","updated":"2018-09-03T05:52:41.055Z","comments":true,"path":"2017/08/01/bigdata2/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/01/bigdata2/","excerpt":"","text":"깃허브란 형상관리 툴이다. A(팀장,a모듈담당) B(b모듈담당) C(c모듈담당) 개발자가 하나의 프로젝트를 개발중이다. A 가 프로젝트(모듈 a,b,c 포함)를 올린다. 그 후 B C 에게 그 사실을 알린다. B C 는 프로젝트를 내려받고 B,C가 자신의 모듈을 수정 후 커밋을 한다. A,B,C는 수정된 것을 내려 받은 후 테스트를 한다. git가 있으며 내부에는 Repository가 있다. git는 레파지토리가 2개 존재한다.하나는 로컬이고 하나는 원격이다. 로컬 레파지토리에 프로젝트를 올리는것을 commit 라고 하며 로컬 레파지토리를 원격 레파지토리에 맞추는 것을 push 라고 한다. 원격 레파지토리에서 프로젝트를 로컬레파지토리로 갖고오는것을 full 내 프로젝트로 반영하는것은 fetch라고 한다. 하지만 보통 로컬레파지토리와 프로젝트를 같이 놓는다.(편의상)1.내 프로젝트 올리기이클립스에서 실행1.이클립스 - show view - git Repository 선택2.프로젝트 우클릭 후 - team - share …-체크-create누름(로컬레파지토리 프로젝트를 같이하는것.) 깃허브에서 실행1.레파지토리 new - 프로젝트 이름이랑 동일하게 생성(굳이 안해도되나 편의상)2.깃 주소를 복사 이클립스에서 실행1.git Repository탭 - remote - Configure fetch 체크(push 체크하면 올리기만 되고 받기는 안된다.) - change 버튼 클릭 - save Fetch 클릭2.project explorer탭으로 - team - commit - Unsatage Changes에 있는 것들을 staged Changed로 내림. 커밋메세지는 추가할 수 있도록 하자. - commit and push 클릭 - next - finish 2.타 프로젝트 받기.방법1. 깃허브에서 다운받아서 임포트하기. 방법2. 프로젝트를 fork한다. 깃허브에서 실행원하는 프로젝트로 가서 fork를 누르고내 레파지토리로 가보자. 자신의 레파지토리에 생성되있는게 있을것임.이제 자기 레파지토리에 있는것을 잡아 땡겨보자clone or download 에서 url 복사 이클립스에서 실행git Repository탭으로 가서 컨트롤+vnext-next - browse 눌러서 자기 워크스페이스 선택 (로컬 레파지토리와 프로젝트저장소를 하나로 합치는것.)working tree 선택 후 오른쪽 누르고 import .. 클릭 후 finish Project explorer 탭으로 가서 보면 에러가 난다. (환경설정이 달라서 나는 에러이다.)프로젝트 우클릭 후 - properties - java build path 선택- Libraries 탭 선택 - 더블클릭 후 - alternate JRE 에서 선택 3.레파지토리 삭제해당레파지토리로 가서 - 세팅 - 레파지토리 이름 입력 이클립스에서 실행team - disconnect 후 delete Repository 클릭하나로 뭉쳐놨기 때문에 맨위 하나만 선택하면 된다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"}],"tags":[]},{"title":"1.자바프로그래밍 기본","slug":"bigdata1","date":"2017-08-01T00:05:28.000Z","updated":"2018-09-03T05:52:34.717Z","comments":true,"path":"2017/08/01/bigdata1/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/01/bigdata1/","excerpt":"","text":"특징많은 클래스, 파일로 프로그램이 구성된다. 클래스는 데이터를 갖고 있고 메소드는 데이터를 다루게 된다. 객체의 데이터를 다루기 위해서는 외부에서 메소드를 호출해야 한다. 하드웨어는 컴포넌트화로 인해 빠른 발전이 이루어졌다. 소프트웨어 또한 이에 따라 컴포넌트화로 발전하게 되었다. 객체지향은 설계분석이 가능하다. 요구사항 분석-&gt;추상화-&gt;객체관계 분석(상속,의존 등) 캡슐화, 상속, 다형성의 특징을 갖는다. 코드의 재사용성이 높다. 추상화 과정으로 인해 가능해지는것. 상속을 통해 부모에 존재하는 메소드 사용가능.잘못된 예: 홈쇼핑 프로젝트에서 만든 Person 클래스를 ERP를 만드는곳에서 Person을 만드는데 사용한다. 예외처리를 통해 신뢰성이 높아진다. java는 운영체제에 영향을 받지 않는다는 특징. JRE + API + javac + rt.jar = JDK 객체와 클래스객체는 정보를 효율적으로 관리하기 위하여 의미를 부여하고 분류하는 논리적 단위클래스를 사용자 데이터 타입 이라고도 한다. 객체의 구성요서는 속성(필드,인스턴스 변수)이 필요하다.클래스 내부에 있는 변수는 필드 혹은 속성이라 한다.!기능은 메소드라 한다. 컴파일 과정네비게이터로 bin 폴더를 보자.코들를 짜면 bin 폴더 내부에 클래스파일이 컴파일되어 생성된다. 메소드 영역필드정보(클래스에 대한 정보. getClass() 메소드를 통해 얻을 수 있다.), 메소드 코드, main메소드, static 변수, static 메소드 stack지역변수. 자바는 전역변수의 개념이 없으므로 모든 변수는 여기에 생성됨. heap객체 접근자public - 내부, 같은 패키지, 자식접근, 외부 가능. protected - 내부, 같은 패키지, 자식접근 가능. (default) - 쓰지않는것을 권고한다. 내부, 같은 패키지에서 접근가능. private - 내부에서만 접근 가능. 정보은닉데이터는 private를 넣고 접근할 때 메소드를 쓴다. 엔터프라이즈에서는 이러한 메소드를 빈이라고 부른다. finalfinal은 클래스 앞, 변수앞 , 필드 앞에도 정의할 수 있다.final은 여기가 마지막이라는 뜻.상수는 대문자로 만들라는 관례가 있다.!따지고 보면 변수와는 별 다른게 없지만 알아보기 편하게!123final int VALUE = 10;VALUE = 30; //에러발생 1234public final class Test&#123;.....&#125;이 경우 다른클래스가 Test클래스를 상속할 수 없음. 1234public final Sring getName() &#123; return name;&#125;오버라이딩 금지!! 생각해보자12345678910public void show() &#123; System.out.println( \"점[x=\" + x + \",y=\" + y +\"]을 그렸습니다.\"); &#125;public void show(boolean visible) &#123; //외부에서 매개변수를 통해 보이고 안보이고를 show메소드로만 통제 if(visible) &#123; show(); &#125;else &#123; System.out.println( \"점[x=\" + x + \",y=\" + y +\"]을 지움.\"); &#125; 코드를 위와 같이 구현 시 사용자는 show라는 메소드에 접근하고 boolean 값만을 통해 출력 미출력을 통제할 수 있다. 이 형태가 좋은 이유는 show , notShow 와 같은 메소드를 만들어서 사용자가 모든 메소드를 알고 있어야하는 상황을 없앨 수 있다.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"Chat-Bot","slug":"Chat-Bot","date":"2017-07-17T08:49:17.000Z","updated":"2018-11-14T09:37:34.995Z","comments":true,"path":"2017/07/17/Chat-Bot/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/17/Chat-Bot/","excerpt":"","text":"과정GCP 우분투로 생성 후123456sudo apt-get install -y build-essentialcurl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -sudo apt-get install -y nodejs 초기화1npm init 후 엔터 쭈욱 1npm install --save cheerio node.js에서 제이쿼리의 선택자를 쓸 수 있게되어 설치.1npm install --save request url에 접속하여 html을 다운받을 수 있게된다. 1npm install --save async 비동기 방식을 사용할 수 있게 된다.1npm install --save node-cron 주기적인 작업을 실행시키기 위해 설치하였다.1npm install --save iconv html을 가져 왔을 때 한글 깨짐을 막을 수 있다.1sudo npm install pm2 -g 서버가 문제가 생겼을 경우 재시작 시켜주며 성능향상에 기여한다.pm2의 명령어는 다음과 같다.12345678pm2 start 서버.js --name 별칭 //실행하면서 별칭을 붙여준다.pm2 list //실행되고 있는 pm2리스트를 조회pm2 stop 별칭 // pm2를 중지한다.pm2 restart 별칭 //pm2 재시작한다.pm2 delete 별칭 //pm2 종료pm2 show 별칭// 정보확인","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"}]},{"title":"19장. PXE 서버, 킥스타트","slug":"ThisIsLinux42","date":"2017-07-16T12:22:55.000Z","updated":"2018-09-03T05:52:00.768Z","comments":true,"path":"2017/07/16/ThisIsLinux42/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/16/ThisIsLinux42/","excerpt":"","text":"Centos를 100개 깔아야 하는 상황에는 여러가지 방법이 있겠지만 PXE 설치서버를 구성해놓는다면 쉽게 설치가 가능하다!1.DHCP 서버, TFTP 서버, syslinux부팅파일, FTP 또는 웹서버를 PXE 설치 서버에 구성해 놓는다. 즉 PXE는 하나의 프로그램이 아니라 여러개의 프로그램을 잘 조합해 놓은것을 의미2.Centos를 설치할 PC의 전원을 켠다.3.설치할 파일을 네트워크로 전송해서 자동으로 설치 PXE는 초기 설치화면 즉 언어설정 전 까지만 완료해 주지만 킥스타트는 초기설정까지 해준다. 1.PXE 설치1.1 서버에서 설정1# yum -y install syslinux dhcp tftp-server vsftpd //관련패키지 설치 1.1 DHCP 설정12345678910111213141516# systemctl stop firewalld# systemctl disable firewalld# vi /etc/dhcp/dhcpd.conf맨아래 다음 입력subnet 192.168.111.0 netmask 255.255.255.0 &#123; option routers 192.168.111.2; option subnet-mask 255.255.255.0; range dynamic-bootp 192.168.111.120 192.168.111.199; option domain-name-servers 192.168.111.2; allow booting; allow bootp; next-server 192.168.111.100; filename &quot;pxelinux.0&quot;;&#125;입력 후 종료 1.2 TFTP 설정123# vi /etc/xinetd.d/tftpdisable = no 로 변경저장후 종료 1.3 ftp로 iso이미지 접근가능하게오른쪽위 cd모양 우클릭 - 세팅 - Use ISO image… - Centos이미지 찾고 위에 Connected, Connect at power on 체크 - OK123# umount /dev/cdrom# mount /dev/cdrom /var/ftp/pub ftp를 접속할 경우 cd롬파일을 접근가능 1.4 부팅에 필요한 파일 준비tftp는 부팅파일을 전송하는 역할이다.123456789101112131415161718# cp /var/ftp/pub/images/pxeboot/vmlinuz /var/lib/tftpboot/# cp /var/ftp/pub/images/pxeboot/initrd.img /var/lib/tftpboot/# cp /usr/share/syslinux/pxelinux.0 /var/lib/tftpboot/# ls -l /var/lib/ftpboot# mkdir /var/lib/tftpboot/pxelinux.cfg# cd /var/lib/tftpboot/pxelinux.cfg# touch default //부팅에 관련된 파일 생성# vi default 다음을 입력DEFAULT CentOS7_Auto_InstallLABEL CentOS7_Auto_Install kernel vmlinuz APPEND initrd=initrd.img repo=ftp://192.168.111.100/pub# ps -ef | grep dnsmasq //충동하는 프로세스 kill위해# kill -9 1696# systemctl disable dnsmasq 1.5 관련 서비스 시작123456# systemctl restart dhcpd //서비스 시작# systemctl restart vsftpd# systemctl restart xinetd //tftp임# systemctl enable dhcpd //상시가동# systemctl enable vsftpd# systemctl enable xinetd 1.6 VMware에서 제공하는 DHCP를 끄자워크스테이션 키고 - Edit - Virtual Network Editor - change setting 누르고-VMnet8선택 - Use local DHCP .. 체크 해제 후 - OK이제 서버에서만 DHCP 서버를 제공한다. 1.7 새로운 PC를 만들자버츄어 머신에서 진행하자버츄어머신 네임을 TestCom으로로케이션을 Centos 폴더 내 TestCom으로 하자그 후 부팅하면 설치가 된다. 2.킥스타트 설치킥스타트는 교재를 참고하자.","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"18장. 방화벽 컴퓨터를 만들자","slug":"ThisIsLinux41","date":"2017-07-16T02:04:12.000Z","updated":"2018-09-03T05:51:58.265Z","comments":true,"path":"2017/07/16/ThisIsLinux41/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/16/ThisIsLinux41/","excerpt":"","text":"방화벽은 내부, 외부를 차단해주는 장비 또는 컴퓨터라고 생각하면 된다. 방화벽으로 인해 외부에서 내부 네트워크로 함부러 침입할 수 없다. 그 기법중 많이 쓰이는 것이 사설IP이다.방화벽 컴퓨터는 랜카드가 두개여야 된다. 내부와 결합되는(사설 IP) 랜카드 외부와 연결되는 랜카드(공인IP) 실습에서 192.168.xxx는 공인 ip10.1.xxx 는 내부ip로 사용한다책 737을 통해 네트워크 구성을 확인하자 1. 서버 B 설정(웹서버로 사용할것임)서버B의 네트워크 세팅에 들어가서 네트워크 어댑터 클릭 후 Bridged 클릭그러면 네트워크가 Bridged네트워크 안으로 들어옴(사설ip로 사용하기로 함)그 후 ip를 변경하자 123456789# nmtui edit ens32Address를 10.1.1.20/24로 변경Gateway를 10.1.1.1로 변경Dns 168.126.63.1로 변경 //kt에서 운영하는 dns 서버ok버튼# reboot# ip addr inet이 10.1.1.20 인지 확인 2. 클라이언트 설정(클라이언트에서 실행)클라이언트의 네트워크 세팅에 들어가서 네트워크 어댑터 클릭 후 Bridged 클릭 그러면 네트워크가 Bridged네트워크 안으로 들어옴123456789# nmtui edit ens33IPv4 CONFIGURATION을 Manual로 바꾸고 Show 엔터Address를 10.1.1.10/24Gateway는 10.1.1.1DNS Server는 168.126.63.1 OK 엔터# reboot# ip addr 3. 서버B,클라이언트 사설네트워크 테스트현재까지 구현한것(서버B,클라이언트)은 게이트웨이가 구현되어있지 않으므로 외부로 나갈 수 없다. 하지만 사설네트워크로 안에서는 연결되어 있으므로 ping이 왔다갔다 하는지 확인해보자 클라이언트에서 실행1# ping -c 3 10.1.1.20 4. 서버 구성(서버에서 실행)4.1 랜카드 하나가 외부로 연결 잘 되어있는지 확인해보자123# nmtui edit ens32게이트웨이, DNS Servers가 192.168.111.2로 잘 되어있다.# halt -p 서버에 랜카드를 하나 더 달자.vmware 워크스테이션에서 Edit virtual machins settings를 눌러 Add 후 Network Adapter 선택 다음 후 Bridged 선택하고 Finish 그 후 부팅추가한 장치가 ens32인지 확인해보자날짜 옆에 랜카드 모양을 누르면 ens34가 추가되어 있다. 네트워크설정 클릭 후 오른쪽 아래 톱니모양(유선연결1)을 누르고 신원을 누르자. 그 후 ens34로 입력하자다음 IPv4를 선택하여 자동을 수동으로 변경하자그 후 주소 10.1.1.1네트마스크 255.255.255.0게이트웨이 10.1.1.1네임서버 끄자IPv6로 가서 끄자이제 적용을 누르고 재부팅하자 12345# vi /etc/sysconfig/network-scripts/ifcfg-ens346,7행 지워버리기# systemctl restart network# ifconfigens32 는 192.168.111.100번으로 ens34는 10.1.1.1 이제 하드웨어 설정은 끝났다 5. 클라이언트에서 핑을 날려보자1# ping 10.1.1.1 6. 서버에 정책을 적용시켜보자1234567891011121314151617181920212223242526272829303132# vi /etc/sysctl.confnet.ipv4.ip_foward=1 맨아래 입력# echo 1 &gt; /proc/sys/net/ipv4/ip_forward //아무 메세지 안나오면 성공# cat /proc/sys/net/ipv4/ip_forward //1출력됨포워딩성공!# iptables --policy FORWARD DROP# iptables --policy INPUT DROP# iptables --policy OUTPUT DROPens34 장치를 설정해주자input 설정# iptables --append INPUT --in-interface ens34 --source 10.1.1.0/24 --match state --state NEW,ESTABLISHED --jump ACCEPToutput 설정# iptables --append OUTPUT --out-interface ens34 --destination 10.1.1.0/24 --match state --state NEW,ESTABLISHED --jump ACCEPT# iptables --append FORWARD --in-interface ens34 --source 10.1.1.0/24 --destination 0.0.0.0/0 --match state --state NEW,ESTABLISHED --jump ACCEPTens32 설정# iptables --append FORWARD --in-interface ens32 --destination 10.1.1.0/24 --match state --state ESTABLISHED --jump ACCEPT# iptables --table nat --append POSTROUTING --out-interface ens32 --jump MASQUERADE설정한것 저장# service iptables save# firewall-config영구적 - 마스커레이딩 - 마스커레이딩영역 체크 - 옵션 다시불러오기 7.클라이언트에서 인터넷 해보자이 경우 클라이언트는 자신의 ip(10.1.1.0)이 아닌 Server IP(192.168.111.100)으로 접속하게 된다. 이를 확인해보자 7.1 윈 클라이언트를 켜자파일질라서버를 카페에서 받자에딧 -유저- 오른쪽add -centos 입력- password centos -ok왼쪽 add 아무 디렉토리 선택- write/delete 선택 -okcmd 열고 netsh advfirewall firewall add rule name=”FTP서버” dir=in action=allow protocol=tcp localport=21방화벽 설정 입력ipconfig아이피를 기억하자 (지금은 192.168.111.128임) 7.2 클라이언트에서 FTP 접속해보자1234567# su# yum -y install ftp# ftp 192.168.111.128centoscentos&gt;pwd&gt;ls 7.3 윈도우 클라이언트에서 누가 접속했는지 확인해보자netstat /an찾다 보면 192.168.111.100이 들어온것을 확인할 수 있다.즉 사설네트워크 컴퓨터는 외부로 나갈 때 192.168.111.100으로 나간다! 8. 서버B를 웹서버로 만들고 윈 클라이언트로 접속해보자8.1 서버 B에서 실행12345678910# yum -y install httpd# firewall-cmd --add-service=http //포트열자# cd /var/www/html# touch index.html# vi index.htmlCentos7-Web Server 입력저장 후 종료# systemctl restart httpd# systemctl enable httpd 8.2 서버에서 80번 포트로 연결오면 서버 B로 연결해라를 설정서버에서 실행12# iptables --table nat --append PREROUTING --proto tcp --in-interface ens32 --dport 80 --jump DNAT --to-destination 10.1.1.20# service iptables save //저장 8.3 윈도우 클라이언트에서 접속해보자192.168.111.100 으로 접속하자","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"17장. 프록시 서버 설치와 운영","slug":"ThisIsLinux40","date":"2017-07-15T09:55:25.000Z","updated":"2018-09-03T05:51:55.792Z","comments":true,"path":"2017/07/15/ThisIsLinux40/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/15/ThisIsLinux40/","excerpt":"","text":"프록시서버?웹서핑을 할 경우 웹브라우저가 외부로 가서 파일을 가져와 읽게 되는것이다. 두 브라우져가 같은곳을 접속하면 따로 가져오게 되는 현상이 발생할 수 있다. 하지만 프록시 서버를 지정해놓으면 프록시 서버가 캐시에 a사이트 데이터를 저장 해놓고 다른 웹브라우져가 a서버를 요청하면 a 데이터를 보내준다. 프록시서버 구현(서버에서)123456789101112131415161718# yum -y install squid //설치# vi /etc/squid/squid.conf:set nu:26acl centos7 src 192.168.111.0/255.255.255.0 //c클래스 지정:54http_access allow centos7:62주석 제거 하고 100을 1000으로맨아래 다음추가visible_hostname centos7# firewall-config영구적 선택 - 포트 - 추가 3128 - 다시불러오기# systemctl stop firewalld //맘편하게 방화벽 끄는것# systemctl restart squid# systemctl enable squid# systemctl status squid 웹브라우저에서 프록시서버 지정(클라이언트)파이어폭스를 켜고 - 편집 - 환경설정 -고급 - 네트워크 - 설정 - 프록시 수동설정 192.168.111.100 포트 3128 입력 - 확인 윈도우클라이언트에서 지정(윈클라이언트)도구 -인터넷옵션 -LAN설정 프록시서버 192.168.111.100 3128 입력 1","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"16장. DHCP 서버 설치와 운영","slug":"ThisIsLinux39","date":"2017-07-15T07:09:22.000Z","updated":"2018-09-03T05:51:53.401Z","comments":true,"path":"2017/07/15/ThisIsLinux39/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/15/ThisIsLinux39/","excerpt":"","text":"DHCP(Dynamic Host Configuration Protocol) 서버는 자동으로 네트워크 정보(IP주소, 서브넷 마스크, 게이트웨이 주소,DNS 서버 주소)를 할당해 주는것이다. 일반 PC는 자신에게 고정IP가 할당되어있지 않아도 DHCP서버가 할당해준다. 그러므로 일반사용자는 IP에 대한 지식 없이도 인터넷 사용이 가능해진다. Vmware에서 제공하는 DHCP 서버의 기능은 중지시켜야 한다. 클라이언트 설정1234# ifconfigip를 DHCP로부터 할당받은것.# cat /etc/resolv.confnameserver 또한 DHCP로 부터 할당받은것. 1. DHCP 기능중지워크스테이션 - Edit - Virtual Network Editor - change setting 선택 - VMnet8선택 - DHCP Setting 선택128부터 254까지를 할당하는 것을 확인 Use local DHCP …. 클릭 해제Apply이제 IP를 자동으로 할당받지 못한다. 2. DHCP 서버 설정하자.12345678910111213141516171819202122232425262728293031323334353637# yum -y install dhcp# ps -ef | grep dnsmasq //dhcp와 충돌하므로 죽이자.nobody 1696 1 0 18:21 ? 00:00:00 /sbin/dnsmasq --conf-file=/var/lib/libvirt/dnsmasq/default.confroot 3514 2462 0 18:28 pts/0 00:00:00 grep --color=auto dnsmasq# kill -9 1696 //다를 수 있다.# systemctl disable dnsmasq //껏다켜도 실행 되지 않도록.# vi /etc/dhcp/dhcpd.conf //dhcp 설정파일아래를 추가하자. (엔터로 인한 공백이 존재하면 안된다)ddns-update-style interim;subnet 192.168.111.0 netmask 255.255.255.0 &#123; option routers 192.168.111.2; //라우터설정 option subnet-mask 255.255.255.0; //서브넷마스크설정 range dynamic-bootp 192.168.111.30 192.168.111.50; //ip범위 설정 30~50까지 20개 option domain-name-servers 192.126.63.1; //dns설정(kt에서 제공하는것) default-lease-time 10000; //디폴트 임대시간 max-lease-time 50000; //최대임대시간&#125; # ls /var/lib/dhcpddhcpd.leases에 ip를 임대해준것에 대한 기록이 있다.# systemctl restart dhcpd# systemctl enable dhcpd //상시가동# systemctl status dhcpd //잘 작동하는지 확인# systemctl stop firewalld# systemctl restart dhcpd 3. 클라이언트에서 IP 할당받아보자1234# su -c &apos;systemctl restart network&apos;password 입력# ifconfig //아이피 확인해보자192.168.111.30을 받았다. (아까 30~50을 지정해줌) 4. 윈도우 클라이언트에서 IP 할당받아보자네트워크 - 공유센터 - 어댑터 - 로컬 영역 연결을 사용안함으로 했다가 사용으로 변경 - cmd를 켜고 ipconfig 를 입력하면192.168.111.31을 받은것을 확인할 수 있다. 5. 서버에서 빌려간것들을 확인해보자12# cat /var/lib/dhcpd/dhcpd.leasesIP를 언제빌려갔고 누가 빌려갔고 맥어드레스 등을 확인할 수 있다. 6. 다시 워크스테이션의 DHCP를 켜자워크스테이션 - Edit - Virtual Network Editor - change setting 선택 - VMnet8선택 - DHCP Setting 선택 - Use local DHCP …선택","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"15장. Samba 서버 설치와 운영","slug":"ThisIsLinux38","date":"2017-07-15T05:37:36.000Z","updated":"2018-09-03T05:51:50.707Z","comments":true,"path":"2017/07/15/ThisIsLinux38/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/15/ThisIsLinux38/","excerpt":"","text":"NFS 유닉스와 유닉스 유닉스와 리눅스간 파일공유이고삼바는 유닉스(리눅스)와 윈도우즈간에 공유하는것. 1.윈도우가 삼바 서버1.1 윈도우 클라이언트를 삼바 서버로 만들자(윈클라이언트실행)C 드라이브에 smbShare 폴더만든다. 그 폴더 속성 들어가서 공유탭의 공유버튼 누르고 Everyone 선택하고 추가 그 후 Everyone은 읽기/쓰기로 선택 명령프롬프트 관리자 모드로 열고 net user root 1234 /add 입력. //윈도우즈 사용자 추가ipconfig192.168.11.131임을 기억하자 1.2 삼바 클라이언트로 접속해보자(서버에서 실행)123456789101112# rpm -qa | grep samba# smbclient -L 192.168.111.1311234입력# mkdir /sambaMount# mount -t cifs //192.168.111.131/smbShare /sambaMount //윈도우는 //로 해야함1234입력# ls -l /sambaMount# cp /boot/vmlinuz-* /sambaMount 2. 리눅스가 삼바 서버윈도우는 삼바 클라이언트라는 개념이 없다. 그래서 리눅스가 윈도우인척 폴더를 공유해 놓으면 윈도우 클라이언트는 해당폴더가 윈도우가 공유했는지 리눅스가 공유한지 모르고 그냥 쓰게 된다. 2.1 리눅스 서버를 삼바 서버로 만들자(서버에서 실행)12345678910111213141516171819202122232425262728# yum -y install samba관련파일 카페에서 받자# cd 다운로드# yum -y localinstall system-config-samba*여기서 에러날 경우 카페 자료실을 참고하자# systemctl restart smb# systemctl enable smb# ls /share / //share 폴더를 공유하자# chmod 707 /share# system-config-samba설정- 서버설정 - workgroup/centOS 7 입력- 보안탭가서 인증모드 공유로 하고 확인workgroup은 윈도우의 그룹이다.+를 누르고 폴더는 /share로 하고 쓰기가능,보이기 체크접근탭을 눌러서 모든사용자에게 접근부여 선택설정 - samba사용자 눌러서 사용자 추가.유닉스 사용자명은 centOS / winuser /1234 /1234 입력 후 확인# systemctl stop firewalld# firewall-config //삼바, 삼바 클라이언트 열기 //지금은 방화벽을 꺼둔상태라 하지 않아도 된다.# systemctl restart smb 2.2 윈도우에서 접속해보자컴퓨터 -&gt; 네트워크 드라이브 연결드라이브 Q로 선택폴더에 \\\\192.168.111.100\\share 입력centos1234 2.3 서버에 접속한 사용자를 보자(서버에서 실행)1# smbstatus","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"14장. NFS 서버 설치와 운영","slug":"ThisIsLinux37","date":"2017-07-15T03:11:36.000Z","updated":"2018-09-03T05:51:48.695Z","comments":true,"path":"2017/07/15/ThisIsLinux37/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/15/ThisIsLinux37/","excerpt":"","text":"NFS 서버리눅스 사이에 파일이나 폴더를 공유하는것NFS를 구현하면 다양한 클라이언트가 공유 디렉터리에 접근할 수 있다.서버에서는 서버를 구현하고 클라이언트는 그것을 마운트하여 사용한다. 서버를 NFS 서버로 구현(서버로 실행)1234567891011121314# rpm -qa nfs-utils //설치 확인(깔려있다.)# vi /etc/exports //공유할 폴더를 지정하는 파일/share 192.168.111.*(rw,sync) 입력 //리드 라이트, 싱크까지 시킴# mkdir /share# chmod 707 /share/# cp /boot/vmlinuz-3* /share/file1# ls -l /share/# systemctl restart nfs-server //서비스 시작# systemctl enable nfs-server //상시가동# exportfs -v //공개된 폴더 보임# systemctl stop firewalld //방화벽 끄기.. //관련된 것이 많아서 끄는게 낫다. 클라이언트로 NFS 접속(클라이언트로 실행)123456789101112131415# rpm -qa nfs-utils //패키지 설치여부 확인(깔려있다)# showmount -e 192.168.111.100 //서버에서 마운트한 폴더 조회# cd# mkdir myShare# su password 입력# cd /home/centos# mount -t nfs 192.168.111.100:/share myShare //마운트# ls -l myShare# cd myShare/# touch abc# touch bcd 클라이언트가 생성한게 서버에도 있나 확인1# ls -l /share //abc,bcd 파일이 존재한다 윈도우로 접속해보자일반적으로는 NFS는 제공을 안하지만 엔터프라이즈의 경우엔 제공해준다.제어판 - 프로그램 - 기능 사용/사용안함 클릭- nfs용 클라이언트 체크확인재부팅관리자로 cmd를 열자mount 192.168.111.100:/share *내컴퓨터를 누르면 접속 가능 NFS서버의 그래픽 설정도구를 사용해보자1234567페도라20에서 제공하므로 카페에서 다운받자# yum -y install# cd 다운로드# yum -y localinstall system-config-nfs-1.4.2-1.fc20.noarch.rpm# mkdir /share2# system-config-nfs","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"13장. FTP 서버 설치와 운영","slug":"ThisIsLinux36","date":"2017-07-15T02:04:42.000Z","updated":"2018-09-03T05:51:46.152Z","comments":true,"path":"2017/07/15/ThisIsLinux36/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/15/ThisIsLinux36/","excerpt":"","text":"네임서버, 이메일서버, 웹서버 보다는 훨신 간단하다.FTP 는 file transfer protocol의 약자로 파일을 전송하기 위한 서비스. 대용량 파일을 전송 할 때 FTP 서버는 성능이 좋다. ftp서버의 종류는 몇가지가 있는데 CentOS에서는 vsftpd를 제공한다. 페도라, 레드헷 엔터프라이즈 쪽에서 인기가 좋다.proftpd는 주로 대형 사이트에서 오래동안 인기가 많았다.pure-ftpd는 Troll-FTPd를 기반으로 프랭크 데니스가 2001년에 제작함.사실 사용자입장에서는 어떤 ftp이든 관계가 없다. 1.vsftpd실습1.1 vsftpd 설치 및 운영(서버실행)12345678910111213# yum -y install vsftpd //165kb 밖에 안되는데 성능이 좋다!# cd /var/ftp //vsftpd의 홈 디렉토리# ls -l //일반적으로 pub라는 디렉토리에 파일을 넣어놓는다. //우리회사가 A라는 파일을 배포해야하면 일반적으로 pub폴더에 넣음.# cd pub# ls# cp /boot/vmlinuz-3* file1# systemctl restart vsftpd //ftp 시작# systemctl enable vsftpd //상시가동# firewall-config //방화벽 열기영구적탭 . ftp 선택 . 옵션 firewalld다시불러오기 실습1.2 vsftpd 윈도우에서 접속해보자(윈클라이언트실행)알드라이브 설치192.168.111.100 입력포트 21익명로그인 체크연결파일 업로드가 안된다. 이유 : ftp는 기본적으로 다운로드만 가능하다. 아무나 업로드 가능하면 악성코드를 올릴 수 도 있다!하지만 허용할 수 있다. 실습1.3 vsftpd 업로드 가능하게 변경(서버에서 실행)12345678# vi /etc/vsftpd/vsftpd.conf29행 어나니머스가 업로드하는것을 허락한다. 주석해제33행 어나니머스가 디렉토리를 만드는것을 허락한다. 주석해제# chown ftp.ftp /var/ftp/pub //펍 소유주 변경# ls -l# systemctl restart vsftpd //서비스재시작 실습1.4 vsftpd 명령어로 파일을 올리고 받아보자(서버B에서 실행)123456789101112# yum -y install epel-release //레드헷에 접속해서 다운받을수 있도록 설치# yum -y install ncftp# ncftp 192.168.111.100&gt;cd pub&gt;get file1 //file1 다운로드&gt;put anaconda-ks.cfg //아나콘다파일 업로드&gt;ls -l &gt;bye //종료 2.proftpd실습2.1 proftpd 설치(서버실행)1234567891011121314151617# yum -y remove vsftpd //충돌 나니까 제거# yum -y install epel-release //proftpd도 레드헷에 있어서 해줘야함.# yum -y install proftpd //proftpd 설치# vi /etc/proftpd.conf //설정파일 열기:set nu :356 주석처리:425 주석처리 &lt;/IfDefine&gt;:383 DenyAll을 AllowAll로 변경//이제 어나니머스도 접속 가능# systemctl restart proftpd # systemctl enable proftpd 방화벽은 아까 열었으므로 안열어도 된다. 실습2.2 윈클라이언트에서 접속(윈클라이언트 실행)3. pure-ftpd실습3.1 pure-ftpd 설치(서버실행)123456789# yum -y remove proftpd# yum -y install pure-ftpd //레드햇에서 제공한다.# vi /etc/pure-ftpd/pure-ftpd.conf:set nu:77 익명사용자가 허용이 되어있다.:286 yes를 no로 변경# systemctl restart pure-ftpd# systemctl enable pure-ftpd","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"12장. 웹서버 설정파일,APM 컴파일 설치","slug":"ThisIsLinux35","date":"2017-07-14T09:45:57.000Z","updated":"2018-09-03T05:51:37.717Z","comments":true,"path":"2017/07/14/ThisIsLinux35/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/14/ThisIsLinux35/","excerpt":"","text":"x윈도를 통해 httpd.conf파일을 설정해보자httpd.conf는 웹서버 설정파일이다. 책을 통해 이 내용을 알아보자.1234카페에서 system-config-httpd 파일을 받자.# yum -y localinstall system-config-httpd-1.5.5-6.fc20.noarch.rpm# system-config-httpd 소스를 컴파일해서 APM을 설치최적화된 APM을 구성할 수 있는 장점. 아파치 설치12345678910111213141516171819202122232425262728293031323334353637383940# yum -y remove httpd //컴파일 한것을 쓰기위해 깔린것을 지움# yum -y install gcc gcc-c++ //컴파일러 설치# cd 다운로드/# tar xfj pcre* //압축풀기# cd pcre-8.36/# ./configure ; make; make install //세개의 명령어 한꺼번에# cd 다운로드/# tar xfj httpd-2.4.10.tar.bz2# tar xfj apr-1.5.1.tar.bz2# tar xfj apr-util-1.5.4.tar.bz2# mv apr-1.5.1 httpd-2.4.10/srclib/apr //파일이름을 apr로 srclib에저장# mv apr-util-1.5.4 httpd-2.4.10/srclib/apr-util //파일이름을 apr-util로 srclib에 저장# ls httpd-2.4.10/srclib# cd httpd-2.4.10/# ./configure --with-included-apr --with-pcre=/usr/local/bin/pcre-config --prefix=/web/httpd2/ ; make ; make install # vi /etc/ld.so.conf마지막에 다음 두줄 추가/web/httpd2/lib/web/httpd2/modules# ldconfig //방금 추가한 내용 적용# cp /web/httpd2/bin/apachectl /etc/init.d/httpd2 //아파치 시작스크립트 복사# vi /etc/init.d/httpd2맨 아래 다음 두줄 추가# chkconfig: -85 15# description: 아파치 웹서버 입니다.# chkconfig httpd2 on //부팅될때마다 시작되도록# systemctl restart httpd2# systemctl status httpd2localhost로 접속해보자APM 중 아파치 설치 완료! 마리아 db 설치12345678910111213141516171819202122232425262728293031323334353637두번째 마리아 db는 컴파일된 바이너리 코드를 설치하자(카페에서 미리 받아놓자)# cd /root/다운로드# tar xfz mariadb-10.0.15-linux-x86_64.tar.gz# mv mariadb-10.0.15-linux-x86_64 /web/mariadb# groupadd mysql //mysql 그룹 추가# adduser -M -d /web/mariadb -g mysql -s /bin/false -r mysql //실제 사용하지 않는 유저 생성# /web/mariadb/scripts/mysql_install_db --user=mysql --basedir=/web/mariadb --datadir=/web/mariadb/data//마리아 디비 초기화# cp -a /web/mariadb/support-files/my-huge.cnf /etc/my.cnfy# vi /etc/my.cnf29행에 다음 두줄 추가basedir = /web/mariadbdatadir = /web/mariadb/data# cp -a /web/mariadb/support-files/mysql.server /etc/init.d/mariadb //실행스크립트 복사# systemctl restart mariadb# chkconfig mariadb on //상시가동되도록# /web/mariadb/bin/mysqladmin -u root -p password엔터12341234//마리아 디비 관리자 암호 변경# PATH=$PATH:/web/mariadb/bin# mysql -u root -p1234 입력//정상작동하는지 접속 php 설치123456789101112131415161718192021222324252627282930# cd /root/다운로드# yum -y install libxml2-devel openssl-devel libjpeg-devel libpng-devel//관련 패키지 설치# tar xfj php-5.6.4.tar.bz2# cd php-5.6.4# ./configure --with-mysql=/web/mariadb --with-apxs2=/web/httpd2/bin/apxs --with-mysqli=/web/mariadb/bin/mysql_config --with-imap-ssl --disable-debug --with-iconv --with-gd --with-jpeg-dir --with-png-dir --with-libxml-dir --with-openssl ; make ; make install //컴파일 및 설치# ls -l /web/httpd2/modules/libphp5.so//제일 중요한 파일. 이파일을 위해 컴파일을 했다.# vi /web/httpd2/conf/httpd.conf147행에 모듈이 추가 된것을 확인376행에 AddType application/x-httpd-php .php .php3 .php4 .php5 .htm .html .inc아파치 웹서버가 376행의 타입까지 인식을 하도록 만듬# cp php.ini-production /etc/php.ini# systemctl stop httpd2# systemctl start httpd2# systemctl status httpd2# firewall-config영구적 . http 선택 옵션 firewalld 다시불러오기# cd /web/httpd2/htdocs/ //웹서버의 홈폴더# vi phpinfo.php //샘플파일 만들기다음 한줄 추가&lt;?php phpinfo(); ?&gt;http://192.168.111.100/phpinfo.php 접속해보자 과연 이 과정들을 거쳐 만들어진것들이 최고의 성능을 낼까?그것은 확실히 모른다. 현재 패키지들이 잘 만들어져 나오기 때문에 굳이 컴파일을 통해 진행된것들이 훨신 좋은 성능을 얻거나 하지는 않는다.학습차원에서 컴파일을 진행해 보았다. 12장은 활용도가 높으므로 익혀두자","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"12장. 클라우드 서비스 구축","slug":"ThisIsLinux34","date":"2017-07-14T08:04:41.000Z","updated":"2018-09-03T05:51:40.600Z","comments":true,"path":"2017/07/14/ThisIsLinux34/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/14/ThisIsLinux34/","excerpt":"","text":"클라우드 서비스를 구축해봅시다.클라우드 서비스는 서버에 파일이 있고 각각의 PC마다 폴더를 지정하여 동기화가 된다. 즉 웹하드는 업로드 다운로드를 하지만 클라우드는 자동으로 동기화가 되는점이 다르다. 카페에서 관련 서버 두개를 깔자.123456789# cd /root/다운로드# yum -y localinstall owncloud- *# ls -l /var/www/html // owncloud가 깔렸나 확인# systemctl restart httpd //서비스 재시작# firewall-config//영구적 선택 - http,https//방화벽 설정 열기클라이언트에서 192.168.111.100/owncloud 접속admin 1234 입력자세한 사용법은 책을 참고하자!","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"12장. 웹하드 설치와 운영","slug":"ThisIsLinux33","date":"2017-07-14T05:26:47.000Z","updated":"2018-09-03T05:51:30.606Z","comments":true,"path":"2017/07/14/ThisIsLinux33/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/14/ThisIsLinux33/","excerpt":"","text":"웹하드는 웹서버상에서 파일을 저장할 수 있는것. 웹하드에 파일을 저장해 놓으면 전세계 어디서든지 내려받고 수정할 수 있다. 설정하자1234567891011121314151617181920212223# cd /var/www/html# ls -l# mv /root/다운로드/pydio-core-6.0.2.tar.gz / .# tar xfz pydio-core-6.0.2.tar.gz# mv pydio-core-6.0.2 webhard //폴더명 변경# chmod 707 webhard/ //일반사용자가 접근할 수 있게 권한변경# chown -R apache.apache webhard/# ls -l# yum -y --skip-broken install php-* //php관련 패키지 설치 //--skip-broken 설치하다 에러나면 그냥 무시해라# yum -y install php-mcrypt //레드헷 엔터프라이즈에 존재 //지금은 설치 안될것이다.# yum -y install epel-release//레드헷 엔터프라이즈도 yum으로 깔 수 있게됨 # yum -y install php-mcrypt //이젠 설치가 된다.# vi /etc/httpd/conf/httpd.conf151 행 AllowOverride All로 변경# systemctl restart httpd 리눅스 클라이언트에서 접속해보자http://192.168.111.100/webhard/ 접속click here 클릭한국어 하고 start wizardadmin admin 12345678 12345678 global option 클릭default language만 한국어로 변경 configurations storage 클릭하고database system 선택database에 xeDB 입력User에 xeUser 입력Password에 1234 입력Try connecting…. 클릭 add some users 클릭centoscentos@hanbit.co.kr센토스사용자12341234Install pydi 클릭웹브라우져 껏다 켜서http://192.168.111.100/webhard/ 접속 centos1234 후 로그인업로드를 해보자! 업로드 용량 제한을 풀자서버에서 실행하자123456789101112131415161718vi /etc/php.ini //현재는 8m이상 업로드가 안되는데 제한을 풀자.:384 (384라인으로감!)30초가 넘어가면 종료되도록 설정되어있다 300초로 수정하자:6728M를 100M으로 수정:8002M 를 100M으로 수정:wq# cd /var/www/html/webhard/data/cache/ //캐쉬로 인해 제대로 작동하지 않을 수 있으므로 캐쉬를 지우자 //지금 캐쉬폴더가 없는데 실행을 안해서 그런가..?# rm -f plugin*# systemctl restart httpd 업로드를 다시 해보자리눅스 클라이언트에서.. 1","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"12장. APM 개념과 설치, XE 설치와 운영","slug":"ThisIsLinux32","date":"2017-07-14T02:14:09.000Z","updated":"2018-09-03T05:51:33.665Z","comments":true,"path":"2017/07/14/ThisIsLinux32/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/14/ThisIsLinux32/","excerpt":"","text":"리눅스에서 가장 많이 활용하는것중 하나가 웹서버이다.APM = Apache 웹서버 + 프로그래밍언어 PHP + 데이터베이스 MaraiaDB리눅스 환경에서 사용될 경우 LAPM(Linux Apache,PHP,MariaDB)라고도 부름.APM 이라는 소프트웨어는 존재하지 않으며 이 3가지가 서로 잘 연동되어 운영되도록 만든 환경을 APM이라 함 APM 설치설치를 해보자서버에서 진행12345# rpm -qa httpd php mariadb-serverhttpd만 깔려있으므로 나머지를 깔자# yum -y install mariadb-server mariadb php php-mysqlnd# rpm -qa httpd php mariadb-server //깔린버전 확인해보자# yum -y install php-gd 가동해보자12345678910111213# systemctl restart httpd# systemctl restart mariadb# systemctl restart php // php는 서비스가 아니라 httpd에 포함되는 기능이라 시작이 안된다.# systemctl enable httpd //상시가동# systemctl enable mariadb # firewall-config영구적 선택 - http,httpsmysql은 안열어도 됨. 어차피 안에서만 접근하고외부에서 접근하지 않을것이므로 옵션- 다시불러오기 접속해보자파이어폭스 키고 localhost php 하나를 만들어보자12345678# cd /var/www/html# pwd# ls# touch phpinfo.php# vi phpinfo.php아래 한줄 입력&lt;?php phpinfo(); ?&gt; 파이어 폭스 켜고 http://localhost/phpinfo.php 접속해보자 mariadb 확인해보자1# mysql XE 설치123456789101112# vi /etc/httpd/conf/httpd.conf //XE 외부에서 접근 가능하게:set number151 none 를 All로 변경# systemctl restart httpd# cd /var/www/html# mv /root/다운로드/xe.zip .# unzip xe*# chmod 707 xe //권한 변경# cd /var/www/html/xe/modules/# ls //board는 게시판임 XE 실습123456# mysql&gt;GRANT ALL PRIVILEGES ON xeDB.* TO xeUser@localhost IDENTIFIED BY &apos;1234&apos;;&gt;exit# mysql -u xeUser -p1234&gt; CREATE DATABASE xeDB; XE 설정외부에서 해도되고 내부에서 해도된다. 즉 관계 없다.윈 클라이언트로 하자.192.168.111.100/xe 접속한국어 . 다음동의. 다음다음mysql 선택 다음xeUser /1234 /xeDB 다음kora선택 다음aa@aa.com / 4321 /4321 관리자임. / admin 게시판 추가는 책을보자","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"11장. 쇼핑몰 데이터베이스 구축, Oracle 설치, Oracle에서 쇼핑몰 DB 구축","slug":"ThisIsLinux31","date":"2017-07-13T09:09:57.000Z","updated":"2018-09-03T05:51:27.835Z","comments":true,"path":"2017/07/13/ThisIsLinux31/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/13/ThisIsLinux31/","excerpt":"","text":"서버에서 실행해도 되고 윈 클라이언트에서 해도된다. 그러나 윈 클라이언트에서 해보자 윈도우에서 실행cmd 열기cd “c:\\Program Files (x86)”cd “MariaDB 10.0”cd MariaDB 10.0cd bin mysql -h 192.168.111.100 -u winuser -p4321 입력쿼리문은 책을 참조하자….. 오라클을 설치해보자서버에서 실행하자 카페에서 링크타고 오라클을 들어가서 깔자123456789101112131415161718192021222324252627# cd 다운로드/# ls -l# unzip oracle* //압축을 풀자# ls -l Disk1/# cd Disk1/오라클을 설치하기 위해서는 가상메모리 2기가가 필요함.그래서 추가적으로 2기가를 추가한다.# dd if=/dev/zero of=/swapfile bs=1024 count=4194304# mkswap /swapfile //스왑메모리로 만들자# swapon /swapfile //스왑을 키자# swapon -s //스왑 확인 총 (6기가 임을 확인)스왑을 껏다 켜도 유지되도록 하자# cd /etc/rc.d # chmod 755 rc.local# vi rc.local맨 밑에swapon /swapfile 추가# reboot# swapon -s //스왑 확인 총 (6기가 임을 확인)오라클을 본격적으로 설치하자# cd 다운로드/Disk1/# pwd# ls -l# yum -y localinstall oracle* 오라클을 설정하자123456# service oracle-xe configure엔터(8080은 외부로 접속하는 포트)엔터(1521은 sql+로 접속하는 포트)1234엔터1234엔터y 엔터(자동으로 실행할꺼냐) 오라클 서비스를 시작하자123456789101112131415# /etc/init.d/oracle-xe start //오라클 시작# vi /etc/bashrc //맨아래 다음을 입력.# . /u01/app//oracle/product/11.2.0/xe/bin/oracle_env.sh //오라클 환경설정하는 스크립트 실행하는것. //껏다켜면 이 한줄을 입력해야 하지만 //그 과정을 없애기 위해 /etc/bashrc에 추가# firewall-config영구적 선택.포트 탭 선택추가 8080 tcp추가 1521 tcp(오라클을 센토스에서 만든것이 아니라 등록이 되어있지 않다.)옵션 - Firewalld 다시불러오기 오라클에 접속해보자웹브라우저 실행192.168.111.100:8080/apexinternaladmin1234로그인123412341234applyreturn1234 로그인 마리아db에서 입력한 쿼리문을 오라클에서 실행해보자.123456# mkdir /oradata //데이터베이스가 생성될 디렉토리# chmod 777 /oradata# sqlplus //오라클에서 데이터베이스 시작system 입력 //오라클에서 가장 높은 관리자는 system1234 입력책보고 쿼리 입력","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"11장. MariaDB 설치/운영 , Windows에서 접속","slug":"ThisIsLinux30","date":"2017-07-12T09:21:35.000Z","updated":"2018-09-03T05:51:25.577Z","comments":true,"path":"2017/07/12/ThisIsLinux30/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/12/ThisIsLinux30/","excerpt":"","text":"마리아 DB 운영DBMS 설치12345678910111213141516171819카페에 올려놓은 마리아 db를 세개 다 받자.# yum -y remove mariadb-libs // 버전이 달라 새로 설치하면 충돌우려..# yum -y localinstall Maria*# systemctl restart mysql //mysql이 오라클로 들어가자 //개발자들이 마리아를 만들어냄.. # systemctl status mysql# checkconfig mysql on // systemctl enable mysql 과 동일 //상시가동하도록 설정# firewall-config //방화벽 열기영구적 탭 -&gt; 다시불러오기# mysql // 마리아디비 실행&gt; showdatabases; //그냥 확인차원칙은# mysql -u root -p 라고 입력 후 비번입력해야함지금은 비번을 설정 하지 않았으므로 엔터만 누르면 된다. 마리아 디비 암호 설정123456# mysqladmin -u root password &apos;1234&apos;마리아 디비 사용자인 root는 비번이 1234# mysql -u root -p //로그인1234 입력&gt;exit 윈도우 클라이언트에서 마리아DB 접속카페 접속해서 마리아디비 설치리눅스는 서버 클라이언트 따로지만 윈도우용은 하나다.다른건 설치하지 말고 클라이언트만 설치하자 서버에서 실행1234567# mysql -u root -p&gt; USE mysql&gt;SELECT user,host FROM user WHERE user NOT LIKE &apos;&apos;;루트 사용자는 외부에서 접속할 수 없다는 것을 확인.&gt;GRANT ALL PRIVILEGES ON *.* TO winuser@&apos;192.168.111.%&apos; IDENTIFIED BY &apos;4321&apos;; //192.168.111.XXX 는 허용하겠다.(윈도우 유저의 아이피의 마지막이 변동가능성이 있기 때문에 %로 처리) 윈도우에서 실행cmd 열기cd “c:\\Program Files (x86)”cd “MariaDB 10.0”cd MariaDB 10.0cd bin mysql -h 192.168.111.100 -u winuser -p4321 입력show databases;","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"10장. 웹 메일의 설치 및 사용","slug":"ThisIsLinux29","date":"2017-07-11T18:40:05.000Z","updated":"2018-09-03T05:51:23.317Z","comments":true,"path":"2017/07/12/ThisIsLinux29/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/12/ThisIsLinux29/","excerpt":"","text":"웹 메일의 설치 및 사용10장의 지금까지의 구현내용은 문제가 있다. 일반사용자는 POP3, SMTP 등에 대한 설정하는것에 대한 지식이 없으며 원하지도 않는다.즉. 이메일 서버를 구축하려면 웹 메일까지 설정을 해주어야 한다.우리는 이를 위해 다람쥐 메일이라고 불리는 squirrelmail을 사용한다. 다람쥐 메일 설치(서버)센토스에서 다람쥐는 제공하지 않으므로 페도라것을 사용해야한다. (페도라의 거의 모든 패키지는 센토스에서 돌아간다.)1234567891011121314151617181920212223242526272829303132333435363738394041# wget http://download.hanbit.co.kr/centos/7/squirrelmail-1.4.22-13.fc20.noarch.rpm# yum -y localinstall squi* //로컬설치# chown apache.apache -R /usr/share/squirrelmail/ //웹사용자인 아파치로 소유주 변경# chown apache.apache -R /var/lib/squirrelmail/# chown apache.apache -R /var/spool/squirrelmail/# chown apache.apache /etc/squirrelmail/config.php# /usr/share/squirrelmail/config/conf.pl //설정할 수 있는 실행파일2입력1 (도메인 변경)naver.comA4mail.naver.com8othersr101ko_KR2euc-krsrsq간단하게 다람쥐 메일을 들어올 수 있게 설정# vi /etc/httpd/conf/httpd.conf 맨위에 다음 한줄 추가Alias /webmail/ /usr/share/squirrelmail/# systemctl restart httpd # systemctl enable httpd 포트를 추가해야하는데 방화벽을 아까 꺼놨기 때문에 따로 하지 않겠다.웹을 www로 들어가기 떄문에 웹주소도 네임서버에 추가# vi /var/named/naver.com.db 맨뒤에 다음 한줄 추가www IN A 192.168.111.100# systemctl restart named 클라이언트에서 테스트 해보자파이어폭스에서 www.naver.com/webmail/ 입력맨아래 예외 추가 -&gt; 보안예외 확인lee / lee 입력편지쓰기-&gt; kim@daum.net -&gt;전송윈도우 클라이언트에서 받기를 눌러보자, 그 후 답장을 눌러 보내보자","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"10장. 센드메일 서버의 구현","slug":"ThisIsLinux28","date":"2017-07-11T08:30:49.000Z","updated":"2018-09-03T05:51:19.504Z","comments":true,"path":"2017/07/11/ThisIsLinux28/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/11/ThisIsLinux28/","excerpt":"","text":"네임서버를 만들었으니 이메일을 보내는 메일서버를 만들어 보자. 1.서버 메일서버를 만들자(naver)1.1 서버에서 메일 서버를 만들자(서버에서 진행)123456789101112131415161718192021222324252627282930313233# yum -y install sendmail-cf dovecot //sendmail-cf 보내는메일서버 //devoct 받는 메일서버# vi /etc/mail/sendmail.cf :set number85를 Cwnaver.com 으로 수정264 Addr=127.0.0.1 를 지운다저장외부 호스트가 메일을 전달할 수 있도록 허가# vi /etc/mail/access 다음을 추가naver.com RELAYdaum.net RELAY192.168.111 RELAY# makemap hash /etc/mail/access &lt; /etc/mail/access //변경내용 적용사용자의 메일박스에서 메일을 꺼내 사용자에게 전달하는 도베캇 설정# vi /etc/dovecot/dovecot.conf:set number24행 30행 33행 주석제거저장# vi /etc/dovecot/conf.d/10-ssl.conf:set number8행 ssl=yes로 수정저장# vi /etc/dovecot/conf.d/10-mail.conf:set number25행 주석제거119행 mail_access_groups =mail 으로 수정159행 주석제거저장 1.2 서버에 사용자를 만들자(서버에서 진행)1234# adduser lee# passwd lee암호 lee 이 사용자는 lee@naver.com 1.3 서비스를 시작하자(서버에서 진행)12345# systemctl restart sendmail# systemctl enable sendmail# systemctl restart dovecot# systemctl enable dovecot 1.4 서버에서 만든 메일서버가 잘 작동하나 확인해보자(클라이언트에서 진행)이를 위해 클라이언트에서 메일을 보낸다.(클라이언트에서 실행)12345678910111213141516171819202122232425262728293031323334# su# vi /etc/resolv.confnameserver 192.168.111.100# yum -y install evolution //이메일 클라이언트 프로그램프로그램-&gt;오피스-&gt;에볼루션계속-&gt;계속 전체이름: 이네이버전자메일 주소: lee@naver.com계속서버종류 pop선택서버: mail.naver.com사용자이름: lee포트: 995암호화방식: SSL특정방식사용계속계속서버 mail.naver.com계속이름 : 네이버 메일계속적용계속 허용 //꼭 해야한다.암호: lee로그인 암호:centos새로만들기받는사람 lee@naver.com새로만들기를 눌러 lee@naver.com으로 메일을 하나 보내보자. 그러면 보낸편지함에 하나 들어있고 메일박스로 들어가있는상태. 그 후 보내기/받기를 누르면 받은편지함에 메일이 하나 생성된다. 2.서버B 메일서버를 만들자(daum)2.1 서버B에 메일 서버를 만들자(서버B에서 진행)123456789101112131415161718192021222324252627282930313233# yum -y install sendmail-cf dovecot //sendmail-cf 보내는메일서버 //devoct 받는 메일서버# vi /etc/mail/sendmail.cf :set number85를 Cwdaum.net 으로 수정264 Addr=127.0.0.1 를 지운다저장외부 호스트가 메일을 전달할 수 있도록 허가# vi /etc/mail/access 다음을 추가naver.com RELAYdaum.net RELAY192.168.111 RELAY# makemap hash /etc/mail/access &lt; /etc/mail/access //변경내용 적용사용자의 메일박스에서 메일을 꺼내 사용자에게 전달하는 도베캇 설정# vi /etc/dovecot/dovecot.conf:set number24행 30행 33행 주석제거저장# vi /etc/dovecot/conf.d/10-ssl.conf:set number8행 ssl=yes로 수정저장# vi /etc/dovecot/conf.d/10-mail.conf:set number25행 주석제거119행 mail_access_groups =mail 으로 수정159행 주석제거저장 2.2 서버B에 사용자를 만들자(서버B에서 진행)1234# adduser kim# passwd kim암호 kim 이 사용자는 kim@daum.net 2.3 서비스를 시작하자(서버B에서 진행)12345678# systemctl restart sendmail# systemctl enable sendmail# systemctl restart dovecot# systemctl enable dovecot# systemctl stop firewalld //방화벽 끄기# systemctl disable firewalld //방화벽 끄기 3. 최종테스트를 해보자3.1 윈도우 클라이언트에서 해보자썬더버드를 받자. 이때 네이버에 접속되지 않는데 아까 도메인 서버를 100으로 세팅해놔서 그렇다..이름 : 김다음메일주소 : kim@daum.net암호 : kimPOP3 선택하고 완료lee@naver.com 으로 메일을 보내보자클라이언트로 돌아와 보내기/받기를 눌러보자 그 후 회신을 눌러보자그 후 윈도우 클라이언트로 와서 받기를 눌러보자.","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"10장. 메일서버 개념, 메일서버를 위한 네임서버 구현","slug":"ThisIsLinux27","date":"2017-07-10T15:56:35.000Z","updated":"2018-09-03T05:51:16.962Z","comments":true,"path":"2017/07/11/ThisIsLinux27/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/11/ThisIsLinux27/","excerpt":"","text":"메일서버네임서버에 대한이해가 필수적이므로 이해하고 넘어올것.E-mail의 송수신에서 사용되는 프로토콜 다음, 네이버의 메일서버 계정을 갖고있다면 kim@daum.net / lee.naver.com 가 있다. kim@daum.net -&gt; lee.naver.com 메일전송smtp를 통해 kim 메일서버의 큐에 들어가고 여유가 있을 때 smtp 프로토콜을 이용해 lee의 메일서버로 보내놓는다. 메일서버는 메일 박스에 넣어놓고 lee는 pop3 imap프로토콜을 써서 자신의 컴퓨터로 확인한다.보내는 프로토콜 : smtp받는 프로토콜 : POP3 IMAP 실습계획Server : naver 메일서버, 네임서버 역할을 한다.Server(B) : daum 메일 서버WinClient : 메일 클라이언트Client : 메일 클라이언트 1. 메일서버를 구현하기 전에 네임서버를 구현하자1.1 다음을 서버에서 실행하자123456789101112131415# vi /etc/hostname 첫줄 지우고 mail.naver.com 입력# vi /etc/hosts 맨 뒤에 다음 입력 192.168.111.100 mail.naver.com# yum -y install sendmail //메일서버를 구현하려면 sendmail이 설치되어 있어야함# vi /etc/mail/local-host-names 아래 mail.naver.com 입력# vi /etc/sysconfig/network HOSTNAME=mail.naver.com 입력# reboot 1.2 다음을 서버 B에서 실행하자12345678910111213141516# yum -y install sendmail# vi /etc/hostname 첫줄 지우고 mail.daum.net 입력# vi /etc/hosts 맨 뒤에 다음 입력 192.168.111.200 mail.daum.net# vi /etc/mail/local-host-names 아래 mail.daum.net 입력# vi /etc/sysconfig/network HOSTNAME=mail.daum.net 입력# reboot 1.3 서버를 마스터네임 서버로 만들자 (서버에서 실행하자)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# yum -y install bind bind-chroot# vi /etc/named.conf:set number11행 127.0.0.1 지우고 any로12행 ::1 지우고 none로17행 localhost 지우고 any로여기까지만 하면 캐싱전용 네임서버이다.우리가 만들것은 마스터 네임서버이므로 맨아래 다음을 추가zone &quot;naver.com&quot; IN &#123; type master; file &quot;naver.com.db&quot;; allow-update &#123; none; &#125;;&#125;;zone 위에 커서 올리고 5yy 누르고 p(5줄 복사)zone &quot;daum.net&quot; IN &#123; type master; file &quot;daum.net.db&quot;; allow-update &#123; none; &#125;;&#125;;저장 후 종료# cd /var/named# touch naver.com.db# vi naver.com.db$TTL 3H@ SOA @ root. ( 2 1D 1H 1W 1H ) IN NS @ IN A 192.168.111.100 IN MX 10 mail.naver.com. //달라진부분; mail exchange 메일이 오면 mail.naver.com한테 메일처리를 하게해라mail IN A 192.168.111.100# cp naver.com.db daum.net.db //내용이 비슷하니까 복붙# vi daum.net.db$TTL 3H@ SOA @ root. ( 2 1D 1H 1W 1H ) IN NS @ IN A 192.168.111.200 IN MX 10 mail.daum.net.mail IN A 192.168.111.200으로 수정# named-checkconf //name.conf파일을 확인 //아무메세지가 없으면 문법문제 없음# named-checkzone naver.com naver.com.db# named-checkzone daum.net daum.net.db포트는 여러개 열어야 하는데 복잡하므로 아얘포트문제는 생기지 않도록 다 열어놓자. 즉 방화벽을 꺼놓자.# systemctl stop firewalld //방화벽 끄기# systemctl disable firewalld //재부팅해도 꺼지도록# systemctl restart named //네임서버 시작# systemctl enable named //재부팅해도 켜지도록# systemctl status named //잘 돌고있는지 확인# nslookup //실제 내부에서 잘동작하는지 확인&gt;server 192.168.111.100&gt;mail.naver.comAddress: 192.168.111.100 //성공&gt;mail.daum.netAddress: 192.168.111.200 //성공 2.각 컴퓨터의 로컬네임 서버를 생성한 네임서버로 지정하자2.1 서버의 네임서버를 지정123456# cd /etc/sysconfig/network-scripts/# ls //수정할 파일을 확인하자 ens....# # vi ifcfg-ens32 // 껏다 켜도 유지되도록 설정DNS1=192.168.111.100 으로 하자# systemctl restart network# cat /etc/resolv.conf //확인 서버 B의 네임서버를 지정123456# cd /etc/sysconfig/network-scripts/# ls //수정할 파일을 확인하자 ens....# # vi ifcfg-ens32 // 껏다 켜도 유지되도록 설정DNS1=192.168.111.100 으로 하자# systemctl restart network# cat /etc/resolv.conf //확인 2.2 클라이언트의 네임서버 지정클라이언트는 고정ip가 아니기 때문에 껏다 켜면 vmware가 제공하는 2번으로 바뀌기 때문에 클라이언트는 껏다 켜지 않겠다. 그러므로 conf파일만 수정하자123456789101112$ su -# vi /etc/resolv.confnameserver 192.168.111.100으로 수정# exit# nslookup&gt; mail.daum.netAddress: 192.168.111.200 //확인&gt; mail.naver.comAddress: 192.168.111.100 //확인 2.3 윈도우 클라이언트 설정12345678cmd 열기ipconfig //이더넷 어댑터 로컬 영역 연결netsh interface ip set dns &quot;로컬 영역 연결&quot; static 192.168.111.100ping mail.daum.net 1#","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"9장. 마스터 네임서버 구축, 라운드 로빈 방식 네임서버","slug":"ThisIsLinux26","date":"2017-07-09T05:49:08.000Z","updated":"2018-09-03T05:51:14.691Z","comments":true,"path":"2017/07/09/ThisIsLinux26/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/09/ThisIsLinux26/","excerpt":"","text":"앞에한건 캐싱전용이었다.캐싱전용네임서버 - 자기가 관리하는건 없고 무조건 밖에 나가서 알아다가 알려줌. 마스터 네임 서버 - 자기가 관리하는 것들이 있다. 마스터 네임 서버 구축1. 웹서버 하나 간단하게 만들자(서버)1234567# rpm -qa httpd //설치가 되어있다.# systemctl status httpd //시작되어있나 확인# systemctl restart httpd //시작# firewall-config영구적 - http 체크 - firewalld 다시불러오기# vi /var/www/html/index.html&lt;h1&gt; CentOS 7 홈피 입니다&lt;/h1&gt; //삽입 2. ftp서버 간단하게 만들자(서버B)서버 B를 켠다.123# yum -y install vsftpd# firewall-cmd --permanent --add-service=ftp //방화벽설정# firewall-cmd --reload 3. 환경설정을 해주자(서버)서버에서12345678910# vi /etc/named.conf:set number맨아래 가서zone &quot;centos.com&quot; IN &#123;type master; file &quot;centos.com.db&quot;; allow-update&#123;none;&#125;;&#125;;입력. 이 의미는 서버컴퓨터는 centos.com의 마스터 네임서버다. 그리고 상세정보는 centos.com.db(임의로 지은것)에 들어있다.# named-checkconf //방금작성한것 문법적으로 잘못된것 없나 확인 4. centos.com.db를 만들자(서버)123456789101112131415161718192021# cd /var/named# pwd# ls# touch centos.com.db# vi centos.com.db아래 추가$TTL 3H@ SOA @ root. (2 1D 1H 1W 1H) IN NS @ IN A 192.168.111.100www IN A 192.168.111.100ftp IN A 192.168.111.200위 세줄은 항상 써주는것.네번째는 자기 자신의 ip 입력나머지 아래 두줄은 알려줄것.# named-checkzone centos.com centos.com.db //오류있는지 확인# systemctl restart named방화벽 설정은 앞에서 해줬으니 안해도됨 5. 접속 테스트해보자클라이언트 켜자12345$ su -$ vi /etc/resolv.conf맨 아래 192.168.111.100 으로 수정www.centos.com 접속해보자ftp 접속해보자서버 B에서 다음을 실행하자(ftp서비스 시작)12# systemctl restart vsftpd# systemctl status vsftpd클라이언트에서 접속해보자123# ftp ftp.centos.com // anonymous //엔터 라운드 로빈 방식의 네임 서버이전에 실습한 방식은 여러명이 동시에 접속할 경우 서버 하나에 부하가 걸린다. 그래서 웹 서버를 여러개 만들어서 요청이 들어올 때마다 번갈아가면서 요청처리. 네이버가 이 방식을 쓴다.123# nslookupwww.naver.com두개가 넘어온다. 실습.www.john.com 으로 접속 했을 때 각각 다른 페이지를 뿌려주는실습.(라운드로빈 방식 확인가능) 1234# nslookup&gt; www.yes24.com //아이피 주소를 확인하기위해&gt; www.danawa.com //아이피 주소를 확인하기위해&gt; www.nate.com //아이피 주소를 확인하기위해 1234567891011121314151617# cd /var/named# vi centos.com.db아래 두줄 지우고 다음으로 대체www IN CNAME webserver.centos.com.webserver 100 IN A 61.111.13.51 200 IN A 119.205.194.11 300 IN A 120.50.131.112순차적으로 주소를 알려준다. 100,200,300 은 순차번호이다.# systemctl restart named# nslookup&gt;server 192.168.111.100&gt;www.centos.com결과가 세개가 온다. 클라이언트에서 접속해보자123# vi /etc/resolv.conf//192.168.111.100 이 맞나 확인//아니면 설정하기 웹 브라우져 닫고www.centos.com 들어가보자(여러번)","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"9장. 도메인 이름 체계 개념, 캐싱 전용 네임서버 구축","slug":"ThisIsLinux25","date":"2017-07-09T01:29:00.000Z","updated":"2018-09-03T05:51:12.346Z","comments":true,"path":"2017/07/09/ThisIsLinux25/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/09/ThisIsLinux25/","excerpt":"","text":"초창기 인터넷에서는 1대의 네임 서버만으로 충분히 IP주소와 이름의 관리가 가능했다. 하지만 인터넷이 확장되면서 그것이 도메인 이름 체계가 고안되었다. 원칙은 www.nate.com. 이다. 맨 뒤에 .을 붙여줘야 한다. 로컬 네임서버가 작동하는 순서www.nate.com. 접속과정1./etc/hosts 를 보고 없으면 /etc/resolv.conf 에 있는 로컬 네임서버를 참고한다.2.하지만 이 로컬네임서버도 많은것을 알지 못하므로 얘도 루트 네임서버한테 물어본다. 이렇게. “내가지금 www.nate.com으로 가려한다.”3.그러면 루트네임서버가 “그건 내가 모르지만 내가 관리하는 com의 네임서버 ip를 줄게”4.그러면 로컬네임서버는 다시 com네임서버에게 다시 물어본다5.그러면 com네임서버가 nate ip를 알려준다. 그러면 nate.com아이피는 www의 ip를 응답해준다. www.daum.net. 접속과정루트네임서버 -&gt; net 네임서버 -&gt;daum네임서버 -&gt;www네임서버 이제 우리가 할 실습!/etc/resolv.conf 에 있는 로컬네임서버를 만드는것.서버컴퓨터 : 캐싱전용 네임서버 (PC에서 URL로 IP주소를 얻고자 할 때 해당하는 URL의 IP주소를 알려주는 네임 서버를 말함) 클라이언트,서버B 에서 /etc/resolv.conf의 주소를 서버컴퓨터로 한다. 서버 설정1. 관련 패키지 설치1# yum -y install bind bind-chroot 2. 누가 서버컴퓨터로 물어보든 응답해주게 설정123456# vi /etc/named.conf //캐싱정보관련 설정파일:set number11행 보면 127.0.0.1 지우고 any로 변경 //누가 서비스를 요청하던 제공하겠다12행 ::1 지우고 none로 변경17행 localhost any로 변경named.conf 파일을 수정함으로서 누가 서버컴퓨터가 누가물어보든 응답을 해준다. 3. 서비스 재시작 및 환경설정123456789101112# systemctl restart named //네임서버의 서비스 이름은 named# systemctl status named //작동여부 확인disable 가 있다는건 껏다켜도 동작하지 않는다는것.# systemctl enable named //껏다켜도 작동하도록 설정# firewall-config영구적 선택 -&gt; dns 선택-&gt; 옵션/firewalld다시불러오기# nslookup //내부적으로 잘돌아가는지 테스트&gt;server 192.168.111.100&gt;www.daum.net&gt;exit 클라이언트 설정Client 켜고 실행123456# su -c &apos;vi /etc/resolv.conf&apos;password 입력192.168.111.100 으로 수정파이어폭스로 아무데나 접속해보자 Server B 켜고 실행123456789# vi /etc/resolv.confpassword 입력192.168.111.100 으로 수정# ping -c 3 www.yahoo.com# yum -y install elinks //텍스트모드의 웹브라우져# elinks //실행 윈도우에서 설정제어판 열기네트워크 상태 및 작업보기로컬영역 연결 클릭속성IPv4 속성다음 dns 서버 주소 사용기본 설정 DNS 서버에 192.168.111.100 입력 윈도우에서 원래대로 돌리기cmd 열고ipconfig 입력이더넷 어댑터 뒤에있는 글자 복사. netsh interface ip set dns “로컬 영역 연결” dhcp//로컬 영역 연결은 (이더넷 어댑터 뒤에있는 글자)","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"9장. 네임서버 개념, IP주소 획득 흐름","slug":"ThisIsLinux24","date":"2017-07-09T00:07:45.000Z","updated":"2018-09-03T05:51:10.168Z","comments":true,"path":"2017/07/09/ThisIsLinux24/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/09/ThisIsLinux24/","excerpt":"","text":"네임서배 개요네임서버=DNS(Domain Name System)서버도메인 이름을 IP주소로 변환시켜 주는 역할 = 이름해석12345678910# nslookup //컴퓨터에 연결된 네임서버를 조회&gt; server //도메인 이름을 칠 때 물어보는 주소 조회Default server: 192.168.111.2Address: 192.168.111.2#53&gt; www.nate.comServer: 192.168.111.2Address: 192.168.111.2#53exit 네임서버의 위치를 저장해 놓는곳은?123# cat /etc/resolv.confGenerated by NetworkManagernameserver 192.168.111.2 실습123456789101112131415# vi /etc/resolv.conf#을 넣어 두줄 다 주석처리.저장 후 종료www.nate.com 접속되지 않음# vi /etc/hosts211.234.241.205 www.nate.com 추가저장 후 종료www.nate.com 접속 가능네임서버가 죽어있는데 열린다. /etc/hosts에 먼저 접근 후resolv.conf파일에 접근한다.즉 수첩에 전화번호가 적혀있으면 114에 전화하지 않는것. nate.com 접속방식웹브라우저에서 www.nate.com을 치면 /etc/hosts에 접근하여 해당 ip가 있는지 확인을 한다. 존재 할 경우 그 ip로 접속하고 존재하지 않을 경우 /etc/resolv.conf 로 가서 네임서버를 확인하고 해당 ip주소를 알아온다.","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"8장. SSH서버, VNC서버","slug":"ThisIsLinux23","date":"2017-07-08T09:16:00.000Z","updated":"2018-09-03T05:51:07.639Z","comments":true,"path":"2017/07/08/ThisIsLinux23/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/08/ThisIsLinux23/","excerpt":"","text":"SSH서버텔넷과 용도는 동일하지만 보안이 강화되어있음명령문을 입력 시 암호화 되어서 날라간다. SSH서버를 쓰는것이 권장사항이다. CentOS에서 쓰는 SSH서느는 openSSH 서버라 함. 실습1.서버가 설치되었는지 확인12# rpm -qa | grep openssh설치되어있다. 2.가동되고 있는지 확인12345# systemctl status sshdLoaded: loaded (/usr/lib/systemd/system/sshd.service; enabled) //enable는 상시가동이라는 뜻Active: active (running) since 토 2017-07-08 17:43:06 KST; 1h 5min ago //돌고 있다.즉 ssh는 기본적으로 centos에서 깔려있고 가동되어 있다.기본적으로 쓰인다!!! 3.방화벽 열렸는지 여부 확인12# firewall-config쭉 내리면 ssh가 켜져있다. 4.새로운 리눅스(Client)에서 접속해보자클라이언트 켜자.1234# rpm -qa | grep openssh //깔려있나확인# ssh teluser@192.168.111.100 //telnet와 접속방법이 다름# ifconfig //서버컴퓨터의 아이피 확인 5.윈도우에서 접속해보자Putty 설치192.168.111.100 접속참고로 ssh는 포트 22 telnet는 23한글이 깨지면 오른쪽 누르고 유니코드로 전환abc.txt를 하나 만들고 gedit abc.txt를 실행하면 되질 않는다.왜냐하면 텔넷,SSH는 텍스트 모드로만 전송이 되기 때문에.즉 그래픽 명령어는 아얘 쓸 수 없다. 그럼 telnet ssh 다른점이 없는건가?그렇다. 기능은 같으나 ssh가 보안이 추가된 것이다. VNC 서버X 윈도우 환경으로 원격접속을 사용하고 싶을 때.telnet ,ssh 보다 많이 느리다. 그래픽이 왔다갔다하기 때문에! 1.VNC 설치 및 설정123# rpm -qa | grep tiger //설치유무 확인//미니멈 버전이 깔려있다. 다시깔자# yum -y install tigervnc-server VNC는 사용자한테 너 접속해, 너 화면번호 몇번 써 를 지정해야한다. 2.센토스 사용자 너 1번화면으로 접속해를 설정123456# cp /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@:1.service//1번화면을 쓰기위한 작업# vi /etc/systemd/system/vncserver@\\:1.service :set number40행,41행 의 &lt;USER&gt;을 지워버리고 centos로 고침 그리고 저장 후 종료 3.방화벽 열기1# firewall-config 설정에서 영구적 선택쭉 내려서 vnc-server체크옵션에서 firewalld 다시불러오기 클릭 4.centos사용자가 1번화면으로 들어올 때 전용 비밀번호를 생성즉 vnc 전용 비밀번호 생성123# su - centos# vncserver암호는 123456으로 설정 5.접속해보자리눅스 클라이언트에서 접속12345# rpm -qa | grep tiger //깔려있지 않은것을 확인# su -c &apos;yum -y install tigervnc&apos; //루트 권한으로 실행하는것.# vncviewer 192.168.111.100:1 //1은 디스플레이 번호 password 입력윈도우 클라이언트에서 접속카페이서 tigervnc 설치파일 깔기옵션해서 해상도를 낮추면 사용할만 함(color level)tigervnc vncviewer을 켜고192.168.111.100:1 입력하고 암호 123456","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"8장. 텔넷서버","slug":"ThisIsLinux22","date":"2017-07-08T08:32:45.000Z","updated":"2018-09-03T05:51:04.785Z","comments":true,"path":"2017/07/08/ThisIsLinux22/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/08/ThisIsLinux22/","excerpt":"","text":"이번장은 상당히 중요하다. 앞으로의 모든 장은 네트워크 서버를 구축하는데 8장이 첫 구축이다. 그러므로 8장을 잘 이해하면 큰 흐름을 이해 할 수 있다. 텔넷서버오랫동안 전통적으로 사용되어 온 원격 접속 방법이다.텔넷 서버에 접속하려면 텔넷 클라이언트를 쓰면 된다. 각 서버마다 해당되는 클라이언트가 존재한다. 텔넷 서버 구축 단계1.텔넷 서버 설치2.텔넷 서비스 시작3.텔넷 전용 사용자 생성4.방화벽 설정(포트 열기)5.텔넷 서비스 상시가동6.클라이언트에서 접속 실습모든 가상머신을 초기화하자! 1.텔넷 서버 설치12# rpm -qa | grep telnet //텔넷이 설치되었나 확인# yum -y install telnet-server //설치되어있지 않아 설치 2.텔넷 서버 서비스 시작12345# systemctl restart telnet.socket //restart는 시작이 안되어있으면 새로 시작하고 시작되어있으면 재시작함.# systemctl status telnet.socket //가동여부 확인 3.텔넷 전용 사용자 생성12# adduser teluser# passwd teluser //1234로 설정 4.방화벽 설정(포트 열기)외부에서 접속이 가능하기 위해서 여는 것이므로 일단 내부에서 잘 접속이 되는지 확인 후 에 방화벽을 열자1234567891011# yum -y install telnet //텔넷 클라이언트 프로그램 설치# telnet 127.0.0.1 //자기 자신으로 접속 teluser / 1234 입력# exit //종료 이제 방화벽 설정하자# firewall-config //설정차을 띄우자 설정 영구적 탭 선택 //서버는 한번 쓰는게 아니라 영원히 쓰기 때문에. 영역 탭의 public 선택 후 서비스에서 telnet 체크 옵션-&gt;Firewall 다시불러오기 이제 포트가 열렸다. 5.텔넷 서비스 상시가동포트가 열렸지만 컴퓨터가 껏다 켜면 제대로 작동안하기 때문에 다음을 입력1# systemctl enable telnet.socket //껏다 켜도 유지됨 6.클라이언트에서 접속이제 윈 클라이언트를 부팅하고 접속해보자.접속을 위해서는 서버의 IP주소가 필요하다. 서버에서 다음을 입력1# ifconfig //192.168.111.100IP주소 확인 했으니 윈 클라이언트로 가서 제어판-프로그램-프로그램 및기능Windows 기능 사용/사용안함 가서 맨아래 텔넷 클라이언트 기능 설치 윈도우 cmd를 열자그 후 telnet 192.168.111.100teluser /1234 입력 후 엔터접속이 된다.exit로 종료","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"7장. 셸 스크립트 프로그래밍","slug":"ThisIsLinux21","date":"2017-07-08T01:54:28.000Z","updated":"2018-09-03T05:51:02.355Z","comments":true,"path":"2017/07/08/ThisIsLinux21/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/08/ThisIsLinux21/","excerpt":"","text":"Centos의 기본 셸은 bash셸은 명령어를 해석 해 주는 것이다. -Alias, History, 연산 등의 기능을 갖는다. 환경변수12# echo $PATH //명령어를 실행하면 //명령어를 찾는 폴더들이 출력됨. 셸 스크립트 프로그래밍C언어와 유사하다.변수, 반복문,제어문 등의 사용이 가능vi, gedit으로 작성 가능 12345678910111213# vi name.sh //셸의 약자로 sh다음과 같이 입력#!/bin/sh //셸은 이것을 무조건 쓴다.echo &quot;사용자이름: &quot;$USERNAMEexit 0vi를 빠져나와서# sh name.sh //실행 방법 1# chmod u+x name.sh //실행방법2# ./name.sh //실행방법2 변수의 기본변수를 사용하기 전에 미리 선언하지 않으며, 변수에 처음 값이 할당되면서 자동으로 변수가 생성모든 변수는 ‘문자열(String)’로 취급변수 이름은 대소문자를 구분변수를 대입할 때 ‘=’ 좌우에는 공백이 없어야함 12345678910111213141516# testval = Hello //에러발생. 공백존재# testval=Hello# echo $testval //Hello 출력됨# testval=Yes Sir //에러발생# testval=&quot;Yes Sir&quot;# echo $testval //Yes Sir 출력# testval=7+5# echo testval //7+5 출력# testval=&apos;expr 7+5&apos;# echo testval //12 출력","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"6장 사용자별 공간 할당(쿼터)","slug":"ThisIsLinux20","date":"2017-07-07T14:55:51.000Z","updated":"2018-09-03T05:50:59.979Z","comments":true,"path":"2017/07/07/ThisIsLinux20/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/07/ThisIsLinux20/","excerpt":"","text":"쿼터사용자마다 용량 제한을 두는것이다.ex.클라우드 서비스를 가입하면 데이터 양이 한정되어있음. 쿼터 실습설치 직후로 초기화하자. 새로운 디스크를 추가해서 쿼터 전용 디스크로 하자사용자의 홈 디렉토리는 별도의 디스크로 하는것이 효과적이다. 그리고 사용자별 쿼터도 지정해보자 1. 20기가짜리 하나 디스크 달자1234567# fdisk /dev/sdb# mkfs.ext4 /dev/sdb1# mkdir /userHome //앞으로 추가되는 사용자는 userHome를 홈 디렉토리로 함# mount /dev/sdb1 /userHome/# vi /etc/fstab/dev/sdb1 /userHome ext4 defaults 1 2 추가 2. 유저 두명 추가하자12345678910# useradd -d /userHome/john john //홈디렉토리를 지정하면서 유저생성# useradd -d /userHome/bann bann //홈디렉토리를 지정하면서 유저생성 # ls -l /userHome //확인# passwd john //암호는 1234로 설정# passwd bann //암호는 1234로 설정 3. 아까 추가한 디스크를 쿼터용으로 설정하자1234567# vi /etc/fstabdefaults 를 아래와 같이 변경defaults,usrjquota=aquota.user,jqfmt=vfsv0리부트 해도 되지만 귀찮으니까# mount --options remount /userHome# mount //맨아래서 확인 4. 쿼터디비생성명령어들에 대해 관심있으면 책을보자1234567891011# cd /userHome/# quotaoff -avug# quotacheck -augmn# rm -rf aquota.*# quotacheck -augmn# touch aquota.user aquota.group# chmod 600 aquota.*# quotacheck -augmn# quotaon -avug# ls -l //aquota.group , user 생긴것 확인 5. 개인별 쿼터 설정블록(block)이 현재 사용하는 키로바이트 수 소프트제한(soft)- 넘어갈수 있지만 기간이 있음하드제한(hard) -완전히 못넘어감 소프트를 100으로 주고 하드를 150을 주었을 때130을 저장하면 몇일 이내에 30메가를 줄여야함. inodes- 파일의 개수를 제한하는것123456789101112131415161718192021222324# edquota -u john //유저 존에 대해 쿼터를 수정하겠다.소프트 10240(10메가) 하드 15360(15메가)를 주고 저장# su - john //존으로 로그인# cp /boot/vmlinuz-3.10.0-123.el7.x86_64 test1 // 파일 복사# cp /boot/vmlinuz-3.10.0-123.el7.x86_64 test2# cp /boot/vmlinuz-3.10.0-123.el7.x86_64 test3쿼터가 넘어갔다고 경고 뜸# ls -l //데이터가 잘 들어갔다.# cp /boot/vmlinuz-3.10.0-123.el7.x86_64 test4sdb1: write failed, user block limit reached.cp: `test4&apos;에 쓰는 도중 오류 발생: 디스크 할당량이 초과됨cp: failed to extend `test4&apos;: 디스크 할당량이 초과됨 오류뜬다.# ls -l//마지막 데이터는 용량이 다름 즉 짤려있음# quota // 내가 얼마나쓰고 있는지 확인block 현재 사용량grace가 6일동안 봐준다는것. 6. 존이 한것을 밴한테 그대로 적용하기1234# exit //존 로그아웃# repquota /userHome //쿼터확인# edquota -p john bann","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"6장. LVM 개념과 구현, RAID에 CentOS 설치","slug":"ThisIsLinux19","date":"2017-07-07T03:42:04.000Z","updated":"2018-09-03T05:50:57.003Z","comments":true,"path":"2017/07/07/ThisIsLinux19/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/07/ThisIsLinux19/","excerpt":"","text":"LVMLogical Volume Manage여러개의 하드디스크를 합쳐서 한 개의 파일 시스템으로 사용하는것으로 필요에 따라 다시 나눌 수 있다.예로 2테라 두개를 합친 후 1테라 3테라로 나눠서 사용한다. 물리 볼륨:sda1, sdb1 등의 파티션 볼륨 그룹:물리 볼륨을 합쳐서 1개의 물리그룹으로 만드는것. 논리 볼륨:볼륨 그룹을 1개 이상으로 나눠서 논리 그룹으로 나눈 것 실습3기가, 2기가를 볼륨 그룹으로 만들고3기가, 1기가, 1기가 논리 볼륨으로 만들어보자 1. 2기가, 3기가 디스크 추가버츄어머신 에딧에서.. 2. 파티션 설정12345678910111213141516171819# fdisk /dev/sdbnp1엔터엔터t8ew# fdisk /dev/sdcnp1엔터엔터t8ew 3. 피지컬 볼륨으로 만들기12# pvcreate /dev/sdb1# pvcreate /dev/sdc1 4. 볼륨 그룹으로 만들기123# vgcreate myVG /dev/sdb1 /dev/sdc1# vgdisplay //볼륨그룹 확인 5. 1기가 3기가 1기가로 나누자123456# lvcreate --size 1G --name myLG1 myVG# lvcreate --size 3G --name myLG2 myVG# lvcreate --extents 100%FREE --name myLG3 myVG //나머지 다써라# ls -l /dev/myVG //확인 6. 포멧하자123# mkfs.ext4 /dev/myVG/myLG1# mkfs.ext4 /dev/myVG/myLG2# mkfs.ext4 /dev/myVG/myLG3 7. 마운트하자123456# mkdir /lvm1 /lvm2 /lvm3# mount /dev/myVG/myLG1 /lvm1# mount /dev/myVG/myLG2 /lvm2# mount /dev/myVG/myLG3 /lvm3# df //확인 8. fstab에 등록하자123456# vi /etc/fstab팁 yy 한다음에 pp하면 복붙이된다./dev/myVG/myLG1 /lvm1 ext4 defaults 1 2/dev/myVG/myLG2 /lvm2 ext4 defaults 1 2/dev/myVG/myLG3 /lvm3 ext4 defaults 1 2 RAID 1 방식으로 디스크에 CentOS를 설치하자392p 보고 하자 1234# mdadm --detail -scan //확인해보자# mdadm --detail /dev/md/root //자세히보자","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"6장. RAID6 와 RAID 1+0","slug":"ThisIsLinux18","date":"2017-07-07T00:47:34.000Z","updated":"2018-09-03T05:50:54.285Z","comments":true,"path":"2017/07/07/ThisIsLinux18/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/07/ThisIsLinux18/","excerpt":"","text":"RAID6패리티가 2개이기 때문에 신뢰성이 높다 RAID 1+0RAID 0,1 쓰는것 실습디스크 10개 스냅샷으로 돌아온 후 2기가 짜리 하나를 지워버린다. RAID 6 생성123456789# mdadm --create /dev/md6 --level=6 --raid-devices=4 /dev/sdb1 /dev/sdc1 /dev/sdd1 /dev/sde1# mkfs.ext4 /dev/md6 //포멧# mkdir /raid6# mount /dev/md6 /raid6# df //2기가 확인 RAID 1+0 생성이는 RAID 1을 두개 먼저 생성해야한다. md2 ,md3를 RAID1으로 만들고 이 두개를 RAID 0으로 묶는다. 12345678910111213141516# mdadm --create /dev/md2 --level=1 --raid-devices=2 /dev/sdf1 /dev/sdg1 //raid1 md2로 생성# mdadm --create /dev/md3 --level=1 --raid-devices=2 /dev/sdh1 /dev/sdi1 //raid1 md3로 생성# mdadm --create /dev/md10 --level=0 --raid-devices=2 /dev/md2 /dev/md3 //md2, md3로 raid0 생성# mkfs.ext4 /dev/md10 //포멧# mkdir /raid10# mount /dev/md10 /raid10# df 잘동작하나 확인12345678# cp /boot/vmlinuz-3.10.0-123.el7.x86_64 /raid6/testFile# cp /boot/vmlinuz-3.10.0-123.el7.x86_64 /raid10/testFile# vi /etc/fstab/dev/md6 /raid6 ext4 defaults 1 2/dev/md10 /raid10 ext4 defaults 1 2//재부팅되도 마운트 유지하기 위해 추가 고장내보자SCSI 3, 5 ,8, 9 디스크 없애고 부트 RAID 6 확인12345# mdadm --run /dev/md6 //md6 실행# df //확인# ls -l /raid6 //데이터 확인# mdadm --detail /dev/md6 RAID 1+0 확인1234# mdadm --run /dev/md2# mdadm --run /dev/md3# mdadm --detail /dev/md10","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"RAID 0,1,5 의 고장과 원상 복구","slug":"ThisIsLinux17","date":"2017-07-06T03:33:07.000Z","updated":"2018-09-03T05:50:51.341Z","comments":true,"path":"2017/07/06/ThisIsLinux17/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/06/ThisIsLinux17/","excerpt":"","text":"SCSI 2,4,6,9를 고장내 놓고 잘동작하는 지 확인 해 보겠다. 잘 동작하나 확인하기 위해 고장내기 전에 파일을 옮긴다.123456# cp /boot/vmlinuz-3* /raidLinear/testFile# cp /boot/vmlinuz-3* /raid0/testFile# cp /boot/vmlinuz-3* /raid1/testFile# cp /boot/vmlinuz-3* /raid5/testFile# halt -pvmplayer을 켜고 SCSI 2,4,6,9 디스크를 제거쫌 지나면 응급복구모드로 실행이됨암호를 입력해주자 ls -l /dev/sd* 을 하니까 당겨져 있다. sdc가 sdb 이런식으로 RAID 1, 5 는 데이터가 살아있어야 한다. RAID 1 확인1234567# df //마운트가 다 끊겨있다.# mdadm --run /dev/md1 //강제로 가동시키는 것시작되었다.# df //raid1가 마운트 된것을 확인.# ls -l /raid1 //데이터가 잘 있는지 확인# mdadm --detail /dev/md1 //하나는 살아있고 하나는 removed인것을 확인 RAID 5 확인12345# mdadm --run /dev/md5 //강제로 가동시키는 것시작되었다.# df //raid5가 마운트 된것을 확인.# ls -l /raid5 //데이터가 잘 있는지 확인# mdadm --detail /dev/md5 //하나는 살아있고 하나는 removed인것을 확인 RAIDLinear 확인12# mdadm --run /dev/md9 //강제로 가동시키는 것실행할 수 없다. 결함을 허용하지 않음 RAID 0 확인12# mdadm --run /dev/md0 //강제로 가동시키는 것실행할 수 없다. 결함을 허용하지 않음 시스템이 재대로 실행되도록 해보자1234567891011# mdadm --stop /dev/md9 //종료# mdadm --stop /dev/md0 //종료# vi /etc/fstabmd9,md0 주석 하고# reboot리부트를 했는데 복구모드로 실행이 된다면 컨트롤 D를 누르고실행한 다음에 재 마운트를 해주면 된다.# df //마운트가 되어있는것 확인. 새로운 디스크를 장착하여 원상복구를 시켜보자Linear RAID, RAID 0 은 데이터를 살릴 순 없다.그러나 RAID 1, RAID 5는 데이터를 살릴 수 있다. vmplayer에서 디스크 4개를 1기가씩 주고 추가하자. 알아서 빈곳을 잘 찾아간다. 우리가 조금전 추가했던것은 sdc, sde, sdg, sdi 이다.2,4,6,9 로 들어갔으므로.. RAID 0, Linear Raid는 새로 만들어주어야 한다.12345678910111213141516# ls -l /dev/sd* //# fdisk /dev/sdc~sdi 까지 n 입력 p 입력 엔터 엔터 t 입력 fd 입력 w 입력# mdadm --stop /dev/md9 //다시만들기위해 stop# mdadm --create /dev/md9 --level=linear --raid-devices=2 /dev/sdb1 /dev/sdc1#mdadm --detail /dev/md9 //확인해보자# mdadm --stop /dev/md0 //다시만들기위해 stop# mdadm --create /dev/md0 --level=0 --raid-devices=2 /dev/sdd1 /dev/sde1# mdadm --detail /dev/md9 //확인해보자 RAID 1, RAID 5는 새로만들면 안되고 추가해주어야 한다.1234567891011121314# mdadm /dev/md1 --add /dev/sdg1# mdadm /dev/md5 --add /dev/sdi1# vi /etc/fstab/dev/md9 /raidLinear ext4 defaults 1 2/dev/md0 /raid0 ext4 defaults 1 2/dev/md1 /raid1 ext4 defaults 1 2/dev/md5 /raid5 ext4 defaults 1 2이렇게 바꿔준다.# reboot# df //마운트 확인. 데이터를 한번 확인해보자. 123456789101112131415# ls -l /raid0drwx------ 2 root root 16384 7월 6 17:26 lost+found-rwxr-xr-x 1 root root 4902656 7월 6 17:31 testFile# ls -l /raid1drwx------ 2 root root 16384 7월 6 17:27 lost+found-rwxr-xr-x 1 root root 4902656 7월 6 17:31 testFile# ls -l /raid5drwx------ 2 root root 16384 7월 6 17:29 lost+found-rwxr-xr-x 1 root root 4902656 7월 6 17:31 testFile# ls -l /raidLineardrwx------ 2 root root 16384 7월 6 17:25 lost+found-rwxr-xr-x 1 root root 4902656 7월 6 17:31 testFile raid 1그리고 raid5 는 데이터가 있을것이라 예상했지만 raid0 그리고 raidLinear도 데이터가 존재한다. 어떻게 된 것일까? 운이 좋게 지워지지않은 영역에 존재하는 것일 것이다. 그러므로 데이터를 신뢰 할 수 없으며 이는 포멧을 해주는 것이 좋다. 12345678# umount /dev/md0 //포멧하기전에 마운트를 끊음# umount /dev/md9# mkfs.ext4 /dev/md0 //포멧# mkfs.ext4 /dev/md9# reboot //리부트를 하지않고 바로 마운트를 해줘도됨. //어차피 리부트하면 마운트되어있으니까 아무거나 선택! raid 1, raid 5 의 고장난 디스크에 대해서 따로 작업을 해 줘야할줄 알았는데 –add만 하면 되어서 생각보다 간단하다고 생각했다.","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"6장. RAID 정의 및 개념,구현","slug":"ThisIsLinux16","date":"2017-07-06T00:13:09.000Z","updated":"2018-09-03T05:50:48.837Z","comments":true,"path":"2017/07/06/ThisIsLinux16/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/06/ThisIsLinux16/","excerpt":"","text":"RAIDRedundant Array of Inexpensive Disks여러개의 디스크를 하나처럼 사용하는 RAID를 알아보자비용절감 + 신뢰성 향상 + 성능 향상1테라 디스크 3개를 하나로 묶어서 3테라 디스크처럼 쓴다 하드웨어 RAID여러개의 하드디스크를 가지고 장비를 만들어서 사용. 장비업체에서 제공하기 떄문에 사용법이 다를 수 있다. 그리고 상당히 고가이다. 하드웨어RAID가 안정성이 높다. 소프트웨어 RAID디스크를 장착만하면 운영체제 레벨에서 하나로 묶을 수 있다. Linear RAID (339p 그림보기)최소 2개이상의 디스크를 하나로 묶음앞 디스크 부터 차례로 저장100TB 100TB 100TB 를 사용하면 총 300TB가 된다. 즉 공간효율성이 100%임. RAID 0 (339p 그림보기)모든 디스크에 동시에 저장되는 개념그러므로 하드디스크가 3개면 /3 시간으로 저장됨신뢰성이 낮다.빠르지만 전부 잃어버려도 큰 문제가 되지 않는 자료가 적당하다.3TB 100TB 100TB 를 사용하면 총 9TB가 된다. 즉 디스크 크기가 다르면 공간효율성이 100%가 되지 않음.그래서 RAID를 구성할 떈 같은회사 같은 용량의 디스크로 구성한다.디스크 세개중에 하나만 고장나도 디스크를 못쓴다. RAID 1미러링이라 부름1TB 1TB 를 사용하면 1TB 사용가능결함 허용을 제공= 신뢰성 높음. 즉 둘중에 하나가 고장나도 데이터가 보존된다.공간효율이 나쁘므로 비용이 비싸다는 단점이 있다. RAID 5RAID 2,3,4의 장점을 포용하기 때문에 2,3,4를 사용할 필요가 없다.RAID1의 데이터 안정성 +RAID0의 공간 효율성을 추구 디스크 개수 -1개의 공간을 사용. 즉 4개일 경우 3개를 사용(75%) 100개일 경우 99개를 사용(99%)즉 가격이 저렴하면서 안정적인것.최소한 3개 이상의 하드디스크가 필요하며 오류가 발생했을 때는 패리티(Parity)를 이용해서 데이터를 복구결함 허용을 제공 - 즉 디스크 하나가 고장나도 사용 복구 가능하지만 디스크가 하나가 고장났을 때는 복구가 가능하지만 디스크가 2개가 고장날 경우에는 복구 불가능.그래서 100개를 사용하였을 경우에는 불안하다.(2개 이상 고장날 확률이 높아지므로)즉 적은 디스크를 활용할 경우 공간효율은 낮아지지만 신뢰도는 높아진다.일반적으로 RAID 5는 7개에서 10개정도의 디스크로 구성 RAID 6패리트를 2개 쓴다. 즉 디스크가 2개가 고장나도 복구가능. 최소 4개이상의 디스크가 필요함.(패리티를 2개 쓰므로)패리티를 2개 쓰는 알고리즘의 효율성이 떨어져서 성능이 떨어지는 단점이 있어 많이 사용하지는 않음. RAID1 + 0 = RAID + RAID0신뢰성(안정성)과 성능(속도)이 동시에 뛰어난 방법RAID1로 구성된것을 RAID 0 으로 묶음. 그림참고 실습SCSI 0:1 부터 0:10 까지 진행. SCSI 0:1 SCSI 0:2 - Linear RAID SCSI 0:3 SCSI 0:4 - RAID 0 SCSI 0:5 SCSI 0:6 - RAID 1 SCSI 0:8 SCSI 0:9 SCSI 0:10 - RAID 5 SCSI 0:1 만 2GB로 구성하고 나머지는 다 1GB로 구성 에디트 쪽에서 디스크 2기가 1개 1기가 8개 추가. 1# ls -l /dev/sd* //장착이 잘 되었나 확인 9번 반복12345678# fdisk /dev/sdb ~sdj 까지 반복n p 엔터 엔터p //로 확인해보면 시스템이 리눅스인데 RAID로 변경해야한다.t 엔터L 누르면 도움말이 나온다.fd를 입력 후 엔터p를 눌러 확인w를 눌러 저장 1# ls -l /dev/sd* //장착이 잘 되었나 확인 과정 설명1.mdadm 명령어로 논리 볼륨 생성2.mkfs.ext4 명령어로 파일시스템 생성(포멧)3.mount 적용위 3가지 과정은 6장에서 하드디스크 1개추가 과정과 같다. Linear RAID 만들기sdb1 sdc1 이용mdadm RAID를 만들고 없애는 명령어 1234567891011121314151617181920212223# fdisk -l /dev/sdb /dev/sdc // 아까 한것이 잘 적용되었나 확인# mdadm --create /dev/md9 --level=linear --raid-devices=2 /dev/sdb1 /dev/sdc1 //RAID md9를 만드는데 리니어로 디바이스는 //개수 2개로 2개는 /dev/sdb1 /dev/sdc1 로# mdadm --detail --scan //돌고있는지 확인# mdadm --detail /dev/md9 //md9에 대해 자세히 보자# mkfs.ext4 /dev/md9 //포멧하자# mkdir /raidLinear //디렉토리 생성# mount /dev/md9 /raidLinear/ //마운트# df //마운트 확인# vi /etc/fstab //재부팅하면 마운트가 풀리므로 설정/dev/md9 /raidLinear ext4 defaults 0 0 맨 아래 추가# reboot# df //마운트 확인 RAID 0 만들기sdd sde로 한다1234567891011121314151617# mdadm --create /dev/md0 --level=0 --raid-devices=2 /dev/sdd1 /dev/sde1# mdadm --detail --scan //돌고있는지 확인# mdadm --detail /dev/md0 //md9에 대해 자세히 보자# mkfs.ext4 /dev/md0 //포멧하자# mkdir /raid0 //디렉토리 생성# mount /dev/md0 /raid0/ //마운트# df //마운트 확인# vi /etc/fstab //재부팅하면 마운트가 풀리므로 설정/dev/md0 /raid0 ext4 defaults 0 0 추가 RAID 1sdf sdg 사용12345678910111213141516# mdadm --create /dev/md1 --level=1 --raid-devices=2 /dev/sdf1 /dev/sdg1y입력 // raid1은 부트 디바이스로 사용 할 수 없는데 만들겠냐는 뜻# mdadm --detail /dev/md1 //확인해보자# mkfs.ext4 /dev/md1 //포멧하자# mkdir /raid1 //디렉토리 생성# mount /dev/md1 /raid1/ //마운트# df //마운트 확인# vi /etc/fstab //재부팅하면 마운트가 풀리므로 설정/dev/md1 /raid1 ext4 defaults 0 0 추가 RAID 5sdh sdi sdj 사용1234567891011121314151617# mdadm --create /dev/md5 --level=5 --raid-devices=3 /dev/sdh1 /dev/sdi1 /dev/sdj1망가졌다는 메세지 나오는데 무시하면된다. (컴퓨터가 착각함!)# mdadm --detail /dev/md5 //확인해보자# mkfs.ext4 /dev/md5 //포멧하자# mkdir /raid5 //디렉토리 생성# mount /dev/md5 /raid5/ //마운트# df //마운트 확인# vi /etc/fstab //재부팅하면 마운트가 풀리므로 설정/dev/md5 /raid5 ext4 defaults 0 0","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"6장. IDE/SCSI 장치 구성, 하드디스크 1개 추가","slug":"ThisIsLinux15","date":"2017-07-05T07:33:36.000Z","updated":"2018-09-03T05:50:46.752Z","comments":true,"path":"2017/07/05/ThisIsLinux15/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/05/ThisIsLinux15/","excerpt":"","text":"하드디스크 관리는 관리자 입장에서 기본적인것이다.디스크가 모자르면 디스크를 추가해야한다.. 이런걸 어떻게 할지 알아보자 IDE SCSI 장치에 대해IDE는 케이블을 2개 꽂을수가 있다. 여기에 하드디스크를 장착하거나 DVD롬을 장착할 수 있다. 즉 두개의 IDE가 있으면 4개를 장착할 수 있다. 0:0 , 0:1, 1:0 , 1:1 이렇게 구분된다(4개일 경우) SCSI는 총 16개의 SCSI 하드디스크를 꽂을 수 있는 케이블이 따져있다. 0,7번은 VMware가 사용하므로 사용할 수 없다.마찬가지로 SCSI 0:0 ,0:1 로 구분된다. 326p를 통해 그림으로 확인가능 우리가 80GB 의 하드디스크를 추가했는데 이를 sda라 그런다만일 하나더 추가하면 sdb라 그런다.정식이름은 /dev/sda 이다.여기서 파티션을 나누면 sda1,sda2로 나뉜다. 즉 sda는 하드디스크 자체를 의미하며 sda1은 파티션1 sda2는 파티션2를 의미한다. 땅 자체를 사는것을 하드디스크를 추가하는것으로 보면되고 축구장으로 사용하기 위해 특정부분에 선을 긋는것을 파티션을 나눈다고 보면된다. 또한 파티션은 특정디렉터리에 마운트를 해줘야함. 하드디스크 1개 장착과정1.SCSI 0:1에 물리적인 하드디스크 하나 장착 이는 /dev/sdb이다. 2.fdisk 명령어를 통해 파티션을 나눔(실습에서는 파티션1개로)./dev/sdb1 파티션이 생긴다. 3.파티션을 사용하기 위해서는 포멧을 해줘야한다.(mkfs.ext4를 사용) 4.그러면 완전히 준비된 하드디스크가 생기는데 이를 특정 폴더에 마운트해야한다. 5.마운트는 컴퓨터를 끄면 마운트가 끊어지므로 /etc/fstab 파일을 편집해 주어야 한다. 1.SCSI 0:1에 물리적인 하드디스크 하나 장착 이는 /dev/sdb이다.에디트에서 애드를 선택하고 다음스카시를 선택하고 다음맨위를 하고 다음1기가로 선택하고 싱글파일 선택하고 다음어드밴스드를 눌러 0:1로 되어있는것을 확인 123456789# ls -l /dev/sd*brw-rw---- 1 root disk 8, 0 7월 5 18:02 /dev/sdabrw-rw---- 1 root disk 8, 1 7월 5 18:02 /dev/sda1brw-rw---- 1 root disk 8, 2 7월 5 18:02 /dev/sda2brw-rw---- 1 root disk 8, 16 7월 5 18:02 /dev/sdbsda는 초기 설정때 설정한것. 파티션을 두개로 나눠서 sda1, sda2로 나뉜다.왜 sdb1은 없지? 파티션을 나누지 않았으므로! 2.fdisk 명령어를 통해 파티션을 나눔(실습에서는 파티션1개로)./dev/sdb1 파티션이 생긴다.파티션을 나눠보자1234567891011121314151617181920# fdisk /dev/sdbn //새로운 파티션 추가p // p(primary)는 주 파티션 e(extended)는 확장파티션을 의미 //p는 4개까지 나눌 수 있음 //4개 이상하고싶으면 3개는 p로하고 하나는 e로 잡아서 //e 파티션안을 나눠서 늘리면 된다. 이는 굉장히 드문경우 //일반적으로는 p를 쓰면 충분하다.1 //sdb1로 하겠다. 엔터 // 2047까지는 시스템 부분이므로 // 어디서 부터 시작할꺼냐. 엔터하면 2048부터엔터 //끝까지 쓰겠다. p //최종확인w //적용 # ls -l /dev/sd* //생성된 것 확인brw-rw---- 1 root disk 8, 0 7월 5 18:02 /dev/sdabrw-rw---- 1 root disk 8, 1 7월 5 18:02 /dev/sda1brw-rw---- 1 root disk 8, 2 7월 5 18:02 /dev/sda2brw-rw---- 1 root disk 8, 16 7월 5 18:11 /dev/sdbbrw-rw---- 1 root disk 8, 17 7월 5 18:11 /dev/sdb1파일 시스템을 생성하자. 3.파티션을 사용하기 위해서는 포멧을 해줘야한다.(mkfs.ext4를 사용)1# mkfs.ext4 /dev/sdb1 4.그러면 완전히 준비된 하드디스크가 생기는데 이를 특정 폴더에 마운트해야한다.12345678# mkdir /mydata# mount /dev/sdb1 /mydata# df // 마운트 된것을 확인# cp /boot/vmlinuz-3.10.0-123.el7.x86_64 /mydata/data1 // 새로운 디스크에 데이터 복사# df //확인 (용량 늘어난것 확인) 5.마운트는 컴퓨터를 끄면 마운트가 끊어지므로 /etc/fstab 파일을 편집해 주어야 한다.123# vi /etc/fstab /dev/sdb1 /mydata ext4 defaults 0 0 입력 후 vi종료 //dev/sdb1을 /mydata에 마운트하는것. ext4를 이용해 1","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"5장. 리눅스에 Windows 설치 KDE데스크톱 설치","slug":"ThisIsLinux14","date":"2017-07-05T06:37:05.000Z","updated":"2018-09-03T05:50:44.091Z","comments":true,"path":"2017/07/05/ThisIsLinux14/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/05/ThisIsLinux14/","excerpt":"","text":"리눅스 안에서 윈도우를 깔아보자CentOS에서 제공하는 가상머신을 이용하자즉 가상머신에서 가상머신을 만드는…램 올리고, 가상화 켜주고 311p참고 iso 파일을 받고 내폴더에 붙여넣기 해준다. 123# mkdir /iso# mv 600* /iso //파일이름이 600으로 시작함.# ls -l /iso 실습에서는 313p 의 2-0을 생략한다.프로그램 -시스템 도구 -가상머진 관리자로컬 선택 후 새가상머신 생성 왼쪽위 그림(노란색)Win2008 입력후 로컬설치매체 선택후 앞으로iso파일 선택하고 윈도우서버 2008 선택하고 앞으로그대로 두고 앞으로설치전에 사용자 설정 선택 후 완료디스플레이를 VNC로 하고 적용왼쪽 위 설치시작 KDE 데스크톱을 설치해보자센토스는 기본적으로 그놈데스크탑이 들어있다. 윈도우와 비슷한 KDE 데스크탑을 운영할 수 있다.123456$ yum grouplist | grep KDE //KDE 패키지그룹을 조회su -c &apos;yum -y groupinstall &quot;KDE Plasma Workspaces&quot;&apos; //조회됨$ su -c &apos;yum -y groupinstall &quot;KDE Plasma Workspaces&quot;&apos; //루트권한으로 &apos;&apos;안에 있는 명령어 실행(KDE 설치)자동로그인 해제 . 321p 참고1$ reboot톱니 누르고 KDE Plasma 작업공간 선택후 암호 입력 후 로그인","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"5장. 노틸러스, FireFox업그레이드, 기타 X윈도 유틸리티","slug":"ThisIsLinux13","date":"2017-07-05T04:47:34.000Z","updated":"2018-09-03T05:50:41.940Z","comments":true,"path":"2017/07/05/ThisIsLinux13/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/05/ThisIsLinux13/","excerpt":"","text":"노틸러스윈도우 탐색기와 비슷하다.실행법 : 프로그램-보조프로그램-파일 내폴더가 홈 디렉토리이다.컴퓨터가 / 폴더이다.rpm 파일도 설치 가능복붙도 가능 컨트롤 씨브이289p 참고 파이어폭스 업그레이드설치하고압축풀고 12345678910# mv firefox /usr/local //압축푼것 위치이동# chown -R root.root /usr/local/firefox/ 루트에게 권한줌# cd /usr/local/bin# ln -s /usr/local/firefox/firefox . //링크를 걸어줌파폭을 실행하면 에러가 나는데# cd /usr/local/firefox/browser/extensions/# rm -rf *해주고 리부트 어도비리더 설치123# wget http://download.hanbit.co.kr/centos/7/AdobeReader_kor-8.1.7-1.i486.rpm# su -c &apos;yum -y localinstall Adobe*&apos;","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"5장. X윈도 테마, GRUB 배경화면","slug":"ThisIsLinux12","date":"2017-07-05T02:57:03.000Z","updated":"2018-09-03T05:50:39.688Z","comments":true,"path":"2017/07/05/ThisIsLinux12/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/05/ThisIsLinux12/","excerpt":"","text":"이 챕터는 책에서 중요도가 가장 떨어진다!서버관리자가 되었을 때 리눅스를 PC로 사용하는 사람에게 도움을 주기위해 알아둘 필요는 있다. 테마 설치하기12$ rpm -qa gnome-tweak-tool //설치되어있나 확인$ gnome-tweak-tool //툴 켜서 설정변경 GRUB 이미지 설정1234567891011121314$ su -c &apos;yum -y install grub2-starfield-theme&apos; //암호입력 //su -c는 슈퍼바이저 권한으로 실행하는것$ vi /etc/default/grubGRUB_TIMEOUT=5GRUB_DISTRIBUTOR=&quot;$(sed &apos;s, release .*$,,g&apos; /etc/system-release)&quot;GRUB_DEFAULT=savedGRUB_DISABLE_SUBMENU=true#GRUB_TERMINAL_OUTPUT=&quot;console&quot; //여기 주석처리GRUB_CMDLINE_LINUX=&quot;rd.lvm.lv=centos/swap vconsole.font=latarcyrheb-sun16 rd.lvm.lv=centos/root crashkernel=auto vconsole.keymap=us rhgb quiet&quot;GRUB_DISABLE_RECOVERY=&quot;true&quot;GRUB_THEME=&quot;/boot/grub2/themes/system/theme.txt&quot; //여기추가vi 저장후 종료 이미지 파일을 centos폴더에 저장 (ball.png)1mv /home/centos/ball.png /boot/grub2/themes/system실행하여 그림 이동 12345# vi /boot/grub2/themes/system/theme.txt //:set number34행가서 이미지 파일이름 변경# grub2-mkconfig -o /boot/grub2/grub.cfg //적용","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. 응급복구, GRUB, 커널 컴파일","slug":"ThisIsLinux11","date":"2017-07-04T07:09:17.000Z","updated":"2018-09-03T05:50:37.225Z","comments":true,"path":"2017/07/04/ThisIsLinux11/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/04/ThisIsLinux11/","excerpt":"","text":"응급복구261p 참고이게 문제가 될 소지가 있지않냐?그래서 처음 켤때 선택하는거에서 암호를 걸어야 한다. GRUB 부트로더/etc/default/grub 파일과 /etc/grup.d/ 디렉터리의 파일을 수정한 후 ‘grub2-mkconfig’ 명령어를 실행해 설정함 123456789101112131415161718# vi /etc/default/grubtimeout = 30 으로 변경distributor = &quot;Hello&quot; 로 변경# grub2-mkconfig -o /boot/grub2/grub.cfg // 변경사항 반영//여기서 부터 선택하는 곳에서 e 키 못누르게 비번 설정하는것# vi /etc/grub.d/00_header맨 아래 가서 다음코드 추가cat &lt;&lt; EOFset superusers=&quot;thisuser&quot;password thisuser 4321EOF여기까지!vi 빠져나와서# grub2-mkconfig -o /boot/grub2/grub.cfg // 변경사항 반영$ reboot선택하는곳에서 e 누르면 암호 누르도록 함 커널커널 : 하드웨어를 제어하는 기능모든 하드웨어를 제어하는 코드를 다 넣으면 커널이 너무 커지고 무거워진다. 그러므로 잘 안쓰는 하드웨어 코드는 모듈에 빼내서 필요할때마다 사용즉 모듈은 필요할때 쓸 수 있도록 커널의 코드를 밖으로 빼낸것이다! 1234567891011121314151617$ uname -r //커널버전확인$ wget &quot;https://kernel.org/pub/linux/kernel/v3.x/linux-3.17.4.tar.xz&quot; //교재와 동일한 커널 설치$ mv linux-3.17.4.tar.xz /usr/src$ cd /usr/src$ tar xfJ linux-3.17.4.tar.xz //압축을 풀자$ cd linux-3.17.4/커널은 c 코드이므로 설치를 위해 컴파일러를 깔자$ yum -y install gcc gcc-c++ qt qt-devel$ make mrproper // 커널설정 초기화$ make xconfig //커널의 환경설정 설정 후$ make clean$make ; make modules_install ; make install //순서대로 진행됨.","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. 파이프/필터, 프로세스, 서비스/소켓","slug":"ThisIsLinux10","date":"2017-07-04T05:52:52.000Z","updated":"2018-09-03T05:50:34.115Z","comments":true,"path":"2017/07/04/ThisIsLinux10/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/04/ThisIsLinux10/","excerpt":"","text":"파이프두개의 프로그램을 연결해주는 통로1$ ls -l /etc | more //앞에서 뒤로 넘김 필터필요한것만 걸러주는 명령어 123456$ ps -ef //현재 작동중인 프로세스 보여줌$ ps -ef | grep bash //bash와 관련된 프로세스만 //보여줌$ rpm -qa | grep gedit //gedit 관련된것만 보여줌 리다이렉션(보내는 것)123456789$ ls -l &gt; file.txt //결과를file.txt로 만드는것 //file.txt가 존재할 경우 덮어쓰고 //존재하지 않을경우 새로 만들고 작성$ ls -l &gt;&gt; file.txt //결과를file.txt로 만드는것 //file.txt가 존재할 경우 뒤에다 이어서 작성하고 //존재하지 않을경우 새로만들고 작성$ cat sort &lt; file.txt &gt; out.txt //file.txt를 정렬해서 out.txt에 넣어라 프로세스, 데몬프로세스는 하드디스크에 저장된 실행코드가 메모리에 로딩되어 활성화 된것. 포그라운드 프로세스실행하면 화면에 나타나서 사용자와 상호작용을 하는 프로세스 백그라운드 프로세스화면에 나타나지 않고 실행되는 프로세스백신 , 서버 데몬(=서비스,=서버 프로세스)등 프로세스번호각각의 프로세스는 할당된 번호가 있다.12345$ ps -ef | grep bash //bash관련된 프로세스만 보여줌root 693 1 0 13:43 ? 00:00:00 /bin/bash /usr/sbin/ksmtuned693은 자기 프로세스 번호고 1은 부모프로세스 번호이다. 작업 번호현재 실행되고 있는 백그라운드 프로세스의 순차번호 부모프로세스 ,자식프로세스모든 프로세스는 부모프로세스를 갖는다.부모 프로세스를 kill하면 자식프로세스도 자동으로 죽음. 프로세스 관련 명령ps 프로세스 보기1$ ps -ef | grep bash //bash 관련 프로세스 보여줌 kill 프로세스 종료파이어폭스 kill하기123456$ ps -ef | grep fire //파폭 관련 프로세스 보기root 2637 1934 0 13:49 ? 00:00:04 /usr/lib64/firefox/firefox//프로세스번호가 2637이다.$ kill 2637//가끔 킬 해도 죽지 않는 경우가 있는데 그경우 -9 옵션을 준다.$ kill -9 2637 pstree 프로세스 트리로 보기1$pstree //프로세스 구조를 트리로 보여줌 실습 (포그라운드-&gt;백그라운드-&gt;포그라운드)1234567$ yes &gt; /dev/null //y를 계속생성하는 프로세스 생성ctrl+ z 입력.$ bg //백그라운드 보는것. //처음에 했던 동작이 남아있다.[1]+ yes &gt; /dev/null &amp;$ fg 1 //1번작업을 다시 포그라운드로 갖고와라 실습 (포그라운드-&gt;백그라운드-&gt;포그라운드)1234567$ gedit &amp; //지에딧을 백그라운드로 돌려라. //콘솔을 계속 사용할 수 있게된다.$ vi &amp; //백그라운드로 돌아가긴 하는데 의미없다. //vi는 포그라운드로 돌려야 하므로 $ bg //vi의 백그라운드 번호를 알고$ fg 1 //vi를 포그라운드로 갖고옴 서비스와 소켓서비스웹 서버 = 웹 서비스FTP 서버 = FTP 서비스 서비스의 실행 스크립트 파일은 /usr/lib/systemd/system/ 디렉터리에 ‘서비스이름.service’라는 이름으로 확인할 수 있다. 예를들어 웹 서비스는 httpd.service라는 이름의 파일로 존재 소켓서비스는 항상 가동되지만 소켓은 필요할 떄만 구동된다. 외부에서 특정 서비스가 요청되었을 때. 그래서 약간 느리다./usr/lib/systemd/system/ 디렉터리에 소켓이름.socket 이름으로 존재","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. 네트워크 관련 개념과 명령어,SELinux","slug":"ThisIsLinux9","date":"2017-07-04T04:29:36.000Z","updated":"2018-09-03T05:50:31.012Z","comments":true,"path":"2017/07/04/ThisIsLinux9/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/04/ThisIsLinux9/","excerpt":"","text":"TCP/IP우리가 사용하는 인터넷은 tcp/ip 기반이다. 가장널리사용되는 프로토콜의 한 종류 호스트이름 도메인이름호스트이름 : 컴퓨터에 지정된 이름도메인 이름 : hanbit.co.kr rkxdms gudtlr IP 주소랜카드에 부여되는 중복되지 않는 유일한 주소 네트워크 주소같은 네트워크에 속해있는 공통된 주소 브로드캐스트 주소제일 뒤가 255인 주소내부 네트워크의 모든 컴퓨터가 듣게 되는 주소 게이트웨이, 라우터라우터=게이트웨이네트워크 간에 데이터를 전송하는 컴퓨터 또는 장비 넷마스크, 클래스넷마스크 : 네트워크의 규모를 결정ex(255.255.255.0) DNS 서버= 네임서버URL을 IP로 변환해주는 서버 12345678910111213141516$ nmtui //네트워크와 관련된 작업진행$ rdate -s time.bora.net //시간설정$ nmtui //설정 변경후 종료 네트워크매니저텍스트ui$ systemctl restart network //네트워크 재시작 (해줘야함)$ ifconfig //네트워크장치에 할당된 ip주소 확인$ ifdown ens32 //이거는 systemctl restart network //보다 강력하게 서버를 끄는것.$ ifup ens32 //서버 재시작 $ nslookup naver.com //DNS서버의 작동을 테스트$ ping www.yahoo.com //네트워크 응답 확인$ ping -3 www.yahoo.com //세번만 피을 때려라 주요 파일네트워크 기본적인 정보가 설정되어 있는 파일/etc/sysconfig/network /etc/sysconfig/network-scripts/ifcfg-ens32ens32 장치에 설정된 네트워크 정보가 모두 들어있는 파일ens32가 아니라 eno일수도 있다.BOOTPROTO = none 고정아이피를 쓰겠다.DNS1 DNS가 여러개 나올 수 있으므로 1이 필요ONBOOT =”yes” 네트워크를 쓰겠다 /etc/resolv.confDNS 서버의 정보와 호스트 이름이 들어있다.168.126.63.1 //kt에서 제공하는 네임서버이다 //네임서버가 없을 때 사용가능 SELinux보안에 취약한 리눅스를 보호하기 위해 탄생책에서는 실습을 위해 기능을 꺼두었다./etc/sysconfig/selinux를 편집하였다.SELINUX=disabled 이렇게..","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. 파일 압축과 묶기, CRON과 AT","slug":"ThisIsLinux8","date":"2017-07-04T00:26:28.000Z","updated":"2018-09-03T05:50:28.832Z","comments":true,"path":"2017/07/04/ThisIsLinux8/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/04/ThisIsLinux8/","excerpt":"","text":"파일 압축유닉스는 압축하는 파일이 여러개이다. 그래서 확장자도 여러개이다. 점점 개선이 되면서 여러개가 생긴것이다. 예전것도 쓰고 최신것도 쓰므로 모두 사용할줄 알아야함gzip-&gt;bzip2-&gt;xz 순으로 발전해옴 xz가 압축률도 제일좋다. 12345678910111213141516171819# cp glist.txt file1.txt //파일 복사# cp glist.txt file2.txt# cp glist.txt file3.txt# xz file1.txt# bzip2 file2.txt# gzip file3.txt# ls-l file*-rw-r--r-- 1 root root 1080 7월 4 09:31 file1.txt.xz-rw-r--r-- 1 root root 1072 7월 4 09:31 file2.txt.bz2-rw-r--r-- 1 root root 1053 7월 4 09:31 file3.txt.gz# xz -d file.txt.xz //압축해제# bzip2 -d file2.txt.bz2 //압축해제# gzip -d file3.txt.gz //압축해제# gunzip file3.txt.gz //위와 같음 gz로 압축한게 제일작은데? 파일마다 다르다!! 일반적으로는 gz가 효울이 제일 떨어진다. 그래서 일반적으로 커널파일을 xz로 배포한다.리눅스에서의 압축은 파일을 압축해서 원본파일이 사라진다는것을 주의하자. 파일 묶기리눅스는 압축, 묶기가 다르다묶기는 원본파일이 유지되며 하나로 묶은것이라 보면된다.12345678910# tar cvf bin.tar bin1 bin2 bin3 //bin1,2,3이 bin.tar로 묶임# rm -f bin? //bin1,2,3 제거# tar xvf bin.tar //풀기# ls -l-rw-r--r-- 1 root root 14714880 7월 4 09:41 bin.tar-rwxr-xr-x 1 root root 4902656 7월 4 09:40 bin1-rwxr-xr-x 1 root root 4902656 7월 4 09:40 bin2-rwxr-xr-x 1 root root 4902656 7월 4 09:40 bin3묶으면서 압축을 진행해보자12345678# rm -f bin.tar# tar cvfj bin.tar.bz2 bin1 bin2 bin3 //bz2형식으로 압축하면서 묶어줌# rm -f bin.tar.bz2# tar cvfJ bin.tar.xz bin1 bin2 bin3 //xz형식으로 압축하면서 묶어줌 //J가 대문자이다.# tar xvfJ bin.tar.xz /etc/sysconfig //xz압축해제 +tar 풀기 파일 위치 검색12345678910# find /etc -name &quot;*.conf&quot; //etc밑에 확장명이 conf 인것을 찾음# find /etc -name &quot;*.conf&quot; &gt; conf.txt //위 대상으로 conf.txt로 저장# find /home -user centos //centos 사용자의 파일들 검색# find /usr/bin -size +95k -size -100k //사이즈가 95kb 이상 //100kb 이하인것 검색# find /usr/bin -size +95k -size -100k -exec ls -l &#123;&#125; \\; // 윗줄의 결과가 중괄호 속에 들어가서 // ls -l 명령어 실행 시스템 설정123456# yum -y install system-config-date# system-config-date //날짜 설정 가능# nmtui //네트워크 설정# firewall-config CRON과 ATCRON : 주기적으로 반복되는 일을 자동적으로 실행될 수 있도록 실행 42 4 1 ** root run-parts /etc/cron.hourly42 : 42분4 : 4시1 : 1일* : 매 월* : 매 요일 01 * * * * root run-parts /etc/cron.daily맨 뒤는 요일이므로 제외하고매월매일매시1분마다. 02 4 * * * root run-parts /etc/cron.weekly매일 4시 2분마다 실행하라 03 4 * * 0 root run-parts /etc/cron.monthly일요일 4시 3분마다 실행해라 AT : 한번 실행되는것# at 3:00am tomorrow -&gt;내일 새벽 3시# at 11:00pm January 30 -&gt;1월 30일 오후 11시# at now + 1 hours -&gt;한시간 후그 후 예약 명령어 입력후 엔터완료되면 ctrl + d 쉘 스크립트 : 윈도우의 배치파일처럼 실행할 명령어가 쭉 나열되어있는것 CRON 실습123456789101112131415161718192021222324252627282930313233343536# systemctl status crond //크론이 돌고있는지 확인# vi /etc/crontab01 3 15 * * root run-parts /etc/cron.monthly //한줄 추가 매달 매 요일 15일마다 3시 1분에# cd /etc/cron.monthly/# vi myBackup.sh다음을 입력#!/bin/sh // 써줘야함set $(date) //날짜를 읽어옴fname=&quot;backup-$2$3.tar.xz&quot; //$2는 월 $3은 일tar cfJ /backup/$fname /home // /home폴더를 묶음vi 종료# chmod ugo+x myBackup.sh //쉘스크립트 파일 실행권한부여# mkdir /backup //백업파일 보관할 장소 생성# systemctl restart crond //예약하는 작업이 재시작된다.# date 011503002019 //테스트를 위해 시간을 변경 //월일시분년2019. 01. 15. (화) 03:00:00 KST 로 변경됨# systemctl restart crond // 시간적용을 위해 재시작1분이 지나고# ls-l /backup/ AT 실습12345678910111213# rdate -s time.bora.net //서버에 가서 정확한 시간을 세팅함# at 4:00 am tomorrow //내일 새벽 4시에 할 명령어 입력at&gt; yum -y updateat&gt; reboot입력 후 ctrl + d# at -l 예약된것 확인1 Wed Jul 5 04:00:00 2017 a root# atrm 1 //1번 목록 제거 1","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. RPM 사용법, YUM 사용법","slug":"ThisIsLinux7","date":"2017-07-03T09:58:51.000Z","updated":"2018-09-03T05:50:26.052Z","comments":true,"path":"2017/07/03/ThisIsLinux7/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/03/ThisIsLinux7/","excerpt":"","text":"RPM초창기 리눅스는 설치가 어려웠다 .소스코드를 갖고와서 적재적소에 컴파일을 해야했다. 그래서 일반사용자가 사용하기엔 거의 불가능했다. 이러한 이유로 외면을 받았었다. 결국 Redhat에서 RPM(Redhat Package Manager)을 내놓았다. 윈도우의 setup.exe 라고 생각하면 된다. gedit-3.8.3-6.el7.x86_64.rpm 패키지이름 : gedit -&gt; 패키지(프로그램)의 이름버전 : 3.8.3 -&gt; 대게 3자리수로 구성. 주버전, 부버전, 패치버전릴리즈번호 : 6 -&gt; 문제점을 개선할 때마다 붙여지는 번호 //noarch:모든CPUCentOS버전 : el7 -&gt; CentOS에서 배포할 경우에 붙여짐아키텍처 : x86_64 -&gt; 64비트 CPU를 의미 자주쓰는 RPM 명령어 옵션123456789101112131415$ rpm -Uvh 패키지파일이름.rpm // U -&gt; (대문자)패키지가 설치/업그레이드 // v -&gt; 설치진행과정의 확인 // h -&gt; 설치진행과정을 &quot;#&quot;마크로 화면에 출력$ rpm -e 패키지이름 //패키지 삭제$ rpm -qa 패키지이름 //패키지가 설치되었는지 확인$ rpm -qf 파일의 절대경로 // 파일이 어느 패키지에 포함된 것인지 확인$ rpm -qlp 패키지파일이름.rpm //패키지 파일에 어떤 파일들이 포함되었는지 확인$ rpm -qip 패키지파일이름.rpm //패키지 파일의 상세정보 실습12345678910111213$ rpm -qa mc //mc 패키지가 설치되었나 확인$ rpm -Uvh mc-4.8.7-8.el7.x86_64.rpm //설치$ rpm -qa mc //mc 패키지가 설치되었나 확인$ rpm -qi mc //mc 패키지 정보 출력$ rpm -e mc-4.8.7-8.el7.x86_64.rpm //삭제오류: mc-4.8.7-8.el7.x86_64.rpm 패키지가 설치되어 있지 않습니다//설치파일을 삭제하는것이다.!!!!$ rpm -e mc //패키지 이름만으로 삭제 YUM의 등장Yellowdog Updater Modified rpm의 경우 의존성 문제가 존재함. 이를 해결하기 위해 나온것이 YUM의존성 문제란? A를 설치하기 위해 B가 먼저 설치되어있어야 하는것.rpm은 B가 설치되어있지 않을 경우 A패키지 설치를 시도할 경우 B를 설치해야 한다고 알려주기는 하나 대략적으로 알려주고, B또한 다른 패키지에 의존성이 있을수도 있어 불편함을 유발한다. yum은 인터넷이 정상적으로 동작해야 작동함. yum은 의존성이 있는것을 모두 알아서 설치해준다!!! 즉 yum 명령어는 내부적으로 rpm명령을 실행하는것!! yum의 동작과정1.yum install을 입력한다2./etc/yum.repos.d/ 를 참고하여 URL을 확인하고3.전체 패키지 목록 파일을 요청한다(CentOS 7 패키지 저장소로)4.전체 패키지 목록 파일만 다운로드5.설치할 패키지와 관련된 패키지의 이름을 화면에 출력6.y를 입력하면 설치에 필요한 패키지 파일을 요청함7.설치할 패키지 파일을 다운로드해서 자동 설치12345678910111213141516$ yum install 패키지이름 //패키지 설치$ yum -y install 패키지이름 //패키지 설치(y안눌러도 됨)$ yum remove 패키지이름 //패키지 제거$ yum localinstall rpm파일이름.rpm //로컬에 존재하는 rpm으로 설치 // 만약 의존성이 있을경우 그 대상은 레파지토리에서 깐다.$ yum info mc //mc패키지에 관한 정보확인 $ yum groupinstall &quot;패키지 그룹이름&quot; //예로 자바를 깐다면 jdk //이클립스 등 한꺼번에 설치됭$ yum clean all //캐시를 지우는것. //yum이 이상할때 써보자 yum고급실습네트워크를 거치지 않고 마운트 시킨 dvd에서 받는다. 교재 221참고dvd에 없으면 네트워크에서 갖고온다. yum grouplist123456789101112$ yum grouplist //그룹리스트 조회$ yum grouplist hidden //숨겨진것까지 조회//영어로 그룹을 설치하는것이 좋다.. 그러므로$ chvt 2 //2번 가상터미널로 이동$ root password$ yum grouplist hidden &gt; glist.txt //glist.txt로 생성$ chvt 1 //x 윈도모드로 이동 226p 비타민퀴즈223p를 따라 설정 후 yum groupinstall “GNOME Desktop” 입력","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. 파일의 소유권/허가권, 링크","slug":"ThisIsLinux6","date":"2017-07-03T04:33:03.000Z","updated":"2018-09-03T05:50:22.782Z","comments":true,"path":"2017/07/03/ThisIsLinux6/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/03/ThisIsLinux6/","excerpt":"","text":"123# touch sample.txt //빈 파일생성# ls -l-rw-r--r-- 1 root root 0 7월 3 13:35 sample.txt 1.맨앞의 -는 파일의 유형을 의미. -: 일반파일 d: 디렉토리 l: 링크파일 2.rw-r–r–는 세개씩 끊어 읽으면 된다.2-1. 맨앞 세개는 소유자의 파일접근권한 (rw-)즉 소유자는 읽기, 쓰기 가능, 실행 불가 2-2. 두번째는 그룹의 파일접근권한읽기만 가능 2-3. 세번째는 그 외의 사용자의 파일접근권한이다.읽기만 가능또한 rw-r–r–는 3자리씩 끊어서 보면 644로 볼수 있다.rwxrwxrwx는? 666 3.1은 링크의 수 4.root는 파일 소유자 이름 5.root는 파일 소유 그룹이름 6.0은 파일의 크기 7.7월 3 13:35는 마지막 변경 날짜/시간 8.sample.txt는 파일이름 chmod 파일 허가권 변경1234567891011121314151617181920212223242526# chmod 655 sample.txt# ls -l sample.txt-rw-r-xr-x 1 root root 0 7월 3 13:35 sample.txt$ chmod o-x test //일반사용자(o : ordinary)는 -x (x:execute) 실행 못하도록$ ls -l test-rwxrwxrw- 1 centos centos 52 7월 3 13:52 test //마지막 x가 빠짐$ chmod ug-w test //소유주(u: user), 소유그룹(g: group) 쓰기권한 제거$ ls -l test-r-xr-xrw- 1 centos centos 52 7월 3 13:52 test //3번째 6번째 w가 빠짐$ chmod ugo-r test //전부다 읽기권한 제거$ ls -l test ---x--x-w- 1 centos centos 52 7월 3 13:52 test //r이 제거된것 확인$ chmod uo+rw test //소유주, 기타사용자에게 읽기,쓰기 허용$ ls -l test -rwx--xrw- 1 centos centos 52 7월 3 13:52 test//숫자를 넣지 않고 하는것을 심볼릭방법이라 하는데 이것이 더 편할 때가 있다.숫자로 할 경우 기존의 권한도 알아야 하기 때문에.. chown 파일 소유자 변경123# chown centos sample.txt //centos로 소유권을 넘김# ls -l sample.txt-rw-r-xr-x 1 centos root 0 7월 3 13:35 sample.txt //소유권 변경됨 chgrp 파일 소유 그룹 변경123# chgrp centos sample.txt# ls -l sample.txt-rw-r-xr-x 1 centos centos 0 7월 3 13:35 sample.txt chown 파일 소유자, 그룹 변경123# chown root.root sample.txt# ls -l sample.txt-rw-r-xr-x 1 root root 0 7월 3 13:35 sample.txt ./에 대한 이해파일을 실행하기 위해서는 아래의 명령어를 입력해야한다.1# ./파일명./는 왜 붙는것일까?그냥 파일명만 입력하면 찾지못하는데 그 이유는 현재 디렉토리가 경로에 없어서 그렇다.그래서 ./을 넣어주는 것이다. 앞에서 배웠듯이 . 은 현재 디렉토리를 의미하는것을 떠올려보자.즉 ./파일명 는 현재 디렉터리 아래에 있는 파일명을 실행하라는 것이다. su 해당사용자로 로그인1234# su - centos //centos계정으로 로그인 //루트계정일 경우 암호를 묻지않는다. //-를 붙이면 디렉토리가 centos디렉토리로 변경되가 //붙이지 않으면 변경되지 않는다. 실습해보자.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# touch test //test 파일 생성# vi test //이후 명령어(ex ls) 입력 그후 저장후 종료# ./test //test 파일 실행실행되지 않음. # chmod 755 test //실행권한을 모두 준다.# ./test //실행된다.현재 파일의 소유권은 root이다.# chown centos.centos test //소유자,그룹을 변경# su - centos //센토스 사용자로 접근 //이때 암호는 물어보지 않음. 루트에서 이동하는것이므로$ ls -l /root/test //허가 거부가 된다. //왜냐하면 /root 디렉토리가 일반사용자는 들어올수 없게 되어있음. //그러므로 파일을 이동시키거나, /root 디렉토리에 다른사용자가 들어 //올수 있게 허가해주어야 한다. 후자는 좋지 않은 방법이므로 전자를 //활용하자# exit //centos계정 로그아웃# mv test ~centos //centos 홈폴더로 test파일이동.# su - centos //다시 centos로 로그인$ chmod 777 test$ chown root.root test //소유권을 다시 root로 변경 //불가능하다. 어딜감히 root로 변경해 //악성코드를 심고 할 수도 있고..위험함.. //그래서 이 명령어는 루트사용자만 가능!!!$ chmod o-x test //일반사용자(o : ordinary)는 -x (x:execute) 실행 못하도록$ ls -l-rwxrwxrw- 1 centos centos 52 7월 3 13:52 test //마지막에 -가 들어간것을 확인$ chmod ug-w test //소유주(u: user), 소유그룹(g: group) 쓰기권한 제거$ ls -l test-r-xr-xrw- 1 centos centos 52 7월 3 13:52 test //3번째 6번째 w가 빠짐$ chmod ugo-r test //전부다 읽기권한 제거$ ls -l test ---x--x-w- 1 centos centos 52 7월 3 13:52 test //r이 제거된것 확인$ chmod uo+rw test //소유주, 기타사용자에게 읽기,쓰기 허용$ ls -l test -rwx--xrw- 1 centos centos 52 7월 3 13:52 test//숫자를 넣지 않고 하는것을 심볼릭방법이라 하는데 이것이 더 편할 때가 있다.숫자로 할 경우 기존의 권한도 알아야 하기 때문에.. 링크파일의 링크는 하드링크, 심볼릭 링크가 있다.윈도우의 바로가기처럼 연결되어있는것은 심볼릭링크 소프트 링크라 한다. 원본파일이 inode블록(실제 파일정보를 갖고있는것)을 가르키고 inode블록은 원본파일 데이터를 가르킨다. 하드링크파일은 inode를 직접 가르키며심볼링크파일은 새로운 inode를 만들고 새로운 inode는 원본파일 포인터를 하나 더만들고 그것을 가르킨다. 원본파일 포인터는 원본파일을 가르킨다. 교재 201p를 참고하자. 주로 하드링크보다는 심볼릭 링크를 생성한다. 실습해보기1234567891011121314151617181920212223242526272829# mkdir linktest# cd linktest/# vi basefile //아무거나 입력후 저장후 종료//원본파일이 생겼으므로 inode 블록이 생성되었을것이다.# ls -il basefile //inode 번호 확인405679049 -rw-r--r-- 1 root root 34 7월 3 14:36 basefile //405679049이 inode 번호# ln basefile hardlink //하드링크 생성# ln -s basefile softlink //소프트링크생성# ls -il405679049 -rw-r--r-- 2 root root 34 7월 3 14:36 basefile405679049 -rw-r--r-- 2 root root 34 7월 3 14:36 hardlink405679048 lrwxrwxrwx 1 root root 8 7월 3 14:40 softlink -&gt; basefile//basefile inode와 hardlink inode가 같다. softlink의 inode는 새로 만들어서 basefile을 가르킨다.# mv basefile ../ //원본파일을 앞 디렉토리로 이동시킴# ls -il# cat hardlink // 출력이 될까 안될까? //출력이 된다. 그 이유는 원본 inode를 가르키기 때문에!# cat softlink // 출력이 될까 안될까.? //안된다. 원본파일이 없어졌기 때문에.# mv ../basefile //다시 원상복구 시킴 (앞디렉토리로간 basefile 델꼬옴) 12","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. 사용자 및 그룹 관리","slug":"ThisIsLinux5","date":"2017-07-03T02:29:09.000Z","updated":"2018-09-03T05:50:20.339Z","comments":true,"path":"2017/07/03/ThisIsLinux5/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/03/ThisIsLinux5/","excerpt":"","text":"리눅스는 다중 사용자 시스템이다. 즉 서버 한대에 여러명이 접속한다. 그러므로 사용자를 관리하고 그룹을 관리하는게 중요한 이슈이다.기본적으로 rootㄹ는 슈퍼유저가 관리하며 모든 사용자는 하나 이상의 그룹에 소속되어야 한다.사용자는 /etc/passwd에 정의되어 있다.아래의 명령문을 실행시켜 vi 에디터로 확인해보자.1# vi /etc/passwd마지막 줄엔 다음과같은 코드가 존재한다.1centos:x:1000:1000:centos:/home/centos:/bin/bash이에 대해 자세히 알아보자. 1.centos = 사용자가 centos 이다. 2.x = 비밀번호 3.1000 = centos라는 사용자의 ID 4.1000 = centos사용자는 반드시 소속된 그룹이 있어야하는데 이는 소속된 그룹의 ID 즉 그룹번호이다.어떻게 그룹번호를 갖고 그룹명을 알까? /etc/group 파일에 정의되어 있다. 이 파일을 vi 에디터로 열면 그룹이름:그룹비밀번호:그룹의ID(그룹번호)의 형식을 갖는다.centos:x:1000:centos // 그룹이름:그룹비밀번호:그룹의ID(그룹번호)이게 무슨뜻일까? centos라는 사용자가 centos그룹에 속해 있다는 것이다. 마지막 centos 는 생략이 가능하며 신경쓰지 않아도 된다.예를 들면 홍길동이라는 부서에 홍길동 사원이 존재하는것이다. 회사에서는 부서를 만들고 사원을 뽑는다. 마찬가지로 centos도 새로운 사용자를 만들면 사용자 이름과 같은 그룹을 만들고 이 그룹에 해당시킨다.이것과 관련해 실습을 진행해보자.12345678# useradd myuser //유저 등록# tail -5 /etc/passwd //해당파일의 마지막 5줄만 보기myuser:x:1001:1001::/home/myuser:/bin/bash //그룹번호 1001을 기억# tail -5 /etc/group //해당파일의 마지막 5줄만 보기myuser:x:1001: //사용자 이름과 같은 그룹이 만들어졌고 그 그룹에 사용자가 속해있다. 5.centos = 전체이름이다. 생략이 가능하다 6./home/centos centos = 사용자의 홈 디렉토리 7./bin/bash = 사용할 기본 쉘 실습해보자디렉토리 설명/etc/passwd : 사용자 정보가 있음/etc/shadow : 사용자 비밀번호가 있음(비밀번호는 암호화되어서 저장됨)/etc/group : 그룹정보가 있음 실습 1유저 생성, 유저 그룹지정, 그룹생성1234567891011121314151617181920212223242526272829303132333435363738# useradd user1 //user1생성# tail -5 /etc/passwd //생성되었는지 확인user1:x:1001:1001::/home/user1:/bin/bash //잘생성됨# tail -5 /etc/shadow //사용자의 비밀번호를 확인해보자user1:!!:17350:0:99999:7::: //비밀번호를 설정하지 않았지만 암호화 되어있다.# tail -5 /etc/group //사용자의 그룹이 생성되었나 확인해보자user1:x:1001: //잘 생성되었다하지만 바람직하지 않다.! user1의 그룹이 user1이라니 말이되나!다시실습해보자 이번에는 그룹을 먼저 생성하고 사용자를 소속시키자# userdel -r user1 //보통 현업에선 -r옵션을 넣어 디렉토리까진 지우지 않는다. //하지만 실습이므로 과감하게 지운다.# groupadd centosGroup //그룹생성# tail -5 /etc/group //잘생성되었나 확인centosGroup:x:1001: //잘생성됨# useradd -g centosGroup user1 //centosGroup에 소속된 user1생성# useradd -g centosGroup user2 //centosGroup에 소속된 user2생성# tail -5 /etc/passwd //잘 생성되었나 확인.user1:x:1001:1001::/home/user1:/bin/bashuser2:x:1002:1001::/home/user2:/bin/bash //잘 생성되었고 사용자 ID는 다르지만 같은 그룹ID를 갖는다.# passwd user1 //암호지정. 이후 1234 1234입력 //일반사용자는 암호를 8자 미만으로 지정못하지만 //루트사용자는 8자 미만으로 지정해줄수 있다.# passwd user2 //암호지정. 이후 1234 1234입력# tail -5 /etc/shadow //user1,user2의 암호를 보자 //user1,user2의 암호를 1234로 지정하였지만 //암호화된 값이 다르다!! 실습 2x윈도에서 사용자권한관리 - x윈도가 없으면 안되므로 비추12# yum -y install system-config-users //system-config-users패키지 설치# system-config-users //x윈도우 상에서 사용자 관리가 가능하다! 관련 명령어189p 참고1234567891011121314151617181920212223242526-u : ID 지정-g : 그룹지정-d : 홈디렉터리지정-s : 쉘 지정# useradd shkim //새로운 사용자를 추가# passwd shkim //사용자의 비밀번호를 지정하거나 변경# usermod -g root shkim //사용자의 속성을 변경# userdel shkim //사용자는 지우나 디렉토리를 제거하지 않음. //-r 옵션이 존재. 이는 사용자가 사용하던 디렉토리까지 제거# change -m 2 shkim //사용자의 암호를 주기적으로 변경하도록 설정 //-m 2는 최소 이틀이상 써야한다.(189p 참고)# groups // 사용자가 속한 그룹을 보여줌# groupadd newgroup //새로운 그룹을 새성 # groupmod -n newgroup mygroup//그룹의 속성을 변경 newgroup을 mygroup로 변경# groupdel newgroup //그룹을 삭제# gpasswd newgroup //그룹의 암호설정","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. 리눅스 기본 명령어","slug":"ThisIsLinux4","date":"2017-07-02T06:25:50.000Z","updated":"2018-09-03T05:50:17.839Z","comments":true,"path":"2017/07/02/ThisIsLinux4/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/02/ThisIsLinux4/","excerpt":"","text":"기본명령어당연히 알고있어야 하는것들이다! 자연스럽게 사용할줄 알아야함! 폴더 == 디렉토리리눅스는 숨김파일일 경우 파일명 앞에 . 이 붙는다. (폴더도 마찬가지) $ ls -l 명령어를 실행하였을 때-로 시작하면 파일 d로 시작하면 디렉토리 ls 파일 목록보기123456789101112131415$ ls // 파일이나 폴더의 목록을 보는것 윈도우의 dir.$ ls /etc/sysconfig //특정 폴더내의 목록을 보는것$ ls -a //숨김파일까지 보는것.$ ls -l // 자세히 보는것 //-로 시작하면 파일 d로 시작하면 디렉토리$ ls *.cfg //확장자가 cfg인것$ ls ls my* // my로 시작하는것들 조회$ ls -al //숨김파일까지 자세히 조회 // -a, -l 의 결합 cd 디렉토리 이동x윈도가 있으면 편하겠지만 없으면 이동이 명령어로만 가능하기 때문에 익숙해지자. cd 명령어를 쓴 후에는 pwd 를 통해 현재 디렉토리를 보자. 리눅스의 디렉터리 구조를 이해 할 수 있게된다. 1234567891011121314151617181920212223$ cd /etc/sysconfig/$ pwd //현재 디렉터리 위치 출력$ cd / // 최상위폴더로 이동(루트 디렉토리라함) // $ cd / 명령어의 경우 다음 명령창이 아래와 같이 나온다. // [root@localhost /]#$ cd // &quot;/루트 디렉토리&quot;(현재 사용자의 홈폴더)로 이동 // $ cd 명령어의 경우 다음 명령창이 아래와 같이 나온다. // [root@localhost ~]$ cd /etc //루트 디렉토리의 etc로 이동(절대경로)$ cd etc //현재 디렉토리에서 etc로 이동 (상대경로)$ cd .. //현재 디렉토리의 바로 앞 디렉토리로 이동$ cd . //현재 디렉토리 반환$ cd ~centos //해당 사용자의 홈 디렉토리로 이동 //즉 $ cd~사용자 == $ cd 여기서 주의할점!우리가 서버에서 사용하는 계정은 root이라는 점을 잊지말자.$ cd / 명령어를 실행하면 루트 디렉토리 즉 최상위 폴더로 이동하는데 여기서 ls를 입력하면 root 폴더가 하나 있다. 이 두가지를 혼동하는 경우가 많은데 주의 하도록 하자. 루트 디렉토리 그리고 루트 디렉토리에 존재하는 root 폴더는 다르며 루트 디렉토리안의 root 폴더는 root계정이기 때문에 존재하는것이다. 강의에서는 루트 디렉토리 그리고 /root 디렉토리 로 구분한다. ..에 대한 이해다음을 이해해보자1234[root@localhost /]# cd /etc/sysconfig/network-scripts/[root@localhost network-scripts]# cd ../../../root[root@localhost ~]# pwd/root .에 대한 이해다음을 이해해보자이거를 어디다 쓸까 싶지만 현재 디렉토리의 어떤것을 실행하거나 어떤 것을 현재 디렉토리로 옮길 때 사용된다.123[root@localhost ~]# cd .[root@localhost ~]# pwd/root touch 비어있는 파일 생성1$ touch //비어있는 파일 생성 rm 파일 삭제123$ rm file1 // 삭제명령어 (삭제할것인지 재확인함)$ rm -f file1 // 삭제 명령어(삭제할것인지 확인하지 않고 삭제) cp 복사123$ cp file3 file4 //file3가 file4로 복사됨$ cp -r /etc/sysconfig . // /etc/sysconfig폴더를 현재 폴더에 복사한다. -r은 디렉토리 복사일 때 필요함 mv 이동 및 파일명 변경123$ mv myfile3.txt /root/sysconfig //myfile3.txt파일을 /root/sysconfig 로 이동$ mv file file3 //파일이름을 file에서 file3로 변경 mkdir 디렉토리 생성1234$ mkdir folder1 //folder1 디렉토리 생성$ mkdir -p dir1/dir2/dir3 // dir1/dir2/dir3 디렉토리를 생성 // 디렉토리가 3개가 만들어지는것이 아니라 dir1 안에 dir2 안에 dir3가 만들어진다. rmdir 디렉토리 제거1234567$ rmdir folder1 //디렉토리 제거 (폴더가 비어있을 경우 가능)$ rmdir -r folder1 //내부에 파일이 있는 디렉토리 제거 //(안에 들어있는 파일 하나하나 지울것인지 다물어본다.)$ rm -rf dir1 //묻지도 따지지도 않고 dir1 디렉토리 제거 //매우 위험하다!! 주의해서 사용 cat 파일 읽기사실 vi를 써도 되지만 그게 귀찮을 떄 사용1$ cat anaconda.ks.cfg head 파일 읽기맨 위의 10줄만 보기1$ head anaconda-ks.cfg tail 파일 읽기맨 밑의 10줄만 보기1$ tail anaconda-ks.cfg more,less 페이지 단위로 읽기페이지 단위로 끊어 읽기 스페이스는 다음페이지 B는 이전페이지 종료하려면 Q123$ more anaconda-ks.cfg$ less anaconda-ks.cfg //less more보다 몇가지 명령어가 더 존재함 file 파일이 어떤 파일인지 확인1$ file file1 //디렉터리인지, 링크인지, 비었는지 등을 알려준다. $ file /dev/cdrom 은 링크이다. 내 환경에서는 sr0을 가르키지만 다를 수 있다는 점을 알고있자. clear1$ clear //화면을 깨끗하게 해준다.","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. vi에디터, CD/DVD마운트","slug":"ThisIsLinux3","date":"2017-07-02T04:13:19.000Z","updated":"2018-09-03T05:50:15.264Z","comments":true,"path":"2017/07/02/ThisIsLinux3/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/02/ThisIsLinux3/","excerpt":"","text":"에디터gedit / vi 로 나뉜다. gedit는 윈도우의 메모장으로 생각하면 되며 단순하다. vi는 리눅스에서 자주 사용되므로 반드시 익혀야 한다. gedit1234$ gedit //gedit 실행 //윈도우 + 스페이스 : 한영전환$ gedit 파일명 // 파일열기 vi 에디터x윈도우가 설치되지 않은곳에서도 사용 가능하기에 공통적으로 사용가능하다!초기 실행시 vi에디터는 명령모드이다. 즉 입력이 불가능한 상태이다. 새파일 작성시 , 수정시 12345678$ vi 파일명 //vi 에디터가 실행된다.i 또는 a 입력 //이후 편집, 입력작업진행esc //작업이 끝난 후 명령모드로 변경:wq //저장하고 종료한다.:q! //수정사항 무시하고 종료.코드의 행 번호를 확인하고 싶을경우1$ :set number swp 파일?중간에 작업을 하다 터미널이 비정상적으로 종료될 경우 swp파일이 생성된다. vi를 실행하면 에러가 뜨는데 엔터를 누르면 작업이 가능하다. 이 파일을 확인하기 위해서는 다음명령어를 입력한다.1$ ls -a //숨김파일까지 조회 그 후 파일을 swp 파일을 지우려면 다음을 입력한다.1$ rm .myfile3.txt.swp 도움말기능도움말 사용방법1$ mas ls //ls에 대한 도움말을 확인 . 스페이스바로 페이지 이동가능 마운트물리적인 장치와 디렉터리를 연결시켜주는 과정무슨소리지? 윈도우는 CD를 넣으면 D 드라이드 등으로 연결시켜 주지만 리눅스는 이과정이 없어서 특정 디렉토리로 연결시켜 주는것이다. X윈도우에서 가능하며, 텍스트 모드에서 가능하다1.우선 vmware상으로 cd를 삽입해야 하므로 그 과정을 거친다. 좌측상단 Player을 누르고 Removable Decices -&gt; CD/DVD -&gt; Setting 을 들어간다.혹은 우측상단 CD 모양 누르고 Setting 2.CD/DVD 탭으로 가서 Connected 키고 Use ISO…. 에 iso 이미지 선택 3.자동으로 인식이 되는데???? 리눅스는 자동으로 안된다며…하지만 이게 되는 리눅스가 있고 안되는게 있다. 또한 텍스트 모드는 자동으로 인식이 되지 않으므로 수동으로 연습하는 것이 필요! 마운트 사용법사전지식 :dvd장치의 경로 : /dev/cdrom보통 /media/cdrom 디렉토리를 마운트 할 떄 많이씀 12345678910111213141516171819$ umount /dev/cdrom //마운트 된것을 끊는것. 연결이 되지 않았을 경우 오류메시지가 나온다. 하지만 상관없다.$ ls /media //마운트 대상 디렉터리를 생성하기 전에 존재유무 확인$ mkdir /media/cdrom //마운트 대상 디렉토리 생성$ mount /dev/cdrom /media/cdrom //마운트!$ cd /media/cdrom //디렉토리 이동$ ls //마운트가 잘 되었는지 확인$ umount /dev/cdrom //마운트 끊기 하지만 에러가 난다. 현재 cdrom 안에 존재하기 때문에.$ cd // 홈디렉토리로 이동$ umount /dev/cdrom //마운트 끊기 재시도$ ls /media/cdrom //정상적으로 끊어진것을 확인 ISO 파일 제작p180 보고 진행하세요~ 앞으로 사용할 일은 없지만 가볍게 실습해보세요ISO 파일을 생성하는 명령어는 genisoimage 이다. 또 iso 파일을 CD로 굽기 위한 명령어는 cdrecord이며 DVD로 굽는 명령어는 growisofs 이다. 먼저 아래의 명령어로 패키지가 설치되어있는지 확인해보자.1$ rpm -qa 패키지이름설치되어있지 않다면1$ yum -y install 패키지명 으로 설치를 한다. 그 후 아래와 같이 입력하자. /boot디렉토리의 모든 파일을 test1.iso파일로 만드는 것이다.-r -J 는 8글자 이상의 파일 이름 및 대소문자를 구분해서 인식하는 옵션이며 -o는 출력할 파일을 위한 옵션이다.1$ genisoimage -r -J -o test1.iso /boot 테스트 해보기 위해 디렉토리를 만들고 마운트 시킨다.1234$ mkdir /media/iso$ mount -o loop test1.iso /media/iso$ ls -l /media/iso$ ls -l /boot 테스트를 했으면 마운트를 취소시켜준다1$ umount /media/iso","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. 시작과종료, 가상콘솔, 런레벨, 자동완성","slug":"ThisIsLinux2","date":"2017-07-01T13:53:50.000Z","updated":"2018-09-03T05:50:13.099Z","comments":true,"path":"2017/07/01/ThisIsLinux2/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/01/ThisIsLinux2/","excerpt":"","text":"참고사항lrwxrwxrwx. 어쩌구가 있을경우 맨앞의 l은 링크파일임을 의미한다. 윈도우의 바로가기를 생각하자! 종료관련 명령어리눅스는 기본개념이 멀티유저 이므로 함부러 누군가 종료하거나 재시작하면 문제의 소지가 있다. ex) 네이버 서버를 누군가 종료시킨다면? 리눅스를 서버로 사용할 경우 리눅스는 종료가 아닌 로그아웃이 일반적인 개념이다! 12345678910111213141516171819202122$ shutdown -P now // 종료$ shutdown -P +10 //10분후에 종료$ shutdown -c //종료예약한것 취소$ shutdown -r 23:00 //23시에 재부팅$ shutdown -r +10 //10분후에 재부팅$ shutdown -c // 리부팅예약한것 취소$ shutdown -k +15 //20분 후에 종료된다는 메세지가 날라감 //루트를 제외한 모든 사용자에게.. //실제 종료는 안됨. //필요한 이유: 서버에 많은 사용자가 접속하였을 경우 사용자들의 로그아웃을 유도.$ init 0~6 // 0-종료모드 2-멀티유저모드 5-그래픽모드의 다중사용자모드 6-리부트모드$ startx //x윈도우 모드로 변경 주의) 예로 단순히 init4에서 init1로가는것과 다르다. //명령어 모드에서 x윈도우 모드로 변경되는것 가상콘솔 명령어CentOS는 6개의 가상콘솔을 제공하는데 ctrl+alt+F2~F6으로 이동이 가능하다. F1은 X윈도우 모드이다. 1$ chvt 1~6 입력 //가상콘솔 이동 자동완성일부만 입력하고 탭을 누르면 자동완성된다.12345678910$ /abcdef를 입력하고자 할 경우$ /abc만 입력하고 탭키를 누르면$ /abcdef 가 입력된다.먄약 abcde, abcdef 라는 디렉토리가 존재할 경우에는$ /abc입력 후 탭키를 누르면 자동완성이 되지않는다. 이 경우 탭키를 두번누르면 abcde, abcdef 라는 디렉토리가 있다는 사실을 알려준다. 히스토리123$ history //자신이 입력했던 명령어들이 출력된다.$ history //히스토리 리스트를 제거한다.","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"리눅스 명령어","slug":"Instruction","date":"2017-07-01T04:57:06.000Z","updated":"2018-09-03T05:50:02.002Z","comments":true,"path":"2017/07/01/Instruction/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/01/Instruction/","excerpt":"","text":"참고사항 $: 일반사용자 #: 루트사용자 명령어123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228$ halt -p // 종료$ gedit 파일명 //편집기 열기$ ifconfig //윈도우 ipconfig와 동일$ reboot //리부트 명령어$ su - //루트사용자의 권한을 얻음(폴더가 이동됨)$ su //루트사용자의 권한을 얻음(폴더 이동되지 않고)$ setfont sun12x22 //글자크기 변경$ vi 파일명 //vi 에디터 열기$ ip addr //ip 확인$ clear //콘솔창 초기화$ yum 프로그램 //프로그램 설치$ cd //홈디렉터리로 이동$ shutdown -P now // 종료$ shutdown -P +10 //10분후에 종료$ shutdown -c //종료예약한것 취소$ shutdown -r 23:00 //23시에 재부팅$ shutdown -r +10 //10분후에 재부팅$ shutdown -c // 리부팅예약한것 취소$ shutdown -k +15 //20분 후에 종료된다는 메세지가 날라감 //루트를 제외한 모든 사용자에게.. //실제 종료는 안됨. //필요한 이유: 서버에 많은 사용자가 접속하였을 경우 사용자들의 로그아웃을 유도.$ init 0~6 // 0-종료모드 2-멀티유저모드 5-그래픽모드의 다중사용자모드 6-리부트모드$ startx //x윈도우 모드로 변경 주의) 예로 단순히 init4에서 init1로가는것과 다르다. //명령어 모드에서 x윈도우 모드로 변경되는것$ chvt 1~6 입력 //가상콘솔 이동$ gedit //gedit 실행 //윈도우 + 스페이스 : 한영전환$ gedit 파일명 // 파일열기$ vi 파일명 //vi 에디터가 실행된다.i 또는 a 입력 //이후 편집, 입력작업진행esc //작업이 끝난 후 명령모드로 변경:wq //저장하고 종료한다.:q! //수정사항 무시하고 종료$ :set number //코드의 행번호 확인$ ls -a //숨김파일까지 조회$ rm .myfile3.txt.swp //파일삭제$ mas ls //ls에 대한 도움말을 확인 . 스페이스바로 페이지 이동가능$ umount /dev/cdrom //마운트 된것을 끊는것. 연결이 되지 않았을 경우 오류메시지가 나온다.$ mount /dev/cdrom /media/cdrom //마운트!$ rpm -qa 패키지이름 //패키지 설치여부 확인$ yum -y install 패키지명 으로 설치를 한다.$ ls // 파일이나 폴더의 목록을 보는것 윈도우의 dir.$ ls /etc/sysconfig //특정 폴더내의 목록을 보는것$ ls -a //숨김파일까지 보는것.$ ls -l // 자세히 보는것 //-로 시작하면 파일 d로 시작하면 디렉토리$ ls *.cfg //확장자가 cfg인것$ ls ls my* // my로 시작하는것들 조회$ ls -al //숨김파일까지 자세히 조회 // -a, -l 의 결합$ cd /etc/sysconfig/$ pwd //현재 디렉터리 위치 출력$ cd / // 최상위폴더로 이동(루트 디렉토리라함) // $ cd / 명령어의 경우 다음 명령창이 아래와 같이 나온다. // [root@localhost /]#$ cd // &quot;/루트 디렉토리&quot;(현재 사용자의 홈폴더)로 이동 // $ cd 명령어의 경우 다음 명령창이 아래와 같이 나온다. // [root@localhost ~]$ cd /etc //루트 디렉토리의 etc로 이동(절대경로)$ cd etc //현재 디렉토리에서 etc로 이동 (상대경로)$ cd .. //현재 디렉토리의 바로 앞 디렉토리로 이동$ cd . //현재 디렉토리 반환$ cd ~centos //해당 사용자의 홈 디렉토리로 이동 //즉 $ cd~사용자 == $ cd $ touch //비어있는 파일 생성$ rm file1 // 삭제명령어 (삭제할것인지 재확인함)$ rm -f file1 // 삭제 명령어(삭제할것인지 확인하지 않고 삭제)$ cp file3 file4 //file3가 file4로 복사됨$ cp -r /etc/sysconfig . // /etc/sysconfig폴더를 현재 폴더에 복사한다. -r은 디렉토리 복사일$ mv myfile3.txt /root/sysconfig //myfile3.txt파일을 /root/sysconfig 로 이동$ mv file file3 //파일이름을 file에서 file3로 변경$ mkdir folder1 //folder1 디렉토리 생성$ mkdir -p dir1/dir2/dir3 // dir1/dir2/dir3 디렉토리를 생성 // 디렉토리가 3개가 만들어지는것이 아니라 dir1 안에 dir2 안에 dir3가 만들어진다.$ rmdir folder1 //디렉토리 제거 (폴더가 비어있을 경우 가능)$ rmdir -r folder1 //내부에 파일이 있는 디렉토리 제거 //(안에 들어있는 파일 하나하나 지울것인지 다물어본다.)$ rm -rf dir1 //묻지도 따지지도 않고 dir1 디렉토리 제거 //매우 위험하다!! 주의해서 사용$ cat anaconda.ks.cfg // 파일을 읽기$ head anaconda-ks.cfg //위에 10줄만 읽기$ head -5 anaconda-ks.cfg //위에 5줄만 읽기$ tail anaconda-ks.cfg //아래 10줄만 읽기$ more anaconda-ks.cfg //페이지 단위로 끊어읽기$ less anaconda-ks.cfg //페이지 단위로 끊어읽기 less가 more보다 몇가지 명령어가 더 존재함$ file file1 //디렉터리인지, 링크인지, 비었는지 등을 알려준다.# userdel -r user1 //보통 현업에선 -r옵션을 넣어 디렉토리까진 지우지 않는다. //하지만 실습이므로 과감하게 지운다.# groupadd centosGroup //그룹생성# useradd user1 //user1생성# useradd -g centosGroup user1 //centosGroup에 소속된 user1생성# useradd -g centosGroup user2 //centosGroup에 소속된 user2생성# passwd shkim //사용자의 비밀번호를 지정하거나 변경# usermod -g root shkim //사용자의 속성을 변경# userdel shkim //사용자는 지우나 디렉토리를 제거하지 않음. //-r 옵션이 존재. 이는 사용자가 사용하던 디렉토리까지 제거# change -m 2 shkim //사용자의 암호를 주기적으로 변경하도록 설정 //-m 2는 최소 이틀이상 써야한다.(189p 참고)# groups // 사용자가 속한 그룹을 보여줌# groupadd newgroup //새로운 그룹을 새성 # groupmod -n newgroup mygroup//그룹의 속성을 변경 newgroup을 mygroup로 변경# groupdel newgroup //그룹을 삭제# gpasswd newgroup //그룹의 암호설정$ chmod o-x test //일반사용자(o : ordinary)는 -x (x:execute) 실행 못하도록$ ls -l test-rwxrwxrw- 1 centos centos 52 7월 3 13:52 test //마지막 x가 빠짐$ chmod ug-w test //소유주(u: user), 소유그룹(g: group) 쓰기권한 제거$ ls -l test-r-xr-xrw- 1 centos centos 52 7월 3 13:52 test //3번째 6번째 w가 빠짐$ chmod ugo-r test //전부다 읽기권한 제거$ ls -l test ---x--x-w- 1 centos centos 52 7월 3 13:52 test //r이 제거된것 확인$ chmod uo+rw test //소유주, 기타사용자에게 읽기,쓰기 허용$ ls -l test -rwx--xrw- 1 centos centos 52 7월 3 13:52 test//숫자를 넣지 않고 하는것을 심볼릭방법이라 하는데 이것이 더 편할 때가 있다.숫자로 할 경우 기존의 권한도 알아야 하기 때문에..# chown centos sample.txt //centos로 소유권을 넘김# ls -l sample.txt-rw-r-xr-x 1 centos root 0 7월 3 13:35 sample.txt //소유권 변경됨# chgrp centos sample.txt //파일소유그룹 변경# ls -l sample.txt-rw-r-xr-x 1 centos centos 0 7월 3 13:35 sample.txt# chown root.root sample.txt //파일 소유자, 그룹 변경# ls -l sample.txt-rw-r-xr-x 1 root root 0 7월 3 13:35 sample.txt# su - centos //centos계정으로 로그인 //루트계정일 경우 암호를 묻지않는다. //-를 붙이면 디렉토리가 centos디렉토리로 변경되가 //붙이지 않으면 변경되지 않는다.# ps -ef | grep dnsmasq //dnsmasq 프로세스 번호 확인# kill -9 xxxx //xxxx프로세스 kill","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"리눅스 명령어","slug":"리눅스-명령어","permalink":"http://KKimSangHeon.github.io/tags/리눅스-명령어/"}]},{"title":"리눅스 에러","slug":"LinuxError","date":"2017-07-01T04:45:37.000Z","updated":"2018-09-03T05:50:10.132Z","comments":true,"path":"2017/07/01/LinuxError/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/01/LinuxError/","excerpt":"","text":"증상:Virtualized performance counters are not supported on the host CPU type. Module VPMC power on failed. Failed to start the virtual machine 이라는 에러메세지 출력. 해결법:.vmx 파일을 열고 vpmc.enable 부분을 “FALSE”로 수정. 증상:quotaoff: command not found , 쿼터에 대한 명령어가 실행이 안됨. 해결법:1# yum install quota 증상:ifconfig가 먹히질 않는다. 해결법1# yum install net-tools 방화벽 설정dns 방화벽 설정을 허용한다고 가정. 해결법12# firewall-cmd --permanent --add-service=dns //방화벽 설정 허용# firewall-cmd --reload //설정내용 적용 증상:받고싶은 패키지가 있는데 레드헷전용이다. 해결법1# yum -y install epel-release //레드헷에 접속해서 다운받을수 있도록 설치 증상: vsftpd를 사용하는데 너무 느리다. 해결법123456# vi /etc/vsftpd/vsftpd.conf# local_max_rate=0# systemctl restart vsftpd","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux Error","slug":"Linux-Error","permalink":"http://KKimSangHeon.github.io/tags/Linux-Error/"}]},{"title":"BinarySearch","slug":"BinarySearch","date":"2017-06-30T10:38:20.000Z","updated":"2018-09-03T05:49:11.759Z","comments":true,"path":"2017/06/30/BinarySearch/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/BinarySearch/","excerpt":"","text":"이진탐색데이터의 정렬이 선행되어야 한다. 시간복잡도는 O(log2n) 이다.BinarySearch.c 재귀적인 방법12345678910111213141516int ISearch(int ar[], int first, int last, int target)&#123; int mid; if(first &gt; last) return -1; // -1의 반환은 탐색의 실패를 의미 mid=(first+last) / 2 ; if(ar[mid] == target) return mid; // 탐색된 타겟의 인덱스 값 반환 else if(target &lt; ar[mid]) return ISearch(ar, first, mid-1, target); else return ISearch(ar, mid+1, last, target);&#125; BinarySearch.c 반복문 이용123456789101112131415161718BinarySearch(int DataSet[], int Size, int target)&#123; int Left,Right,Mid; Left=0; Right=Size-1; while(Left&lt;=Right)&#123; Mid=(Left+Rigth) / 2 ; if( Target==DataSet[Mid]) return DataSet[Mid]; else if(Target&gt;DataSet[Mid]) Left=Mid+1; else Right=Mid-1; &#125; return NULL;&#125; 이진탐색의 경우 비교대상이 되는 mid값을 단순히 (first+last)/2로 설정한다.그러나 보간 탐색의 경우 mid 값 설정방식이 다르며 이진탐색보다 우수한 성능을 보인다. 보간탐색탐색대상이 앞쪽에 위치 할 경우 앞쪽에서 탐색을 시작하고 뒤쪽에 위치할 경우 뒤쪽에서 탐색을 시작한다.이진탐색보다 우수하다.ISearch.c12345678910111213141516int ISearch(int ar[], int first, int last, int target)&#123; int mid; if(ar[first]&gt;target || ar[last]&lt;target) return -1; // 이진 탐색과의 차이점을 반영한 문장 mid = ((double)(target-ar[first]) / (ar[last]-ar[first]) *(last-first)) + first; if(ar[mid] == target) return mid; // 탐색된 타겟의 인덱스 값 반환 else if(target &lt; ar[mid]) return ISearch(ar, first, mid-1, target); else return ISearch(ar, mid+1, last, target);&#125; 보간탐색의 mid값 계산 방법 그림[1]에서 arr[s]는 찾는값을 의미함. 참고 : 윤성우의 열혈 자료구조","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://KKimSangHeon.github.io/categories/Algorithm/"},{"name":"Search","slug":"Algorithm/Search","permalink":"http://KKimSangHeon.github.io/categories/Algorithm/Search/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/tags/Data-Structure/"},{"name":"Search","slug":"Search","permalink":"http://KKimSangHeon.github.io/tags/Search/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"http://KKimSangHeon.github.io/tags/BinarySearch/"}]},{"title":"2장. CentOS 리눅스 소개","slug":"ThisIsLinux1","date":"2017-06-30T09:55:52.000Z","updated":"2018-09-03T05:49:54.370Z","comments":true,"path":"2017/06/30/ThisIsLinux1/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/ThisIsLinux1/","excerpt":"","text":"리눅스 리눅스란?리눅스 = 무료 유닉스 라 생각하면 된다.1991 ‘리누스 토르발스’가 버전 0.01을 최초로 완성. 리누스 토르발스는 커널(kernel)만 개발함(여기서 커널은 자동차 엔진이라고 보면된다.)모든 배포판은 리누스 토르발스가 개발한 커널을 갖고 사람들이 만들어진것이다. CentOS 또한 마찬가지..자동차로 비유하자면 A,B,C 회사가 하나의 엔진을 사용하여 각기 다른 자동차를 만들어내놓음.우리가 공부할 CentOS의 커널버전은 3.17.4인데 변경이 가능하다.!자동차로 비교하면 자동차를 그대로 두고 엔진만 변경하는것.이를 커널 업그레이드 라고 한다. GNU 프로젝트?GNU 프로젝트 - GPL(General Public License[자유 소프트웨어의 수정과 공유의 자유를 보장하는것.]) 에 따라 소스를 배포하여 공개하고 그것을 더 개선하여 배포하고 의 반복.. 리눅스 또한 마찬가지. 그래서 현재는 유닉스 보다 더 좋다고 말하는 사람들이 많다. 여기서 재미있는점 하나. 소스코드를 무료로 얻어서 기능개선 후 판매는 가능하다. 그러나 GPL에 의해 소스코드는 공유해야한다는점. 레드햇 리눅스와 CentOS 리눅스?전 세계적으로 유명하며 기업에서 많이쓴다. 무료버전은 없으며 상용버전만 존재한다. 하지만 GPL에 의해 소스코드는 공개되어 있어 레드햇 엔터프라이즈 리눅스의 소스코드를 그대로 가져와 로고만 바꾼것이 CentOS!!결국 레드햇 리눅스 == CentOS 리눅스","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"기수정렬 (RadixSort)","slug":"RadixSort","date":"2017-06-30T05:36:34.000Z","updated":"2018-09-03T05:49:36.715Z","comments":true,"path":"2017/06/30/RadixSort/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/RadixSort/","excerpt":"","text":"기수정렬버켓에 데이터를 작은 수 부터 넣고 빼내어 정렬하는 방식이다.기수정렬의 시간복잡도는 O(ln)이며 l은 버켓의 크기를 의미한다. red, why, few 정렬가능 - 버킷 3개 필요10,161,18,1 가능 - 버킷 3개 필요proffesor , red , why 불가능125 , -101, 167, -505 불가능 ##참고사항 1의자리 수 구하기-num/1%1010의자리 수 구하기 -num/10%10100의 자리 수 구하기 -num/100%10 InsertionSort.c123456789101112131415161718192021222324252627282930313233343536373839void RadixSort(int arr[], int num, int maxLen) // maxLen은 가장 긴 데이터의 길이&#123; Queue buckets[BUCKET_NUM]; int bi; int pos; int di; int divfac = 1; int radix; // 총 10개의 버킷 초기화 for(bi=0; bi&lt;BUCKET_NUM; bi++) QueueInit(&amp;buckets[bi]); // 가장 긴 데이터의 길이만큼 반복 for(pos=0; pos&lt;maxLen; pos++) &#123; // 정렬 대상의 수만큼 반복 for(di=0; di&lt;num; di++) &#123; // N번째 자리의 숫자 추출 radix = (arr[di] / divfac) % 10; // 추출한 숫자를 근거로 데이터 버킷에 저장 Enqueue(&amp;buckets[radix], arr[di]); &#125; // 버킷 수만큼 반복 for(bi=0, di=0; bi&lt;BUCKET_NUM; bi++) &#123; // 버킷에 저장된 것 순서대로 다 꺼내서 다시 arr에 저장 while(!QIsEmpty(&amp;buckets[bi])) arr[di++] = Dequeue(&amp;buckets[bi]); &#125; // N번째 자리의 숫자 추출을 위한 피제수의 증가 divfac *= 10; &#125;&#125; 참고 : 윤성우의 열혈 자료구조","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://KKimSangHeon.github.io/categories/Algorithm/"},{"name":"Sort","slug":"Algorithm/Sort","permalink":"http://KKimSangHeon.github.io/categories/Algorithm/Sort/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/tags/Data-Structure/"},{"name":"Sort","slug":"Sort","permalink":"http://KKimSangHeon.github.io/tags/Sort/"},{"name":"Radix Sort","slug":"Radix-Sort","permalink":"http://KKimSangHeon.github.io/tags/Radix-Sort/"}]},{"title":"퀵정렬 (QuickSort)","slug":"QuickSort","date":"2017-06-30T05:36:18.000Z","updated":"2018-09-03T05:49:32.953Z","comments":true,"path":"2017/06/30/QuickSort/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/QuickSort/","excerpt":"","text":"퀵정렬퀵 정렬 O(nlog2n)- 피벗을 정하여 분할하여 정복.. 피벗을 선택 할때 3개를 선택하여 평균치를 구하여 구하면 더 효율적으로 피벗을 정할 수 있다.피벗이 잘 선택될 경우 시간복잡도가 줄어든다. 최악의 경우 O(n^2)이 될 수 있다 (피벗값이 많이 안좋을 경우) O(nlog2n)의 시간복잡도를 갖는 다른 정렬 알고리즘 보다 평균적으로 빠르다.why ? 데이터 이동이 상대적으로 작고 병합정렬과 같이 별도의 메모리 공간을 요구하지 않기 때문에.. 나만의 요약! : 피벗값을 기준으로 처음지점부터 시작한 반복문은 피벗보다 작은값을 찾고 뒤에서 시작한 반복문은 피벗보다 큰값을 찾아 서로 바꾼다. ( 단 피벗을 지나치치 않음) QuickSort.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void Swap(int arr[], int idx1, int idx2)&#123; int temp = arr[idx1]; arr[idx1] = arr[idx2]; arr[idx2] = temp;&#125;int Partition(int arr[], int left, int right)&#123; int pivot = arr[left]; // 피벗의 위치는 가장 왼쪽! int low = left+1; int high = right; while(low &lt;= high) // 교차되지 않을 때까지 반복 &#123; while(pivot &gt; arr[low]) low++; while(pivot &lt; arr[high]) high--; /* while(pivot &gt;= arr[low] &amp;&amp; low &lt;= right) low++; while(pivot &lt;= arr[high] &amp;&amp; high &gt;= (left+1)) high--; */ if(low &lt;= high) // 교차되지 않은 상태라면 Swap 실행 Swap(arr, low, high); // low와 high가 가리키는 대상 교환 &#125; Swap(arr, left, high); // 피벗과 high가 가리키는 대상 교환 return high; // 옮겨진 피벗의 위치 정보 반환&#125;void QuickSort(int arr[], int left, int right)&#123; if(left &lt;= right) &#123; int pivot = Partition(arr, left, right); // 둘로 나눠서 QuickSort(arr, left, pivot-1); // 왼쪽 영역을 정렬 QuickSort(arr, pivot+1, right); // 오른쪽 영역을 정렬 &#125;&#125; 참고 : 윤성우의 열혈 자료구조","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://KKimSangHeon.github.io/categories/Algorithm/"},{"name":"Sort","slug":"Algorithm/Sort","permalink":"http://KKimSangHeon.github.io/categories/Algorithm/Sort/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/tags/Data-Structure/"},{"name":"Sort","slug":"Sort","permalink":"http://KKimSangHeon.github.io/tags/Sort/"},{"name":"Quick Sort","slug":"Quick-Sort","permalink":"http://KKimSangHeon.github.io/tags/Quick-Sort/"}]},{"title":"병합정렬 (MergeSort)","slug":"MergeSort","date":"2017-06-30T05:36:10.000Z","updated":"2018-09-03T05:49:26.329Z","comments":true,"path":"2017/06/30/MergeSort/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/MergeSort/","excerpt":"","text":"병합정렬재귀적으로 분할하여 병합하는 방식으로 재귀적으로 모든 요소들을 쪼갠 후 합쳐나간다. 시간복잡도는 O(nlog2n))이다. MergeSort.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void MergeTwoArea(int arr[], int left, int mid, int right)&#123; int fIdx = left; int rIdx = mid+1; int i; int * sortArr = (int*)malloc(sizeof(int)*(right+1)); int sIdx = left; while(fIdx&lt;=mid &amp;&amp; rIdx&lt;=right) &#123; if(arr[fIdx] &lt;= arr[rIdx]) sortArr[sIdx] = arr[fIdx++]; else sortArr[sIdx] = arr[rIdx++]; sIdx++; &#125; if(fIdx &gt; mid) &#123; for(i=rIdx; i&lt;=right; i++, sIdx++) sortArr[sIdx] = arr[i]; &#125; else &#123; for(i=fIdx; i&lt;=mid; i++, sIdx++) sortArr[sIdx] = arr[i]; &#125; for(i=left; i&lt;=right; i++) arr[i] = sortArr[i]; free(sortArr);&#125;void MergeSort(int arr[], int left, int right)&#123; int mid; if(left &lt; right) &#123; // 중간 지점을 계산한다. mid = (left+right) / 2; // 둘로 나눠서 각각을 정렬한다. MergeSort(arr, left, mid); MergeSort(arr, mid+1, right); // 정렬된 두 배열을 병합한다. MergeTwoArea(arr, left, mid, right); &#125;&#125; 참고 : 윤성우의 열혈 자료구조","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://KKimSangHeon.github.io/categories/Algorithm/"},{"name":"Sort","slug":"Algorithm/Sort","permalink":"http://KKimSangHeon.github.io/categories/Algorithm/Sort/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/tags/Data-Structure/"},{"name":"Sort","slug":"Sort","permalink":"http://KKimSangHeon.github.io/tags/Sort/"},{"name":"Merge Sort","slug":"Merge-Sort","permalink":"http://KKimSangHeon.github.io/tags/Merge-Sort/"}]},{"title":"힙정렬 (HeapSort)","slug":"HeapSort","date":"2017-06-30T05:35:38.000Z","updated":"2018-09-03T05:49:20.343Z","comments":true,"path":"2017/06/30/HeapSort/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/HeapSort/","excerpt":"","text":"힙 정렬힙을 만들어서 힙에 넣고 빼는것으로서 시간복잡도는 O(nlog2n) 이다. BubbleSort.c12345for(i=0;i&lt;n;i++) HInsert(&amp;heap,arr[i]);for(i=0;i&lt;n;i++) arr[i]=HDelete(&amp;heap); 참고 : 윤성우의 열혈 자료구조","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://KKimSangHeon.github.io/categories/Algorithm/"},{"name":"Sort","slug":"Algorithm/Sort","permalink":"http://KKimSangHeon.github.io/categories/Algorithm/Sort/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/tags/Data-Structure/"},{"name":"Sort","slug":"Sort","permalink":"http://KKimSangHeon.github.io/tags/Sort/"},{"name":"Heap Sort","slug":"Heap-Sort","permalink":"http://KKimSangHeon.github.io/tags/Heap-Sort/"}]},{"title":"삽입정렬 (InsertionSort)","slug":"InsertionSort","date":"2017-06-30T05:35:28.000Z","updated":"2018-09-03T05:49:23.449Z","comments":true,"path":"2017/06/30/InsertionSort/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/InsertionSort/","excerpt":"","text":"삽입정렬1~n까지 정렬해 나감 1~2 정렬 12묶음 3정렬 13묶음 4정렬첫 번째 데이터는 정렬이 되어있다고 봄. 그래서 i=0이아닌 1부터 시작.시간복잡도는 O(n^2) 이다. InsertionSort.c123456789101112for(i=1;i&lt;n;i++)&#123; insData=arr[i]; //정렬대상을 insData에 저장 for(j=i-1;i&gt;=0;j--) &#123; if(arr[j]&gt;insData) arr[j+1]=arr[j]; else break; &#125; arr[j+1]=insData;&#125; 참고 : 윤성우의 열혈 자료구조","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://KKimSangHeon.github.io/categories/Algorithm/"},{"name":"Sort","slug":"Algorithm/Sort","permalink":"http://KKimSangHeon.github.io/categories/Algorithm/Sort/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/tags/Data-Structure/"},{"name":"Sort","slug":"Sort","permalink":"http://KKimSangHeon.github.io/tags/Sort/"},{"name":"Insertion Sort","slug":"Insertion-Sort","permalink":"http://KKimSangHeon.github.io/tags/Insertion-Sort/"}]},{"title":"선택정렬 (SelectionSort)","slug":"SelectionSort","date":"2017-06-30T04:59:38.000Z","updated":"2018-09-03T05:49:40.089Z","comments":true,"path":"2017/06/30/SelectionSort/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/SelectionSort/","excerpt":"","text":"선택정렬오름차순일 경우 작은걸 맨앞에 넣고 그 다음 작은걸 두 번째 넣고 ..이 과정을 계속 반복한다. 시간복잡도는 O(n^2) 이다. SelectionSort.c12345678910for(i=0;i&lt;n-1;i++)&#123; maxIdx=i; for(j=i+1;j&lt;n;j++) //최소값 탐색 &#123; if(arr[i]&lt;arr[maxIdx]) maxIdx=j; &#125; swap;&#125; 참고 : 윤성우의 열혈 자료구조","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://KKimSangHeon.github.io/categories/Algorithm/"},{"name":"Sort","slug":"Algorithm/Sort","permalink":"http://KKimSangHeon.github.io/categories/Algorithm/Sort/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/tags/Data-Structure/"},{"name":"Sort","slug":"Sort","permalink":"http://KKimSangHeon.github.io/tags/Sort/"},{"name":"Selection Sort","slug":"Selection-Sort","permalink":"http://KKimSangHeon.github.io/tags/Selection-Sort/"}]},{"title":"작성논문","slug":"paper","date":"2017-06-30T04:40:14.000Z","updated":"2017-07-07T00:51:51.519Z","comments":true,"path":"2017/06/30/paper/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/paper/","excerpt":"","text":"A Survey of Fingerprint Indoor Positioning TechniquesintroductionThe location based service (LBS) industry is so flourishing that enumerating all LBSs available now is almost impossible. In the marketing field, LBSs may recognize the current location of tenta-tive customers and push advertisement messages and coupons to them when they enter a predefined area. When a person makes a call to 911, the location of the person is identified by the emergency response agency so that help can be provided quickly. The location-based information service deliv-ers information of points of interests located near to the user. The navigation service is another well-known type of location-based services.Location-based service cannot be realized unless the positioning problem is solved. The Global Positioning System (GPS) can be used as a general solution for outdoor positioning. However, posi-tioning for indoor area is still under development. We are especially interested in wireless local area network (WLAN)-based indoor positioning techniques because it is available in almost all huge man made constructions. Most of WLAN-based indoor positioning techniques use either the signal propa-gation model or fingerprints.Implementation of the signal propagation model based indoor positioning method can be done quickly whereas implementation of the fingerprint method takes a long time. However, the finger-print method is more accurate than the signal propagation model based method. This paper surveys recently published fingerprint indoor positioning techniques. 자세히 보기 Review of the Techniques for Smart Learning SystemsintroductionFlipped learning is said to be one of the most efficient teaching and learning methods. In flipped learning, students watch lecture videos at home. In the class, they solve interesting problems under the teacher’s guide. Nowadays, students watch videos through smart devices while they are on the way home. Therefore, schools should provide a smart learning system.A database of lecture videos, smart applications, content management systems, and streaming servers are essential parts of smart learning systems. There are many database management system (DBMS) with which we can develop database of lecture videos. Among them, this paper reviews techniques to use MySQL DBMS. 자세히 보기 Techniques for Group Management Application DevelopmentintroductionA group management system provides many types of valuable services. For example, a teacher can be aware of current locations of all the students in real time during a field trip using a group management mobile application. In the early stage of location based service, fleet management was one of the hottest research topics. This paper reviews group management related research results.Positioning, handling maps, handling a database and mobile programming are indispensable technologies for the development of fleet management systems. Usages of these technologies in fleet management system development are discussed.자세히 보기 Survey of Techniques for Location-Based Mobile Campus Guide SystemsintroductionLocation-based service provides useful information based on the place where the user is located. Smart phones are ideal devices that provide location-based services because they are equipped with various sensors with which we can determine the location of smart phones.As an example of location-based service, the authors of [1] introduced a campus guide mobile app. This paper surveys techniques needed in development of location-based mobile campus guide systems. Campus guide systems prints out texts and images. It also plays audios and videos. Therefore, video on demand (VOD) techniques will be discussed. Techniques to identify the context of user will also be discussed. Finally, this paper will propose a design of a campus guide 자세히 보기","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"작성 논문","slug":"작성-논문","permalink":"http://KKimSangHeon.github.io/tags/작성-논문/"}]},{"title":"시각장애인을 위한 길안내 app","slug":"For-blind","date":"2017-06-30T03:42:08.000Z","updated":"2017-06-30T04:32:05.752Z","comments":true,"path":"2017/06/30/For-blind/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/For-blind/","excerpt":"","text":"참가배경-교내 창업경진대회가 진행 중이라는 소식을 듣고 참가하게 되었습니다. 비콘과 관련된 프로젝트를 진행중이던 상황이라 비콘을 이용해서 창업아이템을 고안하게 되었습니다. Idea를 떠올린 계기 -지하철을 이용하던 어느 날 시각장애인이 길을 찾는데 어려움을 겪는 것을 보았습니다. 시각장애인이 길을 찾는데 어려움을 겪은 이유는 점형블록에 대한 인식이 부족한 상인이 올려둔 짐 때문이었고 결국 시각 장애인은 주변 사람들의 도움을 통해 올바른 길을 찾아 갈 수 있었습니다. 저는 그 이후 지하철 내 점형블록을 눈여겨보게 되었습니다. [그림1]의 좌측 사진과 같이 깨진 점형블록이 보수되지 않은 채 존재하며, 우측 사진과 같이 매트가 깔려있기도 했습니다. -또한 그들을 위한 시설인 음성유도기 또한 고장나있는경우가 많으며 가격이 비싸다는 단점이 존재하였습니다.(개당 약 270만원) Idea 소개역사에 10m^2당 비콘을 하나씩 설치하여 핑거프린팅 알고리즘을 적용한 후 현재위치를 파악합니다. (FingerPrinting Algorithm(참고)) 그 후 [그림3]과 같이 이동방향을 파악 후 이동방향에 따른 음성안내를 실시합니다.음성안내를 실시하기 위해서는 다음의 Newtone API 혹은 Naver의 음성합성 기능을 사용하면 가능합니다. 결과 운이 좋게도 장려상과 30만원의 장학금을 지급받았습니다 !","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://KKimSangHeon.github.io/tags/Android/"},{"name":"Beacon","slug":"Beacon","permalink":"http://KKimSangHeon.github.io/tags/Beacon/"},{"name":"창업경진대회","slug":"창업경진대회","permalink":"http://KKimSangHeon.github.io/tags/창업경진대회/"}]},{"title":"기숙사 외박계","slug":"Dormitory-Sleep-Out","date":"2017-06-30T01:22:14.000Z","updated":"2017-06-30T03:37:41.143Z","comments":true,"path":"2017/06/30/Dormitory-Sleep-Out/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/Dormitory-Sleep-Out/","excerpt":"","text":"프로그램 개발배경-교내 기숙사의 외박계 프로그램이 존재하지 않으며, 업체에 의뢰하여 제작하려했으나 비용상의 문제로 거절된것을 알게되었습니다. 그래서 직접 만들어서 제출하면 어떨까 라는 생각을 하게되어 개발하게 되었습니다. 프로그램 소개CentOS상에 서버를 실행시켰으며, 카카오톡 옐로아이디 페이지에서 세팅을 진행하였습니다. 각 과정을 거친 후 자신의 외박계를 하나 작성할 수 있는 프로그램입니다. 프로그램 동작화면 초기 채팅방에 진입하였을 경우 외박계를 작성할 것인지, 작성한 외박계를 확인할 것인지 선택합니다.외박계 작성을 선택하였을 경우 이름, 거주하는 동, 호수, 귀관일, 행선지를 입력하고전화번호 또한 입력 후 아무키나 입력하면 등록이 완료됩니다.[그림1]에서 확인버튼을 선택하였을 경우 [그림4]와 같이 입력한 내용을 확인할 수 있습니다. 작성된 외박계를 관리자가 확인하기 위해서는 채팅방에서 supervisorgj@를 입력합니다. 그 후 [그림5]와 같이 외박계를 조회할 수 있습니다. 소스코드 (Github Repository)-카카오톡 자동응답 서버 소스코드","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://KKimSangHeon.github.io/tags/Node-js/"},{"name":"Kakao talk open API","slug":"Kakao-talk-open-API","permalink":"http://KKimSangHeon.github.io/tags/Kakao-talk-open-API/"},{"name":"챗봇","slug":"챗봇","permalink":"http://KKimSangHeon.github.io/tags/챗봇/"},{"name":"MySQL","slug":"MySQL","permalink":"http://KKimSangHeon.github.io/tags/MySQL/"},{"name":"CentOS","slug":"CentOS","permalink":"http://KKimSangHeon.github.io/tags/CentOS/"}]},{"title":"Music Share","slug":"music-share","date":"2017-06-30T00:31:38.000Z","updated":"2017-08-11T06:17:27.853Z","comments":true,"path":"2017/06/30/music-share/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/music-share/","excerpt":"","text":"프로그램 개발배경-C 소켓프로그래밍에 대한 이해를 높이고자 진행한 프로젝트입니다. 프로그램 소개-본 프로그램은 회원가입기능, 로그인기능, 서버에 mp3파일을 올리는기능 등이 구현되어 있습니다. 회원가입을 하고 로그인 후 서버에 mp3파일을 올리거나 다운로드 받을 수 있습니다. 프로그램 개발환경은 우분투 14.04 LTS 입니다. 프로그램 기능 초기 서버에 접속하였을 경우 화면입니다. 서버에서는 클라이언트의 접속현황 및 상태를 확인할 수 있으며 클라이언트에서는 다음에 할 수 있는 일을 확인할 수 있습니다. 두 클라이언트가 회원가입을 진행하고 있고 이에 대한 내용이 서버측 화면에 출력됩니다. 클라이언트가 가입한 ID를 이용하여 로그인을 하였습니다. 로그인 후 에는 서버에 존재하는 mp3파일리스트를 조회하거나 mp3파일을 업로드, 다운로드 할 수있습니다. 클라이언트가 로그인을 한 후 mp3파일을 업로드하는 화면입니다. 클라이언트가 로그인을 한 후 서버에 존재하는 mp3파일을 조회하는 화면입니다. [그림4]에서 KSH클라이언트가 업로드한 hello.mp3 파일을 HRA클라이언트가 접속하여 다운로드 하는 화면입니다. 비밀번호를 찾기위해 ID, Email을 입력하였고 이 후 비밀번호가 화면에 출력되는 모습입니다. github Repository","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"C","slug":"C","permalink":"http://KKimSangHeon.github.io/tags/C/"},{"name":"Socket","slug":"Socket","permalink":"http://KKimSangHeon.github.io/tags/Socket/"},{"name":"Music Share","slug":"Music-Share","permalink":"http://KKimSangHeon.github.io/tags/Music-Share/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://KKimSangHeon.github.io/tags/Ubuntu/"}]},{"title":"다수 사용자의 실시간 위치추적 어플리케이션 구현","slug":"where-are-you","date":"2017-06-29T14:53:44.000Z","updated":"2017-10-03T18:02:21.818Z","comments":true,"path":"2017/06/29/where-are-you/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/29/where-are-you/","excerpt":"","text":"App 개발배경-한 인원이 다수의 인원을 통제해야 하는 상황은 다양한 상황에서 발생할 수 있습니다. 가령 한 초등학교에서 현장체험학습의 일환으로 박물관을 방문하였을 경우, 교사 한명이 통제해야할 학생수는 약 30명에 이릅니다. 이는 교사에게 부담스러운 수가 될 수 있을것이라 판단하여 어플리케이션을 통해 극복하고자 하였습니다. App 소개-본 어플리케이션은 BLE기반의 비콘을 이용하여 실내에서 다수 사용자의 위치를 파악하는 어플리케이션입니다. App을 사용하기 위해서는 User는 자신의 정보를 등록해야 하며 이때 입력하는 데이터는 이름, ClassID 입니다. Supervisor는 이름 혹은 (이름,ClassID)를 이용하여 User의 최근 위치를 파악할 수 있는데 ClassID로는 해당 ClassID를 갖는 모든 User가 조회되며, (이름,ClassID)으로는 해당 User의 이동경로를 파악할 수 있습니다. System Architecture -본 어플리케이션의 이용자는 크게 User, Supervisor로 나뉘는데 User의 경우 FingerPrintingServer로 자신이 인식한 비콘들의 값을 전송합니다. 이를 수신한 FingerPrintingServer 서버는 User의 위치를 FingerPrinting 알고리즘을 적용하여 계산한 후 DB에 업데이트합니다. 이용자가 Supervisor 일 경우에는 StudentLocationPage에 접근하여 User들의 위치를 읽어옵니다. FingerPrinting Algorithm-본 어플리케이션의 핵심 알고리즘은 FingerPrinting Algorithm 입니다. 이 알고리즘을 구현하기 위해 72개 지점에서 비콘인식 실험을 100번 간 진행하였습니다. 결과물을 토대로 평균, 분산, 표준편차 등을 곱하고 나누어서 가장 실제 위치와 근접한 값을 구할 수 있었으며 최종적으로 오차를 약 1.65m 까지 줄일 수 있었습니다. -다음은 간단한 FingerPrinting Algorithm 적용 방식입니다. (서버에서 사용하는 알고리즘과는 다릅니다.)핑거프린팅 기법은 사전에 측정된 각 좌표 별 비콘의 신호값을 토대로 현재 위치를 추측하는 기술입니다. 예를 들어 그림1과 같이 각 좌표 별 사전에 측정된 비콘의 신호값(RSSI)이 존재한다고 가정 해 보겠습니다.현재 위치에서 측정된 각 비콘의 RSSI 값이 B1: -86 B2: -91 B3: -100 일 때 Coordinate1에 대한 각 비콘 신호의 차이의 합을 구하면 (-86, -87과의 차이) + (-91, -90과의 차이) + (-100, -101과의 차이) 3입니다. 이 과정을 Coordinate2 또한 반복하면 결과값은 14이며 , Coordinate3 은 26입니다.이 중 오차가 가장 작은 즉 최소값을 갖는 좌표가 현재 위치라 판단할 수 있을 것 이므로 현재 위치는 Coordinate1이라 추측할 수 있겠습니다. Result ClassID로 조회하였을 경우 [그림1]과 같이 해당 User들이 최근에 위치한 좌표값을 확인할 수 있습니다. (이름,ClassID)로 조회하였을 경우 해당 User의 이동경로가 [그림2]와 같이 출력됩니다. User의 위치는 카카오톡 yelloID (ID:WhereAreYou)로도 확인이 가능한데 [그림3]과 같이 카카오톡을 이용하여 위치 조회가 가능합니다. 소스코드 (Github Repository)-안드로이드 어플리케이션 소스코드-카카오톡 자동응답 서버 소스코드-웹페이지 서버 소스코드-소켓 서버 소스코드","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://KKimSangHeon.github.io/tags/Android/"},{"name":"Reco Beacon","slug":"Reco-Beacon","permalink":"http://KKimSangHeon.github.io/tags/Reco-Beacon/"},{"name":"Beacon","slug":"Beacon","permalink":"http://KKimSangHeon.github.io/tags/Beacon/"}]},{"title":"안녕하세요!","slug":"about-me","date":"2017-06-29T09:58:22.000Z","updated":"2020-01-06T12:50:53.094Z","comments":true,"path":"2017/06/29/about-me/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/29/about-me/","excerpt":"","text":"Introduction안녕하세요. 이 블로그는 제가 개인적으로 공부한 내용, 진행했던 프로젝트를 업로드하고, 공유하고자 만들었습니다. 부족한 부분에 대한 태클은 언제든지 환영하며 빠르게 반영하도록 하겠습니다. 부족하지만 방문해주셔서 감사드리며 앞으로 더욱 완벽한 블로그를 만들기 위해 노력하겠습니다! Profile 동국대학교 경주캠퍼스 졸업 4.0/4.5 (2011.03~2017.02) 소프트모아 현장실습 (2016.06~2016.07) 아이티센 인턴수료 [공공2사업부문 개발2팀] (2016.12~2017.03) 비트교육센터 빅데이터 전문가양성과정 수강 (2017.07.31~2017.11.10) 마인즈랩 인턴수료 [Machine Learning Tutor 팀] (2017.11~2018.03) 웍스모바일 인턴수료 [Media Cloud Platform 팀] (2018.03 ~ 2018.05) KT [IT기획실 / 소프트웨어개발단] (2018.10 ~ 현재) Awards General Co-chairs of 2016 9th International Workshop Series / Best Paper Award (2016.04) 동국창업아이템 경진대회 / 장려상 (2016.05) 동국대학교 경주캠퍼스 2017 봄 우등졸업생 (2017.02) ABLETHON / 우수상 (2017.10) Certificate 워드프로세서 (2012.06) 컴퓨터활용능력 1급 (2013.08) IT Plus Level 3 (2013.08) 정보처리기사 (2016.11) SQLD (2017.10) 리눅스마스터 2급 (2018.03) Activity 대한민국청소년의회 / 청소년 모의국회 스태프 (2011.07) 버담소리 / 보육원 봉사활동 (2014.12 ~ 2015.05) 코딩클럽 / 아동 코딩교육 (2015.08 ~ 2015.12) 동국대학교 컴퓨터공학과 / C, Java 멘토링 멘토 (2015.09 ~ 2016.12) 정보통신산업진흥원 / 한이음 ICT 멘토링 멘티 (2016.04 ~ 2016.12) Project- 다수 사용자의 실시간 위치추적 어플리케이션(Android, Beacon, Socket) - 부모님을 부탁해(Android) - Music Share(C, Socket) - 기숙사 외박계(Node.js, Kakao API) - 시각장애인을 위한 길안내 app제안(android) - 작성 논문 - 엄마가 보고있다(android) - 데이터 프리 기프티콘(android) - 동국대 경주캠퍼스 채팅봇(Node.js, Kakao API, AWS) - Wholin 밴드(android) - 그룹웨어(Web, Spring) - 쓱쓱끝(Android, Web, Spring)","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"Introduction","slug":"About-Me/Introduction","permalink":"http://KKimSangHeon.github.io/categories/About-Me/Introduction/"}],"tags":[{"name":"Sang Heon Kim","slug":"Sang-Heon-Kim","permalink":"http://KKimSangHeon.github.io/tags/Sang-Heon-Kim/"}]},{"title":"부모님을 부탁해","slug":"request-parent","date":"2017-06-29T09:52:18.000Z","updated":"2017-08-11T06:19:57.080Z","comments":true,"path":"2017/06/29/request-parent/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/29/request-parent/","excerpt":"","text":"App 소개 및 개발배경-본 어플리케이션은 증가하는 고독사를 줄여보자는 취지에서 개발하게 된 어플리케이션입니다. 부재중 통화수가 사전에 등록해 놓은 n 개가 되었을 경우 사전에 등록해 놓은 지인에게 위치정보가 포함된 문자메세지가 송신되는 앱 입니다. 초기화면에서 문자메세지를 수신할 번호, 부재중통화의 개수n을 입력하고 동작하기 버튼을 누릅니다. 어플리케이션을 설치한 스마트폰 주인이 부재중통화를 n번 받지 않을 경우 스마트폰의 현재 위치가 등록한 번호로 전송됩니다. -시연영상github Repositorygoogle play 방문","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://KKimSangHeon.github.io/tags/Android/"},{"name":"고독사 감소","slug":"고독사-감소","permalink":"http://KKimSangHeon.github.io/tags/고독사-감소/"}]},{"title":"거품정렬 (BubbleSort)","slug":"BubbleSort","date":"2017-06-29T05:36:52.000Z","updated":"2018-09-03T06:03:44.702Z","comments":true,"path":"2017/06/29/BubbleSort/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/29/BubbleSort/","excerpt":"","text":"거품정렬거품정렬의 코드는 다음과 같다.시간복잡도는 O(n^2) 이다. BubbleSort.c12345678910for(i=0;i&lt;n-1;i++)&#123; for(j=0;j&lt;(n-i)-1;j++) &#123; if(arr[j]&gt;arr[j+1]) &#123; swap; &#125; &#125;&#125; 참고 : 윤성우의 열혈 자료구조","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://KKimSangHeon.github.io/categories/Algorithm/"},{"name":"Sort","slug":"Algorithm/Sort","permalink":"http://KKimSangHeon.github.io/categories/Algorithm/Sort/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/tags/Data-Structure/"},{"name":"Sort","slug":"Sort","permalink":"http://KKimSangHeon.github.io/tags/Sort/"},{"name":"Bubble Sort","slug":"Bubble-Sort","permalink":"http://KKimSangHeon.github.io/tags/Bubble-Sort/"}]}]}