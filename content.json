{"meta":{"title":"Kim Sang Heon's Bolg","subtitle":null,"description":"Welcome to Sang Heon's Blog.","author":"Kim Sang Heon","url":"http://KKimSangHeon.github.io"},"pages":[],"posts":[{"title":"16.프로세스 동기화의 다른 도구인 모니터 사용","slug":"operating-system16","date":"2019-02-22T13:51:04.000Z","updated":"2019-02-22T14:07:13.829Z","comments":true,"path":"2019/02/22/operating-system16/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/22/operating-system16/","excerpt":"","text":"모니터동기화 도구로 세마포어를 배웠다. 세마포어는 조금 오래된 동기화 도구인데 지금은 모니터를 많이쓴다. 주로 자바에서 많이쓴다.즉 세마포 이후 프로세스 동기화 도구 이며 세마포 보다 고수준 개념 세마포어의 구조정수변수, 큐, P(acquire)동작, V(release)동작 모니터의 구조공유자원 , 공유자원 접근함수 , 2개의 큐 2개의 큐?하나는 배타동기. 즉 한쓰레드만 공유자원에 접근할 수 있도록 하는 큐하나는 조건동기를 위한 큐 베타동기를 위한큐 | 다양한 함수 | 조건동기를 위한큐 1.쓰레드 한개만 공유자원 접근 함수에 접근할 수 있다. 즉 들어오고 싶어하는 애들은 베타동기를 위한 큐에서 기다려야 한다.2.진입 쓰레드가 조건을 만족하면(wait를 콜) 조건동기 큐로 들어가는데 이땐 블록된다. 그러면 새 쓰레드가 진입가능3.새 쓰레드는 조건동기로 블록된 쓰레드를 notify를 호출하여 깨울 수 있다4.깨워진 쓰레드는 현재 쓰레드가 나가면 재진입할 수 있다.(하나의 쓰레드만 접근 가능하므로) 세마포어에 비해 복잡하나 사용하기 편리하다. 배타동기: synchronized 키워드 사용하여 지정조건동기: wait(), notify(), notifyAll() 메소드 사용 베타동기: 하나만 특정함수에 들어갈 수 있다. 자바에서는 함수 정의 앞에 synchronized 키워드를 붙인다.조건동기는 wait 함수를 호출하여 조건동기를 위한 큐에 갇히게 할 수 있고 notify(하나깨우기) 혹은 notify all(전체깨우기) 을 호출하여 깨울 수 도 있다. 상호배제 용도로 사용1234567891011121314151617class BankAccount &#123; int balance; synchronized void deposit(int amt) &#123; int temp = balance + amt; System.out.print(\"+\"); balance = temp; &#125; synchronized void withdraw(int amt) &#123; int temp = balance - amt; System.out.print(\"-\"); balance = temp; &#125; int getBalance() &#123; return balance; &#125;&#125; 위처럼 하면 동기화가 가능하다. 세마포어 보다 쉽다! Ordering 용도로 사용P1은 공백/ S1/notify();P2는 wait/S2/공백 P1이 입금, P2가 출금 로직이라고 가정하고 생각해보자. P1,P2 반복해서 출력되게 하려면 boolean 변수 하나를 둬서 처리123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475int balacne = 0;boolean p_turn;synchronized void deposit(int amt) &#123; int temp = balance + amt; balance = temp; notify(); p_turn = false; wait();&#125;synchronized void withdraw(int amt) &#123; while(p_turn) wait(); int temp = balance - amt; balance = temp; p_turn = true; notify();&#125;---class Buffer &#123; int[] buf; int size, count, in, out; Buffer(int size) &#123; buf = new int[size]; this.size = size; count = in = out = 0;&#125;synchronized void insert(int item) &#123; while (count == size) try &#123; wait(); &#125; catch (InterruptedException e) &#123;&#125; buf[in] = item; in = (in+1)%size; notify(); count++;&#125;synchronized int remove() &#123; while (count == 0) try &#123; wait(); &#125; catch (InterruptedException e) &#123;&#125; int item = buf[out]; out = (out+1)%size; count--; notify(); return item; &#125;&#125;---교착상태에 대한 고려는 되지 않음.class Chopstick &#123; private boolean inUse = false; synchronized void acquire() throws InterruptedException &#123; while (inUse) wait(); inUse = true; &#125; synchronized void release() &#123; inUse = false; notify(); &#125;&#125;","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"15.교착상태 필요조건, 교착상태의 해결법","slug":"operating-system15","date":"2019-02-22T13:50:56.000Z","updated":"2019-02-22T13:56:55.165Z","comments":true,"path":"2019/02/22/operating-system15/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/22/operating-system15/","excerpt":"","text":"교착상태발생이유 : 프로세스들이 자원을 많이 필요로 한다. 하지만 누가 사용하고 있으면 기다려야한다.이러한 형태가 원을 이루면 교착상태가 발생한다. 교창상태 필요조건.Mutual exclusion (상호배타) : 자원을 서로 공유하지 못함Hold and wait (보유 및 대기) : 하나를 잡고있으면서 다른것을 원함No Preemption (비선점) : 다른것을 강제로 뺏어오지 못함.Circular wait (환형대기) : 자원을 갖고있으면서 기다리는데 원형형태 네가지가 만족되면 일어날 수 있다. 반드시 일어나는것은 아님 교착상태 처리교착상태 처리는 크게 네가지가 있다.1.교착상태 방지Deadlock Prevention 2.교착상태 회피Deadlock Avoidance 3.교착상태 검출 및 복구Deadlock Detection &amp; Recovery 4.교착상태 무시Don’t Care 1.교착상태 방지설명 : 필요조건 중 네가지 조건중에 하나라도 깨도록 하는것.상호베타 조건을 깨기: 이를 위해 공유가 가능하게 해야한다. 현실적으로 어렵다. 읽어내기만 하는 파일 같은 경우에는 가능하지만 일반적으로는 부적절 보유 및 대기 깨기: 동시에 젓가락 갖게하기. 왼쪽 젓가락 잡고 오른쪽 젓가락 잡을라 했는데 누가 오른쪽을 갖고있으면 왼쪽도 놓기. 이는 굶어 죽을 확률이 생김. 자원의 활용도가 떨어진다. 상호베타 조건깨는것보다는 쉽다.자원을 가지고 있으면서 다른 자원을 기다리지 않게 즉 자원이 없는 상태에서 모든 자원 대기; 일부 자원만 가용하면 보유 자원을 모두 놓아주기단점: 자원 활용률 저하, 기아 (starvation) 비선점 깨기: CPU의 경우에는 일부 가능하겠으나 일반적으로 불가능 환형대기 깨기 : 자원에다 번호 부여하고 자원의 오름차순으로 자원을 요청토록 함. 즉 R1,R2,R3 가 있을때 R1, R2 요청/ R2,R3 요청/ R1,R3요청처럼 구현. 자원의 활용도가 떨어진다. 보통 보유 및 대기 깨기 혹은 환형대기 깨기를 사용한다. 2.교착상태 회피설명 : 자원을 할당할 때 위험한 할당이 되지 않도록 하는것.자원을 프로세스 한테 골고루 나눠주는것을 OS가 한다. 이를 리소스 매지저 / 올로케이터라 한다.교착상태는 자원요청에 대한 잘못된 승인에 기인한다고 본다. 불안전한 할당 (Unsafe allocation)운영체제는 자원을 할당할 때 불안전 할당 되지 않도록불안전 할당 → 교착상태 유발대출전문 은행과 유사: Banker’s Algorithm 3.교착상태 검출 및 복구설명 : 프로세스가 필요한 대로 자원을 나눠주고 데드락이 발생하면 OS의 프로세스 복구.교착상태가 일어나는 것을 허용 그리고 주기적 검사진행. 주기적 검사는 이를 하기 위한 오버헤드가 크다.교착상태 발생 시 복구하기위해 주기적으로 이전의 상태를 기억하고 있어야 한다.이를 위해 한 프로세스를 강제로 종료시키거나 혹은 자원을 선점하여 일부 프로세스에게 할당. 4. 교착상태 무시설명 : 교착상태는 실제로 잘 일어나지 않으므로 그냥 무시해버린다.교착상태 발생 시 재시동. 컴퓨터에서 가장 중요한것은 메모리 관리이다. 이를 프로세스 매니지먼트 부서가 하는데 이는 CPU 스케줄링 부서, 프로세스 싱크로나이즈 부서로 구성된다. 싱크로나이즈에서는 데드락관리또한 중요. 메인메모리 관리가 메모리 매니지 부서가 있다. 다음부터 공부한다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"14.읽기-쓰기 문제, 식사하는 철학자 문제","slug":"operating-system14","date":"2019-02-22T13:50:49.000Z","updated":"2019-02-22T13:53:18.540Z","comments":true,"path":"2019/02/22/operating-system14/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/22/operating-system14/","excerpt":"","text":"읽기-쓰기 문제, 식사하는 철학자 문제 Reader &amp; WriterDB 읽기만 하는 프로세스 DB를 바꾸는 프로세스 A가 DB를 읽고 있을 때 B가 읽을 수 있다.즉 한 프로세스가 DB를 읽을 때 다른 프로세스도 읽을 수 있게 허용해줘야 한다. The first R/W problem (readers-preference)리더가 있으면 라이터가 미뤄지는것 The second R/W problem (writers-preference)라이터가 먼저 우선순위가 주어지는것 The Third R/W problem아무한테도 주지 않는것 정리 : 즉 리더가 들어왔는데 라이터가 들어오려면 블록되어야 하고라이터가 들어왔는데 리더가 들어오려면 블록되어야 하고리더가 들어와있는데 리더가 들어오면 허용해야한다 Dining Philosopher Problem다음 프로그램 설명철학자 5명이 둥근탁상에 앉아있다. 젓가락은 5개뿐. 즉 자신의 왼쪽 오른쪽에 젓가락이 위치.젓가락을 세마포어로 만들고 초기화를 1로한다.무한루프를 돌면서 왼쪽젓가락, 오른쪽 젓가락을 acquire 하고. 먹고 다시 왼쪽 오른쪽 젓가락을 release한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.concurrent.Semaphore;class Philosopher extends Thread &#123; int id; // philosopher id Semaphore lstick, rstick; // left, right chopsticks Philosopher(int id, Semaphore lstick, Semaphore rstick) &#123; this.id = id; this.lstick = lstick; this.rstick = rstick; &#125; public void run() &#123; try &#123; while (true) &#123; lstick.acquire(); rstick.acquire(); eating(); lstick.release(); rstick.release(); thinking(); &#125; &#125;catch (InterruptedException e) &#123; &#125; &#125; void eating() &#123; System.out.println(\"[\" + id + \"] eating\"); &#125; void thinking() &#123; System.out.println(\"[\" + id + \"] thinking\"); &#125;&#125;class Test &#123; static final int num = 5; // number of philosphers &amp; chopsticks public static void main(String[] args) &#123; int i; /* chopsticks */ Semaphore[] stick = new Semaphore[num]; for (i=0; i&lt;num; i++) stick[i] = new Semaphore(1); /* philosophers */ Philosopher[] phil = new Philosopher[num]; for (i=0; i&lt;num; i++) phil[i] = new Philosopher(i, stick[i], stick[(i+1)%num]); /* let philosophers eat and think */ for (i=0; i&lt;num; i++) phil[i].start(); &#125;&#125; 위의 프로그램은 쭉 가다가 정지된다. 그 이유는 기아상태 유발모든사람이 각자의 왼쪽 젓가락을 들었을 때 해당상황이 발생이를 교착상태라 한다. 운영체제에서 중요한것은 프로세스 관리. 이중 중요한것이 CPU 스케줄링, 동기화 문제이다.동기화에서 중요한건 크리티컬 섹션문제, 효율성 증대 즉 ordering 인데 ordering를 잘못하면 교착상태(Deadlock)에 빠지게 된다. 교착상태(Deadlocks)프로세스가 실행되기 위해서는 하드웨어 자원이 필요하다. 이를 리소스 즉 자원이라 한다. 자원을 사용하는 애플리케이션 즉 프로세스가 있고 중간에 OS가 있다. OS는 애플리케이션한테 자원을 잘 나눠줘야 한다. 자원은 한정되어 있는데 이를 사용하고자 하는 프로세스는 많다. 여기서 잘 나눠주지 못하면 교착상태가 발생한다. 어떤 자원은 갖고 있으나 다른 자원은 갖지 못할 때 (e.g., 다른 프로세스가 사용 중) 대기해야 한다.다른 프로세스 역시 다른 자원을 가지려고 대기할 때 교착상태 가능성 발생 교착상태는 어떤자원을 갖고있을 때 다른 자원을 갖고자 할 때 발생 교착상태 필요 조건 (Necessary Conditions)Mutual exclusion (상호배타) : 리소스가 상호 배타적이다. 즉 한프로세스가 A를 쓰고 있다면 다른 프로세스는 A를 쓰지 못한다.Hold and wait (보유 및 대기) : 왼쪽 젓가락 잡고있으면서 오른쪽 젓가락을 기다리는것.No Preemption (비선점) : 다른사람의 젓가락 하나를 강제로 뺏을 수 없다.Circular wait (환형대기) : 대기하는 형태가 원을 이룸. 교착상태OS에서는 데드락이 일어나지 않도록 미리 조취를 해야한다. 자원의 사용요청 (request) → 사용 (use) → 반납 프로세스가 자원을 쓰려면 OS에게 요청을 한다. 그 요청이 올바르면 OS는 그것을 허용하고 프로세스가 자원을 다 쓰면 OS에게 반납한다. 동일 자원동일 형식 (type) 자원이 여러 개 있을 수 있다 (instance) - 예: 동일 CPU 2개, 동일 프린터 3개 등 자원 할당도 (Resource Allocation Graph)시스템 내에 어느 자원이 있고 어떤 프로세스에게 할당되었는가에 대한 그래프어떤 자원이 어떤 프로세스에게 할당되었는가?어떤 프로세스가 어떤 자원을 할당 받으려고 기다리고 있는가?자원: 사각형, 프로세스: 원, 할당: 화살표 그래프 강의는 37분부터 보자 교착상태 필요조건자원 할당도 상에 원이 만들어져야 (환형대기) - 충분조건은 아님!자원에서 프로세스를 가르키면 프로세스가 자원을 할당받은 상태프로세스에서 자원을 가르키면 자원을 요청한 상태 짝수번 철학자는 왼쪽들고 오른쪽 들고홀수번 철학자는 오른쪽들고 왼쪽거 들기. 그러면 원형이 깨지게 되어 교착상태가 발생하지 않게된다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"13.전통적 동기화 문제, 생산자-소비자 문제","slug":"operating-system13","date":"2019-02-21T13:10:14.000Z","updated":"2019-02-22T13:52:46.125Z","comments":true,"path":"2019/02/21/operating-system13/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/21/operating-system13/","excerpt":"","text":"OS에서 가장중요한게 프로세스 관리이중 CPU 스케줄링, 프로세스 동기화가 중요하다.이때 임계구역 처리를 잘해야한다. 전통적 동기화 예제1.Producer and Consumer Problem(생산자-소비자 문제, 유한버퍼 문제 (Bounded Buffer Problem))2.Readers-Writers Problem(공유 데이터베이스 접근)3.Dining Philosopher Problem(식사하는 철학자 문제) Producer-Consumer Problem생산자-소비자 문제생산자가 데이터를 생산하면 소비자는 그것을 소비예: 컴파일러 &gt; 어셈블러, 파일 서버 &gt; 클라이언트, 웹 서버 &gt; 웹 클라이언트 Bounded Buffer보통 생산소비와 소비속도는 다르다.그래서 보통 창고(버퍼)에 저장하고 컨슈머가 조금씩 빼먹는다. 생산된 데이터는 버퍼에 일단 저장 (속도 차이 등)현실 시스템에서 버퍼 크기는 유한생산자는 버퍼가 가득 차면 더 넣을 수 없다.소비자는 버퍼가 비면 뺄 수 없다 버퍼가 가득차면 생산자는 버퍼가 비워질때까지 기다려야한다.버퍼가 비면 소비자는 빼갈것이 없다. 생산자가 10000번 넣고 소비자가 10000번 넣으면 0이되지 않을 수 있다.이유 : 공통변수 count, buf[] 에 대한 동시 업데이트공통변수 업데이트 구간(= 임계구역)에 대한 동시 진입 해결법 : 임계구역에 대한 동시 접근 방지 (상호배타)세마포를 사용한 상호배타 (mutual exclusion, mutex) Busy-wait바쁘게 기다린다.생산자: 버퍼가 가득 차면 기다려야 == 빈(empty) 공간이 있어야 한다소비자: 버퍼가 비면 기다려야 == 찬(full) 공간이 있어야 한다 이때 무한루프를 돌면서 기다리면 CPU는 다른일을 못하고 잡히게 된다. -&gt; 비효율적해결법 : 두개의 세마포어를 사용. empty의 초깃값은 BUF_SIZE 만큼 full의 초깃값은 0으로 하여 사용생산자 :empty.acquire();PRODUCE;full.release(); 소비자 :full.acquire();CONSUME; empty.release();","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"12.세마포를 사용한 프로세스 동기화","slug":"operating-system12","date":"2019-02-20T14:16:51.000Z","updated":"2019-02-20T14:17:22.281Z","comments":true,"path":"2019/02/20/operating-system12/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/20/operating-system12/","excerpt":"","text":"프로세스 관리에서 중요한것들CPU 스케줄링 : 이전포스팅 참고 프로세스(쓰레드) 동기화필요이유 : 보통컴퓨터 안에있는 프로세스들은 독립적이지 않고 협조적이므로 즉 공통된 자원에 접근함동기화가 되지 않으면? : 누군가는 계속 입금하고 누군가는 출금하는 로직이 있을 때 다 더한값이 0이 아닐 수 있다.임계구역 : 공통적으로 사용되는 부분 임계구역 문제 해결 : 상호베타, 진행, 유한대기 ( 모르겠으면 이전포스팅 보자)우리가 원하는대로 프로세스 순서를 맞추는것. 동기화 툴세마포어 : acquire P동작 release V동작이 있음누가 CPU 서비스를 받다가 acquire를 호출했는데 if문이 만족하면 세마포어 큐안에 잡혀들어간다. 이 후 누가 wake를 시켜주면 다시 레디큐로 들어가게 된다.세마포어는 Mutual exclusion을 위해 사용한다. 즉 크리티컬 섹션에는 한명만 들어갈 수 있다. 세마포어의 일반적 사용은 Mutual exclusion 그리고 Ordering으로 나뉜다.그 중 Ordering를 구현하기 위해서는 다음과 같이 하면 된다. P1 P2S1 S2 P1, P2가 있을 때 P1을 먼저 실행하고자 할 때(Ordering) : 세마포어의 value를 0으로 셋팅한다. 그 후 P2 앞에 sem.acquire를 호출한다.이러면 P1이 먼저 호출되면 우리가 원하던 대로 되는것이고 그렇지 않고 P2가 먼저 실행될 경우 세마포어 큐에 들어가서 block이 된다. 아무튼 P1이 먼저 실행되게 되고 실행을 완료하면 release를 호출하여 P2가 실행 될 수 있도록 한다.즉 다음과 같은 형태 P1 P2 acquireS1 S2release 세마포어 정리세마포어는 임계구역 문제 해결, 프로세스 실행 순서 제어를 한다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"11.임계구역 문제, 동기화 도구","slug":"operating-system11","date":"2019-02-19T11:04:12.000Z","updated":"2019-02-20T14:16:20.363Z","comments":true,"path":"2019/02/19/operating-system11/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/19/operating-system11/","excerpt":"","text":"임계구역 문제(critical-section problem)여러개의 쓰레드로 이뤄진 시스템에서 각각의 쓰레드는 코드영역을 갖고있는데 이를 크리티컬 섹션이라한다. 또한 쓰레드로 부터 공통으로 사용되고 변경될 수 있는 부분을 의미한다. 어떤 복수개의 쓰레드들이 공통적으로 사용하는 부분. 임계영역 해결이를 해결하기 위해 다음 세가지가 만족되어야 한다. Mutual exclusion (상호배타): 오직 한 쓰레드만 진입Progress (진행): 진입 결정은 유한 시간 내. 즉 누가 먼저 들어가야되는지 유한시간내에 결정해야 한다.Bounded waiting (유한대기): 어느 쓰레드라도 유한 시간 내 크리티컬 섹션안에 들어갈 수 있어야한다. 기다리는 시간이 한계가 정해져 있다. 동기화의 목적우리가 원하는대로 프로세스 혹은 쓰레드의 실행 순서를 결정 지을 수 있는것. O/S 가 가진 여러 매니지먼트(프로세스 매니지먼트,메모리 매니지먼트,파일 시스템 매니지먼트, I/O 매니지먼트) 중 가장 중요한것은 프로세스 매니지먼트. 프로세스 매니지먼트는 두 가지로 나뉘는데 하나는 CPU Scheduling, Synchronization Synchronization를 위한도구세마포어 모니터가 있다. Semaphores : 기차역에서 출발신호를 의미하는 깃발이다. 네덜란드사람 딕스트라가 만듦.내부구조는 정수 하나와 동작 두개로 구성된다. 하나는 P 동작 하나는 V 동작P: Proberen (test) 즉 acquire() 검사V: Verhogen (increment) 즉 release() 증가. 스택에는 푸쉬, 팝이라는 동작이 있다. 마찬가지로 세마포어도 내부에 정수가 있고 P,V가 존재한다.123456789101112131415void acquire() &#123; value--; if (value &lt; 0) &#123; add this process/thread to list; // 누가 호출하면 큐안에 넣는다. block; &#125;&#125;void release() &#123; value++; if (value &lt;= 0) &#123; remove a process P from list; //누군가 갇혀있으면 깨워준다. wakeup P; &#125;&#125; 저번에 배웠듯이 레디큐에서 CPU의 서비스를 받기 위해 기다리던 프로세스들이 CPU 서비스를 받다 IO를 만나면 IO서비스를 받으려 하는데 누가 IO서비스를 받고있다면 IO Queue(Device Queue)에서 대기하다 IO서비스를 받고 끝나면 다시 레디큐로 돌아온다. 타임쉐어링 시스템의 경우엔 IO를 만나지 않더라도 시간이 지나면 다시 레디큐로 돌아간다. 이는 프로세스의 큐잉 모델 즉 줄서서 기다리는 모델이다. 세마포어는 정수값도 있고 세마포어 큐도 있다. 어떤 프로세스가 레디큐에 있다 CPU를 쓰다가 acquire를 호출했는데 if문이 맞으면 갇혀버린다.(like 감옥) 이후에 누가 release를 해주면 감옥에서 탈출하여 다른 레디큐로 갈 수 있다. 위에서 value는 권한의 갯수로 생각하면 된다. 세마포어는 Mutual exclusion 상호베타를 위해 동작한다.세마포어의 초깃값이 1이라 하자. 이때 레디큐에 A, B가 있다고 하자.먼저 A가 acquire(); 을 호출하면 0이 되고 크리티컬 섹션 안으로 들어간다.(블록 걸리지 않음)이때 컨텍스트 스위칭이 되고 B가 acquire를 호출하면 이때는 value가 -1이므로 세마포어 큐에 갇히게 된다. (크리티컬 섹션 안으로 못들어간다). 그 후 A가 작업을 마치고 release를 호출하게 되면 value를 늘리고 세마포어 큐에 갇혀있는 B를 깨워 다시 레디큐로 들어가게 한다. 이를 상호베타라 한다. Monitors : 메모리 매니지먼트라파일 시스템 매니지먼트I/O 매니지먼트","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"10.프로세스 동기화의 중요성, 은행계좌 문제","slug":"operating-system10","date":"2019-02-18T13:31:45.000Z","updated":"2019-02-18T13:34:32.742Z","comments":true,"path":"2019/02/18/operating-system10/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/18/operating-system10/","excerpt":"","text":"1. 쓰레드란?프로그램 내부의 흐름, 맥 맥이 하나만 있는 프로그램 : 싱글쓰레드여러개있는것: 멀티(다중)쓰레드 쓰레드가 여러개가 빠르게 동시에(왔다갔다하면서) 실행됨. 우리는 CPU하나임을 가정하고 공부하기 때문에 1.1 쓰레드 구조프로세스의 메모리 공간 공유 : (code, data)프로세스의 자원 공유 : (file, i/o, …)비공유: 개별적인 PC, SP, registers, stack 운영체제의 프로세스 관리부서에서 중요한것은 프로세스 동기화 또는 쓰레드 동기화이다. 프로세스는 크게 두가지로 나뉜다.Independent process : p1, p2가 영향이 없다Cooperating process : p1, p2가 영향을 주던지 받던지 한다. 이런경우가 훨씬 많다.프로세스간 통신: 전자우편, 파일 전송프로세스간 자원 공유: 메모리 상의 자료들, 데이터베이스 등명절 기차표 예약, 대학 온라인 수강신청, 실시간 주식거래 2. 프로세스(쓰레드) 동기화공통데이터에 접근하는것은 문제가 발생할 수 있다. (공유되는 프로세스가 동시에 접근할 때.)동기화가 제대로 이뤄지지 않으면 똑같은 자리에 두명이상이 배정된다던가 하는 문제가 생긴다. 프로세스간에 순서를 잘 지정해서 이상한 상태에 빠지지 않도록 하여 데이터의 일관성을 유지 2.1 BankAccount Problem (은행계좌문제)부모님은 은행계좌에 입금; 자녀는 출금입금(deposit)과 출금(withdraw) 은 독립적으로 일어난다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"9.다중 큐 스케쥴링, 프로세스 생성과 소멸, 쓰레드","slug":"operating-system9","date":"2019-02-18T13:29:58.000Z","updated":"2019-02-18T13:31:23.624Z","comments":true,"path":"2019/02/18/operating-system9/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/18/operating-system9/","excerpt":"","text":"다중 큐 스케쥴링, 프로세스 생성과 소멸, 쓰레드다양한 CPU 스케줄링 알고리즘First-Come, First-Served (FCFS)Shortest-Job-First (SJF)PriorityRound-Robin (RR)Multilevel QueueMultilevel Feedback Queue 1. Multilevel Queue Scheduling1.1 Process groups : 프로세스는 그룹별로 묶일 수 있다.System processes : 가장 긴급하고 먼저 처리되어야 하는것.Interactive processes : 대화형 프로세스Interactive editing processes : ex 워드프로세스Batch processes : 인터액션이 따로 없다.Student processes 성격이 다양한것을 동일한 큐에 세우는것이 맞지 않다라고 판단.입출금은 빠르게 끝나는데 대출은 오래 끝나니까!이를 위해 큐를 여러개를 두자 이를 멀티레벨 큐. 1.2 Single ready queue → Several separate queues각각의 Queue 에 절대적 우선순위 존재또는 CPU time 을 각 Queue 에 차등배분각 Queue 는 독립된 scheduling 정책 큐가 여러개이므로 우선순위를 둬서 차등반영한다.또한 각 큐별로 다른 스케줄링 기법을 사용한다. 2. Multilevel Feedback Queue Scheduling큐를 여러개 둔다는점은 Multilevel Queue Scheduling와 같은데 하나의 입구로 진입해서 거의 실행되지 않는다면 다른큐로 이동한다. 2.1 다른 Queue 로의 점진적 이동모든 프로세스는 하나의 입구로 진입너무 많은 CPU time 사용 시 다른 Queue 로기아 상태 우려 시 우선순위 높은 Queue 로 상용운영체제는 여러 큐를 갖고있어 다양한 스케줄링 정책을 두어 적절히 활용한다. 3. Process Creation프로세스는 사람과 비슷하다. 프로세스는 프로세스에 의해 만들어진다. 그렇다면 제일 첫번째 프로세스는 어떻게 만들어졌을까??O/S가 메모리로 올라가고 초기화 작업을 하면 제일 처음 프로세스를 만든다. 제일 첫번째 프로세스 이름을 유닉스의 경우 init프로세스(OS마다 다름)라 한다. 이 프로세스가 다른 프로세스를 만든다. 3.1 Process Identifier (PID)사람의 주민등록번호와 같은것.처음 만들어지는 프로그램은 0이다.PPID? 부모 PID 3.2 프로세스 생성fork() system call - 새로운 프로세스 만드는것.exec() - 만들어진 프로세스의 실행파일을 메모리로 갖고오는것. 3.3 프로세스 종료exit() system call - 해당 프로세스가 가졌던 모든 자원은 OS에게 반환 (메모리, 파일, 입출력장치 등) 4. 쓰레드프로그램 내부의 흐름, 맥이라고 한다. 4.1 다중 쓰레드(Multithreads)하나의 프로그램에 맥이 2개이상 있는것.맥이 빠른 시간 간격으로 스위칭 된다 → 여러 맥이 동시에 실행되는 것처럼 보인다Web browser : 화면 출력하는 쓰레드 + 데이터 읽어오는 쓰레드Word processor : 화면 출력하는 쓰레드 + 키보드 입력 받는 쓰레드 + 철자/문법오류 확인 쓰레드 이전강의까지는 P1이 끝나면 P2로 넘어간다 했는데 그건 예전의 OS이다.즉 현재의 컴퓨터는 컨텍스트 스위칭 단위가 프로세스가 아니라 쓰레드 단위이다. 각 쓰레드는 코드와 데이터 공유하고 스택은 공유하지 않는다. 한 프로세스에는 기본 1개의 쓰레드 : 단일 쓰레드 (single thread) 프로그램한 프로세스에 여러 개의 쓰레드 : 다중 쓰레드 (multi-thread) 프로그램 4.2 쓰레드 구조프로세스의 메모리 공간 공유 : (code, data)프로세스의 자원 공유 : (file, i/o, …)비공유: 개별적인 PC, SP, registers, stack","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"8.SJF, Priority, RR 스케쥴링","slug":"operating-system8","date":"2019-02-16T04:17:07.000Z","updated":"2019-02-17T11:46:28.048Z","comments":true,"path":"2019/02/16/operating-system8/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/16/operating-system8/","excerpt":"","text":"CPU 스케줄링 알고리즘CPU 스케줄링은 레디큐에서 프로세스들이 CPU의 작업을 기다리고있을 때 누가 먼저 들어갈것인가에 대한것. FCFS는 이전포스트 참고 AWT를 평균대기시간이라 함.ATT를 Average turnaround time 반환시간이라함. SJF가장 짧은것을 먼저하는것.P1 6P2 8P3 7P4 3의 프로세스가있을 때 대기시간. p4, p1,p3,p2의 순서로 진행된다.평균 대기시간은 (3+16+9+0)/4 = 7 이다.FCFS로 하면(0+6+14+21) /4 = 10.25 이다. 실제로 프로세스가 얼마나 사용할지는 모른다. 해봐야 한다.대기시간을 줄이기 위해 적절한 방법이긴 한데 CPU 사용시간을 예측을 해야한다.(이를 정확하게 예측하기 위해서는 과거를 기억해야 하는등 계산하는데 오버헤드가 발생한다.) 실제로 적용하기엔 어렵다! Preemptive or Nonpreemtive 둘다 적용가능하다. Priority Scheduling우선순위가 높은것을 먼저 처리 우선순위는 내부적요소, 외부적 요소로 결정된다.내부요소: 타임 리밋이 짧은것을 높게주기, 메모리 적게잡는놈 높게주기, IO가 길고 CPU burst가 짧은거 높게주기 등등외부요소: 돈 많이 낸사람, 정치적요소 일반적으로 많이 사용된다. 이 또한 Preemptive or Nonpreemtive 둘다 적용가능하다. 문제점: 기아상태우선순위가 낮은 프로세스가 기다리는데 우선순위 높은것들이 자꾸 들어온다면 아무리 기다려도 자기 차례가 오지 않는다.해결방법 : againg 어떤 프로세스가 오래머물러 있다면 점진적으로 우선순위를 높여준다 Round Robin시간을 쪼개서 진행Time quantum 시간양자 = time slice (보통 10 ~ 100msec으로 잡는)Preemptive scheduling 타임퀀텀을 얼마로 잡느냐에 따라 AWT가 달라진다.즉 Time quantum에 의존적이다Time quantum을 무한대로 주면 FCFS와 동일하다 반대로 Time quantum을 0으로 주면 동시에 도는것과 같이느낄 수있다,context switching overhead 가 발생함.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"7.스케쥴링 척도, FCFS","slug":"os7","date":"2019-02-15T12:27:56.000Z","updated":"2019-02-17T11:45:42.025Z","comments":true,"path":"2019/02/15/os7/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/15/os7/","excerpt":"","text":"CPU 스케쥴링프로그램은 하드디스크안에 들어있고 아무런 동작도 하지안흔다. 메인메모리에 올라가서 실행이 되면 활동한다. 활동중에 있는 프로그램을 프로세스라함. 프로세스에 대한 것들을 PCB안에 넣어놓는다. 컴퓨터 안에는 여러가지 큐가 있는데 job queue, ready queue, device queue가 있다. 메인메모리에 여러 프로그램이 올라와있는게 멀티 프로그래밍프로그램이 몇개인가에 대한것이 Degree of multiprogramming 잡스케줄러가 하는일은 i/o-bound 를 CPU-bound process 적절히 분배하는것. short-term scheduler : 메모리에 올라온 프로세스들은 CPU를 받기위해 줄서있는데 어느놈을 선택해서 서비스해줄지에 대한것Long-term scheduler : 하드디스크에서 메인메모리에 올라가기 위해 job queue에 대기하는 프로그램중 어느놈을 먼저 올려야하는지에 대한것 메인메모리에 올라온 프로세스중에 일정시간동안 사용되지 않는것을 물리적인 하드디스크에 Swap out 한다.Medium-term scheduler : Swap out 리스트중 어느것을 Swap in 할지에 대한것을 의미함. 하드디스크는 파일시스템목적, Backing store(물리적인 하드디스크에 Swap out할 때 목적지) 용도로 사용된다. Context switchingCPU가 p1을 실행하다 p2로 넘어가는데 이를 문맥교환이라 한다. Scheduler레디큐에 있는 놈 중 어느놈을 CPU로 보내줄까에 대한것.지금있는 프로세스가 끝나면 어느놈을 선택할것인가에 대한것.O/S안에 들어있는 컴퓨터 프로그램이다. Dispatcher스케줄러가 선택한 프로세스를 실행하도록 여러가지 상태를 변경해주는것.p2가 선택되었다면 p2를 돌리기 위해 p1의 현재상태 프로그램카운터,스택포인터,레지스터,베이스레지스터 등을 P1의 PCB 에 저장해 놓아야한다.즉 p1의 현재상태를 pcb1에 저장해놓는다. p2의 PCB에저장된 값을 복원(restore)이런일을 하는것이 디스패처라 한다.이런일을 하는것은 오버헤드(부담)이 발생하게 된다. 이를 Context Switching Overhead라고 한다. 즉 컨텍스트 스위칭을 자주하는것은 손해이다.Dispatcher는 주로 어셈블리어와같은 low 레벨로 짜서 효율을 높인다. CPU스케줄링현재 실행중인 프로세스가 끝나면 어느것을 실행해줄까 Preemptive vs Non-preemptivePreemptive : CPU가 어떤일을 하고 있는데 IO를 만나거나 끝나지도 않았는데 강제로 끝내고 들어갈 수 있는것Non-preemptive : 이미 어떤프로세스가 실행중이면 끝나거나 IO를 만나지 않으면 변경되지 않는것 Scheduling criteria(척도)특정 Scheduling 기법을 판단하는 기준 CPU Utilization (CPU 이용률) : CPU가 놀지않고 얼마나 열심히 일하는가. a방법은 100%로 돌고 b방법은 80%로 들 때 a방법을 채택 Throughput (처리율) : 시간당 몇개의 작업을 처리하는가. Turnaround time (반환시간) : 작업이 ready queue로 들어가 작업을 끝내고 나오는 시간. Waiting time (대기시간) : CPU를 받기위해 ready queue에서 얼마나 기다려야 하는가. 당연히 짧을수록 좋다. Response time (응답시간) : interactive 환경에서 중요하다. 처음 응답이 나올때 까지 걸리는 시간. 주로 대화형 컴퓨터에서 척도로 삼음 기타 요소 존재…. First-Come, First-Served (FCFS)먼저온놈을 먼저 처리해준다. - Non-preemptive schedulling레디큐에 프로세스가 대기중이다. p1은 burst time 24p2는 3p3는 3 일때 평균적으로 기다린 시간은 (0 +24 + 27)/3 = 17 이다. P3,P2,P1 순으로 들어왔다고 할 경우 (0+3+6)/3 = 3 이라고 할 수 있다.당연히 아래방식이 더 좋다. 간트차트 추가 즉 이런방식으로 해주면 평균 대기시간을 고려할 때 그리 좋은방법이 아니다. Convoy Effect (호위효과) : CPU를 많이 잡아먹는놈이 앞에있으면 뒤에놈들이 오래 기다려야 한다. Shortest-Job-First (SJF)짧은 작업을 먼저 처리해준다. Shortest-Remaining-Time-FirstPriorityRound-Robin (RR)Multilevel QueueMultilevel Feedback Queue","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"6.프로세스의 정의, CPU 스케쥴러, 멀티프로그래밍","slug":"os6","date":"2019-02-15T12:24:01.000Z","updated":"2019-02-22T14:32:45.181Z","comments":true,"path":"2019/02/15/os6/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/15/os6/","excerpt":"","text":"프로세스 관리CPU를 프로세스한테 어떻게 잘 나눠주는가에 대한것. Process실행중인 프로그램. 프로그램은 무덤속에 있는것. 프로세스는 살아있는것.program in execution: text + data + stack, pc, sp, registers, … 프로세스의 상태new - 메인 메모리로 올라온 상태.ready - 실행할 준비가 모두 다 된상태 ( waiting이 끝나도 ready로 돌아옴)running - CPU가 실행중인 상태 (CPU를 잡게된 상태)waiting - 기다리는 상태. ( hwp 프로그램이 프린터를 요청하고 기다림. 즉 IO를 만나는 경우에도 wating상태가 된다,)terminated - 끝난상태. ready, running, wating의 반복으로 프로세스가 동작 타임쉐어링 시스템은 일정시간이 지나면 바로 ready 상태로 간다 PCB(Process Control Block )Task == Process프로세스 제어 블록이며 Task Control Block (TCB) 이라고도 함. PCB는 프로세스에 대한 모든 정보를 담고있다.하나의 프로세스에 대해 PCB를 갖고있다. 다른 프로세스로 처리가 넘어가다러도 다시 돌아올 수 있도록 관리.상태정보, PC(지금은 몇번지인지. 번지정보), registers, MMU info (base, limit), CPU time(CPU 이용시간), process id, list of open files(얘가 지금 어떤파일을 사용하고 있는지)… PCB는 OS의 프로세스 관리 부서(프로세스 매니지먼트,모르겠으면 이전포스팅 참고) 안에 들어있다. 모든프로그램은 원래 하드디스크 안에 들어있다. 여러가지 Queue하드디스크에서 메모리로 올라가기 위해서는 줄서서 기다려야한다. 그런것을 Job queue라고 한다. 메인메모리에 올라와서 CPU를 받으려면 줄서야 하는데 이를 Ready queue라고 한다. I/O를 사용하려 해도 줄서서 기다려야 한다. 이를 Device queue 라고 한다. I/O를 끝내면 ready상태로 가는데 여기서도 줄서서 기다려야 한다. Job scheduling(Long-term scheduler)하드디스크에서 메인메모리에 올라가기 위해 job queue에 대기하는 프로그램중 어느놈을 먼저 올려야하는지에 대한것을 Job scheduling(Long-term scheduler)라 한다. 잡 스케줄링은 역시 O/S 안에 프로세스 관리안에 존재한다.일반적으로 프로세스가 끝나고 메모리가 비워져야 일어나기 때문에 Long-term scheduler 라고도 한다. 즉 스케줄러가 일어나는 시간이 몇분이 걸린다. CPU Scheduler( Short-term scheduler )메모리에 올라온 프로세스들은 CPU를 받기위해 줄서있는데 어느놈을 선택해서 서비스해줄지에 대한것을 CPU Scheduler( Short-term scheduler )이라 한다.메인 메모리에 여러 프로그램이 있는데 스위칭이 빠르게 일어난다. 1초에 수십번,수백번도 발생한다. 그래서 Short-term scheduler 라고도 부른다. 다른 스케줄링 보다도 가장 중요한 스케줄링이다. Device Scheduler디바이스 서비스를 받기위해 기다리는것을 Device Scheduler이라 한다. 멀티프로그래밍메인메모리에 하나의 프로그램, 프로세스를 올리는것이 아니라 여러개를 올리는것. Degree of multiprogramming - 멀티프로그래밍의 정도 ( 메인메모리에 몇개의 프로세스가 올라와있는가) 프로세스의 구분프로세스는 크게 두가지로 나눌 수 있다,i/o-bound : 프로세스가 하는게 주로 I/O를 사용하는것(ex. 워드프로세서)CPU-bound process : 프로세스가 주로 cpu를 사용함.(ex. 일기예보와 같은 계산) O/S는 작업을 적당히 섞어서 잡 스케줄링결과로 CPU 혹은 IO에만 작업이 치중해 한쪽이 놀지 않도록 한다. Medium-term scheduler서버컴퓨터에 여러명이 사용중이라 가정하자. B라는 사람이 심심해서 커피를 마시러 갔다하자. 그동안 B를 위한 메모리는 올라와있지만 CPU는 아무역할도 하지 않는다. 즉 낭비다. B를 위한 자원을 쫒아내는것이 이득인데 이를 위해 디스크로 쫒아내고 비어있는 메모리공간을 확보한다. 여기서 쫒아내는 것을 Swap out라고 한다. 이처럼 디스크를 프로세스 이미지를 쫒아내는 목적으로 사용하는것을 swap device 라고 한다. 다시 B가 커피를 마시고 돌아와 마우스를 움직이면 Swap device로 갔던 프로세스를 불러들이는데 이를 Swap in이라 한다. swap device로 swap in되고 swap out 되는것을 Swapping 이라 한다. 이때 쫒겨났을때 쫒겨난 자리로 그대로 들어가는것을 보장하지는 않는다. 즉 Medium-term scheduler 는 현재 사용되고 있지 않은 어떤놈을 쫒아낼지 결정하는것이다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"5.운영체제의 주요 서비스 프로세스, 메모리, 파일관리, 시스템 호출","slug":"operating-system","date":"2019-02-14T13:01:23.000Z","updated":"2019-02-17T11:02:54.527Z","comments":true,"path":"2019/02/14/operating-system/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/14/operating-system/","excerpt":"","text":"운영체제 서비스지금은 서버컴퓨터 하나에 여러명이 동시에 사용하는 구조.이러한 구조에선 한사람이 잘못된 것을 할 경우 해악이 될 수있다. 다중유저시스템, 다중프로그래밍시스템에서 필요한 보호들 1.입출력장치 보호A,B가 바로 하드웨어에 접근하지 못하도록 함어떻게? In(입력),Out(출력) 명령을 특권명령으로 만들어 A,B는 이를 실행하지 못하고 O/S에게 부탁하여 실행토록 함.그러면 O/S가 프린터를 구동시켜줌 2.메모리 보호자기에게 넘어간 메모리 접근을 못하도록 하는것.유저1이 OS영역이나 다른사람 영역을 못들어가도록 함.어떻게? MMU를 활용하여 base, limit 값을 넘지 못하도록한다. 넘을경우 인터럽트를 발생시켜 프로그램 강제종료 3.CPU 보호while(a=1)…위의 경우 CPU가 한 사용자에 독점되게 된다.어떻게? 타이머를 걸어서 일정시간이 지나면 인터럽트를 걸도록 한다.인터럽트 서비스 루틴에는 CPU가 골고루 돌아가고 있는지. 한 프로그램에만 돌아가고 있지 않은지 파악하도록 짠다.인터럽트 &gt; 운영체제 &gt; 다른 프로그램으로 강제 전환 운영체제가 하는일정부가 하는일과 비슷하다.자원을 효율적으로 나눠주는 시스템을 OS라 한다.모든애플리케이션은 하드웨어를사는데 이 하드웨어를 적절하게 분배하는것을 OS라 한다. 프로세스 매니지먼트이 중 CPU를 나눠주는 부분이 프로세스 매니지먼트 프로세스는 ? 메인 메모리에서 실행중인 프로그램. 실행상태에 있는 프로그램하드디스크에는 많은 프로그램이 있지만 메인메모리로 올라와 있는 것을 프로세스라 함.그래서 프로그램 매니지먼트라 하지않고 프로세스 매니지먼트라 함. 프로세스들이 많아지만 교착상태가 발생할 수 있는데 이를 프로세스 관리부분이 처리해준다. 메인메모리 매니지먼트주기억장치를 나눠주는 부분이 메인메모리 매니지먼트 프로세스한테 메인메모리를 할당한다.메모리의 어느 부분이 어느 프로세스에게 할당되었는가 추적 및 감시프로세스 종료 시 메모리 회수 (deallocation)메모리의 효과적 사용가상 메모리: 물리적 실제 메모리보다 큰 용량 갖도록 파일 매니지먼트하드디스크 안에 파일을 관리하는것이 파일 매니지먼트 판 위에 트랙을 만들고 이를 잘라서 섹터라 한다. 즉 트랙, 섹터의 집합 파일을 만들기도 하고 없애기도 하고 디렉토리 생성 삭제에 관여파일에 대한 기본동작(open, close, read, write, create, delete) 지원백업(backup) 보조기억장치관리(Secondary storage management)보조기억장치는 트랙, 섹터의 집합인데 이를 어떻게 관리할것인가 하드 디스크, 플래시 메모리 등 섹터들을 모아서 block이라 하는데 block들에 데이터를 저장하게 되는데 빈 공간 관리, 저장공간 할당, 디스크 스케쥴링을 제공한다. 입출력 장치 관리장치드라이브 관리(웹켐, 사운드카드 등)입출력 장치의 성능향상을 위해 버퍼링, 캐싱, 스풀링을 활용한다 스풀링 메모리 대신 하드디스크를 중간 매체로 사용한다.스풀링 : 프린터는 일반적으로 느리기때문에 씨피유에 저장하기 보다는 씨피유보다 느리고 프린터 보다 빠른 하드디스크에 저장하는것.빈 공간 관리 (free space management)저장공간 할당 (storage allocation)디스크 스케쥴링 (disk scheduling) 네트워킹보호기타 등등…시스템 콜O/S가 제공하는 여러가지 기능을 받기 위해 호출하는것. OS에는 여러가지 관리 부서가 있다.또한 여러가지 프로그램이 메모리로 올라가 여러 프로세스가 존재한다,각 프로세스는 OS가 제공하는 관리 기능들이 필요한데 이때 이를 사용하기 위한것이 시스템 콜이라 한다. 주요 시스템 콜– Process: end, abort, load, execute, create, terminate, get/setattributes, wait event, signal event– Memory: allocate, free– File: create, delete, open, close, read, write, get/set attributes– Device: request, release, read, write, get/set attributes, attach/detache devices– Information: get/set time, get/set system data– Communication: socket, send, receive","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"4.사용자모드와 관리자모드, 하드웨어 보호","slug":"os4","date":"2019-02-11T12:29:11.000Z","updated":"2019-02-15T12:27:37.482Z","comments":true,"path":"2019/02/11/os4/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/11/os4/","excerpt":"","text":"이중모드, 하드웨어 보호한 컴퓨터를 여러 사람이 동시에 사용하는 환경이다.한사람의 실수가 전체에 영향을 끼칠 수 있으므로 일반유저는 STOP, HALT, RESET 등과같은 명령어는 일반 유저가 이용할 수 없도록 하는것. 이를 이중모드라 한다. 이를 사용자(user)모드, 관리자(supervisor) 모드 라고 한다.관리자 모드 = 시스템 모드 = 모니터 모드 = 특권 모드특권 명령(ex. STOP, HALT, RESET, SET_TIMER, SET_HW 등은 관리자 모드에서만 사용 가능) 이중모드 동작방식CPU안에 레지스터 ALU, 제어유닛이 있다, 레지스터는 비트들의 모음(32bit의 경우 32개가 있다.)레지스터 비트는 carry,zero, negative, overflow 와 같은 플래그도 갖고있다,또한 이중모드를 나타내기 위한 플래그(모니터 비트라 함) 또한 레즈스터에 존재한다. 모니터 비트가 1이면 시스템모드 0이면 유저모드이다. 가령 게임을 실행하고 저장한다고 가정해보자.1.처음 파워를 키면 부팅이 일어난다 이때는 모니터 비트가 1이다.(시스템 모드)2.OS의 부트가 끝나고 특정 게임을 실행한다고 하자, 그럼 디스크에서 게임을 메모리로 갖고올 것이다.3.그리고 실행이 게임으로 넘어갈 때 모니터 비트는 0 (유저모드)로 변경된다.4.다시 게임내용을 하드디스크에 저장할 때는 OS에게 부탁(SWI,소프트웨어 인터럽트)하여 OS가 저장하게 한다(다른파일을 덮어쓰는지와 같은 부정한 행위를 하는지에 대한 판단을 하고 저장하게 해줌). 이때는 모니터 비트가 다시 1이된다. //물론 게임 자체적으로 디스크에 저장할 수 있지만 보안상의 이슈 존재!5.저장을 완료하면 다시 게임 프로그램으로 돌아오고 모니터 비트가 0이된다. 운영체제 서비스 실행될 때는 관리자 모드사용자 프로그램 실행될 때는 사용자 모드하드웨어/소프트웨어 인터럽트 발생하면 관리자 모드운영체제 서비스가 끝나면 다시 사용자 모드 하드웨어 보호1.입출력장치에 대한 보호 하드웨어에 대한 적절한 보호가 없을 때의 경우내가 프린트하는데 누가 방해할라고 그놈도 계속 프린트 명령을 보내는상황이 발생했을 때.내가원하는 출력물, 상대가 원하는 출력물이 섞여서 나오는 경우가 생길 수 있다. 어떻게?아무유저나 In,Out 명령을 내리지 못하도록 특권명령으로 한다. 사용자가 입출력 명령을 직접 내린 경우?Privileged instruction violation 이라 하며 해당 프로그램을 강제로 중지시킨다. 메모리 보호멀티프로그래밍, 타임쉐어링 프로그래밍에서는 동시에 여러프로그램이 돌고있다.특정 프로그램이 돌면서 다른 프로그램 혹은 OS의 영역에 기웃거리지 못하게 한다. 어떻게?메모리에 접근하려면 어드레스 버스를 통해야하는데 어드레스 버스에 문지기를 두어 자기것에만 접근하는지 확인한다.확인할 때는 base, limit 를 참고한다. 잘못된 범위를 읽을 땐 인터럽트를 O/S로 보낸다. 잘못된 번지를 읽을 때 보내는 신호를 보통 Segment violation 라고 부른다. 여기서 문지기를 MMU(Memory Management Unit)라고 한다. base 와 limit 사이에 들어오는지 확인하며 base와 limit는 OS가 관리한다. 또한 base와 limit는 아무나 설정하면 안되므로 특권명령으로 관리된다. 3.CPU 보호","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"3.최근의 고급운영체제, 인터럽트에 기반한 현대 운영체제","slug":"os3","date":"2019-02-11T10:49:46.000Z","updated":"2019-02-15T12:27:37.793Z","comments":true,"path":"2019/02/11/os3/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/11/os3/","excerpt":"","text":"다중 프로세서 시스템메모리는 하난데 CPU가 여러개이다. 이를 병렬 시스템이라고도 한다.장점 : 병렬 시스템을 통한 성능향상을 목표 비용 : 하나의 강한 CPU 보다 여러개의 저렴한 CPU로 구성하는것이 일반적으로 저렴하다. 신뢰성 제공 : 하나가 고장나도 다른 CPU로 돌릴 수 있다. CPU가 여러개일 때 운영체제를 다중 프로세서 운영체제라 한다. 또한 강결합이라 한다. 분산 시스템멀티컴퓨터 시스템이라고도 하며 네트워크(LAN) 등으로 연결되어 있다.이는 메인메모리가 따로있고 랜으로 연결되어있으므로 소결합이라 한다.OS도 서로 다 따로따로 있다. 이를 분산 운영체제라 한다. 다중프로세서 시스템, 분산시스템의 공통점신뢰성, 성능, 비용절감을 목표로 한다. 실시간 시스템특정 시간내에 반드시 연산이 끝나야 하는것.시간제약 즉 Deadline를 정해둔다. 실시간 시스템은 네비게이션에서도 쓰인다. 실시간 경로안내할때 그 지점에 도착하기 전에 계산이 끝나야하기 때문에주로 공장자동화, 군사, 항공, 우주 분야에서도 쓰인다.실시간 시스템을 위한 운영체제는 실시간 운영체제(Real-time OS = RTOS)라 한다. 인터럽트현대 운영체제는 인터럽트 기반 시스템이다. 컴퓨터를 키면 ROM에 있는 부트로더가 디스크에서 O/S를 메모리로 갖고온다. 이를 부팅이라 한다.이 후 운영체제는 메모리에 상주하게 된다.이 다음에는 아이콘이 나타나고 깜빡거린다.이러다 우리가 마우스를 움직이면 전기신호가 발생하고 CPU에 인터럽트 선을 통해 전기신호를 올려준다.그럼 CPU는 지금하던일을 중지하고 OS안에 마우스가 어떤 전기신호를 보냈을 때 어떤 행동을 하라고 정의되어있는지(mouse interrupt service routine)에 따라 처리한다. 하드웨어 인터럽트인터럽트 결과 운영체제 내의 특정코드를 실행한다.(ISR)interrupt Service Routine 종료 후 다시 대기 소프트웨어 인터럽트SWI 명령어는 인터럽트가 걸리는것이다. 보통 인터럽트는 하드웨어가 걸리는데 SWI(Software interrupt) - ARM에서의 소프트웨어 인터럽트 명령INT - 팬티엄에서의 인터럽트 명령 hwp 프로그램이 실행되다가 하드디스크에 있는 내용을 읽어온다고 가정하자.하드디스크를 읽어오는 루틴은 O/S안에 존재한다. 이것또한 ISR이다. 아무튼 하드디스크 내용을 읽기위해 소프트웨어 인터럽트가 걸리게 되고 O/S안에 있는 하드디스크를 읽어오는 루틴을 실행하고 원래 실행중인 곳으로 돌아온다. 운영체제는 평소에는 대기상태이다운영체제는 평소에는 대기상태이다. 그러나 하드웨어 인터럽트, 소프트웨어 인터럽트, 내부인터럽트에 의해 운영체제 코드를 실행한다. 내부 인터럽트는 5를 0으로 나누는것과 같은 논리적인 오류가 있을 때 발생하는 인터럽트이다. 이 땐 divide by zero를 처리하는 ISR이 호출된다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"2.일괄처리부터 시분할시스템까지 운영체제 변천 역사","slug":"os2","date":"2019-02-10T13:33:13.000Z","updated":"2019-02-15T12:27:36.853Z","comments":true,"path":"2019/02/10/os2/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/10/os2/","excerpt":"","text":"컴퓨터의 역사2차세계 대전 중 1940년대 말 만들어졌다. 1.초기에는 운영체제가 존재하지 않았다. 2.이후엔 Batch processing system(일괄처리)이 나왔다이는 최초의 O/S로 볼 수 있다. 3.Multiprogramming system가령 수를 더해서 출력하고 다시 이를 특정 수를 반복해서 더하는 프로그램이 있다고 해보자.수를 더하는것은 CPU가 할 것이고 출력은 입출력 장치가 하게될것이다.이 때 CPU가 작업을 마치고 출력을 위해 입출력 장치가 출력을 실행하게 되면 느린 i/o의 성능으로 인해 CPU가 idle(노는시간) 즉 기다리는 시간이 생기게 된다. 이를 개선하기 위해 메모리에 여러 프로그램을 올리고 실행중인 프로그램이 i/o를 만나면 다른 프로그램을 실행토록 한다. 이를 통해 CPU가 노는 시간이 없도록한다.이와 관련하여 CPU scheduling가 나오게된다. 어떤 순으로 실행하여 성능을 좋게할까에 대한 알고리즘이다.메모리 관리또한 나오게된다. 이는 적절하게 프로그램을 메모리에 배치하기 위한 기법이다.보호개념또한 등장하게 되는데 메모리에서 다른 프로그램의 영역에 침범하면 안되므로! 4.Time-sharing system여러사람이 한 컴퓨터로 들어와 자신의 프로그램을 사용한다고 가정하자. 이 때 여러사람들은 Multiprogramming system에서는 동시에 사용하기란 불가능하다.(이는 I/O를 만나야 다른 프로그램을 동작시키는 로직이므로..)그래서 아주 짧은시간으로 나눠 여러 유저의 작업을 번갈아가며 CPU가 처리해주도록 한다. 이러한 시스템이 등장하며 특정유저가 다른 유저에게 데이터를 주고받는것이 즉 프로세스간 통신이 가능해졌다.또한 누가 먼저 앞서고 뒤서는지에 대한 동기라는 개념이 등장한다.또한 하드디스크의 일부를 메인메모리인냥 사용하는 기술인 가상 메모리 또한 등장하게된다. OS 기술 천이컴퓨터의 규모별 분류는 다음과 같다.과거의 분류 : Supercomputer &gt; Mainframe &gt; Mini &gt; Micro현재의 분류 : Supercomputer &gt; Server &gt; Workstation &gt; PC &gt; Handheld &gt; Embedded워크스테이션 : PC에서 처리못하는 조금 큰 작업 처리","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"1.\t운영체제의 정의와 역할","slug":"os","date":"2019-02-10T12:03:53.000Z","updated":"2019-02-22T14:15:21.308Z","comments":true,"path":"2019/02/10/os/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/10/os/","excerpt":"","text":"운영체제 포스팅은 http://www.kocw.net/home/search/kemView.do?kemId=978503 (KOCW) 를 참고하여 작성됩니다. 운영체제가 없는 PC는 어떨까?야생마와 같다. 프로그램 실행과 같은 동작을 할 수 없게된다.하드디스크에 있는 파일을 메모리에 올릴수 없다.즉 하드디스크에 있는 파일을 운영체제가 올려주는것! 운영체제란?하드웨어를 잘 관리하는것.(하드웨어: 프로세서, 메모리, 디스크…)이를 통해 성능을 올리고 사용자에게 편의성을 제공 부팅메모리는 램, 롬으로 나뉜다. 대부분은 램으로 구성된다. 롬은 많아야 수백키로바이트밖에 되지 않는다,그렇다면 ROM이 필요한 이유는? 전원을 껐다 켜면 램의 데이터는 다 날라가는데 ROM은 그렇지 않다. 컴퓨터를 부팅하면 프로세서는 ROM에 있는 코드를 읽어온다.그렇다면 ROM에는 어떤 프로그램이 있으며 부팅과정은?1.POST(Power On Self Test) 프로그램을 ROM에서 가져와 실행 POST? 모니터는 끼워져있는가, 키보드는 꽂아져 있나, 메모리는 얼마인가 등을 확인하는 프로그램2.부트로더(Boot loader)를 ROM에서 가져와 실행. 부트로더는? 하드디스크를 뒤져서 os를 메인메모리(RAM)로 갖고온다. 이를 부팅이라 한다. 메모리에 올라온 OS는 컴퓨터가 종료될때 까지 지워지지 않는다. 하지만 다른 응용프로그램들은 프로그램 종료에 따라 지워지게된다. 그래서 OS를 메모리 Resident라고 한다. 커널과 쉘OS는 하드웨어를 감싸고 있는데 하드웨어를 제외한 부분을 kernel이라고 한다. 또한 OS의 바깥부분을 (shell,command interpreter)이라 한다. 어떤 명령을 내릴 수 있도록 만드는것을 (shell,command interpreter)이라고 한다.다시말해 OS바깥부분에 위치해서 사용자의 명령을 받아들이는 곳. 그 명령을 인터프리터(해석해서) 명령을 실행해주는 것! 커널은 실제로 Cpu,메모리, 디스크를 관리하는것. 응용프로그램 동작?응용프로그램은 O/S위에서 동작한다.즉 맥킨토시 app을 윈도우에서 실행하면 동작하지 않는다. OS 는 정부와 비슷하다.주어진 자원을 어떻게 활용할까에 대한 고민을 하는것이 유사! 정부에도 여러가지 부서가 있듯이 OS안에도 많은 부서가 존재! 프로세스 매니지먼트 - 프로세스 관리부서메모리 매니지먼트 - 메모리 관리IO 매니지먼트 - 프린트, 키보드 관리파일 매니지먼트 - 파일관리네트워크 매니지먼트 - 네트워크 관리시큐어티 매니지먼트 - 보안관리…..이런부분을 모두 운영체제의 커널로 불린다. 가장중요한것은 프로세스 매니지먼트! CPU가 가장비싸니까 가장 중요하고 프로그램 동작에 핵심이다.그다음으로 중요한것이 메모리 매니지먼트","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Operating System","slug":"CS/Operating-System","permalink":"http://KKimSangHeon.github.io/categories/CS/Operating-System/"}],"tags":[]},{"title":"oneM2M, OMA-DM 생각정리..","slug":"mine","date":"2019-02-08T10:53:12.000Z","updated":"2019-02-10T08:02:03.813Z","comments":true,"path":"2019/02/08/mine/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/08/mine/","excerpt":"","text":"oneM2Miot 솔루션을 제공함에 있어 여러 벤더를 맞추기란 힘들다… oneM2M이라는 표준을 만들고 이를 여러 벤더가 맞춤으로써 응용개발사 또한 iot시스템을 개발함에 있어 개발공수를 낮출 수 있게된다.oneM2M에는 CSE라는게 있는데 공통서비스를 제공하는것이다. 가령 데이터 저장, 요금청구 등등 다양하게 있다.. CSE는 REST 형태로 제공되어 편리하다는 장점이 있으며 최근에는 일반 응용개발에 oneM2M을 적용하여 CSE를 적절히 활용하는 경우도 있다. 이를 Distributed Platform 형태 라고 한다통신사업자는 oneM2M 표준을 기반으로 CSE를 사용하는 플랫폼을 만들고 일반에 공개하게 되면 일반 개발자들은 통신사업자가 만든 플랫폼을 사용할 수 있게된다.(?? 맞는지 모르겠다.) OMA-DM이는 이동통신장치 관리표주으로서 내부 데이터에 접근하고 제어하는 표준이라 이해했다. xml기반 마크업 언어 SyncML 기반으로 명령과 결과를 주고받으며 심지어 운영체제 설치 그리고 응용프로그램의 파라미터 까지 변경이 가능하다고 한다. 여기서 관리할수 있는 자원을 관리객체(MO, Management Object)라고 한다. TR-069CPE WAN Management Protocol (CWMP) 이라 불리며 CPE 즉 사용자 단말을 관리하는 프로토콜인것같다. oneM2M과 OMA-DM의 상관관계???아래부터 개인적인생각입니다. 참고하지도 마세요!oneM2M은 장치에서 받은 데이터를 활용하고 정제 저장하는 표준이라고 생각한다. 즉 디바이스의 정보를 뭐 제어하거나 어떻게 가져오는건 아니라 생각한다.하지만 OMA-DM는 내부데이터 관리와 같은 디바이스 내부로 들어가는 표준인것같다. 아래 그림처럼 구분되나보다","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"IOT","slug":"CS/IOT","permalink":"http://KKimSangHeon.github.io/categories/CS/IOT/"}],"tags":[]},{"title":"onem2m","slug":"onem2m","date":"2019-02-08T09:44:50.000Z","updated":"2019-02-08T10:39:25.022Z","comments":true,"path":"2019/02/08/onem2m/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/08/onem2m/","excerpt":"","text":"https://www.youtube.com/watch?v=tBQ085PvR9E 요약 IOT의 4계층Application layer - 스마트홈, 스마트카, 헬스케어Service layer - IoT 서비스 개발이 용이하도록 공통으로 요구되는 기능 제공 oneM2M, AllJoyn, OICNetwork layer - 장치 간 또는 서비스간 연결, 정보전달 HTTP, CoAP, MQTT, Wi-Fi ...Device layer - 센서 또는 다른 하드웨어 oneM2M ?IoT 응용 개발이 용이하도록 공통 기능을 제공하는 국제표준 플랫폼 기술 데이터관리, 연결 제어, 구독/통지, 보안, 그룹관리 …. 등을 제공하는데 응용 개발자는 이를 적절히 활용하여 개발공수를 줄일 수 있다. oneM2M발생이유기존엔 응용이 특정한 디바이스를 타겟으로 개발되었다. 이를 개선할 수 있는것이 oneM2M oneM2M먼저 Use Case를 기반으로 요구사항을 도출해봤더니 다음과 같았다.일반요구사항: 성능, 네트워크 연결지원에 따른 다양한 IoT장치 지원, QoS 기반 메시지 전달, 과금관리…장치관리요구사항: OMA DM/ BBF TR-069, 펌웨어, 소프트웨어 제어, 고장제어보안 요구사항:요청자에 대한 인증/권한 부여, 기반 네트워크 보안기능 활용 이를 기반으로 공통기능 CSE를 도출해냄데이터관리 : 장치가 데이터를 저장할 수 없을때 플랫폼이 저장해준다연결제어 : 레이턴시는 10ms 이하여야 한다.(예시)구독. 통지 : 온도가 40도 이상이면 문자보내줘과금 : 통신플랫폼의 사업자 이므로 이 또한 가능이종 플랫폼 연동사업자간 로밍 : 나의 커넥티드 카가 해외로 넘어가게 되면 로밍을 제공기타 많은 공통기능 제공 oneM2M 안드로이드 플랫폼이랑 유사하다. CSE는 공통기능이 포함된 엔티티다. AE를 카카오톡이라고 보면 좋다. 카톡은 안드로이드에 존재하는 간단한 API를 호출해 메세지를 보낸다.즉 AE개발자는 CSE를 적절히 활용하면 된다. 여러플랫폼이 서로 연결되어 큰 iot를 만들어 낼 수 있게된다. Distributed Platform 형태인 oneM2MIOT의 호출순서는 다음과 같다고 가정 하자.디바이스 - 게이트웨이 - 클라우드 - 게이트웨이 - 디바이스과거에는 클라우드에만 CSE를 탑재하여 호출하였지만 최근에는 게이트웨이, 디바이스에도 이를 탑재하여 분산처리를 한다.물론 하드웨어의 용량이 부족할 경우 플랫폼 기능을 배제하기도 한다. 이 경우 Constrained Device Support 라고 한다. 그렇다면 CSE를 어떻게 호출할까?과거에는 RPC(Remote Procedure Call)을 활용하였지만 REST 기반 API구조를 사용한다.CSE의 기능들을 REST 형태로 개방한다. 즉 URI만 갖고있으면 웹브라우저에서 기능을 호출할 수 있다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"IOT","slug":"CS/IOT","permalink":"http://KKimSangHeon.github.io/categories/CS/IOT/"}],"tags":[]},{"title":"TR-069","slug":"TR-069","date":"2019-02-08T05:52:45.000Z","updated":"2019-02-10T08:35:10.602Z","comments":true,"path":"2019/02/08/TR-069/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/08/TR-069/","excerpt":"","text":"TR-069customer-premises equipment (CPE, 말단 사용자 장치)Auto Configuration Servers (ACS, 자동 설정 서버) TR-069 (Technical Report 069)는 DSL 포럼 (이후 Broadband 포럼으로 변경)의 기술 명세서이다. 이 문서의 정식 명칭은 CPE WAN Management Protocol (CWMP)이다. 이 문서는 말단 사용자 장치를 관리하기 위한 사용자 계층 프로토콜을 정의하고 있다. TR-069 프로토콜은 양방향 SOAP/HTTP 을 기반으로 customer-premises equipment (CPE, 말단 사용자 장치) 와 Auto Configuration Servers (ACS,자동 설정 서버) 간 통신을 가능하게 한다. 또한 안전한 자동 설정 기능을 제공하며 통합 환경 내에서 다른 CPE 관리 함수를 제어하고 동작시킬 수 있도록 해준다. 등장배경 브로드밴드 시장이 활성화 되면서 여러개의 다른 종류의 인터넷 접속 또한 많이 생겨났다. ( 모뎀, 라우터, 게이트웨이, 세트톱박스, VoIP-phone 등). 또한 동시에 이러한 장비들을 설정하는 것은 더욱 복잡해졌다. 말단 사용자에게는 이러한 설정이 더욱 어려운데 이러한 이유로 TR-069 표준이 개발되었다. TR-069 표준은 여러가지 접속 방법에 대한 자동 설정을 제공한다. 이에대한 구체적인 기술적인 사항은 Broadband 포럼에서 관리하고 발행하고 있다.TR-069을 이용해서 말단 장비들은 자동 설정 서버 (Auto Configuration Servers) (ACS)에 접속하고 필요한 설정을 자동으로 받아오게 된다. 이렇게 함으로써 사용자가 따로 설정하지 않아도 필요한 서비스를 사용하는 것이 가능해진다. TR-069는 DSL broadband 시장에서 터미널을 활성화하기 위해 현재 사용중인 표준이다. CPE WAN Management Protocol (CWMP)??서비스 프로바이더가 ACS를 통해 CPE를 원격으로 데이터 모델을 관리할 수 있게 해준다. 제공기능은 다음과 같다. 자동 구성 및 동적 서비스 프로비저닝소프트웨어 / 펌웨어 이미지 관리소프트웨어 모듈 관리 상태 및 성능 모니터링 진단 TR-069 아키텍처 All CWMP sessions begin with the CPE making the Inform RPC on the ACS. This is also referred to as “sending an Inform” or “an Inform message”. An Inform RPC, and consequently, a CWMP session, is always made for a specific reason, called an Event. These Events drive CWMP operation. TR-069 초기 세션ACS와 연결하기 위해서는 다음의 데이터가 필요하다. ACS URL : ACS에 접속하기 위한 URL 주기적인 알림 : ACS와 주기적인 소통이 정의되어야 한다. Username and password - 옵션데이터이나 보안을 위해 하는것이 좋다. 1.First, the CPE initiates a TCP session with ACS and negotiates a secure connection.2.The CPE begins every session by sending an Inform RPC to the ACS, with arguments that include the Event that caused the session. This is done over an HTTP Post.3.In the HTTP Response, the the ACS sends an InformResponse. Once processed by the CPE, this means that the Inform RPC is complete.4.There’s probably no other RPCs that CPE wishes to make on the ACS, so it sends an empty HTTP Post to indicate that it is finished. This may happen at any time during the session.5.The ACS begins to send remote procedure calls to the CPE, such as the GetParamterValues RPC.6.The CPE sends its GetParameterResponse in an HTTP Post, with the information the ACS was looking for. This ends the GetParameterValues RPC.7.The ACS makes any other RPCs it needs to during this session, such as SetParameterValues to change the state of the CPE, or SetParameterAttributes to set up a notification.8.When the ACS has no more RPCs to make, it sends an empty HTTP Response, just like the CPE did earlier. When both the CPE and the ACS have done this, the session is over and it’s time to tear down the connection. 전송방식CWMP는 텍스트 기반 프로토콜입니다. 장치 (CPE)와 자동 구성 서버 (ACS)간에 전송 된 주문은 HTTP 혹은 HTTPS 를 통해 전송됩니다. 이 수준 (HTTP)에서 CPE는 클라이언트 역할을하며 ACS는 HTTP 서버 역할을합니다. 별첨SOAPSOAP(Simple Object Access Protocol)은 일반적으로 널리 알려진 HTTP, HTTPS, SMTP 등을 통해 XML 기반의 메시지를 컴퓨터 네트워크 상에서 교환하는 프로토콜이다. SOAP은 웹 서비스에서 기본적인 메시지를 전달하는 기반이 된다. 참고자료https://www.qacafe.com/tr-069-training/","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"IOT","slug":"CS/IOT","permalink":"http://KKimSangHeon.github.io/categories/CS/IOT/"}],"tags":[]},{"title":"OMA-DM","slug":"oma-dm","date":"2019-02-08T01:29:08.000Z","updated":"2019-02-10T08:41:54.697Z","comments":true,"path":"2019/02/08/oma-dm/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/08/oma-dm/","excerpt":"","text":"OMA(Open Mobile Alliance)이동통신 서비스 애플리케이션 표준화 기구이며 일부 애플리케이션 프로토콜을 다루고 있는 산업 포럼의 증진에 응하기 위해 2002년 6월 설립되었다. Device Management(DM) ?장치 관리 기술이란 직접 수익을 창출하는 기술은 아니지만, 사업자가 응용 서비스를 시작하고 개선하고 관리하는 과정에서 겪는 문제점들을 해결해 줄 수 있는 효과적인 기술로서 이들 서비스를 통한 수익 창출에 효과적인 솔루션이다.WAP, 3G Partnership Project(3GPP), Open Service Gateway Initiative(OSGi), Telemanagement Forum(TMF)등은 그들이 개발한 응용 서비스를 관리해 줄 수 있는 기술, 그들이 개발한 서비스 관리 기법을 가능하게 해줄 기술을 필요로 하게 되었다. OMA-DM장치(단말기) 안에 존재하는 데이터를 서버가 원격으로 접근할 수 있도록 하는 Technology와 규격을 OMA가 제정함 OMA 장치 관리 기술은 범세계적인 이동 통신 시장의 특별한 Use Case와 요구 사항을 고려하여 개발되고 있으며, 특히 이동 단말기의 종류, 운영체제, 지역, 네트워크 기술에 제한되지 않은 열린 기술이기 때문에 결국 기존의 일부 특정 네트워크와 단말기에 국한된 장치 관리 기술들을 통합하거나 대체할 수 있는 기술이다. OMA-DM 은 초기 설정, 소프트웨어 및 펌웨어 관리, 원 격 제어, 진단 및 모니터링 등의 기능을 가지고 있으며, 스마트폰 등의 모바일 단말을 대 상으로 관리 서비스를 제공한다. OMA-DM 프로토콜두 통신 상대가 장치 관리 서비스를 제공하는 서버와 장치 관리 서비스를 받아 처리하는 클라이언트의 관계를 갖는다는 관점에서 비대칭 구조를 갖는 프로토콜이다.장치 관리 서버의 역할은 클라이언트에게 장치 관리 명령을 내리는 것이고 클라이언트의 역할은 주어진 명령을 수행하는 것이다. 장치 관리 서버는 장치 관리 명령을 통해 장치에 설치된 응용 서비스의 파라미터를 변경할 수 있으며, 새로운 파라미터를 생성하도록 할 수 있으며, 장치 내부의 정보를 읽어낼 수 있으며, 응용 소프트웨어를 장치에 설치하고, 그것들의 실행을 원격으로 제어할 수 있을 뿐 아니라 운용체제(OS)를 다시 설치할 수도 있다. 결국, OMA Device Management 프로토콜이란 장치의 자원을 장치 관리 서버가 원격으로 접근할 수 있게하는 프로토콜이며, 장치 관리 프로토콜을 통해 관리할 수 있는 이러한 자원을 관리 객체(Management Object) 라고 부른다 서버와 클라이언트간의 장치 관리 명령과 결과는 원격으로 XML에 기반한 마크업(Markup) 언어인 SyncML 메시지를 HTTP, WSP, OBEX 등의 유선, 무선, 또는 적외선 전송 프로토콜을 통해 서로 전송된다. 뿐만 아니라, Device Management(DM) Tree라는 장치 관리 프로토콜만의 파일 시스템을 정의하고 각 노드를 URI를 통해 접근할 수 있도록 하였다. 그리고, 장치 고유의 데이터 베이스 또는 파일 시스템은 DM Tree와 메핑을 통해 장치 관리 서버에게 투사된다. 그러므로 어떤 장치는 결국 장치 관리 서버에게 있어서 하나의 DM Tree로 나타나게 되는 셈이다. 또한 동일한 장치라도 주어진 접근 권한에 따라 서로 다른 서버에게 다른 형태로 나타나게 된다. OMA Device Management 기술 규격의 구성아래 그림의 규격 구성에 깔린 의도는 첫째로, 기본 규격(Base Protocol)을 다른“Silo”규격들과 분리함으로써 기본 규격이 오랜 기간동안 변하지 않고 꾸준한 안정화 과정을 지날 수 있도록 한다는 것이다. 안정적인 기본 프로토콜의 바탕 위에 변화하는 이동 통신 시장의 요구를 충족시키기 위한 독립적인“Silo”프로토콜들을 정의하도록 함으로써 최소한의 노력으로 안정된 토대 위에서 시장이 필요로 하는 규격을 공급할 수 있는 방안을 마련하였다. 이것은, 각“Silo”규격들이 오직 기본 프로토콜에만 의존적이면서 서로 간에 독립적인 구조를 갖는 프로토콜이기 때문이기도 하다. 둘째로, 자료 동기 프로토콜과 SyncML 파서와 SyncML Toolkit을 공유함으로써 기존 SyncML Toolkit에 기반한 네트워크 인프라를 보호하고 재활용할 수 있도록 하기 위함이다. Management Object (MO)OMA-DA의 관리 서버는 기기 내의 관리 객체(Management Object: MO)를 액세스함으로써 장치를 관리하도록 되어 있다. MO 에는 다음과 같은 것들이 있다. FUMO(Firmware Update Management Object): 펌웨어 업데이트 관리SCOMO(Software Management): 소프트웨어 컴포넌트 설치, 삭제, 관리DiagMon MO(Diagnostics and Monitoring): 배터리, 메모리, 라디오, QoS 파라메터 상태를 수집, 진단ConnMo(Connectivity): 베어러나 프록시 등 설정DCMO(Device Capabilities): 카메라, 블루투스, USB 등 주변기기를 원격으로 활성 화/비활성화하는 권한LAWMO(Lock and Wipe): 분실, 도난시 기기를 잠그거나 완전 삭제BMO(Browser): 브라우저 설정 관리: VirMO(Virtualization): 원격에 있는 가상 머신을 관리Management Policy MO: 어떤 이벤트가 발생하면 어떤 동작을 수행할 수 있도록 하는 정책을 배포 및 관리: OMA-DM 은 HTTP RESTful 메소드를 이용하며, XML 및 JSON 기반의 메시지를 이 용하고, SSL/TLS 보안 기술을 이용. OMA-DM의 가상시나리오어느 한 통신 사업자의 네트워크 관리자가 신규 가입자가 가입할 때 신청한 서비스 내역을 검토한 후 알맞은 응용 프로그램을 가입자 단말기에게 설치하도록 장치 관리 서버에게 요청한다.장치 관리 서버는 Connectionless WAP Push방식으로 DM Notification메시지를 가입자 장치로 전송한다.DM Notification 메시지는 장치 관리 서버의 전자 서명이 포함된 메시지이며 보통 장치 관리 클라이언트에 의해 처리되고 장치 관리 클라이언트가 서버에게 장치 관리 세션을 요청하도록 한다. 장치 관리 세션이 만들어 지면 장치 관리 서버는 응용 프로그램을 장치 관리 명령을 통해 주어진 응용 프로그램을 장치로 다운로드 한 뒤 그 응용 프로그램이 정상적으로 동작할 수 있도록 사용자 계정, 비밀 번호 등 서비스에 필요한 설정값을 구성하여 사용자가 요구한 대로 동작할 수 있도록 한다.마지막으로, 장치 관리 서버는 역시 장치 관리 명령을 통해 장치의 화면에 앞서 일어난 과정에 대해 설명하는 문구를 나타내어 사용자에게 알려 준다. 사용자는 설치된 응용 프로그램을 이용하여 서비스를 이용한다. OMA-DM의 ACLOMA Device Management 프로토콜은 하나의 장치에 대해 여러 장치 관리 서버가 접근할 수 있도록 설계되었다. 예를 들어, 회사 업무용 소프트웨어를 설치한 단말기의 경우 그 회사의 장치 관리 서버를 구축하여 그 소프트웨어에 대한 사용자명, 비밀 번호, 게이트웨이 등 을 설정하여 회사 내 기밀 자원에 접근할 수 있도록 설정할 수 있으며, 다른 일반 서비스 즉, MMS 서비스 등의 관리를 위해선 외부 통신 사업자의 장치 관리 서버를 통해 장치에 접근하도록 하는 경우를 생각할 수 있다. 이를 위해 OMA Device management 프로토콜은 장치 내부에 존재하는 객체에 대한 관리 권한을 Access Control List(ACL)를 통해 제한하고 있다. ACL를 통해 클라이언트는 어떤 장치 관리 서버가 요청한 장치 관리 명령에 대한 수행 여부를 판단할 수 있다. 이러한 판단 기준은 특정 서버의 특정 장치 관리 명령에 대해 명시할 수가 있다. 참고자료OMA 표준화 동향 - OMA Device Management [LG전자 이동통신기술연구소 김 태 현]TTA저널 제 96호","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"IOT","slug":"CS/IOT","permalink":"http://KKimSangHeon.github.io/categories/CS/IOT/"}],"tags":[]},{"title":"oneM2M","slug":"onem2m","date":"2019-02-07T11:46:50.000Z","updated":"2019-02-09T06:51:54.249Z","comments":true,"path":"2019/02/07/onem2m/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/07/onem2m/","excerpt":"","text":"M2M(Machine to Machine) 사물 또는 지능화된 기기들이 사람을 대신해 통신의 양쪽 모두를 맡고 있는 기술을 의미 센서 등을 통해 전달, 수집, 가공된 위치, 시각, 날씨 등의 데이터를 다른 장비나 기기 등에 전달하기 위한 통신을 의미 M2M은 개별 장치들에 대한 연결성을 제공하는 것이 기본 목적 oneM2M기구 설명1.에너지, 교통, 국방, 공공서비스 등 산업별로 종속적이고 폐쇄적으로 운영되는, 파편화된 서비스 플랫폼 개발 구조를 벗어나 응용서비스 인프라(플랫폼) 환경을 통합하고 공유하기위한 사물인터넷 공동서비스 플랫폼 개발을 위해 발족된 사실상 표준화 단체임 2.oneM2M의 기술 워킹그룹(6개)은 요구사항을 다루는 Requirement(WG1), 시스템 구조를 다루는 Architecture(WG2), 프로토콜과 관련한 Protocols(WG3), 보안관련 Security(WG4), 장치관리 및 추상화, 시멘틱과 관련된 Management, Abstraction and Semantics(WG5), 테스킹 규격을 위한 Test(WG6)로 구성되어 있음 oneM2M Release 115.01월 Minimum Deployeable Solution을 모토로 Release 1 규격을 공개하여 다양한 IoT 서비스에서 필요한 공통 기능을 oneM2M 플랫폼의 RESTful API로 지원 oneM2M 플랫폼이 제공하는 기능을 공통 서비스 기능(CSF, Common Services Function) 으로 정의함 공통 기능은 사물인터넷 서비스 애플리케이션에서 자주 사용되는 기능을 정의한 것으로 데이터 저장/공유, 장치 관리, 그룹 관리, 구독/통지(Subscription/Notification), 위치 정보, 과금 등의 기능을 포함하며, 보안 기능은 기본적인 인증, 접근 제어 등의 기능을 제공 또한, oneM2M 코어 프로토콜 메시지(Primitive)는 CoAP, HTTP 및 MQTT 프로토콜 메시지를 통해 전송됨. oneM2M의 코어 프로토콜은 향후 추가 프로토콜 바인딩(Binding)을 지원할 수 있도록 특정 메시지 프로토콜에 종속성을 가지지 않도록 개발되었음 oneM2M Release 216.07월 다양한 IoT 기술과의 연동성을 강조하여 Release 2 규격을 공개하여 OCF, AllJoyn, LwM2M, 3GPP Rel-13 등의 기술과의 연동성을 제공하고 가전 기기에 대한 정보 모델 표준을 제공 및 다양한 추가 기능을 제공 다양한 인더스트리 사물인터넷 플랫폼 및 네트워크 연동이 주 목적 사물인터넷 연동으로는 AllJoyn, OCF(Open Connectivity Foundation) 및 Lightweight M2M 기술과의 연동 규격을 제공함 네트워크 연동으로는 3GPP Rel-13 네트워크와 연동을 위한 트래픽 패턴 설정(Traffic Pattern Configuration) 기능을 정의하고 있으며 릴리즈 3에 모니터링 등의 연동 기능을 추가하기 위한 기술 보고서를 작업을 지속하고 있음 높은 디바이스 및 애플리케이션의 호환성을 보장하기 위해 우선적으로 가전 디바이스에 대한 데이터 모델을 정의함 릴리즈 1에서는 가전 제어 및 센싱 정보를 교환하기 위해 사전에 애플리케이션 간 정의한 데이터 모델을 container 및 contentInstance 자원 타입을 이용했다. 이에 비해 릴리즈 2에서는 oneM2M 플랫폼을 이용하는 모든 애플리케이션이 표준에 정의된 가전 디바이스 데이터 모델을 사용함으로써 가전 제조사 및 애플리케이션 개발자 간에 별도의 데이터 모델을 정의하는 번거로움을 없애고 제품과 애플리케이션 간의 호환성을 보장한다. 프로토콜 바인딩은 동시 송수신(Full-duplex)을 지원하는 WebSocket이 추가됨 oneM2M Release 3Release 3 표준은 기존 연동, 시맨틱, 보안 등의 기능을 향상하고, oneM2M 시장 확대를 위한 개발자 가이드, Product Profile을 추가 개발 1.3GPP Rel-13/14 네트워크 연동 UE Reachability Schedule, Location Update, Roaming, Schedule sync 지원 등 2.Interworking 추가된 Proximal IoT 연동 규격(TS-0033)에서 oneM2M 시스템이 아닌 디바이스나 서비스를 연동하기 위한 범용적인 연동 기술을 정의 OSGi, Modbud, DDS, OPC-UA에 대한 연동 기술 스터디 진행 3.Transaction 지원 어플리케이션의 다중 리소스 엑세스(Create, Retrieve,Update, Delete)에 대한 oneM2M 플랫폼의 트랜잭션 관리(Execute, Commit, Abort, Lock) 기능 제공 4.Semantics 지원 기능 향상 시맨틱 매쉬업, 트리플(Triple) 쿼리, 트리플 데이터 검증 기능 추가 5.멀티캐스트 기반 그룹 관리 기존 그룹 관리 기능을 IP 멀티캐스트 및 3GPP MBMS (Multimedia Broadcast Multicast Service)를 활용할 수 있도록 기능 확장 6.기타 추가 기능 멀티미디어 스트리밍, 다중 리소스 구독(Cross-resource Subscription),AE Reachability Management, Distributed Authorization 등 개발자 가이드 추가 HTTP, CoAP, MQTT 프로토콜 바인딩, Long polling, device managment, semantics 기능 구현 개발자 가이드 작성 완료 보안 기능 개발자 가이드 작성 중 7.Product Profile oneM2M 플랫폼 기능을 요약한 Feature Catalogue (TS-0031) 과 연계하여 oneM2M 제품 개발 시 구현할 기능을 프로파일 화로 정의하고 해당 기능들은 시험인증 규격에 반영됨 oneM2M 공통 플랫폼 기능 모델 Application Entity (AE) : M2M 서비스를 제공하기 위한 어플리케이션 기능 로직을 포함하는 논리적인 엔티티를 의미하며 각각의 AE는 유일한 AE 식별자인 AE-ID로 구별된다. AE에 대한 예로서는 관제 시스템, 스마트그리드 시스템, 헬스케어 시스템을 위한 어플리케이션 등이 고려되어질 수 있다. Common Service Entity (CSE) : oneM2M 서비스 플랫폼에서 공통적으로 제공되어야 하는 공통 서비스 기능을 제공하는 부분으로서, oneM2M 에서 정의한 CSE에는 총 12개의 Common Service Function (CSF) 공통 서비스 기능을 포함하고 있다. CSF는 CSE에서 제공되어져야 하는 기능들 중 비슷한 기능들을 그룹화 한 논리적인 그룹으로, 각각의 CSF 들은 이후에 설명되어질 리소스를 통해서 외부에 노출되어 서비스를 제공할 수 있다. 해당 CSE는 AE를 구별하는 방식과 마찬가지로 CSE의 식별자인 CSE-ID를 통해서 유일하게 식별 가능하다. Network Service Entity (NSE) : CSE가 위치한 미들웨어의 하부 네트워크 서비스에 대한 추상화 영역으로 CSE에게 네트워크 서비스를 제공한다. 제공 가능한 네트워크 서비스의 예로서는 디바이스 관리, 위치관리, 3GPP 이동통신망에 연결되어있는 IoT 디바이스 트리거링 서비스 등이며 해당 서비스를 위해서는 네트워크 서비스가 관여되어진다. Mca (M2M Communication with AE) 참조 포인트 : AE 와 CSE 간의 포인트를 가리키며, 해당 AE가 CSE에서 제공하는 공통 서비스 기능을 이용하기 위한 API 의 연결 포인트이고, CSE 와 AE간의 통신을 위한 연결 포인트이다. Mcc (M2M Communication with CSE) 참조 포인트 : 두 개의 CSE간의 포인트를 가리키며, CSE와 다른 CSE간의 서비스 공개 및 통신을 가능하게 하는 연결 포인트이다. Mcn (M2M Communication with NSE) 참조 포인트 :CSE와 NSE간의 포인트를 가리키며, CSE가 NSE에서 제공되는 네트워크 서비스 기능을 이용할 수 있는 연결 포인트이면서 네트워크 망으로의 데이터 전달 연결 포인트이다. Mcc’(M2M Commmunication with CSE of different M2M Service Provider) 참조 포인트 : 서로 다른 서비스 프로바이더에 종속적인 CSE간의 포인트를 가리키며, 서비스 프로바이더 간 CSE사이의 서비스 공개 및 통신을 지원하는 연결 포인트이다. oneM2M 노드 구성모델 아키텍처 oneM2M의 노드 구성모델은 다음과 같다. Infrastructure Node (IN) : 인프라스트럭쳐 도메인에 위치하고 있는 IN-CSE를 포함하는 서버단에 위치하는 기기를 의미한다. 해당 IN은 서비스 프로바이더 당 한 개의 IN을 지원하는 것으로 정의되며 IN은 한 개의 CSE로만 구성이 되거나 1개 이상의 AE를 포함하는 형태로 구성되어질 수 있다. 논리적 기기인 IN에 매칭되는 물리적 기기로는 서버를 예로 들 수 있다. IN은 Mcc 참조 포인트를 통해서 한 개 이상의 MN과 한 개 이상의 ASN과 연동되며 Mca 참조 포인트를 통해서 한 개 이상의 ADN과 연동될 수 있다. Mcc’을 통한 연동은 다른 서비스 프로바이더 영역에 위치한 IN노드와 연동된다. Middle Node (MN) : 필드 도메인에 위치한 MN-CSE를 포함하는 논리적 기기로 일반적으로 여러 센서나 엑추에이터들이 연결되는 게이트웨이가 이에 해당한다고 보면 된다. MN은 한 개의 CSE로 구성이 되거나, 하나의 CSE에 1개 이상의 AE 를 포함하는 형태로 구성되어질 수 있다. MN은 Mcc참조 포인트를 통해서 적어도 하나의 IN 또는 MN과 연동되며 Mcc 참조 포인트를 통해서 ASN과 연동 및 Mca 참조 포인트를 통한 ADN과 연동될 수 있다. Application Service Node (ASN) : 필드 도메인에 위치한 ASN-CSE와 ASN-AE를 포함하고 있는 논리적 기기이다. 해당 ASN은 한 개의 CSE와 1개 이상의 AE를 포함하는 형태로 구성되며 논리적 ASN에 매칭되는 물리적 기기로는 M2M 디바이스를 예로 들 수 있다. ASN 은 Mcc 참조 포인트를 통해서 한 개의 MN 또는 한 개의 IN에 연동된다. Application Dedicated Node (ADN) : 필드 도메인에 위치한 ADN-AE를 포함하고 CSE를 포함하지 않는 논리적 기기이다. 즉 해당 ADN는 CSE가 없고, 1개 이상의 AE를 포함한다. 논리적 ADN에 매칭되는 물리적 기기로는 센서 및 액츄에이터와 같은 자원제약적인 M2M 디바이스를 예로 들 수 있다. ADN은 Mca 참조 포인트를 통해서 MN 또는 IN과 연동되는 구조를 갖는다. oneM2M 공통 서비스 기능oneM2M 공통 서비스 플랫폼 개발과 관련하여 아키텍처 표준 문서에서 다루고 있는 부분은 Common Service Entity (CSE)에 대한 기능들을 표준화하는 것이다. 그리고 해당 기능들은 oneM2M이 지향하고 있는 리소스 기반 아키텍처 구조를 기반으로 각각의 리소스 타입으로 해당 공통 서비스 기능들이 표현되고 있다. oneM2M 표준화 작업 진행방식은 전체적으로 유스케이스 및 요구사항을 다루고, 이를 통해 필요한 기능들을 도출해 내어 시스템 아키텍처를 디자인하고, 상세 프로토콜을 개발하는 3GPP 표준화 방식에서 취한 Stage 기반의 접근 방식으로 표준 개발을 진행하였다. 각각의 기능은 리소스 타입으로 표현되고 Mcc, Mca, Mcn 참조 포인트를 통해서 서비스가 제공된다. Common Service Function (CSF) : 기능설명Registration (REG) : REG CSF는 AE와 CSE 또는 CSE와 CSE간의 등록을 담당하며, 이러한 등록 관계를 통해서 oneM2M 엔티티간의 접속 및 접근이 가능하며 oneM2M 엔티티간의 데이터 전달을 통한 oneM2M 서비스 구성이 가능해진다Discovery (DIS) : DIS CSF는 기본적으로 oneM2M 리소스 및 어트리뷰트에 담긴 서비스 정보에 대한 검색 기능을 제공한다. 기본적으로 텍스트 기반의 검색이 제공 되어지며, 그 이외에도 특징 기반의 검색 등이 제공되어질 수 있다.Security (SEC) : SEC CSF는 oneM2M 공통 서비스 플랫폼의 공통 기능으로서 접근권한, 키 관리와 같은 보안 메커니즘을 제공하는 기능을 담당한다.Group Management (GMG) : GMG CSF는 리소스들을 그룹으로 관리할 수 있도록 하는 기능을 담당한다. 이를 통해, 비슷한 역할을 하거나, 공동으로 관리되어져야 하는 리소스들을 그룹으로 관리할 수 있다.Data Management &amp; Repository (DMR) :DMR CSF는 기본적으로 데이터 저장소의 기능을 제공하는 것이다. 또한 데이터의 타입, 시맨틱 정보, 시간, 위치와 관련한 데이터의 분류 및 데이터 포맷의 변경 및 데이터 처리 기능을 제공한다.Subscription &amp; Notification (SUB) : SUB CSF는 리소스에 대한 구독정보를 관리하고 리소스 및 어트리뷰트에 대한 업데이트 발생, Child 리소스의 생성, 삭제 등 해당 리소스에 대한 트랙킹 및 관련된 변화 정보를 통지하는 역할을 담당한다.Device Management (DMG) : DMG CSF는 디바이스 관리 기능을 제공하는 공통 서비스 기능이다. 디바이스 관리라고 함은 디바이스에 설치된 펌웨어에 대한 관리, 디바이스 하드웨어 리소스 관리, 디바이스 동작 설정 관리, 진단을 포함한다.Application &amp; Service Management (ASM) : ASM CSF는 ADN, ASN, MN, IN에 위치한 AE와 CSE 소프트웨어에 대한 관리 기능을 담당한다. 해당 기능은 AE와 CSE의 재설치, 업데이트, 고장탐지, 설정에 관한 기능을 제공한다.Communication Management &amp; Delivery Handling (CMDH) : CSE간, AE와 CSE간, 데이터 전달 시에 NSE를 통한 데이터 전달 서비스를 제공하는 기능을 담당한다. CMDH CSF는 메시지 전달을 위해서 언제 보낼건지, 어떤 네트워크 연결을 활용하여 보낼지를 결정한다.Network Service Exposure, Service Execution &amp; Triggering (NSSE) :NSSE CSF는 기저 네트워크와 관련된 통신을 관리하며 Mcn 참조 포인트를 통한 네트워크 접근 서비스를 제공한다.Location (LOC): LOC CSF는 AE의 위치 정보 요청에 대해서 ASN, MN과 관련된 위치정보를 획득하기 위한 방법을 제공하는 CSF이다.Service Charging &amp; Accounting (SCA) : SCA CSF는 oneM2M 공통 서비스 플랫폼을 통해서 제공되는 서비스에 대한 과금 체계 및 방법에 대한 기능을 제공한다. oneM2M의 장치관리 표준oneM2M의 장치관리 표준은 ETSI TC M2M 규약에서 정한 BBF TR-069와 OMA(Open Mobile Alli-ance)-DM(Device Management) 표준을 그대로 승계하였고, 더 나아가 제약 많은 IoT 장치를 위한 OMA LWM2M까지 포함한다. OMA-DM, TR-069는 다음 포스트에서 다룬다 나만의 요약oneM2M에서는 CSE가 핵심이다.별첨LwM2M(Lightweight M2M)LwM2M(Lightweight M2M)은 M2M 또는 IoT 장치 관리를 위하여 LwM2M 서버와 LwM2M 장치에 있는 LwM2M 클라이언트 간의 응용 프로그램 계층 통신 프로토콜을 정의함. 소형기기를 포함하여 다양한 사물인터넷 기기를 지원하기 위한 기기 관리 표준임.1)센서 또는 셀룰러 네트워크를 통한 장치 관리 기능 제공2)네트워크에서 장치로 서비스 데이터 전송3)대부분의 모든 응용 프로그램의 요구사항을 충족하도록 확장 을 위하여 설계됨. 자원이 제한된 LwM2M 디바이스를 감안하여 효율적인 리소스 데이터 모델을 기반으로 가볍고 간결한 프로토콜로 IETF CoAP을 사용하고 있음 REST(Representational State Transfer)웹 상의 자료를 HTTP위에서 별도의 전송 계층 없이 전송하기 위한 아주 간단한 인터페이스이다. URI는 자원을 표현하는 데에 집중하고 행위에 대한 정의는 HTTP METHOD를 통해 하는 것이 REST한 API를 설계하는 중심 규칙이다. CoAP Internet에서 IoT device처럼 제한된 computing 성능을 갖는 device들의 통신을 위해 IETF의 CoRE(Constrained RESTful Environment) working-group에서 표준화한 protocol 신뢰성 있는 동기 수송 방식의 TCP와 그 위의 HTTP는 많은 resource제약을 가진 IoT 환경에서는 적합하지 않아 비동기 수송 방식의 UDP상에서 UDP의 단점을 보완하는 개념을 포함한 통신 protocol OCF사물인터넷 구현 시 REST 구조 기반으로 경량형 CoAP 프로토콜로 사물인터넷 장치들을 연결하고 장치에 존재하는 자원들을 상호제어 할 수 있게 하는 표준 플랫폼 기술 OCF 아키텍처는 클라이언트-서버의 방식으로 RESTful 아키텍처를 기반으로 리소스를 관리하는 모델 사물인터넷 디바이스의 제한된 성능을 고려하여 CoAP(Constrained Application Protocol)을 활용하여 경량 기기에서의 동작도 고려함 MQTTMQTT(Message Queue for Telemetry Transport)는 M2M 또는 IoT 기기와 G/W의 연동을 위해 정의된 프로토콜입니다. 경량 프로토콜로 저전력 장비에서도 운용 가능하며 network bandwidth가 작은 곳에서도 충분히 운용 가능하도록 설계된 프로토콜입니다. 참고자료http://www.iotocean.org/common/download.asp?pach=/upload/Board/&amp;file=6VXFR20174271377.pdf(IoT 표준/기술 동향 2017-9호) 2017-9호_oneM2M Release 3 표준http://www.iotforum.kr/board1/read.asp?bdNum=101&amp;sc_field=&amp;sc_word=&amp;bdCode=13350http://woowabros.github.io/experience/2017/08/11/ost_mqtt_broker.html","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"IOT","slug":"CS/IOT","permalink":"http://KKimSangHeon.github.io/categories/CS/IOT/"}],"tags":[]},{"title":"1.1 테이블과 인덱스의 분리","slug":"db","date":"2019-02-07T11:29:44.000Z","updated":"2019-02-07T11:31:59.183Z","comments":true,"path":"2019/02/07/db/","link":"","permalink":"http://KKimSangHeon.github.io/2019/02/07/db/","excerpt":"","text":"1.1 테이블과 인덱스의 분리테이블과 인덱스가 분리되어 있는것은 관계형 DB의 일반적인 형태이다.과거엔 키와 데이터가 붙어있었다면 현재는 키를 통해 데이터를 한번 더 찾아가야한다. 1.1.1 분리형 테이블의 구조 7p활용가능한 블록을 Free List에 기록했다가 데이터를 저장할 때 제공한다.로우가 끊어지게 될 경우 Free Space를 활용하여 재배치를 하도록 한다. 테이블스페이스 : 논리적인 저장공간을 의미하며 이는 물리적인 데이터 파일로 구성된다.세그먼트 : 테이블 스페이스를 용도별로 나눈것오브젝트 : 세그먼트에 들어올 수 있는것.단위 오브젝트 : 테이블이나 인덱스의 파티션들 파티션된 테이블의 각 파티션이 서로 다른 테이블 스페이스에 존재할 수 있다.ROW ID : 해당값을 통해 물리적인 저장 위치를 찾아낼 수 있다. 이는 논리적인 값으로서 블록 내에서 로우의 위치가 이동하더라도 변하지 않는다.로우의 이주(Migration) : 블록 밖으로 로우가 이동할 경우 이전 블록에 옮긴 주소를 넣어놓는 방법이 있는데 이에 따른 오버헤드를 감수해야한다. 이를 로우의 이주라 한다.체인 : 로우의 길이가 블록을 넘을 때 블록을 연결해서 저장해야하는데 이를 체인이 발생했다라고 한다. 1.1.2 클러스터링 팩터클러스터링 팩터 : 인덱스 로우의 순서와 테이블에 저장되어있는 데이터 로우의 위치가 얼마나 비슷한 순서로 저장되어 있느냐에 대한 정도를 의미.클러스터링 팩터는 액세스 효율에 직접적인 영향 : 클러스터링 팩터가 좋은 인덱스로 액세스를 하면 적은 블록을 액세스 하게 되므로클러스터링 팩터를 향상시키는 방법 임의의 위치에 저장하는 방식. 주기적으로 테이블 재생성. 1.1.3 분리형 테이블의 액세스 영향 요소가) 넓은 범위의 액세스 처리에 대한 대처방안이는 임의의 영역에 데이터가 저장되는 형태로서 액세스할 경우 대가가 크다. 소형테이블의 경우 : 임의로 저장해도 액세스 할 때도 큰 영향이 없다. 중형테이블의 경우 : 어느컬럼에 맞추어 저장할것인지 결정 대형테이블의 경우 : 단순 저장형(ex: log) : 신속한 저장이 요구되므로 분리형이 가장 적절하다. 또한 데이터의 양이 많으므로 파티션과 같은 조치 필요 주로 랜덤액세스이며 다양하지 않은 액세스 형태(ex: 고객): 분리형 구조가 적당. 한번에 대량의 급격히 들어오는 경우가 드물고 범위처리를 자주 하지도 않음. 데이터가 지속적으로 증가 및 다양하 형태의 액세스(ex: 매출) : 파티션을 진행하고 인덱스를 전략적으로 구성하고 SQL 실행계획 최적화. 나) 클러스터링 팩터 향상 전략주기적으로 테이블을 재성성시켜주는 방법이 최고! (이때는 관련 인덱스를 모두 제거하거나 비활성화 할것- 저장속도 저하유발 및 인덱스 분할로 인한 저장밀도가 나빠짐)이를 위해 가장 유리한 형태로 저장되도록 하고 자주 범위처리를 하는 컬럼들로 정렬하자!","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Data Base","slug":"CS/Data-Base","permalink":"http://KKimSangHeon.github.io/categories/CS/Data-Base/"}],"tags":[]},{"title":"hexo command not found 에러 발생시","slug":"hexoerr","date":"2019-01-21T15:12:31.000Z","updated":"2019-01-21T15:14:38.104Z","comments":true,"path":"2019/01/22/hexoerr/","link":"","permalink":"http://KKimSangHeon.github.io/2019/01/22/hexoerr/","excerpt":"","text":"npm이 global로 설치한 것을 찾지 못할 때 발생한다. 환경변수에 아래의 경로를 추가해 주도록 하자 C:\\Users\\SangHeon\\AppData\\Roaming\\npm","categories":[],"tags":[]},{"title":"StringBuffer, StringBuilder","slug":"java4","date":"2018-11-20T00:37:37.000Z","updated":"2018-11-20T00:43:28.993Z","comments":true,"path":"2018/11/20/java4/","link":"","permalink":"http://KKimSangHeon.github.io/2018/11/20/java4/","excerpt":"","text":"String 클래스String은 내부의 문자열을 수정할 수 없다. StringBuffer()메소드는 내부의 문자를 대치하는 것이 아니라, 대치된 새로운 문자열을 리턴한다.문자열을 결합하는 + 연산을 많이 사용하면 할수록 그만큼 String 객체의 수가 ㅇ늘어나기 때문에 프로그램 성능을 느리게 한다. 문자열을 변경하는 작업이 많을 경우 StringBuffer, StringBuilder클래스를 사용하는것이 좋다. 이 두 클래스는 내부 버퍼에 문자열을 저장해두고 그 안에서 추가, 수정, 삭제 작업을 할 수 있도록 설계되어 있기 때문이다.StringBuffer는 멀티 스레드 환경에서 사용할 수 있도록 동기화가 적용되어 있어 스레드에 안전하지만 StringBuilder는 단일 스레드 환경에서만 사용하도록 설계되어 있다.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"리플렉션","slug":"java3","date":"2018-11-20T00:37:34.000Z","updated":"2018-11-20T00:43:01.888Z","comments":true,"path":"2018/11/20/java3/","link":"","permalink":"http://KKimSangHeon.github.io/2018/11/20/java3/","excerpt":"","text":"리플렉션java.lang.reflect 패키지에 소속되어있는 메소드들로 getDeclaredConstructors(), getDeclaredFields(), getDeclaredMethods()가 있다.getDeclaredFields(), getDeclaredMethods()는 클래스에 선언된 멤버만 가져오고 상속된 멤버는 가져오지 않는다. 상속된 멤버도 얻고 싶다면 getFields(), getMethods()를 이용해야 한다.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"익명클래스","slug":"java2","date":"2018-11-20T00:37:31.000Z","updated":"2018-11-20T00:42:29.017Z","comments":true,"path":"2018/11/20/java2/","link":"","permalink":"http://KKimSangHeon.github.io/2018/11/20/java2/","excerpt":"","text":"익명클래스익명객체는 이름이 없는 객체를 말한다. 이는 단독으로 생성할 수 없고 클래스를 상속하거나 인터페이스를 구현해야만 생성할 수 있다. UI 이벤트 처리 객체나 스레드 객체를 간편하게 생성할 목적으로 많이 활용된다.익명클래스는 생성자를 선언할 수 없다는 특징이 있으며 클래스가 재사용되지 않을 때 사용하는것이 좋다.익명 자식 객체에 새롭게 정의된 필드와 메소드는 익명자식 객체 내부에서만 사용되고, 외부에서는 필드와 메소드에 접근할 수 없다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Person &#123; void wake( ) &#123; System.out.println(\"7시 인남\"); &#125;&#125;public class Annoymous &#123; //필드 초기값으로 대입 Person field = new Person() &#123; void work( ) &#123; System.out.println(\"출근~\"); &#125; @Override void wake( ) &#123; System.out.println(\"6시 인남\"); work( ); &#125; &#125;; void method1( ) &#123; //로컬 변수값으로 대입 Person localVar = new Person( ) &#123; void walk( ) &#123; System.out.println(\"산책 고고\"); &#125; @Override void wake( ) &#123; System.out.println(\"7시에 인남\"); walk( ); &#125; &#125;; //로컬변수 사용 localVar.wake( ); &#125; void method2(Person person) &#123; person.wake(); &#125;&#125; 위에 정의한 클래스를 활용해보자 123456789101112131415161718192021222324252627282930public class AnonymousExample &#123; public static void main(String[] args) &#123; Anoymous anony = new Anonymous(); //익명객체 필드 사용 anony.field.wake(); //anony.filed.walk(); 는 에러가 발생한다. 이유가 뭘까? //익명자식 객체는 부모 타입 변수에 대입되므로 부모타입에 선언된 것만 사용할 수 있기 때문인다. //익명 객체 로컬변수 사용 anony.method1(); //익명 객체 매개값 사용 anony.method2( new Person( ) &#123; void study( ) &#123; System.out.println(\"공부~\"); &#125; @Override void wake( ) &#123; System.out.println(\"8시에인남\"); study( ); &#125; &#125; ); &#125;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"중첩클래스의 접근제한","slug":"java1","date":"2018-11-20T00:37:20.000Z","updated":"2018-11-20T00:48:18.343Z","comments":true,"path":"2018/11/20/java1/","link":"","permalink":"http://KKimSangHeon.github.io/2018/11/20/java1/","excerpt":"","text":"중첩클래스의 접근 제한1234567891011121314151617181920212223242526272829public class A &#123; int field1; void method1( ) &#123; &#125; static int field2; static void method2( ) &#123; &#125; class B &#123; void method ( ) &#123; field1 = 10; method1( ); field2 = 10; method2( ); &#125; &#125; static class C &#123; void method( ) &#123; //filed1 = 10; //접근 불가 //method1( ); //접근 불가 field2 = 10; method2( ); &#125; &#125;&#125; 로컬클래스(메소드 안에 클래스 생성)에서 사용 가능한 것은 final로 선언된 매개 변수와 로컬 변수뿐이다. 자바 7 이전에는 final이 붙어있지 않은 매개변수 혹은 변수를 로컬 클래스안에서 사용하고자 하면 컴파일 에러가 발생하였다. 하지만 자바 8부터는 컴파일 에러가 발생하지 않는다. 즉 내부적으로는 final의 특성(값을 변경할 수 없는)을 갖으며 final의 유무로 로컬클래스 내 복사 위치가 결정된다.(복사위치에 대해선 아래 설명)다음은 7,8버전의 final 유무에 따른 접근관련 이슈이다.123456789101112131415161718192021222324252627public class Outter &#123; //자바7 이전 public void method1(final int arg) &#123; final int localVariable = 1; //arg = 100; //불가능 //localVariable = 100 //불가능 class Inner &#123; public void method( ) &#123; int result = arg + localVariable; &#125; &#125; &#125; //자바8 이후 public void method2(int arg) &#123; int localVariable = 1; //arg = 100; //불가능 //localVariable = 100 //불가능 class Inner &#123; public void method( ) &#123; int result = arg + localVariable; &#125; &#125; &#125;&#125; 위의 코드와 같이 final이 없더라도 값 변경은 허용하지 않는다는것이다. ※ final의 유무로 로컬클래스 내 복사 위치가 결정된다?먼저 다음과 같은 코드가 있다고 가정하자.123456789101112void outMethod(final int arg1, int arg2) &#123; final int var1 = 1; int var2 = 2; class LocalClass &#123; void method() &#123; int result = arg1+arg2+var1+var2; &#125; &#125;&#125;위의 LocalClass에 복사된 변수를 보면 다음과 같다.1234567891011class LocalClass &#123; int arg2 = 매개값; //final이 붙지 않아 필드로 복사 int var2 = 2; //final이 붙지 않아 필드로 복사 void method( ) &#123; int arg1 = 매개값; //final이 붙은것은 로컬 변수로 복사 int var1 = 1; //final이 붙은것은 로컬 변수로 복사 int result = arg1 + arg2+ var1+ var2; &#125;&#125;복사된 영역을 신경쓸 필요는 없으나 알고 있는것이 좋겠다! 중첩클래스에서 바깥 클래스 참조 얻기중첩 클래스 내부에서 this키워드를 사용하면 어떻게 될까? 말 그대로 중첩클래스가 this가 되게된다. 그렇다면 바깥 클래스를 가르키기 위해선 어떻게 해야될까.정답은 바깥클래스.this 를 활용하면 된다. 아래를 참고하자 1234567891011121314151617181920212223242526272829303132public class Outter &#123; String field = \"Outter-filed\"; void method( ) &#123; System.out.println(\"Outter-method\"); &#125; class Nested &#123; String field = \"Nested-field\"; void method() &#123; System.out.println(\"Nested-method\"); &#125; &#125; void print( ) &#123; System.out.println(this.field); //중첩객체 참조 this.method( ); //중첩객체 참조 System.out.println(Outter.this.field); //바깥객체 참조 Outter.this.method( ); //바깥객체 참조 &#125; &#125;&#125;public class OutterExample &#123; public static void main(String[] args) &#123; Outter outter = new Outter( ); outter.Nested nested = outter.new Nested( ); nested.print( ); &#125;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"KT SW개발직무 면접","slug":"interview4","date":"2018-10-22T03:36:14.000Z","updated":"2018-10-23T23:37:44.676Z","comments":true,"path":"2018/10/22/interview4/","link":"","permalink":"http://KKimSangHeon.github.io/2018/10/22/interview4/","excerpt":"","text":"시기2018년 8월 ~ 2018년 10월 채용공고 필기시험적성이 아닌 전공, 인성검사로서 진성여중에서 시험을 치뤘었다. 정말 많은사람들이 왔었고 문제의 난이도는 평소 CS에 대한 공부만 충실했다면 무난한 난이도였다. 1차면접면접관 3분과 지원자 1명의 면접형태로서 면접 전 간단한 코딩 테스트를 본다. 푼 문제를 복사하여 면접관분들께 설명드리면서 면접이 시작된다. 이후엔 자기소개서 위주의 프로젝트, 경력관련 질문들이 주를 이뤘다. 여기서 자신감을 갖고 대답했던것이 좋게 작용했던것 같다. 2차면접마찬가지로 면접관 3분과 면접을 본다. 정말 많이 떨렸지만 충분히 준비하고 또 준비했기에 떨지않고 잘 대답할 수 있었다. 주로 경력에 관한 질문이 많았으며 인성질문도 있었다. 건강검진건강검진 이틀전 술을 마신탓에 약간 걱정은 됐으나 다행히 별 탈 없이 통과할 수 있었다. 합격두달간의 긴 여정을 잘 마무리 짓고 최종합격할 수 있었다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"면접","slug":"Etc/면접","permalink":"http://KKimSangHeon.github.io/categories/Etc/면접/"}],"tags":[{"name":"면접","slug":"면접","permalink":"http://KKimSangHeon.github.io/tags/면접/"},{"name":"KT","slug":"KT","permalink":"http://KKimSangHeon.github.io/tags/KT/"}]},{"title":"비트 빅데이터 전문가 양성과정 면접","slug":"interview5","date":"2018-10-22T03:36:14.000Z","updated":"2018-10-24T00:07:41.658Z","comments":true,"path":"2018/10/22/interview5/","link":"","permalink":"http://KKimSangHeon.github.io/2018/10/22/interview5/","excerpt":"","text":"시기2017년 6월 국비지원 교육을 받기위해 필기시험, 면접을 진행한다. 보통 다른과정은 면접이 없지만 전문가 과정이라 회장님과의 면접이 있다고 들었다. 필기시험자바 필기시험을 진행하였으며 난이도는 쉬운편이었다. 오버라이딩, 인터페이스 수준정도의 개념까지만 잘 이해하고 있다면 쉽게 풀 수 있다. 1차면접비트컴퓨터 회장님과 지원자들과 면접을 진행한다.많은 지원자를 대상으로 면접을 진행하기 때문에 자신이 진행했던 프로젝트가 뭐가있는지 물어보고 기술력을 판단하신다. 당락은 그 자리에서 결정되는데 합격률이 생각보다 많이 낮았던 것이 인상깊었다. 후기합격하여 국비지원을 받으며 교육을 수강할 수 있었다. 강사님께서 정말 고수라 많은것을 배울 수 있었고 실무에서 인턴경험 이상으로 값진 경험이었다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"면접","slug":"Etc/면접","permalink":"http://KKimSangHeon.github.io/categories/Etc/면접/"}],"tags":[{"name":"면접","slug":"면접","permalink":"http://KKimSangHeon.github.io/tags/면접/"},{"name":"비트","slug":"비트","permalink":"http://KKimSangHeon.github.io/tags/비트/"},{"name":"국비지원","slug":"국비지원","permalink":"http://KKimSangHeon.github.io/tags/국비지원/"}]},{"title":"알티캐스트 면접","slug":"interview2","date":"2018-10-22T03:36:14.000Z","updated":"2018-10-23T23:25:27.959Z","comments":true,"path":"2018/10/22/interview2/","link":"","permalink":"http://KKimSangHeon.github.io/2018/10/22/interview2/","excerpt":"","text":"시기2018년 6월 1차면접면접관 두분과 지원자 두명 다대다 면접으로 진행된다.경력에 대한 질문, 프로젝트에 대한 질문이 주를 이루며 자기소개서 내용이 거짓이 아니라면 충분히 대답이 가능한 수준이었다. 후기2차면접은 따로 없이 최종 합격통보를 받았다.편안한 분위기속에서 진행되었으며 사옥을 이전한지 얼마되지 않아 깨끗한 느낌을 많이받았다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"면접","slug":"Etc/면접","permalink":"http://KKimSangHeon.github.io/categories/Etc/면접/"}],"tags":[{"name":"면접","slug":"면접","permalink":"http://KKimSangHeon.github.io/tags/면접/"},{"name":"알티캐스트","slug":"알티캐스트","permalink":"http://KKimSangHeon.github.io/tags/알티캐스트/"}]},{"title":"알지피코리아(요기요,배달통) 면접","slug":"interview","date":"2018-10-22T03:36:14.000Z","updated":"2018-10-23T23:17:48.376Z","comments":true,"path":"2018/10/22/interview/","link":"","permalink":"http://KKimSangHeon.github.io/2018/10/22/interview/","excerpt":"","text":"시기2018년 7월 사실 서류자체는 무난하게 복붙이 가능할 정도로 간단했다. 자소서를 작성하면서 정말 감사했던 기억이 난다. 1차면접편안한 분위기속에서 면접관 두분과 면접을 진행했다. 난이도가 높은 면접은 아니었던걸로 기억한다.질문내용은 다음과 같다. 인터페이스 추상클래스 차이가장인상깊었던 문제개발하다 막히면 어떻게하나비동기로 처리하는 방법jap hibernate 차이 소감평범한 회사였고 자유로운 분위기를 느낄 수 있었다. 면접 후 신세계 상품권과 요기요 할인쿠폰을 잘 이용했다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"면접","slug":"Etc/면접","permalink":"http://KKimSangHeon.github.io/categories/Etc/면접/"}],"tags":[{"name":"면접","slug":"면접","permalink":"http://KKimSangHeon.github.io/tags/면접/"},{"name":"알지피코리아","slug":"알지피코리아","permalink":"http://KKimSangHeon.github.io/tags/알지피코리아/"},{"name":"요기요 배달통","slug":"요기요-배달통","permalink":"http://KKimSangHeon.github.io/tags/요기요-배달통/"}]},{"title":"줌인터넷 면접","slug":"interview3","date":"2018-10-22T03:36:14.000Z","updated":"2018-10-24T00:02:11.674Z","comments":true,"path":"2018/10/22/interview3/","link":"","permalink":"http://KKimSangHeon.github.io/2018/10/22/interview3/","excerpt":"","text":"시기2018년 7월 코딩시험문제의 난이도는 크게 어렵지 않은수준이었다. 1차면접면접 때 코딩시험 내용을 질문한다는 후기를 많이 봐 와서 작성했던 코드를 철저하게 분석하여 갔지만 관련 내용은 질문하지 않으셨다.면접관 다섯분과 지원자 한명 다대일 방식으로 면접이 진행되었다. 면접 질문은 다음과 같다. 자바8자바 몇까지 써봄프로미스프로토타입http 송신 수신시 헤더diaop쿠키 세션rest api?예외의 종류 Error에 대한질문stringbuffer stringbuilder 차이인터페이스 staitc defaultresultful api설계해본적암호화기법양방향 단방향 후기정말 많이많이 어려웠던 면접이었던것 같다. 지금까지 봤던 면접 중 가장 어려웠고 많은것을 다시한번 생각해볼 수 있었던 기회였다. 면접관 분들은 친절하셨지만 내 실력이 불친절했던것 같다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"면접","slug":"Etc/면접","permalink":"http://KKimSangHeon.github.io/categories/Etc/면접/"}],"tags":[{"name":"면접","slug":"면접","permalink":"http://KKimSangHeon.github.io/tags/면접/"},{"name":"줌인터넷","slug":"줌인터넷","permalink":"http://KKimSangHeon.github.io/tags/줌인터넷/"}]},{"title":"웍스모바일 인턴 면접","slug":"interview","date":"2018-10-22T03:36:14.000Z","updated":"2018-10-23T23:25:14.117Z","comments":true,"path":"2018/10/22/interview/","link":"","permalink":"http://KKimSangHeon.github.io/2018/10/22/interview/","excerpt":"","text":"시기2018년 3월 1차면접면접은 한번뿐이었으며 기본적인 전공지식 그리고 경험에 대한 질문이 다수였다. ide뭐 쓰는지asyn서치정렬되지않은 데이터 접근http https차이블로킹 논블로킹 차이트랜잭션데드락dns설계패턴동기비동기 차이string stringbuffer차이 소감합격해서 인턴까지 잘 마무리 지을 수 있었고 그린팩토리에서 일한다는 자부심을 느낄 수 있었다. 좋은분들과 함께 근무했던것 같아 좋았었다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"면접","slug":"Etc/면접","permalink":"http://KKimSangHeon.github.io/categories/Etc/면접/"}],"tags":[{"name":"면접","slug":"면접","permalink":"http://KKimSangHeon.github.io/tags/면접/"},{"name":"웍스모바일","slug":"웍스모바일","permalink":"http://KKimSangHeon.github.io/tags/웍스모바일/"}]},{"title":"프로토타입 디자인 패턴","slug":"Prototype-Pattern","date":"2018-09-22T06:26:34.000Z","updated":"2018-10-22T01:47:04.323Z","comments":true,"path":"2018/09/22/Prototype-Pattern/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/22/Prototype-Pattern/","excerpt":"","text":"프로토타입 디자인 패턴프로토타입 패턴은 객체를 복사품을 만드는것을 의미하는 것이다. 복제된 객체는 호출되는 객체의 현재 상태를 갖고 초기화 되는데 이는 얕은복사 혹은 깊은복사에 기반하여 이뤄진다. 얕은복사 vs 깊은복사얕은복사는 단지 참조의 사본을 만든다고 볼 수 있다.깊은복사는 사본을 새로 생성하여 복사대상이 변경되어도 복사한 데이터는 변경되지 않는다. Prototype12345678910111213141516class Quotation&#123; protected: string type; int value; public: virtual Quotation* clone() = 0; string getType() &#123; return type; &#125; int getValue() &#123; return value; &#125; &#125;; CarQuotation, BikeQuotation 는 Quotation클래스를 상속한다.Prototype12345678910111213141516171819202122class CarQuotation: public Quotation &#123; public: CarQuotation(int number) &#123; type = \"Car\"; value = number; &#125; Quotation* clone() &#123; return new CarQuotation(*this); &#125;&#125;;class BikeQuotation : public Quotation &#123; public: BikeQuotation(int number) &#123; type = \"Bike\"; value = number; &#125; Quotation* clone()&#123; return new BikeQuotation(*this); &#125;&#125; 사용예Prototype12345678910111213141516171819202122232425262728293031323334353637 class QuotationFactory &#123; private : Quotation *carQuotation; Quotation *bikeQuotation; public : QuotationFacory() &#123; carQuotation = new CarQuotation(10); bikeQuotation = new BikeQuotation(20); &#125; ~QuotationFactory() &#123; delete bikeQuotation; delete carQuotation; &#125; Quotation* createQuotation(int typeId) &#123; if( typeID ==1 ) return carQuotation-&gt;clone(); else return bikeQuotation-&gt;clone(); &#125; &#125;int main() &#123; QuotationFacory* qf = new QuotationFactory(); Quotation* q; q = qf-&gt;createQuotation(1); delete q; q = qf-&gt;createQuotation(2); delete q; delete qf; return 0;&#125; 프로토타입 패턴에서 복사한다는 것이 무슨뜻인지 이해가 잘 안됐지만 이젠 이해가 간다. 미리 특정형태(프로토타입)을 만들어 놓고 팩토리패턴으로 호출할 때 그 프로토타입을 반환하여 활용할 수 있도록 하는 패턴인것이다. 자바에서의 프로토타입 패턴C++같은 경우엔 위와같이 코드를 작성해야 되지만 Java의 경우 최상위 클래스 Object가 clone() 메소드가 정의되어 있으므로 이를 오버라이딩해서 활용하면 된다.","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Design Pattern","slug":"CS/Design-Pattern","permalink":"http://KKimSangHeon.github.io/categories/CS/Design-Pattern/"}],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://KKimSangHeon.github.io/tags/Design-Pattern/"}]},{"title":"팩토리 메서드 디자인 패턴","slug":"factory-method","date":"2018-09-22T04:25:51.000Z","updated":"2018-09-27T17:40:56.718Z","comments":true,"path":"2018/09/22/factory-method/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/22/factory-method/","excerpt":"","text":"팩토리 메서드 패턴공장처럼 팩토리 메서드의 일은 객체를 생성하는것이다. 이는 생성패턴으로 클래스들 중 하나의 객체를 인스턴스화 하는데 사용된다. 생성자에 비해 많은장점을 갖으며 상황에 따라 생성자 대신 혹은 기존의 생성자에 덧붙여 제공하는것이 좋다. Factory123456789101112131415161718192021222324252627282930313233343536373839// 팩토리 메서드 패턴으로 인스턴스화될 형으로 제공될 기본 클래스class Pet &#123; public : virtual void petSound() = 0;&#125;;// 팩토리 메서드 패턴에 의해 인스턴스를 얻게 될 첫 번째 파생 클래스class Dog: public Pet&#123; public : void petSound( ) &#123; cout&lt;&lt;\"Bow Bow...\"; &#125;&#125;;// 팩토리 메서드 패턴에 의해 인스턴스를 얻게 될 두번째 파생 클래스class Cat : public Pet &#123; public : void petSound() &#123; cout&lt;&lt; \"Meaw Meaw...\"; &#125;&#125;;// 로직에 기반해서 객체들을 인스턴스화하는 팩토리 메서드 패턴 구현class PetFactory &#123; public : Pet* getPet(int petType) &#123; Pet pet = NULL; // 비즈니스 로직에 기반한 객체의 인스턴스화 if (petType == 1) pet = new Dog(); else if(petType ==2) pet = new Cat(); return pet; &#125;&#125; 다음은 생성한 팩토리메소드를 활용하여 인스턴스를 생성하는 방식이다. Factory123456789int main() &#123; PetFactory *PetFactory = new PetFactory(); Pet pet = petFactory-&gt;getPet(2); cout&lt;&lt; \"Pet Sound\"; pet-&gt;petSound();&#125;","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Design Pattern","slug":"CS/Design-Pattern","permalink":"http://KKimSangHeon.github.io/categories/CS/Design-Pattern/"}],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://KKimSangHeon.github.io/tags/Design-Pattern/"}]},{"title":"제주도 여행","slug":"travel","date":"2018-09-18T08:18:54.000Z","updated":"2018-09-21T10:59:58.254Z","comments":true,"path":"2018/09/18/travel/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/18/travel/","excerpt":"","text":"9.13 ~ 9.17 제주도 여행휴식을 취하고자 웅상 파트너인 웅형과 제주도를 다녀왔다. 사진을 조금밖에 못찍어 아쉽지만 있는대로 올려본다. 거의 10여년만에 비행기를 타는거라 비행기를 타기까지 너무 오래걸렸던것 같다. 체크인, 수화물.. 너무 헷갈렸지만 어떻게 어떻게 비행기에 탑승하긴 했다.창가자리에 앉아 밖을 구경하는데 좋긴 좋았던것 같다. 날씨가 좋지 않았던 탓에 흔들렸던것만 빼고는…. 도착 첫날 스즈라는 초밥집에 가서 점식특선을 먹었다. 사진에 보이는것 외에도 호박죽, 야채 샐러드가 나왔는데 맛있었다. 제주도에서 먹은 음식중 Top3안에 들어간다. 사려니숲길유명한 숲길이 있대서 방문해봤다. 정말 나무가 많고 조용한 숲이었다. 이쁘기도 많이 이뻣던것 같다.카메라를 하늘로 향해 찍어보았다. 이유는 모르겠는데 많은 돌탑이 있었다. 그중 신기하게 쌓여진 돌탑이 있어 내가 쌓은척을 해봤다. 웅형이 우연찮게 찍어준 사진이 저렇게 나왔다. 여행하다 만난 사진전공하시는 분도 놀라워 해주셔서 만족스러웠다. 둘째날 묵은 빨간지붕게스트하우스라는 곳인데 3개월된 강아지가 정말 귀여웠다. 가만히 있는 사진을 찍기가 힘들정도로 활발했던것 같다. 다음에 또 제주도를 간다면 한번 더 방문해보고 싶다. 산굼부리라는 곳을 갔는데 비가 올듯 말듯 한 날씨였다. 구름또한 반은 어둡고 반은 밝은걸 느낄 수 있다. 우도여행을 하며 만난 사진전공하시는 분과 함께 우도를 갔다. 나는 전기자전거를 탔고 면허가 있는 두 사람은 2인오토바이 비슷한걸 빌렸다.우도가는 배를 타기 전 기다리는 중.. 혹시 비가 올까 걱정이 되는 날씨였다. 우도에 도착할때 쯤 하늘이 맑아지기 시작했다. 사진을 전공하시는 분이 찍어주신 사진이다. 사진알못이라 잘은 모르겠지만 뭔가 다른거같긴하다. 전공자라 다르긴한거같다. 넥슨 컴퓨터방물관그래도 개발잔데… 라며 방문해봤던 넥슨 박물관이다.신기한 물건도 많고 체험해볼것도 다양했다. 하지만 많은 초중고등학교의 현장학습과 겹친나머지 제대로 이용해보진 못했던게 아쉽다.입구에서부터 넥슨이라는걸 느낄 수 있었다. 사진엔 보이진 않지만 캐릭터 풍선부터 사진찍을만한 요소가 많았지만 비가와서 얼른 들어갔다. 얼굴을 트래킹하며 표정을 따라하는 여우다. 후기정말 많이먹고 좋은사람들을 많이 만날 수 있었던 좋은 여행이었다.날씨도 좋았고 사람도 좋았고 분위기도 좋았다. 아무생각 없이 편히 쉴 수 있었던것같아 좋았다.일상으로 돌아온게 아쉽진 하지만 다음 여행을 기약해야겠다.","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"Travel","slug":"About-Me/Travel","permalink":"http://KKimSangHeon.github.io/categories/About-Me/Travel/"}],"tags":[{"name":"여행","slug":"여행","permalink":"http://KKimSangHeon.github.io/tags/여행/"}]},{"title":"Singleton 디자인패턴","slug":"pattern2","date":"2018-09-11T07:42:21.000Z","updated":"2018-09-27T19:05:02.359Z","comments":true,"path":"2018/09/11/pattern2/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/11/pattern2/","excerpt":"","text":"싱글톤패턴클래스에 대한 오직 하나의 인스턴스 만이 허용되는 패턴이다.이를위해 생성자를 private로 선언하여 외부에서 인스턴스를 생성하는것을 방지한다.싱글톤 패턴을 사용할땐 다중 스레드에 주의해야 한다. 스레드에 안전한 코드는 다음과 같다. Singleton12345678910111213141516class Singleton &#123; public: static Singleton* getInstance() &#123; if (instance == 0) &#123; Lock lock; if (instance == 0 )&#123; instance = new Singleton; &#125; &#125; return instance; &#125; private: Singleton() &#123;&#125; static Singleton* instance;&#125;; 클래스가 적재되는순간 즉 더 빠르게 인스턴스화를 하기 위해서는 아래와 같이 코드를 작성하면 된다. 이 또한 스레드에 주의해서 작성해야 한다는것을 잊지말자. Singleton12345678class Singleton &#123; static Singleton instance = new Singleton(); Singleton() &#123;&#125; public: static Singleton getInstance() &#123; return instance; &#125;&#125;;","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Design Pattern","slug":"CS/Design-Pattern","permalink":"http://KKimSangHeon.github.io/categories/CS/Design-Pattern/"}],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://KKimSangHeon.github.io/tags/Design-Pattern/"}]},{"title":"디자인패턴","slug":"pattern1","date":"2018-09-07T09:31:43.000Z","updated":"2018-09-27T19:05:00.128Z","comments":true,"path":"2018/09/07/pattern1/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/07/pattern1/","excerpt":"","text":"디자인패턴소프트웨어 설계에서 공통적으로 발생하는 문제를 다루는 보편적이고 반복해서 사용할 수 있는 방법. 문제를 해결하기 위한 설명이나 템플릿으로 보면 된다. 디자인패턴을 사용할 때 장점개발 절차의 속도를 높일 수 있다.재사용 가능한 구조적 개념으로 구성되어 있기 때문에 믿을 수 있다. 디자인 패턴을 사용하기 위한 조건 주어진 문제를 명확, 세밀하게 이해한다. 디자인 패턴이 문제에 일치하는지 다시한번 확인해본다. 다른 패턴들 사이에서 관계성을 찾고 변경해야할 사항을 결정한다. 패턴 여러가지의 디자인 패턴은 3가지의 범주로 분류된다.범주는 아래와 같다. 생성패턴 : 객체생성 메커니즘을 다룬다. 객체의 생성을 다루는 객체 생성 패턴, 클래스 인스턴스 생성을 다루는 클래스 생성 패턴으로 분류된다.ex: Factory, Abstract Factory, Builder, Protype, Singleton 패턴. 구조패턴: 객체들과 클래스들이 커다란 구조를 형성하기 위해 결합될 수 있는 방법을 설명한다. 클래스패턴은 상속의 도움을 받아 추상화를 설명하고 어떻게 프로그램에 더 유용한 인터페이스를 제공할 수 있는지 설명하는것이고, 객체 패턴은 객체들이 크고 더 복잡한 구조를 형성하기 위해 연결되고 구성되는지 설명한다.ex: Adapter, Bridge, Composite, Decorator, Flyweight, Proxy 패턴 행위패턴: 객체 사이의 상호 작용과 관련된 것들이다. 이들은 객체간에 공통의 통신 패턴을 파악하고 이러한 패턴을 실현한다.ex: Chain of Responsibility, Command, Interpreter, iterator, Mediator, Memento, Observer, State, Strategy,Template, Vistor 패턴","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"},{"name":"Design Pattern","slug":"CS/Design-Pattern","permalink":"http://KKimSangHeon.github.io/categories/CS/Design-Pattern/"}],"tags":[{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://KKimSangHeon.github.io/tags/Design-Pattern/"}]},{"title":"중첩 클래스, 중첩 인터페이스","slug":"java4","date":"2018-09-05T07:08:43.000Z","updated":"2018-09-05T09:04:56.154Z","comments":true,"path":"2018/09/05/java4/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/05/java4/","excerpt":"","text":"한 클래스가 여러 클래스와 관계를 갖을 땐 독립적으로 선언하는것이 좋다. 하지만 특정 클래스와 관계를 맺을 땐 내부에 선언하여 불필요한 관계 클래스를 감추고 코드의 복잡성을 감출 수 있게된다. 중첩클래스중첩클래스는 크게 두가지로 나뉘는데 다음과 같다.멤버클래스 - 클래스의 멤버로서 선언되는 중첩클래스. 멤버클래스는 static 여부에 따라 인스턴스 멤버클래스, 정적 멤버클래스로 나뉜다. 클래스나 객체가 사용중이면 언제나 재사용 가능.로컬클래스 - 메소드 내부에서 선언되는 중첩클래스. 메소드 실행 시에만 사용되고 종료되면 없어진다. 다음은 인스턴스 멤버 클래스 사용예시이다.NestedClass123456789101112131415class A&#123; class B&#123; B() &#123; &#125; int filed; //static int filed2; //static는 안되는데 그 이유를 생각해보자 void mehtod1()&#123;&#125; //static void method2()&#123;&#125; //역시 static은 안된다. &#125;&#125;// 사용방벙A a = new A();A.B b = a.new B();b.field1 = 3;b.method1(); 다음은 인스턴스 정적 멤버 클래스 사용예시이다.static변수에 대한 이해가 필요하다.NestedClass123456789101112131415class A&#123; static class C&#123; B() &#123; &#125; int filed; static int filed2; //static 가능 void mehtod1()&#123;&#125; static void method2()&#123;&#125; //static 가능 &#125;&#125;A.C c = new A.C();c.file1 = 3;c.method1();A.C.filed2 = 3;A.C.method2(); 다음은 로컬 클래스 사용예시이다.주로 비동기 처리를 위해 스레드 객체를 만들 때 사용한다.NestedClass1234567891011121314void method() &#123; class D &#123; D() &#123;&#125; int filed1; //static int filed2; //static 안된다. void method1() &#123;&#125; //static void method2() &#123;&#125; //static 안된다. &#125; D d = new D(); d.field1 = 3; d.method1();&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"자바8","slug":"java3","date":"2018-09-04T22:49:23.000Z","updated":"2018-09-04T23:25:52.655Z","comments":true,"path":"2018/09/05/java3/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/05/java3/","excerpt":"","text":"자바 개발자 면접을 보며 듣는 질문이 있다.. 자바8의 특징을 아시나요? 자바8에서 추가된 기능은요? 말씀하신 기능에 대해 좀더 자세히 설명해주세요. 그 외적인 부분은 없을까요? 등등 꼬리에 꼬리를 물다보면 항상 바닥을 드러냈던것 같다.사실 자바를 공부하면서 딱히 버전에 대해 신경쓰지 않았던터라 많이 당황스러웠던 질문이었던것 같다.기회가 되면 정리해야지 했는데 나와 비슷한 고민을 했던 분이 계셔서 링크를 남겨놓는다.https://johanneslee.github.io/articles/page7/ http://blog.eomdev.com/java/2016/03/30/default-method.html나 또한 빠른 시일내에 공부해서 게시할 수 있도록 해야겠다.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"인터페이스의 디폴트 메소드","slug":"java2","date":"2018-09-04T22:43:01.000Z","updated":"2018-09-05T06:48:04.679Z","comments":true,"path":"2018/09/05/java2/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/05/java2/","excerpt":"","text":"인터페이스의 디폴트 메소드는 자바8부터 나왔다고 한다.. 알아두자.선언은 인터페이스에 하고 사용은 구현객체에서 한다. 왜 이걸 만들었을까?기존 인터페이스를 확장해서 새로운 기능을 추가하기 위해서 특징?디폴트 메소드는 정의된 형태이므로 implemets했을 때 해당 메소드의 구현을 강제하지 않는다. 디폴트 메소드는 다음과 같이 정의할 수 있다.default12345678910public interface MyInterface&#123; public void method1(); public default void method2()&#123; System.out.println(\"method2\"); &#125; //디폴트 메소드&#125; 디폴트 메소드를 갖는 인터페이스를 인터페이스가 상속했을 때?디폴트 메소드를 처리하기 위해 다음 3가지중 선택가능 디폴트 메소드를 단순히 상속만 받는다. 디폴트 메소드를 오버라이딩 해서 내용 변경 디폴트 메소드를 추상메소드로 재선언","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"어노테이션 그리고 리플렉션","slug":"java","date":"2018-09-04T21:25:09.000Z","updated":"2018-11-20T00:43:05.194Z","comments":true,"path":"2018/09/05/java/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/05/java/","excerpt":"","text":"어노테이션어노테이션은 컴파일 과정과 실행 과정에서 코드를 어떻게 컴파일하고 처리할 것인지를 알려주는 정보이다.@가 붙는 형태로 정의된다. 어노테이션은 다음의 용도로 사용된다.123컴파일러에게 문법에러 체크 ex(@Override)개발 툴이 코드를 자동 생성할 수 있도록 정보제공실행시 특정기능을 실행하도록 정보제공 어노테이션 정의 및 사용법어노테이션 정의는 다음과 같이 할 수 있다.Annotation1234public @interface SHAnnotation &#123; String feature(); int age() default 0;&#125; 위에 정의한 어노테이션을 사용하기 위해서는 다음과 같이 사용할 수 있다.Annotation1234@SHAnnotation(feature=\"개발자\", age=27);혹은@SHAnnotation(feature=\"개발자\");//아래의 경우 디폴트로 되어있는 age값을 세팅하지 않았다. 어노테이션을 적용할 수 있는 대상은 java.lang.annotation.ElementType에 정의 되어있다.해당 열거형을 보면 아래와 같이 다양하게 존재한다.즉 어노테이션을 적용할 수 있는 대상은 다음과 같다.1234567891011121314151617181920212223242526272829// Field descriptor #37 Ljava/lang/annotation/ElementType;public static final enum java.lang.annotation.ElementType TYPE;// Field descriptor #37 Ljava/lang/annotation/ElementType;public static final enum java.lang.annotation.ElementType FIELD;// Field descriptor #37 Ljava/lang/annotation/ElementType;public static final enum java.lang.annotation.ElementType METHOD;// Field descriptor #37 Ljava/lang/annotation/ElementType;public static final enum java.lang.annotation.ElementType PARAMETER;// Field descriptor #37 Ljava/lang/annotation/ElementType;public static final enum java.lang.annotation.ElementType CONSTRUCTOR;// Field descriptor #37 Ljava/lang/annotation/ElementType;public static final enum java.lang.annotation.ElementType LOCAL_VARIABLE;// Field descriptor #37 Ljava/lang/annotation/ElementType;public static final enum java.lang.annotation.ElementType ANNOTATION_TYPE;// Field descriptor #37 Ljava/lang/annotation/ElementType;public static final enum java.lang.annotation.ElementType PACKAGE;// Field descriptor #37 Ljava/lang/annotation/ElementType;public static final enum java.lang.annotation.ElementType TYPE_PARAMETER;// Field descriptor #37 Ljava/lang/annotation/ElementType;public static final enum java.lang.annotation.ElementType TYPE_USE; 어노테이션이 적용될 대상을 지정할 땐 @Target를 활용한다. Annotation12345678910import java.lang.annotation.Target;import java.lang.annotation.ElementType;@Target(&#123;ElementType.TYPE, ElementType.FIELD, ElementType.METHOD&#125;)public @interface SHAnnotation &#123; String feature(); int age() default 0;&#125;// 적용 대상을 TYPE(클래스, 인터페이스, 열거타입), FILED로 설정하였다. 그럼 아래와 같이 어노테이션 적용이 가능해진다.Annotation12345678910111213@SHAnnotation(feature=\"개발자\", age=27)public class AnnotationTest &#123; @SHAnnotation(feature=\"디자이너\") public void method1() &#123; System.out.println(\"메소드1\"); &#125; @SHAnnotation(feature=\"기획자\", age=30) public void method2() &#123; System.out.println(\"메소드2\"); &#125;&#125; 어노테이션 유지 정책어노테이션은 용도에 따라 어느 범위까지 유지할 것인지 지정 가능하다. 세가지로 나뉘는데 다음과 같다.123SOURCE - 소스상에서만 유지CLASS - 바이트 코드 까지 유지RUNTIME - 바이트 코드까지 유지하며 리플렉션을 이용해 런타임 시 어노테이션 정보를 얻을 수 있다. 리플렉션?위에 리플렉션에 대해 설명하자면 런타임 시에 클래스의 메타 정보를 얻는 기능을 의미한다. 클래스의 필드, 생성자, 메소드, 적용된 어노테이션 등을 런타임 시에 알아낼 수 있다. 다시 돌아와서 어노테이션의 유지는 @Retention으로 지정할 수 있다. 대부분 어노테이션은 런타임시에 유지되도록 하는경우가 많다.다음은 어노테이션이 런타임시에 유지되도록 하는 코드이다.Annotation123456789101112import java.lang.annotation.Target;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;@Target(&#123;ElementType.TYPE, ElementType.FIELD, ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface SHAnnotation &#123; String feature(); int age() default 0;&#125; 런타임 중 어노테이션 정보 사용어노테이션을 만들었으면 사용방법 또한 알아야 할 것이다. 이에 대해 자세히 알아보자클래스에 적용된 어노테이션 정보를 얻으려면 Class 클래스를 이용하면 되지만 필드, 생성자, 메소드에 적용된 어노테이션 정보를 얻으려면 Class 클래스의 메소드를 통해 리플렉션 과정이 필요하다. 이 말이 이해가 안되면 코드를 보고 이해하자. 위 까지 모든 과정을 거쳤으면 아래 실습이 문제없을것이다. Annotation12345678910111213141516171819202122232425262728293031323334353637import java.lang.reflect.Method;public class PrintAnnotation &#123; public static void main(String[] args) &#123; SHAnnotation shAnnotation; // 클래스의 어노테이션 정보 가져오기 shAnnotation = AnnotationTest.class.getAnnotation(SHAnnotation.class); System.out.println(AnnotationTest.class.getName()); System.out.println(shAnnotation.feature()); System.out.println(); // 리플렉션을 통해 선언된 메소드 정보 가져오기 Method[] declaredMethods = AnnotationTest.class.getDeclaredMethods(); for(Method method:declaredMethods) &#123; //SHAnnotation 객체 얻기 shAnnotation = method.getAnnotation(SHAnnotation.class); //어노테이션이 적용되었는지 체크 if(method.isAnnotationPresent(SHAnnotation.class)) &#123; System.out.println(method.getName()); System.out.println(shAnnotation.feature()); &#125; try &#123; //메소드 호출부 method.invoke(new AnnotationTest()); System.out.println(); &#125;catch(Exception e) &#123; System.out.println(e.getStackTrace()); &#125; &#125; &#125;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"CS 공부","slug":"myStudy","date":"2018-09-04T12:28:35.000Z","updated":"2018-09-21T10:38:11.078Z","comments":true,"path":"2018/09/04/myStudy/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/04/myStudy/","excerpt":"","text":"대부분의 자료는 http://www.comcbt.com/cbt/ 의 정보처리기사 필기 문제를 참고하여 작성하였다. 데이터베이스기수(Cardinality) : 튜플의 수차수(Degree) : 열의 수 색인 순차 파일은 순차 파일과 직접 파일에서 지원하는 편성 방법이 결합된 형태다.색인 순차 접근 방식 (ISAM, Index Sequential Access Method)색인 순차 파일은 기본영역, 색인 영역, 오버플로 영역으로 구성된다. 병행 제어의 목적 데이터베이스의 공류를 최대화한다. 시스템의 활용도를 최대화한다. 사용자에 대한 응답 시간을 최소화한다. 단위 시간당 트랜잭션 처리 건수를 최대화한다. 데이터베이스의 일관성을 유지한다.[해설작성자 : 출처: http://androphil.tistory.com/335 [소림사의 홍반장!]] 중위표기법 - &gt; 후위표기법스택에 모든 연산자를 넣으면서 형님이 아우 위에 올라오면 그대로 넣고 그 역이면 모두 pop 후위표기법계산연산자의 앞에 등장하는 두개의 숫자가 피연산자이다.차례대로 앞에서부터 계산해 나가자 관계대수1)관계대수-관계형 데이터베이스에서 원하는 정보와 그정보를 검색하기 위해서 ‘어떻게’ 유도하는가를 기술하는 절차적언어(절차 중심)-기존의 릴레이션으로부터 새로운 릴레이션을 생성한다-릴레이션을 처리하기 위해 연산자와 연산 규칙을 제공 연산자 종류 : 순수관계연산자 , 일반집합연산자 관계해석2)관계해석-원하는 정보가 ‘무엇’이라는 것만 정의하는 비절차적언어(결과 중심)-질의어 이용한 표현-관계해석으로 표현한식은 관계대수로 표현 가능-프레디킷해석에 기반-관계 데이터 모델 제안자인 코드가 관계 데이터베이스에 적용할수 있도록 설계하여 제안종류 : 튜플관계해석 , 도메인관계해석 출처 - http://unius.tistory.com/entry/관계대수-vs-관계해석 카르노맵사용되는 알파벳이 4개일 때 블로그와 반대로하자https://m.blog.naver.com/PostView.nhn?blogId=leeyunghuk1&amp;logNo=220958708825&amp;proxyReferer=https%3A%2F%2Fwww.google.co.kr%2F CPU 사용방식멀티 프로그래밍: 한대의 CPU로 여러 개의 프로그램을 동시에 처리 분산처리 프로그래밍: 지역적으로 분산된 여러 대 컴퓨터 연결. 작업분담처리일괄처리 프로그래밍: 처리할 데이터를 모았다가 한번에 처리. EX) 급여계산, 공공요금계산리얼타임(실시간처리) 프로그래밍: 처리 데이터 발생시 바로 처리. EX) 좌석예약, 은행업무[해설작성자 : ʕ • ᴥ •メʔ 북극곰사냥꾼] 플립플롭http://vision.kongju.ac.kr/DigitalMain/dvlec/textbook/chap08/digital08_2.htm 참고 JK 는 SR에 11일때 토글만 추가로 지원하는것 같다. RAM4x2 RAM을 이용하여 16x4 메모리를 구성하고자 할 경우에 필요한 4x2 RAM의 수는?8개(42) 8 = (16*4)[해설작성자 : wg] 문자 데이터 표현표준 ASCⅡ 코드는 7비트 사용, 영문 대소문자, 숫자, 문장 부호, 특수 제어 문자 표현3개의 존 비트, 4개의 디지트 비트로 구성 문자데이터의 표현BCD코드 : 6비트 구성(존 2, 숫자 4)ASCII코드 : 7비트 구성(존 3, 숫자 4)EBICIC코드: 8비트 구성(존4, 숫자4)UNICODE: 16비트 구성 - 전 세계의 문자를 표현 할 수 있는 국제 표준 문자 코드[해설작성자 : 석영호] CPU 스케줄링http://raisonde.tistory.com/entry/CPU-스케줄링-알고리즘 비선점형 스케줄링 : FCFS(FIFO), SJF, HRN, 비선점형 우선순위, 기한부SRT 스케줄링은 수행 시간이 가장 작은 작업을 선점형으로 처리합니다.[해설작성자 : 46200] 커널커널의 기능은 프로세스 생성, 종료/ 기억 장치 할당, 회수/ 파일 시스템 관리 등이 있다 유닉스의 i-nodei-node에 저장되는 정보로는 파일의 소유자에 대한 정보(소유자id, 그룹id), 파일에 대한 정보(크기, 유형, 생성된 시간,링크된 참조 갯수), 시간에 대한 정보(최근 사용시간, 최근 변경시간), 파일 접근 권한, 파일이 저장된 데이터블록 주소가 있다[해설작성자 : 희굴이] 삽입정렬1~n까지 정렬해 나감 1~2 정렬 12묶음 3정렬 13묶음 4정렬첫 번째 데이터는 정렬이 되어있다고 봄. 그래서 i=0이아닌 1부터 시작.시간복잡도는 O(n^2) 이다. 뷰 가상테이블(물리적으로 구현되는 테이블이 아니다) 시스템 검색은 일반 테이블과 동일 논리적 데이터 독립성을 제공 하나의 뷰를 삭제하면 그 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제 접근 제한을 통한 보안 제공 실제 테이터가 저장되지 않는다. 독자적인 인덱스를 가질 수 없다. 뷰를 이용한 또 다른 뷰의 생성이 가능하다. 필요한 데이터만 뷰로 정의해서 처리하여 사용자의 관리가 용이 뷰는 변경이 안되어 지우고 다시 만들어야 함. &lt;- 전위식, 후위식1-/*A+BCDE 를 후위식으로 쉬운 변환방법 설명1.연산자에 따라 묶는다. (이거 못하시면 이론 다시 ㄱㄱ)( - ( / ( * A ( + B C ) ) D ) E ) 2.연산자를 각 괄호 뒤로 뺀다. (중위식으로 할때는 연산자를 문자 사이로 하시면 됩니다.)( ( ( A ( B C ) + ) * D ) / E ) - 3.괄호를 제거한다.A B C + * D / E - [해설작성자 : 쀼쀼] 관계대수, 관계해석관계대수 : 절차적 언어 / 순수 관계 연산(select, project, join, division)과 일반 집합연산(union, intersection, difference, cartesian product)관계해석 : 비절차적 언어 / Predicate Calculus에 기반을 둠 / 튜플 및 도메인 관계해석[해설작성자 : sdk] 관계대수(릴레이션 조작을 위한 연산의집합.기술적인특성)의 순수관계 연산자 릴레이션을 처리하기 위한 연산의 집합으로 피연산자가 릴레이션이고 결과도 릴레이션이다. Select : 수평적 부분집합. 시그마를 사용 Project : 수직적 부분집합. 파이를 이용 Join Division : 두 릴레이션 A,B에 대해 릴레이션의 모든 조건을 만족하는 튜플들을 릴레이션 A에서 분리해 내어 프로젝션 함. 스레싱스레싱(Thrasing):하나의 프로세스가 작업 수행 과정에서 수행하는 기억장치 접근에서 지나치게 페이지 폴트가 발생하여 프로세스 수행에 소요되는 시간보다 페이지 이동에 소요되는 시간이 더 커지는 현상..오류율이 클수록 스레싱이 많이 발생한 것이고.스래싱으로 인해 전체 시스템의 성능 및 처리율은 저하된다.다중 프로그래밍의 어느 시점을 넘어서면 스레싱의 빈도가 높아진다.[해설작성자 : 김은희] [추가해설]Thrashing 현상 방지 방법 다중 프로그래밍의 정도를 적정수준으로 유지 부족한 자원 증설 일부 프로세스 중단 페이지 부재 빈도 조절 워킹 셋 유지 적정프레임 수 제공[해설작성자 : 네비자동실행 앱 : haewon.tistory.com] 메모리 할당기법가변분할 할당 : 다중분할 할당의 한 방법으로, 프로그램을 주기억장치에 적재할 때 함수 등 필요한 크기로 영역을 분할하는 기법고정분할 할당 : 다중분할 할당의 한 방법으로, 주기억장치의 사용자 영역을 일정 수의 고정크기로 분할하여 사용하는 기법오버레이 기법 : 프로그램의 크기가 주기억장치보다 클 때, 프로그램을 여러 조각으로 분할한 후 필요한 조각 순서대로 주기억장치에 적재한다. 실행중 주기억장치의 메모리가 부족하면 이미 존재하는 조각에 새로운 조각을 중첩하여 적재한다.[해설작성자 : ck] 프로세서 상태전이① dispatch (준비상태→실행상태)준비 상태의 프로세스들 중에서 우선 순위가 가장 높은 프로세스를 선정하여 CPU를 할당함으로써 실행상태로 전환한다.② timerrunout (실행상태→준비상태)CPU의 지정된 할당 시간을 모두 사용한 프로세스는 다른 프로세스를 위해 다시 준비 상태로 되돌아간다.③ block (실행상태→대기상태)실행중인 프로세스가 입출력 명령을 만나면 인터럽트가 발생하여 입출력 전용 프로세서에게 CPU를 양도하고 자신은 대기 상태로 전환한다.④ wake-up (대기상태→준비상태)입출력 완료를 기다리다가 입출력 완료 신호가 들어오면 대기중인 프로세스는 준비 상태로 전환한다.[해설작성자 : ㅁㄴㅇㄹ] 페이지 교체기법&lt;문제 해설&gt;NUR (Not Used Recently) 최근 사용하지 않은 페이지 교체 최근 사용여부를 확인하기 위해(시간 오버헤드를 줄이기 위해), 각 페이지마다 참조/변형비트 사용 교체순서 : 00 - 01 - 10 - 11 (0 : 참조비트, 1 : 변형비트)[해설작성자 : 비슷한문제 해설에서 따옴] 페이지 교체 기법 - 새 데이터를 주기억장치에 등록할 때공간이 부족할 경우 먼저 있던 데이터를 빼고 넣는 행위를 말함. FIFO - 제일 오래된 데이터 제거LFU - 가장 적게 사용 되었던 데이터 제거LRU,NUR - ‘최근’ 가장 적게 사용되었던 데이터 제거OPT - 앞으로 가장 적게 사용될 것 같은 데이터를 예측하여 제거(신뢰성 떨어짐) 브룩스 법칙브룩스(Brooks)의 법칙 : 소프트웨어 개발 일정이 지연된다고 해서 말기에 새로운 인원을 투입하면 작업 적응 기간과 부작용으로 인해 일정은 더욱 지연된다는 법칙이다.[해설작성자 : strawsoojin] 결합도의 약한 순서데이터 -&gt; 스템프 -&gt; 제어 -&gt; 공통 -&gt; 컨텐츠 결합도 순서[해설작성자 : 원동민] 전송제어 문자 SOH(Start Of Heding) : 헤딩 시작 STX(Start of Text) : 본문 시작, 전송할 데이터 그룹의 시작 SYN(Synchronous idle) : 동기 문자 DLE(Data Link Escape) : 데이터 투과성을 위해 삽입(전송 제어 문자와 전송 데이터 구분을 위해 사용)[해설작성자 : 실기도 화이팅!]","categories":[{"name":"CS","slug":"CS","permalink":"http://KKimSangHeon.github.io/categories/CS/"}],"tags":[]},{"title":"7.Firebase 호스팅","slug":"firebase7","date":"2018-09-04T10:01:11.000Z","updated":"2018-09-04T10:12:55.152Z","comments":true,"path":"2018/09/04/firebase7/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/04/firebase7/","excerpt":"","text":"firebase deploy를 입력해 배포를 하자명령어를 입력하고 성공하면 위와같은 화면이 출력된다.Hosting URL 이라고 표현된 부분을 통해 접속 가능하다.","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Firebase","slug":"Web-App/Firebase","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Firebase/"}],"tags":[]},{"title":"6.Firebase DB수정 삭제","slug":"firebase6","date":"2018-09-03T15:54:01.000Z","updated":"2018-09-04T07:12:47.996Z","comments":true,"path":"2018/09/04/firebase6/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/04/firebase6/","excerpt":"","text":"DB 수정selectedKey라는 전역변수를 만들고 아래의 두 함수를 추가하면 데이터는 수정이 가능하다. 이때 수정하는 부분의 ref함수의 인자에 selectedKey가 삽입된 것을 확인할 수 있다.Firebase123456789101112131415161718192021222324252627282930313233function fn_get_data_one(key) &#123; selectedKey = key; var memoRef = database.ref('memos/' + userInfo.uid + '/' + key).once('value').then(function(snapshot)&#123; var txt = $(\".textarea\").val(snapshot.val().txt); &#125;);&#125;function save_data() &#123; var memoRef = database.ref('memos/' + userInfo.uid); var txt = $(\".textarea\").val(); // 유효성 검사 if ( txt == '') &#123; return; &#125; if ( selectedKey ) &#123; // 전역변수 selectedKey가 있으면 update memoRef = database.ref('memos/' + userInfo.uid + '/' + selectedKey); memoRef.update(&#123; txt : txt, createDate : new Date().getTime(), updateDate : new Date().getTime(), &#125;) &#125;else&#123; memoRef.push(&#123; txt : txt, createDate : new Date().getTime() &#125;) &#125;&#125; title이 문장의 맨윗줄만 나오도록 하기 위해 on_child_added의 title변수에 txt.substr(0, txt.indexOf(‘\\n’));을 대입하자Firebase12345function on_child_added(data)&#123; ... var title = txt.substr(0, txt.indexOf('\\n')); ...&#125; 이번에는 + 버튼을 눌러 메모를 추가할 수 있도록 확인해보자버튼에 onClick = ‘initMemo();’ 를 추가하고 다음의 함수를 추가하자.Firebase1234function initMemo() &#123; $('.textarea').val(''); selectedKey = null;&#125;이제 + 버튼을 누르면 새로운 메모를 입력할 수 있게된다. 이제 데이터가 변경되었을 때 왼쪽 리스트가 변경되도록 해보자get_momo_list 함수에 아래의 코드를 추가하여 변경에 대한 처리를 추가한다.Firebase1234567memoRef.on('child_changed', function(data)&#123; var key = data.key; var txt = data.val().txt; var title = txt.substr(0, txt.indexOf('\\n')); $(\"#\"+ key + \"&gt; .title\").text(title); $(\"#\"+ key + \"&gt; .txt\").text(txt);&#125;) 이제 삭제기능을 구현해보자HTML에 다음을 추가하자Firebase1\"&lt;a href=\\\"#!\\\" onclick=\\\"fn_delete_data('\"+key+\"')\\\" class=\\\"secondary-content\\\"&gt;&lt;i class=\\\"material-icons\\\"&gt;grade&lt;/i&gt;&lt;/a&gt;\"그리고 다음 함수를 추가하여 삭제기능 구현하자 Firebase123456789function fn_delete_data(key) &#123; if(!confirm('삭제하시겠습니까')) &#123; return; &#125; var memoRef = database.ref('memos/' + userInfo.uid + '/' + key); memoRef.remove(); $(\"#\"+key).remove();&#125;","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Firebase","slug":"Web-App/Firebase","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Firebase/"}],"tags":[]},{"title":"5.Firebase DB 읽고 쓰기","slug":"firebase5","date":"2018-09-03T13:32:28.000Z","updated":"2018-09-04T10:10:57.627Z","comments":true,"path":"2018/09/03/firebase5/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/03/firebase5/","excerpt":"","text":"포커스가 사라지면 데이터베이스에 input하도록 설정아래의 코드를 추가하면 textarea가 포커스를 잃을 때 마다 데이터를 저장하게 된다.Firebase1234567891011121314151617181920function save_data() &#123; var memoRef = database.ref('memos/' + userInfo.uid); var txt = $(\".textarea\").val(); // 유효성 검사 if ( txt == '') &#123; return; &#125; memoRef.push(&#123; txt : txt, createDate : new Date().getTime() &#125;)&#125;$(function()&#123; $(\".textarea\").blur(function()&#123; save_data(); &#125;);&#125;); 그리고 아래의 코드를 추가하면 왼쪽중 하나를 선택하면 textArea에 내용이 출력된다. Firebase12345function fn_get_data_one(key) &#123; var memoRef = database.ref('memos/' + userInfo.uid + '/' + key).once('value').then(function(snapshot)&#123; var txt = $(\".textarea\").val(snapshot.val().txt); &#125;);&#125; 위에서 once() 함수는 프로미스를 반환한다.","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Firebase","slug":"Web-App/Firebase","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Firebase/"}],"tags":[]},{"title":"4.Firebase DB읽어오기","slug":"firebase4","date":"2018-09-03T09:11:06.000Z","updated":"2018-09-04T10:08:00.528Z","comments":true,"path":"2018/09/03/firebase4/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/03/firebase4/","excerpt":"","text":"DB를 읽고 쓰기 위해 리얼타임 데이터베이스의 규칙에 아래로 수정하자Firebase123456&#123; \"rules\": &#123; \".read\": true, \".write\": \"auth != null\" &#125;&#125; 이전 코드에 다음 코드를 추가하자.Firebase1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;script&gt; var auth, database, userInfo; // Initialize Firebase var config = &#123; apiKey: \"AIzaSyCuXqUy4sOBUh0FBJyqkOde_20s1f6gffs\", authDomain: \"memowebapp-b6255.firebaseapp.com\", databaseURL: \"https://memowebapp-b6255.firebaseio.com\", projectId: \"memowebapp-b6255\", storageBucket: \"memowebapp-b6255.appspot.com\", messagingSenderId: \"582035498309\" &#125;; firebase.initializeApp(config); auth = firebase.auth(); database = firebase.database(); var authProvider = new firebase.auth.GoogleAuthProvider(); auth.onAuthStateChanged(function(user)&#123; if ( user) &#123; // 인증 성공 console.log(\"success\"); console.log(user); userInfo = user; get_momo_list(); &#125;else &#123; // 인증 실패 auth.signInWithPopup(authProvider); &#125; &#125;); function get_momo_list() &#123; var memoRef = database.ref('memos/' + userInfo.uid); memoRef.on('child_added', on_child_added); &#125; function on_child_added(data)&#123; var key = data.key; var memoData = data.val(); var txt = memoData.txt; var title = memoData.title; var firstTxt = txt.substr(0,1); var html = \"&lt;li id='\"+key+\"' class=\\\"collection-item avatar\\\" onclick=\\\"fn_get_data_one(this.id);\\\" &gt;\" + \"&lt;i class=\\\"material-icons circle red\\\"&gt;\" + firstTxt + \"&lt;/i&gt;\" + \"&lt;span class=\\\"title\\\"&gt;\" + title + \"&lt;/span&gt;\" + \"&lt;p class='txt'&gt;\" + txt + \"&lt;br&gt;\" + \"&lt;/p&gt;\" + \"&lt;/li&gt;\"; $(\".collection\").append(html); &#125;&lt;/script&gt;위의 코드는 DB에서 데이터를 읽어온 후 왼쪽 리스트에 추가하는 상황인데 데이터는 다음 그림처럼 생성되어 있어야 한다. “SF9uVrBjLKPRVVKZOCw7x2VKWT22” 이것이 나의 UID이다. 즉 위의코드는 memos라는 DB에 내 UID로 접근해서 데이터를 가져오고 그 데이터들을 append하는것으로 볼 수 있다. 다음 그림은 출력된 화면이다","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Firebase","slug":"Web-App/Firebase","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Firebase/"}],"tags":[]},{"title":"3.Firebase Google Auth 연동","slug":"firebase3","date":"2018-09-03T05:41:11.000Z","updated":"2018-09-03T09:35:07.082Z","comments":true,"path":"2018/09/03/firebase3/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/03/firebase3/","excerpt":"","text":"Firebase1234567891011121314151617&lt;script&gt; var auth; // Initialize Firebase var config = &#123; apiKey: \"xxx\", authDomain: \"xxx\", databaseURL: \"xxx\", projectId: \"xxx\", storageBucket: \"xxx\", messagingSenderId: \"xxx\" &#125;; firebase.initializeApp(config); auth = firebase.auth(); var authProvider = new firebase.auth.GoogleAuthProvider(); auth.signInWithPopup(authProvider);&lt;/script&gt; 위의 코드를 추가한 후 서버를 껏다 켜고 localhost:5000으로 접속하면 팝업이 뜬다. Firebase12345678auth.onAuthStateChanged(function(user)&#123; if ( user) &#123; // 인증 성공 console.log(\"success\"); console.log(user); &#125;else &#123; // 인증 실패 &#125; 위의 코드를 추가해서 인증이 되었을 때 로그를 확인해보자. Firebase12345678910111213141516171819202122232425262728&lt;script&gt; var auth; // Initialize Firebase var config = &#123; apiKey: \"xxx\", authDomain: \"xxx\", databaseURL: \"xxx\", projectId: \"xxx\", storageBucket: \"xxx\", messagingSenderId: \"xxx\" &#125;; firebase.initializeApp(config); auth = firebase.auth(); var authProvider = new firebase.auth.GoogleAuthProvider(); auth.onAuthStateChanged(function(user)&#123; if ( user) &#123; // 인증 성공 console.log(\"success\"); console.log(user); &#125;else &#123; // 인증 실패 auth.signInWithPopup(authProvider); &#125; &#125;);&lt;/script&gt; 로그를 확인 했으면 위와같이 코드를 수정해서 인증을 실패 했을 때 팝업창이 뜨도록 설정해놓자","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Firebase","slug":"Web-App/Firebase","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Firebase/"}],"tags":[{"name":"firebase","slug":"firebase","permalink":"http://KKimSangHeon.github.io/tags/firebase/"}]},{"title":"2.Firebase 프로젝트 스크립트 적용","slug":"firebase2","date":"2018-09-03T05:35:06.000Z","updated":"2018-09-03T09:35:04.040Z","comments":true,"path":"2018/09/03/firebase2/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/03/firebase2/","excerpt":"","text":"index.html파일을 내려받아 자신의 프로젝트 public 폴더에 붙여넣자 파이어베이스 콘솔창에서 웹 앱 선택 후 스크립트 복사 후 index.html의 스크립트 부분에 복붙 앞으로 구현 할 기능 인증기능을 이용한 구글 호출 구글인증 성공시 메모리스트 출력 실패시 구글창 다시 호출 메모 저장기능 메모 한건 출력기능 메모 수정기능 메모 삭제기능","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Firebase","slug":"Web-App/Firebase","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Firebase/"}],"tags":[{"name":"firebase","slug":"firebase","permalink":"http://KKimSangHeon.github.io/tags/firebase/"}]},{"title":"여행 동영상 기반 SNS개발_2(기술명세)","slug":"hex","date":"2018-09-03T05:29:34.000Z","updated":"2018-09-07T09:32:07.865Z","comments":true,"path":"2018/09/03/hex/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/03/hex/","excerpt":"","text":"개발 내용Part 1. - 현석, 상헌서버 개발서버 &lt;-&gt; 안드로이드(클라이언트) 간 데이터 통신(동영상 전송)서버 &lt;-&gt; 안드로이드 간 동영상 스트리밍 제공 안드로이드(클라이언트) 개발전체 UI 개발안드로이드 &lt;-&gt; 서버 통신 개발안드로이드 킷캣 버전이후로 동작하도록 개발안드로이드 크기와 상관없이 깔끔한 UI가 되도록 개발 DB 개발SNS 기능을 고려, 친구(팔로워) 관리사용자가 좋아요 누른 것들 관리동영상 관리동영상 썸네일 관리 서버기술은 Firebase 기반으로 하되 Android는 자바, 코틀린 중 어느것으로 할지 18/09/08까지 결정 Part 2. - 용호, 웅섭안드로이드(클라이언트) 개발NDK 연동동영상 플레이어 관련 UI 개발 동영상 플레이어 개발동영상 플레이어 라이브러리 활용, 개발기본적인 재생기능되감기 기능카메라로 촬영된 동영상을 읽어와 이미지를 덧씌우는 기능촬영된 동영상을 읽어와 특정 구간으로 끊어서 저장하는 기능 Part 3. - 호인(용호/현석)안드로이드 UI 설계Part 1과 협력하여 안드로이드 전체 UI 설계(카카오 오븐 등으로 구체적인 이미지로 설계할 것, Part 1과 기술적으로 가능한지 검토하면서 진행)간단한 이미지 편집(포토샵 사용 가능하면 좋고, 아니면 무료 이미지 검색) 진행상황 관리프로젝트 일정관리(개별로 한주동안 할 업무량을 측정, 관리)우리 팀 활동 내역 및 진행상황을 블로그/구글드라이브/SNS 등으로 그 내용을 간단하게나마 기록하고 공유하면 좋겠음 -&gt; 추후 기업연계가 가능했으면…돈 관리(모임/책 구매/간식 등)동기부여 및 잔소리(분명 나태해지고…놀다 안함)모임 관리(특정 시간, 장소 등 조사)","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"HEX Team","slug":"Etc/HEX-Team","permalink":"http://KKimSangHeon.github.io/categories/Etc/HEX-Team/"}],"tags":[]},{"title":"1.Firebase 환경설정","slug":"firebase1","date":"2018-09-03T04:31:40.000Z","updated":"2018-09-03T09:35:00.569Z","comments":true,"path":"2018/09/03/firebase1/","link":"","permalink":"http://KKimSangHeon.github.io/2018/09/03/firebase1/","excerpt":"","text":"공부내용https://www.inflearn.com/course/파이어베이스-강좌-웹-어플리케이션 의 강좌를 수강하며 나름대로 정리해본것이다. 파이어베이스웹과 모바일 개발에 필요한 기능을 제공하는 백엔드 서비스이다. 보안, 인증, DB설계, API설계등을 프론트 개발자에게 편리하게 제공하는것. firebase.google.com 에 간 후 로그인을 하고 새 프로젝트를 생성한다. Firebase 설치과정12345678910111213141516171819202122232425262728Node.js 설치npm install firebase-tools -g 를 콘솔창에서 입력하여 설치firebase loginY 입력구글로그인하고 승인firebase list 를 입력해서 확인mkdir memoWebcd memoWebfirebase init //firebase 프로젝트 생성스페이스바 누르고 엔터를 입력해 데이터베이스 선택아까 만들어놓았던 프로젝트 선택데이터 베이스 파일이름 입력firebase initHosting 선택public 입력y 입력2018-09-03 오후 02:21 161 database.rule.json2018-09-03 오후 02:22 291 firebase.json2018-09-03 오후 02:22 &lt;DIR&gt; public위의 세개 파일이 생성된것을 확인firebase servehttp://localhost:5000/ 으로 입력이 가능해진다. 개인적인 생각Firebase를 이용하면 많은것을 편리하게 구성하고 쉽게 만들수 있다는 생각이 든다.구글이 왜 구글인지 알 수 있을것같다..","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Firebase","slug":"Web-App/Firebase","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Firebase/"}],"tags":[{"name":"firebase","slug":"firebase","permalink":"http://KKimSangHeon.github.io/tags/firebase/"}]},{"title":"여행 동영상 기반 SNS개발_1(요구사항 분석)","slug":"hex","date":"2018-08-21T17:21:20.000Z","updated":"2018-09-07T09:32:01.424Z","comments":true,"path":"2018/08/22/hex/","link":"","permalink":"http://KKimSangHeon.github.io/2018/08/22/hex/","excerpt":"","text":"A. 주요 Concept여행에 특화된 소셜 네트워크 서비스 짧은 순간순간의 여행. 길고 오래도록 추억하세요. 1분 영상을 통해 현재 여행지를 자랑하고 Best Traveller가 되어보세요. B. 주요 서비스 내용 / 구성도 (Service Flow) 나만의 여행 동영상 갤러리 편리한 영상 편집기능 BEST여행지 추천 및 공유 여행 실시간 현지 분위기 살펴보기 C. 주요 Target 고객 더욱 완벽한 여행을 준비하는, 여행을 공유하고 싶은, 여행을 추억하고 싶은 모든 낭만적인 여행가 여행지의 분위기를 간접 경험하고 싶은 현대인들 D. 서비스 Business Model1.가치a.추억 남기기b.여행 정보 공유c.관광산업 활성화 2.수익 모델a.관광산업(여행사 여행상품, 관광지) 및 비관광산업 광고대행b.인앱(BGM, 재생시간 연장, 워터마크 제거, 고화질 영상 제공, 저장공간 제한) E. 상품 확장 계획 여행경로 공유 네비게이션 길찾기 제공 관광상품과 연계하여 관광지 홍보 (관광이 활성화되지 않은 지역 인지도 향상 효과) 추천 관광지 등에서 다양한 미션 이벤트를 통해 여행지 특화 콘텐츠 제공(ex. 이동 점프샷, 먹방 여행코스 등) Flow chart","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"HEX Team","slug":"Etc/HEX-Team","permalink":"http://KKimSangHeon.github.io/categories/Etc/HEX-Team/"}],"tags":[{"name":"Social Media","slug":"Social-Media","permalink":"http://KKimSangHeon.github.io/tags/Social-Media/"}]},{"title":"학생 등하차 알림 시스템","slug":"project","date":"2018-07-27T14:25:25.000Z","updated":"2018-09-03T05:45:52.539Z","comments":true,"path":"2018/07/27/project/","link":"","permalink":"http://KKimSangHeon.github.io/2018/07/27/project/","excerpt":"","text":"개발배경최근 유아 및 아동들의 등 하차시 발생하는 문제들로 인해 다양한 사회문제들이 발생하고 있다.이를 App을 통해 극복해보고자 개발하였으며 해당 시스템은 NFC칩을 이용하여 학생들의 등하차를 관리하는 시스템이다. 개발현황NFC 등록NFC 인식내부 DB(SQLite)를 활용한 승하차 인원관리 시스템 구축완료태그 리스트 확인화면 구현완료 To Do버스 위치 실시간수신 위한 서버10초 단위로 현재위치 갱신 및 SMS전송 테스트 해당앱은 성능테스트, 기능테스트만 완료하면 되지만 GPS, SNS테스트를 할 폰이 없어서 일단 프로젝트 중단..지금까지 작성한 코드는 아래에서 확인 가능GitHub","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"안드로이드, 등하차시스템","slug":"안드로이드-등하차시스템","permalink":"http://KKimSangHeon.github.io/tags/안드로이드-등하차시스템/"}]},{"title":"임베디드 2","slug":"embedded","date":"2018-07-11T04:46:52.000Z","updated":"2018-09-03T06:02:20.807Z","comments":true,"path":"2018/07/11/embedded/","link":"","permalink":"http://KKimSangHeon.github.io/2018/07/11/embedded/","excerpt":"","text":"캐쉬는 동작방식에 따라Direct Mapping Cache, Associative Mapping Chche, Set Associative Mapping Chche로 나뉜다.세번째가 주로 쓰이는데 세번째는 첫번째 두번째의 혼합형이다. Direct Mapping Cache사용하기 편하고 이해하기 편하다낭비가 심함 Associative Mapping ChcheDirect Mapping Cache의 개선형태DMC보다 Hit rate가 높다.victim선택에 대해 자유롭다.tag를 다 뒤져봐야 한다는점이 단점. 즉 개수가 많을수록 복잡. Set Associative Mapping Chchestatic지역 변수에 static을 사용하면, 전역 변수와 유사하게 변수에 대한 영구적인 저장 공간을 할당한다.static 지역 변수와 전역변수의 차이: static 지역 변수는 해당 블록 안에서만 사용할 수 있다. volatile해당 변수에 대해 컴파일러의 최적화를 막는다.임베디드 프로그래밍이나 멀티쓰레드 프로그래밍에 사용한다. 최적화는 비용절감의 목적으로, 사용하는 메모리의 사용량을 최소화 하면서 성능을 최대화 하고자함.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Embeded C","slug":"Language/Embeded-C","permalink":"http://KKimSangHeon.github.io/categories/Language/Embeded-C/"}],"tags":[]},{"title":"임베디드 1","slug":"embedded","date":"2018-07-09T03:29:07.000Z","updated":"2018-09-03T06:02:18.054Z","comments":true,"path":"2018/07/09/embedded/","link":"","permalink":"http://KKimSangHeon.github.io/2018/07/09/embedded/","excerpt":"","text":"volatile - 최적화 하지마라 ( 어차피 날라갈 값이니까) READ APRINT AREAD APRINT A라는 코드가 있을 때 옵티마이저가 이를 최적화하여READ APRINT APRINT A로 변경하는데 A가 휘발성일경우 문제가 된다. 그래서 위에 VOLATILE를 추가해줘 최적화를 못하도록 명시한다.VOLATILE AREAD APRINT AREAD APRINT A외부의 센서(온도계)등에서 데이터를 가져올 때 같은 경우 사용. 즉 내가 가져오는 시점의 데이터를 활용하고자 할 경우 사용한다. restrict - 최적화 해라 unit8x8_t SIMD를 사용하면 사용할 수 있다. GPU - 일반 프로세서와 구분하기 위해 GPU라 불리는데 주로 그래픽처리에 사용됨(작은 코어가 많다..)SOC - 계산보다는 주변 여러장치를 같이 갖고있다.DSP - 멀티미디어 수식처리의 식을 하나로 만드는것 하드웨어 - Hypervisor - OS RTOS , Resal time Operating System실시간 시스템을 구현 가능한 운영체제우선 순위 기반 스케줄링충분한 개수의 인터럽트 레벨 text data bss dec hex filename8024 32 6072 14128 3730 image text - 기계어로 변경된것들data는 초기화된 전역변수bss는 초기화되지않은 전역변수","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Embeded C","slug":"Language/Embeded-C","permalink":"http://KKimSangHeon.github.io/categories/Language/Embeded-C/"}],"tags":[]},{"title":"std::stringstream aa 불완전한 형식은 사용할 수 없습니다.","slug":"cpperr","date":"2018-06-22T05:21:23.000Z","updated":"2018-09-03T06:02:12.176Z","comments":true,"path":"2018/06/22/cpperr/","link":"","permalink":"http://KKimSangHeon.github.io/2018/06/22/cpperr/","excerpt":"","text":"std::stringstream aa 불완전한 형식은 사용할 수 없습니다.라는 에러 발생할 경우 해당에러의 경우 sstream 을 include 하지 않았을 확률이 높다.1#include &lt;sstream&gt; 을 추가하여 다시 확인해보자","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"C++","slug":"Language/C","permalink":"http://KKimSangHeon.github.io/categories/Language/C/"}],"tags":[{"name":"c++, 에러","slug":"c-에러","permalink":"http://KKimSangHeon.github.io/tags/c-에러/"}]},{"title":"임베디드를 배우기 전 간략한 C 이론 6","slug":"embedded6","date":"2018-06-19T08:20:21.000Z","updated":"2018-09-03T06:02:05.132Z","comments":true,"path":"2018/06/19/embedded6/","link":"","permalink":"http://KKimSangHeon.github.io/2018/06/19/embedded6/","excerpt":"","text":"임베디드를 배우기 전 간략한 C 이론 5 함수포인터를 만들 때 괄호를 추가하는것을 잊지말자.int (*pf)(double, int); 123int temp = 5;void* ptr = &amp;temp; // void 형 포인터: 어떤 변수의 주소값도 저장이 가능한 변수((int*)ptr) = 7; Data 영역 - 전역, staticHeap영역 - 동적할당영역Stack영역- 지역변수, 매개변수 정적할당(배열) - 컴파일 타임에 할당, 접근속도가 빠르다. 코드 유지보수성 낮다(데이터 추가, 삭제)동적할당 - run time(실행타임), 접근속도가 느리다.코드유지보수성이 높다.(데이터 추가 삭제 쉽다.), 메모리 낭비 x, 메모리 자동 해제(x) -&gt;직접해제할것 void *malloc(size_t size);여기서 size_t는 typedef unsigned int size_t 로 보면된다.헤더는 stdlib.h을 불러오면 된다. void pNew = malloc(40); 이 있다고 했을 때 pNew는 힙영역에 할당되는 변수가 아니다. ((int))pNew) = 5; //좋지 않은코드 ((int*)pNew+1) = 7; //좋지 않은코드 int pt = (int)pNew;pt = 5; 또는 pt[0]=5//권장 (pt+1) = 7; 또는 pt[1]=7 //권장 int pNew = (int)malloc(40); 구조체1234struct person&#123; int name[30]; int age;&#125;; 위와 같이 쓸수도 있지만 12345typedef struct &#123; int name[30]; int age;&#125;PER; 보통 이렇게 쓴다.그럼 다음과같이 선언이 가능하다,.PER p1; p1.name =”kim”; //안된다. 문자열 상수이므로. 이해가 안될경우 잘생각해보자. 구조체 멤버변수는 디폴트로 public 구조체에서 “.” 은 구조체 멤버 직접접근연산자12-&gt; 간접접근연산자. 직접접근연산자 구조체는 멤버변수간 패딩바이트를 둬서 구조체의 사이즈를 측정하면 더 크게 나올 수 있다. 구조체 + 포인터변수 구조체 변수를 참조하는 포인터 포인터 변수를 구조체 멤버변수로 포함 (*ptr).age == ptr-&gt;age PER arr[3]; //구조체 배열","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Embeded C","slug":"Language/Embeded-C","permalink":"http://KKimSangHeon.github.io/categories/Language/Embeded-C/"}],"tags":[]},{"title":"임베디드를 배우기 전 간략한 C 이론 5","slug":"embedded4","date":"2018-06-18T08:59:01.000Z","updated":"2018-09-03T06:02:02.084Z","comments":true,"path":"2018/06/18/embedded4/","link":"","permalink":"http://KKimSangHeon.github.io/2018/06/18/embedded4/","excerpt":"","text":"*(pa+0) == pa[0] 포인터 배열 - 포인터를 묶어놓은 배열이다. 더블포인터 - 싱글포인터의 주소를 저장하는 용도로써 사용된다. 12345678910111213int arr_m[3][4] = &#123; &#123;5,6,7,8&#125;, &#123;9,10,11,12&#125;, &#123;13,14,15,16&#125;&#125; //2차원 배열 선언과 동시 초기화int row,col;for (row = 0;row&lt;3; row++)&#123; for(col = 0;col&lt;4;col++) printf(&quot;arr_m[%d][%d]:%d&quot;, row, col, arr_m[row][col]);&#125; 위의 경우에서 arr_m[2] == arr_m+2 == arr_m[2][0] int (pa)[3]; //길이가 3인 int형 2차원 배열을 가르키는 포인터 변수(배열포인터)int pa[3]; //포인터 배열 포인터배열 배열포인터를 헷갈리지 말자배열 포인터는 - 2차원 배열을 가르키는 포인터포인터 배열을 - 포인터를 배열로 만들어 놓은것. char *(str)[50]; 일 때str[0]+1 != str+1좌측은 50만큼 증가하고 우측은 1바이트씩 증가 자료형 앞에 register 을 넣으면 변수가 register 변수에 저장이 된다. 빠르다! static의 생존기간은 전역변수와 같지만 메모리 존재범위은 블록 내에서만! 함수포인터함수명은 함수의 시작주소이다. 함수 포인터를 만드려고 하니int ptr(int a, int b); 와같은 형태가 나왔다,이는 리턴타입이 int 이라는 함수선언과 같으므로괄호를 씌워 int (*ptr)(int a, int b); 로 함수포인터를 만든다. 배열포인터와 유사한 형태로 만들어졌다.배열 포인터 또한 int arr[3] 으로 만들라 했으나 이는 포인터 배열과 일치하므로 괄호를 추가해 int (arr)[3]으로 처리했다.123int Add(int a, int b);int (*ptr)(int a, int b) = Add; 위와같이 사용한다. ptr(2,3) // 간접호출Add(2,3) //직접호출 123456int temp = 5;int * ptr = &amp;temp;void* pv = &amp;temp; //가능하다.*pv = 8; //불가능하다(시작부터 몇바이트를 읽을지는 pv의 자료형으로 판단하는데 몇바이트로 접근해야할지 알 수 없다)*((int*)pv) = 8 //가능 void형 포인터는 모든 변수의 주소값을 저장할 수 있다. 주소값을 표현할 땐 다음과 같이((volatile unsigned int)0x80000000) = 0xFF000000; //나중에 다시한번 배운다. volatile 은 주소값의 데이터가 변경되는것을 막는다.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Embeded C","slug":"Language/Embeded-C","permalink":"http://KKimSangHeon.github.io/categories/Language/Embeded-C/"}],"tags":[]},{"title":"임베디드를 배우기 전 간략한 C 이론 3","slug":"embedded3","date":"2018-06-15T04:19:26.000Z","updated":"2018-09-03T06:01:59.028Z","comments":true,"path":"2018/06/15/embedded3/","link":"","permalink":"http://KKimSangHeon.github.io/2018/06/15/embedded3/","excerpt":"","text":"변수와 상수는 다른것이다.연산자는 사칙연산, 비트연산, 논리연산, 비교연산이 있다.자료형은 char short int float double가 있다. 배열명은 배열의 시작주소를 의미한다.&amp;data[0] == data 배열명은 주소를 바꿀 수 없는 포인터 상수이다. 조건부 컴파일12345#if(0) 1번로직#else 2번로직#endif 2번로직이 실행된다. C 라이브러리 모음http://www.soen.kr/ LR 복귀주소를 저장(함수가 종료되고 다시 시작되어야할 주소)LR들은 스택에 저장되게 되는데 최근 이동해야 할 곳을 가르키고 있는 포인터를 스택 포인터라함.보통 스택이 4단계 이상 쌓이면 설계를 다시해보는것을 고려해 봐야 한다. 1234int Add(int a)&#123; return tmp;&#125; 함수 명 Add가 함수의 시작주소이다. ISR 인터럽트 서비스 루틴 - 특정인터럽트가 발생했을 때 처리해라. 폴링 인터럽트 둘다 이벤트가 발생했을 때 ISR로 가서 처리하고 메인으로 돌아온다.폴링은 함수를 호출해야하고 인터럽트는 호출 없이 서비스 로직이 실행된다. 0 == false == off == 0v == clear == low1 == true == on == 5v == set == high 워치독 타이머 : 컴퓨터의 오작동을 탐지하고 복구하기 위해 쓰이는 전자 타이머이다. 정상 작동 중의 컴퓨터는 시간이 경과하거나 “타임아웃”이 되는 것을 막기 위해, 정기적으로 워치독 타이머를 재가동 시킨다.(내부적으로 소프트웨어를 리셋시키는 타이머) 지역변수 - 해당 함수안에서만 접근, 해당함수 시작과 동시에 메모리에 올라갔다 함수 종료시 소멸된다. 지역변수는 m_를 붙여서 처리하기도 한다. call by value - 복사대입에 의한 호출call by address (pointer) - 포인터를 이용하여 호출call by reference - 참조자를 이용하는것 모든 포인터 변수는 32비트 시스템에서 4바이트로 동일하다","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Embeded C","slug":"Language/Embeded-C","permalink":"http://KKimSangHeon.github.io/categories/Language/Embeded-C/"}],"tags":[]},{"title":"임베디드를 배우기 전 간략한 C 이론 2","slug":"embeded2","date":"2018-06-13T06:54:56.000Z","updated":"2018-09-03T06:01:56.639Z","comments":true,"path":"2018/06/13/embeded2/","link":"","permalink":"http://KKimSangHeon.github.io/2018/06/13/embeded2/","excerpt":"","text":"변수선언-&gt; 자료형 변수명;변수사용-&gt; 변수명오버플러우 : 할당할 수 있는 범위를 넘어선 입력 빅 앤디안 : 낮은 어드레스에 높은 바이트를 넣는다리틀 앤디안 : 낮은 어드레스에 낮은 바이트를 넣는다(ARM, Intel이 사용한다) 내 컴퓨터가 리틀앤디안인지 빅앤디안인지 알아봐라포인터로 한바이트만 읽어서 체크해보자 팬아웃 : 신호가 변질되는것 방지하는것 . 버퍼를 달아서 구현할 수 있다. Not-G (inverter) : 역으로 변경X-Or Gate : 다를 때 참3-State Buffer : B에 신호가 1이여야 A에서 X로 출력됨. B 신호가 0이면 A에서 X로 아무것도 출력되지 않는 고저항상태가 된다. char의 범위 -127~128 비트연산| : 비트 or&amp; : 비트 And~ : 비트 Not&lt;&lt; : 비트 왼쪽시프트 : 비트 오른쪽시프트^ : 비트 xor MSB만 역으로 만들기 위한방법res&amp; = ~(0x01&lt;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Embeded C","slug":"Language/Embeded-C","permalink":"http://KKimSangHeon.github.io/categories/Language/Embeded-C/"}],"tags":[{"name":"c, embedded","slug":"c-embedded","permalink":"http://KKimSangHeon.github.io/tags/c-embedded/"}]},{"title":"임베디드를 배우기 전 간략한 C 이론 1","slug":"embeded","date":"2018-06-11T14:53:29.000Z","updated":"2018-09-03T06:03:44.366Z","comments":true,"path":"2018/06/11/embeded/","link":"","permalink":"http://KKimSangHeon.github.io/2018/06/11/embeded/","excerpt":"","text":"컴파일 : 컴퓨터가 아는 언어로 변경하는것 원시코드를 오브젝트로 (syntax에러 확인)컴파일러 : 이를 실행시켜주는것링커 : 라이브러리를 묶어주고 실행파일을 만든다. 전처리기 : 컴파일 전에 처리 함수는 라이브러리, 사용자 정의 함수로 나뉜다. 함수는 함수원형, 호출, 정의부로 나뉘는데 원형은 함수의 뼈대라고 보면 되고 , 정의는 함수의 동작을 정의한는 부분으로 보면된다. int main(int argc, char * argv[])argc는 - arg counter 로 생각하자두번째 포인터 배열이지만 더블포인터로 볼 수 있다. 메인함수의 경우 vs에서 return을 하지 않을경우 에러가 발생하지 않는데 이는 잘못된것이다.리턴타입이 int인데 return이 없는것은 잘못된것을 알고있자. 반환형이 void인 함수의 return은 함수의 종료를 의미한다. return은 함수의 값 반환, 함수의 종료역할을 한다. ARM 프로세서에는byte(1byte) / half-word(2byte) / word(4byte) 이란게 있다. 일단 알아만 두자123if ( temp = 5) &#123; ...&#125; 위와같은 코드는 절대 짜지말자. if문이 뭐 저래 헷갈릴수 있는 개념더블 포인터 - 포인터의 주소를 저장하는 변수포인터배열 - 포인터를 모아놓은 포인터배열포인터 - 2차원 배열의 조소를 저장해놓은 변수함수포인터 - 함수의 주소를 저장해 놓은 변수구조체 - 다른 형태의 변수를 배열처럼 저장하기 위해 만들었다. 서식문자%d - 정수%c - 문자%s - 문자열%f - float 자료형%lf - double형 자료형%u - unsigned%x - hex","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Embeded C","slug":"Language/Embeded-C","permalink":"http://KKimSangHeon.github.io/categories/Language/Embeded-C/"}],"tags":[{"name":"c, embedded","slug":"c-embedded","permalink":"http://KKimSangHeon.github.io/tags/c-embedded/"}]},{"title":"string does not name a type","slug":"cpperror6","date":"2018-05-07T05:22:47.000Z","updated":"2018-09-03T06:01:29.738Z","comments":true,"path":"2018/05/07/cpperror6/","link":"","permalink":"http://KKimSangHeon.github.io/2018/05/07/cpperror6/","excerpt":"","text":"12분명히 string을 include 했을때도 발생한다면 namespace를 붙여줬는지 확인해보자아니면 using namespace std; 을 선언하자","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"C++","slug":"Language/C","permalink":"http://KKimSangHeon.github.io/categories/Language/C/"}],"tags":[{"name":"c++, 에러","slug":"c-에러","permalink":"http://KKimSangHeon.github.io/tags/c-에러/"}]},{"title":"conflicting declaration ‘std::string tempJsonData’","slug":"cpperror5","date":"2018-05-07T05:22:17.000Z","updated":"2018-09-03T06:01:25.043Z","comments":true,"path":"2018/05/07/cpperror5/","link":"","permalink":"http://KKimSangHeon.github.io/2018/05/07/cpperror5/","excerpt":"","text":"1변수명이 겹치는것이 존재하는경우 발생하는 에러이다.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"C++","slug":"Language/C","permalink":"http://KKimSangHeon.github.io/categories/Language/C/"}],"tags":[{"name":"c++, 에러","slug":"c-에러","permalink":"http://KKimSangHeon.github.io/tags/c-에러/"}]},{"title":"분명히 inlcude를 했는데  was not declared in this scope 라고 뜨는경우","slug":"cpperror4","date":"2018-05-07T05:20:20.000Z","updated":"2018-09-03T06:01:26.170Z","comments":true,"path":"2018/05/07/cpperror4/","link":"","permalink":"http://KKimSangHeon.github.io/2018/05/07/cpperror4/","excerpt":"","text":"12345이 경우 다른 파일의 헤더와 겹치는 경우일 수 있다.#ifndef _AA_H#define _AA_H 라고 헤더를 정의했을 때 다른파일도 헤더를 AA로 선언했을 가능성이 높다.무분별한 복붙을 지양하자..","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"C++","slug":"Language/C","permalink":"http://KKimSangHeon.github.io/categories/Language/C/"}],"tags":[{"name":"c++, 에러","slug":"c-에러","permalink":"http://KKimSangHeon.github.io/tags/c-에러/"}]},{"title":"no matching function for call to ‘~~~, <unresolved overloaded function type>, ~~~)’","slug":"cpperror3","date":"2018-05-07T05:20:12.000Z","updated":"2018-09-03T06:01:19.306Z","comments":true,"path":"2018/05/07/cpperror3/","link":"","permalink":"http://KKimSangHeon.github.io/2018/05/07/cpperror3/","excerpt":"","text":"함수 호출부의 2번째 인자를 확인해보자 대표적으로 값을 반환하는 함수를 호출하는데 ()를 붙이지 않았을 경우 발생","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"C++","slug":"Language/C","permalink":"http://KKimSangHeon.github.io/categories/Language/C/"}],"tags":[{"name":"c++, 에러","slug":"c-에러","permalink":"http://KKimSangHeon.github.io/tags/c-에러/"}]},{"title":"definition of implicitly-declared ‘DataBuffer::DataBuffer()’ 에러","slug":"cpperror2","date":"2018-05-06T13:47:39.000Z","updated":"2018-09-03T06:01:16.928Z","comments":true,"path":"2018/05/06/cpperror2/","link":"","permalink":"http://KKimSangHeon.github.io/2018/05/06/cpperror2/","excerpt":"","text":"헤더파일에 해당 생성자를 선언하지 않았을 경우 발생 생성자를 다시한번 살펴보자","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"C++","slug":"Language/C","permalink":"http://KKimSangHeon.github.io/categories/Language/C/"}],"tags":[{"name":"c++, 에러","slug":"c-에러","permalink":"http://KKimSangHeon.github.io/tags/c-에러/"}]},{"title":"‘size_t’ does not name a type 에러가 발생했을 때","slug":"cpperror","date":"2018-05-05T13:19:09.000Z","updated":"2018-09-03T06:01:11.099Z","comments":true,"path":"2018/05/05/cpperror/","link":"","permalink":"http://KKimSangHeon.github.io/2018/05/05/cpperror/","excerpt":"","text":"123456다음중 아무거나 include하자Defined in header &lt;cstddef&gt; Defined in header &lt;cstdio&gt; Defined in header &lt;cstring&gt; Defined in header &lt;ctime&gt; Defined in header &lt;cwchar&gt;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"C++","slug":"Language/C","permalink":"http://KKimSangHeon.github.io/categories/Language/C/"}],"tags":[{"name":"c++, 에러","slug":"c-에러","permalink":"http://KKimSangHeon.github.io/tags/c-에러/"}]},{"title":"터미널을 종료해도 서버가 켜져있도록 유지","slug":"angular","date":"2018-05-01T08:46:42.000Z","updated":"2018-09-03T06:01:02.191Z","comments":true,"path":"2018/05/01/angular/","link":"","permalink":"http://KKimSangHeon.github.io/2018/05/01/angular/","excerpt":"","text":"터미널을 종료해도 서벼가 켜져있도록 유지하는 방법 npm으로 forever을 설치 후12forever start node_modules/@angular/cli/bin/ng serve --host=0.0.0.0forever stopall","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Angular2","slug":"Web-App/Angular2","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Angular2/"}],"tags":[{"name":"Angular2","slug":"Angular2","permalink":"http://KKimSangHeon.github.io/tags/Angular2/"},{"name":"Web","slug":"Web","permalink":"http://KKimSangHeon.github.io/tags/Web/"}]},{"title":"C++ 함수에서의 참조자의 활용","slug":"cpp1","date":"2018-04-15T23:19:55.000Z","updated":"2018-09-03T06:03:06.648Z","comments":true,"path":"2018/04/16/cpp1/","link":"","permalink":"http://KKimSangHeon.github.io/2018/04/16/cpp1/","excerpt":"","text":"","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"C++","slug":"Language/C","permalink":"http://KKimSangHeon.github.io/categories/Language/C/"}],"tags":[{"name":"c++, 참조자","slug":"c-참조자","permalink":"http://KKimSangHeon.github.io/tags/c-참조자/"}]},{"title":"OpenCV 설치","slug":"opencv-exam1","date":"2018-04-04T23:23:32.000Z","updated":"2018-09-03T06:00:42.038Z","comments":true,"path":"2018/04/05/opencv-exam1/","link":"","permalink":"http://KKimSangHeon.github.io/2018/04/05/opencv-exam1/","excerpt":"","text":"http://webnautes.tistory.com/1030참고로 나는 마지막 pkg_config 관련해서 vi ~/.bash_profile을 입력후export PKG_CONFIG_PATH=”$LIB_DIR/opencv/lib64/pkgconfig” 을 입력했다 컴파일 방법g++ -o facedetect facedetect.cpp $(pkg-config –libs –cflags opencv)g++ -o facedetect facedetect.cpp ‘pkg-config –libs –cflags opencv’ 참고할만한 예제http://hanmin-dev.tistory.com/13 (이미지의 픽셀 RGB 구하는법 알려줌 Makefile 구성방법 알려줌)http://eehoeskrap.tistory.com/34?category=537364 ( 픽셀 소금뿌리기)","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"}],"tags":[]},{"title":"리눅스 개인폴더에 설치된 디렉토리 사용하기","slug":"linux-bash-profile","date":"2018-03-29T23:29:17.000Z","updated":"2018-09-03T06:00:55.200Z","comments":true,"path":"2018/03/30/linux-bash-profile/","link":"","permalink":"http://KKimSangHeon.github.io/2018/03/30/linux-bash-profile/","excerpt":"","text":"서버에 curl이 설치되어 있고 내 로컬에도 curl이 설치되어 있을 때 내 curl을 사용하기 위한 방법 vi ~/.bash_profile을 열고 아래를 입력하고 export CURL_DIR=”$HOME/apps/usr/curl/bin”export PATH=$CURL_DIR:$PATH source ~/.bash_profile을 입력 curl -V를 통해 잘 적용되었나 확인","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"}]},{"title":"아파치 모듈추가","slug":"apache-add-module","date":"2018-03-23T11:39:06.000Z","updated":"2018-09-03T06:00:26.880Z","comments":true,"path":"2018/03/23/apache-add-module/","link":"","permalink":"http://KKimSangHeon.github.io/2018/03/23/apache-add-module/","excerpt":"","text":"아파치 모듈 추가/home/sangheon/apps/apache 이라는 경로에 아파치가 설치되어있다고 가정. ./apxs -n modulename -g 로 모듈추가. 그럼 현재 위치(bin)에 modulename디렉토리가 생성된다. /home/sangheon/apps/apache/conf 경로로 이동하여 httpd.conf를 열자 약 150라인 정도 다음을 추가하자.LoadModule modulename_module modules/mod_modulename.so &lt;Location /modulename&gt; SetHandler modulename &lt;/Location&gt;위의 내용은 mod_modulename.c 파일을 참고하여 작성가능 /home/sangheon/apps/apache/bin 디렉토리에 이동하여 ./apxs -c -i /home/sangheon/apps/apache/bin/modulename/mod_modulename.c 를 입력하자. 여기서 특정 라이브러리를 이용할 경우 뒤에 -l라이브러리 이름을 입력하자. curl을 이용할 경우 -lcurl을 입력 bin 디렉토리에서./apachectl restart 입력 만약 c 파일을 수정했을 경우엔 4번 5번을 다시 실행하면 된다.권한문제(sudo permission)로 서버를 실행시킬 수 없을 때 다음과 같이 입력하자.sudo /bin/chown root.sangheon /home/sangheon/apps/apache/bin/httpd sudo /bin/chmod 4755 /home/sangheon/apps/apache/bin/httpd","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"}],"tags":[{"name":"아파치 모듈추가","slug":"아파치-모듈추가","permalink":"http://KKimSangHeon.github.io/tags/아파치-모듈추가/"}]},{"title":"","slug":"mytip","date":"2018-03-19T15:00:00.000Z","updated":"2018-04-10T23:50:46.417Z","comments":true,"path":"2018/03/20/mytip/","link":"","permalink":"http://KKimSangHeon.github.io/2018/03/20/mytip/","excerpt":"","text":"vi 관련 코드 정렬하기ggvG=gg는 파일 처음으로이동하고v는 비쥬얼 모드로 전환하고G는 끝까지 드래그=는 정렬 함수 정의를 찾아가고싶을 때ctag 를 사용하자http://bowbowbow.tistory.com/15 ~/.vimrcset hlsearchset nuset autoindentset scrolloff=2set wildmode=longest,listset ts=4set sts=4set sw=1set autowriteset autoreadset cindentset bs=eol,start,indentset history=256set laststatus=2set shiftwidth=4set showmatchset smartcaseset smarttabset smartindentset softtabstop=4set tabstop=4set rulerset incsearchhighlight Comment term=bold cterm=bold ctermfg=4set tags=/home1/irteam/sangheon/getimage/tags","categories":[],"tags":[]},{"title":"2장. 규칙3 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계해라","slug":"effectiveJava4","date":"2018-03-18T23:00:36.000Z","updated":"2018-09-03T06:00:13.303Z","comments":true,"path":"2018/03/19/effectiveJava4/","link":"","permalink":"http://KKimSangHeon.github.io/2018/03/19/effectiveJava4/","excerpt":"","text":"규칙3 생성자나 enum 자료형은 싱글턴 패턴을 따르도록 설계해라싱글턴 : 객체를 하나만 만들 수 있는 클래스. 창관리자, 파일 시스템 같은 것들이 그 예다. 싱글턴을 구현하는 방법은 두가지인데 두 방법 다 생성자는 private로 선언하고, 싱글턴 객체는 정적(static)멤버를 이용한다. 첫번째 방법의 경우 정적멤버는 final로 선언한다. 두 번째 방법은 public으로 선언된 정적 팩터리 메서드를 이용하는 것이다. 두 방법 다 리플렉션 기능을 통해 private 생성자를 호출할 수 있다는 점에 주의해야 한다. 싱글턴을 구현하는 또다른 한가지의 방법은 원소가 하나뿐인 enum 자료형을 정의하는 것이다. 이는 좀 더 간결하며, 직렬화가 자동으로 처리된다. 또한 직렬화가 복잡하게 이루어져도 여러 객체가 생길일이 없으며 리플렉션을 통한 공격에도 안전하다. 책에서는 이 방법이 싱글턴을 구현하는 가장 좋은 방법이라 추천한다. 참고 URL직렬화 : http://woowabros.github.io/experience/2017/10/17/java-serialize.html","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"2장. 규칙2 생성자 인자가 많을 때는 Builder 패턴 적용을 고려하라.","slug":"effectiveJava3","date":"2018-03-15T10:27:56.000Z","updated":"2018-09-03T06:00:10.984Z","comments":true,"path":"2018/03/15/effectiveJava3/","link":"","permalink":"http://KKimSangHeon.github.io/2018/03/15/effectiveJava3/","excerpt":"","text":"규칙2. 생성자 인자가 많을 때는 Builder 패턴 적용을 고려하라.보통 생성자의 인자 혹은 정적팩터리의 인자가 많을 땐 점층적 생성자 패턴(telescping constructor pattern)을 적용한다. 17p점층적 생성자 패턴 : 필수인자만 받는 생성자를 하나 정의하고, 선택적 인자를 하나 받는 생성자를 추가하고, 거기에 두 개의 선택적 인자를 받는 생성자를 추가하는 식으로 생성자들을 쌓아 올리듯 추가하는 것. 하지만 점층적 생성자 패턴은 설정할 필요가 없는 필드에도 인자를 전달해야하는 경우가 생긴다. 즉 인자수가 늘어나면 클라이언트 코드를 작성하기 어려워지고 읽기 어려워진다. 생성자의 인자가 많을 때 사용할 수 있는 두번째 방법은 자바빈(JavaBeans) 패턴이다. 18p자바빈 패턴: 인자없는 생성자를 호출하여 객체부터 만든 다음, 설정메서드(setter)들을 호출하여 필수 필드뿐아니라 선택적 필드값 까지 채우는 것이다. 자바빈 패턴은 1회의 함수 호출로 객체 생성을 끝낼 수 없으므로 객체 일관성이 일시적으로 깨질 수 있다. 또한 변경 불가능(immutable)클래스를 만들 수 없다는점, 스레드 안정성을 제공하기 위해 해야할 일도 많아진다. 점층적 생성적 생성자 패턴의 안정성 , 자바빈 패턴의 가독성을 결합한 것이 바로 빌더(Builder)패턴이다.필요한 객체를 직접 생성하는 대신 클라이언트는 먼저 필수인자들을 생성자 또는 정적 팩터리 메서드에 전부 전달하여 빌더객체(Builder object)를 만든다. 그런 다음 빌더 객체에 정의된 설정 메서드들을 호출하여 선택적 인자들을 추가 해 나간다. 그리고 마지막으로 아무런 인자 없이 build 메서드를 호출하여 변경 불가능 객체를 만든다. 빌더패턴의 장점 작성하기 쉽고, 읽기 쉽다. 인자에 불변식(invariant)을 적용할 수 있다. 여러개의 varargs 인자(가변인자)를 받을수 있다. 하나의 빌더 객체로 여러 객체를 만들 수 있어 유연하다. 빌더패턴의 단점 객체를 생성하기 위해 빌더 객체를 생성해야한다. 오버헤드의 문제가 될 소지는 적지만 성능이 중요한 상황에서는 문제가 될 수 있다. 요약하자면대부분의 인자가 선택적 인자이거나 인자가 많은 생성자나 정적 팩터리가 필요한 클래스를 설계할 때 유용하다. 가독성은 점층적 생성자 패턴보다 향상되며 자바빈을 사용할 때 보다 안전하다.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"2장. 규칙1 생성자 대신 정적 팩터리 메서드를 사용할 수 없는지 생각해보자.","slug":"effectiveJava2","date":"2018-03-13T22:53:39.000Z","updated":"2018-09-03T06:00:08.276Z","comments":true,"path":"2018/03/14/effectiveJava2/","link":"","permalink":"http://KKimSangHeon.github.io/2018/03/14/effectiveJava2/","excerpt":"","text":"규칙 1. 생성자 대신 정적 팩터리 메서드를 사용할 수 없는지 생각해보자.프로그래머가 알아야하는 또다른 객체생성 방법은 클래스에 public로 선언된 팩토리 메서드를 추가하는 것이다. 이러한 방법의 장점은 다음과 같다.1.생성자와 달리 정적 팩토리 메소드에는 이름이 있다. (가독성 향상) 2.호출할 때마다 새로운 객체를 생성할 필요 없다.(객체생성 비용이 클 때 효율적, 개체 통제 클래스로의 역할)개체 통제 클래스(instance-controlled class) : 어떤 시점에 어떤 객체가 얼마나 존재할지 제어가능한 클래스. 이를 통해 싱글턴 패턴을 따르도록 할수 있고, 객체생성이 불가능한 클래스를 만들 수 도 있다. 변경이 불가능한 클래스의 경우 두개의 같은 객체가 존재하지 못하도록 할 수 있다. 3.생성자와 달리 반환값 자료형의 하위 자료형 객체를 반환할 수 있다. (반환되는 객체의 클래스를 유연하게 결정 가능. EnumSet이 그 예시)이를 통해 public으로 선언되지 않은 클래스의 객체를 반환하는 API를 만들 수 있다. 4.형인자 자료형(parameterized type) 객체를 만들 때 편하다.(자바 1.7부터는 자료형 유추가 가능해졌다 14p) 단점은 다음과 같다. public이나 protected로 선언된 생성자가 없으므로 하위 클래스를 만들 수 없다는 것이다. 정적 팩터리 메서드가 다른 정적 메서드와 확연히 구분되지 않는다는 것이다.보통 정적 팩토리 메소드의 이름으로는 다음과같은 이름을 쓴다.valueOf , of , getInstance , newInstance , getType , newType","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"Effective Java","slug":"effectiveJava1","date":"2018-03-12T13:49:17.000Z","updated":"2018-09-03T06:03:44.367Z","comments":true,"path":"2018/03/12/effectiveJava1/","link":"","permalink":"http://KKimSangHeon.github.io/2018/03/12/effectiveJava1/","excerpt":"","text":"워낙 유명한 이책을 한번쯤 보고싶다는 생각을 했었고 이제서야 이 책을 읽으며 스스로 정리한 내용을 잊지 않기위해 블로그에 올려 공유하고자 한다.다음은 이 책을 읽기위해 알아두자. 1. 자바는 네 가지 유형의 자료형을 지원한다. 인터페이스(어노테이션 포함) 클래스(enum 포함) 배열 기본 자료형(primitive)여기서 위의 3개는 참조 자료형(reference type)으로 알려져있으며 모든 개체(instance)와 배열은 객체(object)이다. 하지만 기본 자료형은 객체가 아니다. 클래스의 멤버로는 필드(field), 메서드(method), 멤버 클래스(member class), 그리고 멤버 인터페이스(member interface) 등이 있다. 메서드의 시그니처(signature)는 그 이름과 형식 인자 자료형들로 구성된다. 시그니처에는 메서드의 반환값 자료형은 포함되지 않는다.메소드 시그니처란 : 메소드의 이름과 매개변수 목록 2. 자바 언어 명세서의 정의를 따르지 않는 것들 계승(inheritance)라는 용어를 하위 클래스 정의(subclassing)와 같은 뜻으로 사용한다. 인터페이스에는 계승이라는 용어 대신, 클래스가 인터페이스를 구현(implements)한다고 하거나, 한 인터페이스가 다른 인터페이스를 확장(extends)한다고 표현한다. 접근권한을 명시하지 않았을 때 가능한 접근 수준을 표현할 때는 기본 접근 권한 (default access)대신 의미가 분명한 package-private라는 용어를 사용한다. 3. API 관련 API를 사용해 프로그램을 작성하려는 프로그래머는 API의 사용자(user)라고 지칭한다. 어떤 API를 사용해 구현된 클래스는 API의 클라이언트(client)라고 부른다.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"리눅스마스터 2급","slug":"linuxmaster","date":"2018-03-07T14:51:28.000Z","updated":"2018-09-03T05:59:56.927Z","comments":true,"path":"2018/03/07/linuxmaster/","link":"","permalink":"http://KKimSangHeon.github.io/2018/03/07/linuxmaster/","excerpt":"","text":"취득시기2018년 03월 내용데비안, 레드햇 계열 리눅스의 기본적인 역사 그리고 간단한 명령어 정도만 알고있을 경우 일주일 정도면 취득가능하다. www.comcbt.com/ 에서 연도별 문제를 제공하며 총 5회분의 문제(약 400문제)정도를 풀어보고 시험을 봤었다. 용산공업고등학교에서 시험을 봤으며 학교의 정문을 찾는데 애를 먹었던것 말고는 불편했던점은 없다. 하루 2시간씩 약 일주일동안 공부하였으며 시험 3일 후엔 가답안이 나와 가채점이 가능하다는 것이 다른 자격증에 비해 좋았던것 같다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"자격증","slug":"Etc/자격증","permalink":"http://KKimSangHeon.github.io/categories/Etc/자격증/"}],"tags":[{"name":"자격증","slug":"자격증","permalink":"http://KKimSangHeon.github.io/tags/자격증/"},{"name":"리눅스마스터 2급","slug":"리눅스마스터-2급","permalink":"http://KKimSangHeon.github.io/tags/리눅스마스터-2급/"}]},{"title":"6장. 모듈","slug":"angular2-1","date":"2018-01-28T12:03:56.000Z","updated":"2018-09-03T05:59:49.550Z","comments":true,"path":"2018/01/28/angular2-1/","link":"","permalink":"http://KKimSangHeon.github.io/2018/01/28/angular2-1/","excerpt":"","text":"6장. 모듈앵귤러 애플리케이션을 구성하는 뼈대와 같은 역할. @NgModule 장식자를 이용한다import {Component} from ‘@angular/core’;와 같이 이용하는데 Component는 사용할 모듈이고, @angular/core는 패키지이다. 라이브러리 모듈 147p앵귤러가 제공하는 모듈. ex) 지시자, 파이프, 장식자, 클래스, 인터페이스, 함수, Enum, 타입 별칭(type alias), 상수 사용자 정의 모듈 147p컴포넌트나 지시자와 같이 장식자를 이용한 모듈과 서비스와 함수 값과 같이 장식자가 없는 모듈로 구분됨.외부로 공개할 모듈은 export를 이용해 선언(ES6부터 지원) 애플리케이션 루트 모듈 149p앵귤러는 애플리케이션 루트 모듈이라는 최상위 모듈을 통행 애플리케이션 모듈을 구성한다. 하지만 이 안에 모든 모듈을 구성할 수 없기 떄문에 의미론적으로 - 특징모듈 (개별 컴포넌트 단위가 아닌 단위 애플리케이션을 구성하는 모듈) 공유모듈 (다른 모듈에 포함되어 동작하는 모듈 (반복적으로 선언되는 모듈)) 핵심모듈 (애플리케이션에서 항상 동작할 필요가 있거나 애플리케이션의 전체적인 동작에 핵심적인 역할을 하는 모듈(ex) 타이틀 컴포넌트)로 나눔. 애플리케이션 루트 모듈은 @Ngmodule 장식자를 이용해 정의한다.123456@Ngmodule(&#123; imports : [BrowserModule, CommonModule, FormsModule ...] , providers : [] , declarations : [AppComponent, ...] bootstrap : [AppComponent] &#125;) @Ngmodule내 import영역브라우저 모듈(BrowserModule) 151p브라우저 모듈은 앵귤러가 브라우저에서 동작한다면 반드시 포함되어야함. 지시자, 파이프 같은 구성요소를 템플릿에 나타나게 하는 역할을 함.브라우저 모듈은 공통 모듈을 재노출(re-exports) 한다는 것이다. 이 때문에 브라우저 모듈을 이미 선언했다면 공통 모듈을 선언하지 않아도 된다. 공통모듈(CommonModule) 151p템플릿에서 사용하는 ngIf나 ngFor와 관련된 기능을 포함하고 있는 모듈이다. 폼모듈(FormsModule) 152p템플릿에서 자주 사용하는 NgModel지시자나 내장 검증기 지시자 등을 포함하고 있다. 그래서 폼 모듈을 포함하면 NgModel과 같이 자주 사용하는 지시자를 별도로 추가하지 않아도 된다. AppRoutingModule 152p사용자가 정의할 수 있는 라우팅 모듈이다. 애플리케이션 루트 모듈에 추가한 라우팅모듈은 애플리케이션 수준에서 라우팅을 수행한다. @Ngmodule내 provider영역애플리케이션 전역에서 사용할 서비스를 등록. @Ngmodule내 declarations영역애플리케이션 레벨에서 사용하고자 하는 컴포넌트, 지시자 파이프를 선언한다. @Ngmodule내 bootstrap영역최상위 컴포넌트인 애플리케이션 컴포넌트를 등록 router-outlet 152p하위 특정 컴포넌트로 라우팅 후 하위 컴포넌ㅌ를 표시할 목적으로 라우터 아룰렛 지시자를 포함한다. 라우터 아울렛에 표시할 컴포넌트가 있다면 애플리케이션 라우팅 모듈 설정에 등록한다. 12345678910const appRoutes:Routes = [ &#123; path: &apos;&apos;, component: IntroComponet&#125;, &#123; path: &apos;hello&apos;, component: HelloComponent&#125;, ...];@NgModule(&#123; imports: [RouterModule.forRoot(appRoutes)], exports:[RouterModule] &#125;) appRoutes 변수는 라우팅 설정을 담고 있으며 입력 URL에 대응하는 컴포넌트로 라우팅 되게 한다. appRoutes변수는 forRoot() 메소드를 이용해 등록한다. 유의할 점은 애플리케이션 라우팅 모듈에서만 한 번만 사용돼야 하고 특징 모듈에서는 사용하면 안된다. 애플리케이션 루트모듈에서는 다음과 같이 inports를 해줘야 한다.12@Ngmodule(&#123; imports : [AppRoutingModule ...] , 핵심모듈 155p앵귤러 어플리케이션 관점에서 핵심이 되는 모듈로 애플리케이션 루트 모듈에 한번 설정함을써 애플리케이션 레벨에서 사용할 수 있는 모듈을 말한다. 루트 모듈에 등록됐다는 것은 애플리케이션이 시작될 때 처음 한 번만 호출해서 전역으로 사용하겠다는 의미이다. 대표 예로 타이틀 컴포넌트가 있다. 보통 핵심 모듈은 /app/core에 위치시킨다. 특징모듈 161p모듈이 많아지면 모듈 구성이 복잡해지며 지시자의 이름충돌 등의 문제가 발생할 수 있다. 이를 방지하기 위해 애플리케이션 루트 모듈에서 하위 모듈로 분리하는 것을 특징 모듈이라 한다. 특징 모듈에 선언한 모듈은 다른 모듈에 노출하거나 숨길수도 있다. 추가예정..","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Angular2","slug":"Web-App/Angular2","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Angular2/"}],"tags":[{"name":"Angular2","slug":"Angular2","permalink":"http://KKimSangHeon.github.io/tags/Angular2/"},{"name":"Web","slug":"Web","permalink":"http://KKimSangHeon.github.io/tags/Web/"}]},{"title":"5장. 서비스","slug":"angular2","date":"2018-01-28T12:02:55.000Z","updated":"2018-09-03T05:59:52.611Z","comments":true,"path":"2018/01/28/angular2/","link":"","permalink":"http://KKimSangHeon.github.io/2018/01/28/angular2/","excerpt":"","text":"5장. 서비스앵귤러JS(앵귤러2아님)에서는 기능을 컨트롤러에서 분리하기 위해 서비스 메소드를 써야할지 팩토리 메소드를 써야할지 혼란이 있었으나 2에서는 팩토리와 서비스를 서비스로 단일화 하였고 메소드에서 클래스로 변경하였다.서비스는 공통관심사를 묶어놓았다.provider제공자 그리고 @Injectable() 장식자 이용 서비스 특징 서비스는 의존성 주입이 가능하다. 132p 객체지향적으로 이용가능 목 객체 서비스로 이용가능(서버,외부의 의존성없이 테스트 코드 작성할 때 유용) 135p 프로미스 서비스 (콜백헬과같은 비정상적인 호출형태를 개선하기 위해 나옴) 138p 서비스를 이용한 데이터 교환 가능(부모는 provider 설정을 해줘야하지만 자식은 안한다)","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Angular2","slug":"Web-App/Angular2","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Angular2/"}],"tags":[{"name":"Angular2","slug":"Angular2","permalink":"http://KKimSangHeon.github.io/tags/Angular2/"},{"name":"Web","slug":"Web","permalink":"http://KKimSangHeon.github.io/tags/Web/"}]},{"title":"유용한 사이트 모음","slug":"usefulsite","date":"2018-01-27T13:41:25.000Z","updated":"2018-02-12T23:34:32.218Z","comments":true,"path":"2018/01/27/usefulsite/","link":"","permalink":"http://KKimSangHeon.github.io/2018/01/27/usefulsite/","excerpt":"","text":"알고리즘, 코딩관련https://app.codility.com/programmers/lessons/1-iterations/ 트렌드 분석https://trends.google.com/trends/?hl=ko검색어를 입력하여 해당검색어에 대한 연관이슈 등에 대해 알 수 있다.. IT 관련http://www.itfind.or.kr/IT 관련 이슈를 접할 수 있으며 정기간행물또한 유용하다. 면접","categories":[],"tags":[]},{"title":"4장. 컴포넌트","slug":"angular2","date":"2018-01-15T14:22:50.000Z","updated":"2018-09-03T05:59:39.137Z","comments":true,"path":"2018/01/15/angular2/","link":"","permalink":"http://KKimSangHeon.github.io/2018/01/15/angular2/","excerpt":"","text":"4장. 컴포넌트컴포넌트앵귤러에서 화면하는 구성하는 중요한 구성요소이다. 웹 컴포넌트HTML , CSS, 자바스크립트를 하나의 단위로 묶어주는 기술이다. 웹 컴포넌트 기술은 하나의 기능이 아니라 여러가지 기술들이 합쳐져 하나의 웹 컴포넌트를 구성 웹 컴포넌트는 앵귤러2 컴포넌트의 기반기술이다 앵귤러 2 컴포넌트는 웹 컴포넌트의 기술요소를 기반으로 하므로 웹 컴포넌트를 이해하면 앵귤러 컴포넌트를 이해하는 데 도움된다. HTML 템플릿 템플릿 호출 쉐도우 DOM 커스텀 엘리먼트 중첩컴포넌트 85p부모 컴포넌트가 여러 자식컴포넌트를 포함하는 경우 컴포넌트 트리 86p평면적으로 나열된 컴포넌트가 어떤 포함 관계를 가지는지 알수있게 해줌 컴포넌트 기반 개발 87p컴포넌트를 개발의 중심에 두고 개발하는것. 컴포넌트 89p컴포넌트 내부는 크게 import 영역, @Component 장식자(selector, template, styles로 구성됨), 컴포넌트 클래스 영역으로 나뉜다. 부모가 자식한테 값 전달부모가 속성바인드를 통해 값을 전달하면 자식이 값을 받는 방법은 2가지가 있다. @input 장식자 99p외부에서 전달된 값을 받기 위해 사용하는 장식자 inputs 102p부모가 name1, name2 속성으로 어떠한 값을 전달하면 자식은 @Component장식자 안에 inputs:[‘name1’,’name2’]로 값을 받을 수 있다. 자식의 클래스에서도 name1, name2를 지정해줘야함 자식이 부모한테 값 전달 103p@Output 장식자로 선언한 변수를 EventEmitter로 초기화한다. 그리고 부모에게 보낼 시점이 되면 emit()메소드를 사용해 부모로 이벤트를 전달한다. @ViewChild 장식자 107p화면 DOM에 접근해 첫 번째로 위치한 지시자의 내부 상태(지시자의 속성값)나 정보(컴포넌트 지시자의 경우 내부 메서드)를 가져온다 @ViewChildren 장식자 109p@ViewChild는 하나의 엘리먼트 상태를 갖고왔지만 @ViewChildren 장식자는 여러 지시자의 상태를 한번에 취할 수 있다. @ContentChild 장식자 112p콘텐츠 DOM을 탐색해 지시자 엘리먼트의 상태를 QueryList에 담는 역할을 한다. @ContentChildren 장식자 114p컴포넌트 내부에 위치한 엘리먼트나 지시자에 정보를 담고 있는 쿼리리스트를 얻는다. 쉐도우 DOM의 선택자 118p그냥 styles:[‘span{font-style}’] 이런식으로 하면 해당 컴포넌트의 span만 적용된다. 이를 범위를 넓히거나 좁힐때 사용하는것이 쉐도우 DOM의 선택자이다.1.:host 선택자2.:host-context 선택자3.:deep 선택자","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Angular2","slug":"Web-App/Angular2","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Angular2/"}],"tags":[{"name":"Angular2","slug":"Angular2","permalink":"http://KKimSangHeon.github.io/tags/Angular2/"},{"name":"Web","slug":"Web","permalink":"http://KKimSangHeon.github.io/tags/Web/"}]},{"title":"마인즈랩","slug":"interview6","date":"2018-01-13T13:31:35.000Z","updated":"2018-09-03T05:59:32.994Z","comments":true,"path":"2018/01/13/interview6/","link":"","permalink":"http://KKimSangHeon.github.io/2018/01/13/interview6/","excerpt":"","text":"시기2017년 9월 면접내용판교에서 열린 취업박람회에 참가하여 처음면접을 진행했으며 개발팀이 아닌 분들과 면접을 진행했습니다. 진행했던 프로젝트 그리고 어필하고 싶은 분야에 대한 프로젝트에 대해 설명했습니다. 2차면접은 사무실 내 회의실에서 진행하였으며 각팀의 개발팀 팀장님들 그리고 전무님과 면접을 진행했습니다. 면접 질문은 다음과 같습니다. 자기소개 영업시키면 어떻게 할 지낼것인지 진행했던 프로젝트에 대한 설명 지원동기 자신있는 언어 그 언어의 특징 및 장점 자기소개서 기반 질문 소감면접의 난이도는 높은편은 아니나 자신이 진행했던 프로젝트 그리고 자신있는 언어가 한개이상은 있어야 되는것 같습니다. 직무는 면접 후 결정되었으며 전무님의 질문이 개발을 좋아하시는 분이란걸 느낄수 있게 했습니다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"면접","slug":"Etc/면접","permalink":"http://KKimSangHeon.github.io/categories/Etc/면접/"}],"tags":[{"name":"면접","slug":"면접","permalink":"http://KKimSangHeon.github.io/tags/면접/"},{"name":"minds lab","slug":"minds-lab","permalink":"http://KKimSangHeon.github.io/tags/minds-lab/"},{"name":"마인즈랩","slug":"마인즈랩","permalink":"http://KKimSangHeon.github.io/tags/마인즈랩/"}]},{"title":"아이티센 정보시스템 개발","slug":"interview5","date":"2018-01-13T13:23:16.000Z","updated":"2018-09-03T05:59:29.677Z","comments":true,"path":"2018/01/13/interview5/","link":"","permalink":"http://KKimSangHeon.github.io/2018/01/13/interview5/","excerpt":"","text":"시기2016년 11월 면접내용1차면접은 인사팀, 개발팀 총 3분이 면접관으로 들어오십니다. 지원자는 2명이 면접에 참가합니다.주로 인성위주의 질문이며 진행했던 프로젝트에 대한 질문또한 주십니다.2차면접은 대표님, 인사팀 등등 총 5분정도의 분들이 면접관으로 들어오시며 지원자는 3명이 면접에 참가했습니다. 1차 2차 모두 인성위주, 진행했던 프로젝트에 대한 질문이 주를 이뤘으며 좋은분위기속에서 면접을 마쳤습니다.기억나는 면접질문은 다음과 같습니다. 자기소개 자기소개서 위주의 질문 핵심가치에 대한 질문 팀장으로서 팀원을 이끌어본 경험 3가지 가치와 경험에 대한 설명 포부 지방으로 파견가도 괜찮은지 소감좋은분위기속에서 면접진행되었으며 사옥이 우주선 비슷하게 생겨 신기하다는 생각이 들었습니다. 인턴활동을 진행하면서 들었는데 다른팀의 면접분위기는 무서웠다고 합니다. 면접관에 따라 분위기가 좌우되는것 같습니다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"면접","slug":"Etc/면접","permalink":"http://KKimSangHeon.github.io/categories/Etc/면접/"}],"tags":[{"name":"면접","slug":"면접","permalink":"http://KKimSangHeon.github.io/tags/면접/"},{"name":"itcen","slug":"itcen","permalink":"http://KKimSangHeon.github.io/tags/itcen/"},{"name":"정보시스템 개발","slug":"정보시스템-개발","permalink":"http://KKimSangHeon.github.io/tags/정보시스템-개발/"},{"name":"아이티센","slug":"아이티센","permalink":"http://KKimSangHeon.github.io/tags/아이티센/"}]},{"title":"휴맥스 웹개발","slug":"interview3","date":"2018-01-13T13:06:26.000Z","updated":"2018-09-03T05:59:11.218Z","comments":true,"path":"2018/01/13/interview3/","link":"","permalink":"http://KKimSangHeon.github.io/2018/01/13/interview3/","excerpt":"","text":"시기2017년 10월 면접내용휴맥스 사옥에서 면접 진행하였으며 사옥이 엄청 좋았던 기억이 납니다..총 네분의 면접관분들(실무진 3분 인사팀 1분)과 두명의 지원자가 면접을 진행합니다.면접 질문은 다음과 같습니다. 자기소개 영어로 자기소개 html, css, dom의 역할 oop의 특징 반응형 웹이란 소프트웨어 방법론 질문 관심있는 기술 궁금한점 할수있는 언어 소감영어자기소개는 꼭 준비하는게 좋을것 같습니다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"면접","slug":"Etc/면접","permalink":"http://KKimSangHeon.github.io/categories/Etc/면접/"}],"tags":[{"name":"면접","slug":"면접","permalink":"http://KKimSangHeon.github.io/tags/면접/"},{"name":"웹개발","slug":"웹개발","permalink":"http://KKimSangHeon.github.io/tags/웹개발/"},{"name":"휴맥스","slug":"휴맥스","permalink":"http://KKimSangHeon.github.io/tags/휴맥스/"}]},{"title":"사조시스템즈 전산","slug":"interview2","date":"2018-01-13T13:06:20.000Z","updated":"2018-09-03T05:59:18.303Z","comments":true,"path":"2018/01/13/interview2/","link":"","permalink":"http://KKimSangHeon.github.io/2018/01/13/interview2/","excerpt":"","text":"시기2016년 10월 면접내용 1차면접1차면접은 면접관 3분과 봤습니다. 기억나는 질문은 아래와 같습니다. 자기소개 설날같은 때 지인에게 참치를 팔아줘야 하는데 어떻게 팔 것인가 집이 어디인지 진행했던 프로젝트에 대한 질문. 주량은 얼마나 되는지 흡연여부 지원동기 우리회사, 그룹사가 무슨 일을하는지 1차면접의 합격여부는 당일 알려줬습니다. 2차면접 2차면접은 회장님? 대표님? 과 진행됩니다. 이미 뭐 합격자는 결정되어있던것 같으며 인성위주로 질문하시고 더 멀리보기위해서는 더 높게 올라가라라고 말씀해주신게 인상깊었습니다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"면접","slug":"Etc/면접","permalink":"http://KKimSangHeon.github.io/categories/Etc/면접/"}],"tags":[{"name":"면접","slug":"면접","permalink":"http://KKimSangHeon.github.io/tags/면접/"},{"name":"전산","slug":"전산","permalink":"http://KKimSangHeon.github.io/tags/전산/"}]},{"title":"SQLD, SQL개발자","slug":"certificate4","date":"2018-01-13T11:50:17.000Z","updated":"2018-09-03T06:05:21.232Z","comments":true,"path":"2018/01/13/certificate4/","link":"","permalink":"http://KKimSangHeon.github.io/2018/01/13/certificate4/","excerpt":"","text":"취득시기2017년 11월 내용총 한번의 시험이 있으며 앞부분의 이론적인 부분은 배점이 낮지만 절대 무시하면 안됩니다. 그 말이 이 말같고 이 말이 저 말같은 문제에 낚여 과락이라는 결과가 나올 수 있습니다. 공식교재와 풀이문제집을 구매해서 공부하였으며 책이 잘 읽히는 부분도 있지만 그렇지 않은 부분도 있었습니다. 총 한달정도 기간동안 천천히 공부했으며 공부내용은 개발자로서 살아가는데 많은 도움이 될 것 같으며 DB에 대한 상식 또한 넓어진것 같습니다. 개발자로서 따면 좋은 자격증이라 생각합니다. 하지만 시험당시가 조금 당황스러웠습니다. 문제에 오탈자가 한 두개가 아니라 집중할만하면 계속되는 감독관의 오타수정 알림으로 인해 시험이 5번넘게 중단되었습니다. 대놓고 짜증내는 사람도 있었으며 시험 종료 후 추가시간은 제공되지 않았습니다. 책의 내용, 문제는 개발자로서 알아야 할 상식이 많은것은 분명하나 문제 출제에 조금더 신경써주면 좋을것 같습니다. 전 이제 시험볼일은 없겠지만요 ㅋㅋ","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"자격증","slug":"Etc/자격증","permalink":"http://KKimSangHeon.github.io/categories/Etc/자격증/"}],"tags":[{"name":"자격증","slug":"자격증","permalink":"http://KKimSangHeon.github.io/tags/자격증/"},{"name":"SQLD","slug":"SQLD","permalink":"http://KKimSangHeon.github.io/tags/SQLD/"},{"name":"SQL 개발자","slug":"SQL-개발자","permalink":"http://KKimSangHeon.github.io/tags/SQL-개발자/"}]},{"title":"정보처리기사","slug":"certificate3","date":"2018-01-13T11:50:03.000Z","updated":"2018-09-03T05:58:50.749Z","comments":true,"path":"2018/01/13/certificate3/","link":"","permalink":"http://KKimSangHeon.github.io/2018/01/13/certificate3/","excerpt":"","text":"취득시기2016년 12월 내용필기의 경우 기출문제만 풀어본다면 합격할 수 있는 수준입니다. 전자계산기의 경우 반복해서 숙달해서 풀이법을 익히는게 중요하며 네트워크는 그냥 암기해야하는것 같습니다… 실기의 경우 16년 3회차부터 주관식으로 변경되어 어려워졌다는 말이 많은데 제가 봤던 16년 3회의 경우 그렇게 어렵지만은 않았습니다. 5년치의 실기 문제를 모두 풀어보고 시험에 임했으나 DB과목은 6년전의 문제와 비슷한 유형으로 나와 아차싶었지만 다행이 좋은 점수를 받을 수 있었습니다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"자격증","slug":"Etc/자격증","permalink":"http://KKimSangHeon.github.io/categories/Etc/자격증/"}],"tags":[{"name":"자격증","slug":"자격증","permalink":"http://KKimSangHeon.github.io/tags/자격증/"},{"name":"정보처리기사","slug":"정보처리기사","permalink":"http://KKimSangHeon.github.io/tags/정보처리기사/"}]},{"title":"컴퓨터활용능력 1급","slug":"certificate2","date":"2018-01-13T11:49:58.000Z","updated":"2018-09-03T05:58:55.510Z","comments":true,"path":"2018/01/13/certificate2/","link":"","permalink":"http://KKimSangHeon.github.io/2018/01/13/certificate2/","excerpt":"","text":"취득시기2013년 7월 내용필기는 워드프로세서와 겹치는 부분이 있으며 조금 더 확자된 부분이 있어 그부분만 조금 더 공부하고 쉽게 합격했습니다. 하지만 실기의 경우 생각만큼 쉽지만은 않았습니다. 11년 10월 입대전에 컴활이나 따고 가자해서 시작해서 11년 8월에 필기를 취득하고 13년 7월 전역후 한달동안 빡세게 공부해서 필기시험 만료를 눈앞에두고 취득할 수 있었습니다.전역하고 보니 필기시험 합격의 만료 전까지 실기시험이 3번밖에 없던터라 무작정 이번에 딴다는 각오로 3번 다 시험을 신청했습니다. 첫 시험은 어려웠음에도 불구하고 1점차이로 떨어졌고 두번째 시험에서 합격했습니다. 시험지마다 난이도도 조금씩 차이가 있는것 같으며 운도 어느정도 따라주었던거 같습니다. 실기의 경우 프로시저의 어려운 부분은 과감하게 포기하고 쉬운영역만 공부하였으며 엑셀, 엑세스는 사용방법을 빠삭하게 익혔으며 단축키의 사용법 또한 완벽하게 익혔습니다.컴활을 취득하기 위해 공부했던 내용은 일상생활속에서 생각보다 많은 도움을 주며 단순 취업용 뿐만아니라 엑셀실력 향상에도 많은 도움을 주었습니다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"자격증","slug":"Etc/자격증","permalink":"http://KKimSangHeon.github.io/categories/Etc/자격증/"}],"tags":[{"name":"컴퓨터활용능력 1급","slug":"컴퓨터활용능력-1급","permalink":"http://KKimSangHeon.github.io/tags/컴퓨터활용능력-1급/"},{"name":"자격증","slug":"자격증","permalink":"http://KKimSangHeon.github.io/tags/자격증/"}]},{"title":"워드프로세서 1급","slug":"certificate","date":"2018-01-13T03:40:20.000Z","updated":"2018-09-03T05:58:44.411Z","comments":true,"path":"2018/01/13/certificate/","link":"","permalink":"http://KKimSangHeon.github.io/2018/01/13/certificate/","excerpt":"","text":"취득시기2012년 8월 내용필기의 경우 기출문제만 풀어본다면 가볍게 합격할 수 있는 수준이며 실기도 마찬가지로 한달만 준비하면 딸 수 있는수준입니다. 실기시험을 볼 때 한타는 500타, 영타는 200타 나왔었으며 합격에 무리없을 적당한 속도였습니다. 교재를 보고 숙달하면 실력이 금방 향상되며 오타만 주의하면 쉽게 취득 가능합니다. 워드프로세서의 경우 군대에서 자격증을 취득할 만큼 쉬웠으며 취득했던 자격증 중에 가장 쉬웠던 자격증이었습니다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"자격증","slug":"Etc/자격증","permalink":"http://KKimSangHeon.github.io/categories/Etc/자격증/"}],"tags":[{"name":"자격증","slug":"자격증","permalink":"http://KKimSangHeon.github.io/tags/자격증/"},{"name":"워드프로세서","slug":"워드프로세서","permalink":"http://KKimSangHeon.github.io/tags/워드프로세서/"}]},{"title":"SK 고용디딤돌 면접","slug":"interview","date":"2018-01-13T03:39:23.000Z","updated":"2018-09-03T05:59:01.785Z","comments":true,"path":"2018/01/13/interview/","link":"","permalink":"http://KKimSangHeon.github.io/2018/01/13/interview/","excerpt":"","text":"시기2016년 12월 면접내용모바일개발 직무로 지원해서 면접을 진행했었습니다. SK에서 나오신 면접관 한분 인턴활동을 진행할 기업에서 한분 총 두분의 면접관과 면접을 진행했습니다.질문내용은 SK에서 나오신분은 주로 인성관련 질문을 하시며 기업에서 나오신 면접관님은 전공관련 질문을 많이하십니다.아래는 받았던 질문으로서 기억나는대로 적었습니다 자기소개 스트레스 해소방법 참가했던 대외활동에 대한설명 관심있는 분야 휴학하고 한일 입사 후 어떻게 지낼것인지 DB에서 인덱스란 논클러스트 인덱스 클러스트 인덱스의 차이 기본키는 클러스트인가 논 클러스트인가 소프트공학에 대한 질문 소감면접관 두분 모두 친절하셨으며 잡플래닛에서 보고간 내용 그대로 면접질문이 나와 수월했었습니다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"면접","slug":"Etc/면접","permalink":"http://KKimSangHeon.github.io/categories/Etc/면접/"}],"tags":[{"name":"SK 고용디딤돌","slug":"SK-고용디딤돌","permalink":"http://KKimSangHeon.github.io/tags/SK-고용디딤돌/"},{"name":"면접","slug":"면접","permalink":"http://KKimSangHeon.github.io/tags/면접/"},{"name":"모바일 개발","slug":"모바일-개발","permalink":"http://KKimSangHeon.github.io/tags/모바일-개발/"},{"name":"고용디딤돌","slug":"고용디딤돌","permalink":"http://KKimSangHeon.github.io/tags/고용디딤돌/"}]},{"title":"코인시세를 카카오톡으로 알아보기","slug":"coin","date":"2018-01-09T14:02:40.000Z","updated":"2018-09-03T05:58:40.072Z","comments":true,"path":"2018/01/09/coin/","link":"","permalink":"http://KKimSangHeon.github.io/2018/01/09/coin/","excerpt":"","text":"설명최근 비트코인과 더불어 다양한 코인들이 관심을 끌고있다..그 중 대표적인 거래소인 업비트의 실시간 코인 별 시세를 챗봇으로 확인할 수 있도록 만드는 포스트이다. 현재 확인할 수 있는 코인은 에이다, 리플, 퀀텀, 스텔라루멘, 스테이터스네트워크 이며 얼마든지 추가 가능하다. API업비트는 다른 거래소와는 다르게 공식적으로 API를 제공하지 않는다. 하지만 업비트에 접속 후 네트워크 창을 토대로 request주소를 알아낼 수 있었다.https://crix-api-endpoint.upbit.com/v1/crix/candles/minutes/1?code=CRIX.UPBIT.KRW-XXX위의 주소의 맨 마지막 XXX에 코인의 이름을 입력해 주면 현재 코인의 시세, 1분동안 최저가, 최고가를 알 수 있다. 위의 주소에서 제공하는 데이터는 1분단위로 갱신된다. 실시간으로 코인데이터를 읽어오는 모듈챗봇은 기존 개발된 Node.js 기반의 프로그램을 이용하였다. 소스코드는 아래의 주소에서 확인 가능하다.https://github.com/KKimSangHeon/Dg_Chat_Bot 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100exports.processCoin=function(res,commonFunction,request,async)&#123; var headers = &#123; 'User-Agent': 'Super Agent/0.0.1', 'Content-Type': 'application/x-www-form-urlencoded' &#125; var options = &#123; url: 'https://crix-api-endpoint.upbit.com/v1/crix/candles/minutes/1?code=CRIX.UPBIT.KRW-ADA', method: 'GET', headers: headers, &#125; const tasks = [ function(callback)&#123; var temp=''; request(options, function (error, response, body) &#123; if (!error &amp;&amp; response.statusCode == 200) &#123; // Print out the response body var jsonContent= JSON.parse(body); var resString='에이다: '+jsonContent[0].openingPrice+'\\n'; temp=resString; callback(null,temp); &#125; &#125;) &#125;, function(temp, callback) &#123; options.url = 'https://crix-api-endpoint.upbit.com/v1/crix/candles/minutes/1?code=CRIX.UPBIT.KRW-XRP' request(options, function (error, response, body) &#123; if (!error &amp;&amp; response.statusCode == 200) &#123; var jsonContent= JSON.parse(body); var resString ='리플: '+jsonContent[0].openingPrice+'\\n'; temp+=resString; callback(null,temp); &#125; &#125;) &#125;, function(temp, callback) &#123; options.url = 'https://crix-api-endpoint.upbit.com/v1/crix/candles/minutes/1?code=CRIX.UPBIT.KRW-QTUM' request(options, function (error, response, body) &#123; if (!error &amp;&amp; response.statusCode == 200) &#123; var jsonContent= JSON.parse(body); var resString ='퀀텀: '+jsonContent[0].openingPrice+'\\n'; temp+=resString; callback(null,temp); &#125; &#125;) &#125;, function(temp, callback) &#123; options.url = 'https://crix-api-endpoint.upbit.com/v1/crix/candles/minutes/1?code=CRIX.UPBIT.KRW-SNT' request(options, function (error, response, body) &#123; if (!error &amp;&amp; response.statusCode == 200) &#123; // Print out the response body var jsonContent= JSON.parse(body); var resString ='스테이터스네트워크: '+jsonContent[0].openingPrice+'\\n'; temp+=resString; callback(null,temp); &#125; &#125;) &#125;, function(temp, callback) &#123; options.url = 'https://crix-api-endpoint.upbit.com/v1/crix/candles/minutes/1?code=CRIX.UPBIT.KRW-XLM' request(options, function (error, response, body) &#123; if (!error &amp;&amp; response.statusCode == 200) &#123; // Print out the response body var jsonContent= JSON.parse(body); var resString ='스텔라루멘: '+jsonContent[0].openingPrice+'\\n'; temp+=resString; commonFunction.sendMessage(res,temp); callback(null); &#125; &#125;) &#125; ]; async.waterfall(tasks, function(err)&#123; if (!err) &#123; &#125; else &#123; console.error(err); &#125; &#125;);&#125; Node.js 는 동기방식이라 async 모듈을 이용하여 동기방식으로 각 코인들의 데이터를 읽어온 후 문자열 변수에 저장하였다.tasks 배열안에 함수들이 순차적으로 실행되며 callback 함수를 통해 축적된 문자열을 다음 함수로 넘겨준다.최종적으로 스텔라루멘에 대한 코인정보가 temp 변수에 저장되면 사용자에게 메세지를 전달하게 된다. 이렇게 위와같이 카카오톡으로 업비트에 들어가지 않고 코인들의 시세를 확인할 수 있다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"},{"name":"아무거나","slug":"Etc/아무거나","permalink":"http://KKimSangHeon.github.io/categories/Etc/아무거나/"}],"tags":[{"name":"업비트","slug":"업비트","permalink":"http://KKimSangHeon.github.io/tags/업비트/"},{"name":"API","slug":"API","permalink":"http://KKimSangHeon.github.io/tags/API/"},{"name":"에이다","slug":"에이다","permalink":"http://KKimSangHeon.github.io/tags/에이다/"},{"name":"퀀텀","slug":"퀀텀","permalink":"http://KKimSangHeon.github.io/tags/퀀텀/"},{"name":"스텔라루멘","slug":"스텔라루멘","permalink":"http://KKimSangHeon.github.io/tags/스텔라루멘/"},{"name":"리플","slug":"리플","permalink":"http://KKimSangHeon.github.io/tags/리플/"},{"name":"스테이터스네트워크","slug":"스테이터스네트워크","permalink":"http://KKimSangHeon.github.io/tags/스테이터스네트워크/"}]},{"title":"3장. 타입스크립트","slug":"angular2","date":"2018-01-07T05:05:28.000Z","updated":"2018-09-03T05:58:30.562Z","comments":true,"path":"2018/01/07/angular2/","link":"","permalink":"http://KKimSangHeon.github.io/2018/01/07/angular2/","excerpt":"","text":"위의 책을 공부하며 정리하는 포스트이다. AngularJS디렉티브HTML 태그나 어트리뷰트의 기능을 새롭게 만드는 개념. 애플리케이션의 요구 사항에 맞게 HTML 태그를 확장할 수 있다. ng-app&lt;div&gt;에 ng-app 어트리뷰트를 추가하면 그 &lt;div&gt;만 AngularJS의 영향을 받는다. 바인딩뷰와 모델이 서로를 갱신하는것. AngularJS는 모델이 갱신될 때마다 전체 애플리케이션에 영향을 미치는 $digest 함수를 실행하면서 데이터 바인딩을 점검하고 DOM 객체의 값을 갱신한다. socpe모델의 값은 $scope라는 스코프 안에 선언되며 AngularJS에서는 이 스코프를 여러 계층으로 구성한다. AngularNgModule모듈은 클래스에 @NgModule 어노테이션을 붙여서 지정하고 이 어노테이션 안에서 모듈 내용을 설정한다. SystemJS 모듈로더JS는 script 태그 안에서 로드하고 실행하지만 Angular도 이 방법을 사용할 수 있지만 SystemJS 라이브러리를 사용해서 불러오는것을 권장한다.why? 스크립트 태그를 삭제하지 않으면 이를 불러오려고 하고 불필요한 부하 발생 , 스크립트 태그의 실행순서를 보장하지 않기 때문에 문제가 될 수 있다. environment.ts 파일 -&gt; 빌드를 위한 개발환경 설정 정보들 빌드명령어Angular-CLI로 만들어진 프로젝트의 코드는 타입스크립트 기반이기 때문에 빌드를 통해 브라우저에서 동작 가능한 자바스크립트로 변환해야 한다. ng build 프로덕션용 빌드 명령어ng build –prod 3장 타입스크립트1.let을 이용한 변수선언ES 5 이하에서 호이스팅 문제가 발생하므로 이를 해결하기 위해 ES6의 좋은 특징인 let 선언자를 이용 타입스크립트는 변수명 뒤에 타입을 명시해야 한다. 타입스크립트를 타입 언어라고 하는 이유는 이와 같은 이유이다.let 변수명 : 타입;let emotion2:string=”happy”; 배열타입배열정의 형태1let fruits: string[] = [“a”,”b”]; let fruits2: string[] = [];fruits2.push(“a”); 배열정의 형태2let num:Array = [1,2,3]; 유니언 타입 56p유니언 타입은 2개 이상으로 입력된 타입에 대해 하나의 타입으로 정의하는것. 메소드의 파라미터로 사용가능.var unionX: string | number = 1;console.log(typeof unionX, unionX); // number 1 출력 문자열 표현 58p+와 \\n을 써서 줄바꿈이 가능하지만 다음과 같이 가능하다.let w: string =”world”;let one: number = 1;function hi(){ return “hi”;} let hello_message: string =hello ${w} 1 + ${one} = ${1+1} ${hi()}console.log(hello_message); 디스트럭처링 지원 60pES6에 포함된 특징으로 배열이나 객체에서 데이터를 선택적으로 추출할 수 있는 자바스크립트 할당식이다.var params2 = [‘happy 동물원’, 100];let[m_name2, m_num2] = params2;","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Angular2","slug":"Web-App/Angular2","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Angular2/"}],"tags":[{"name":"Angular2","slug":"Angular2","permalink":"http://KKimSangHeon.github.io/tags/Angular2/"}]},{"title":"ABLETHON 참가","slug":"ablethon","date":"2017-10-17T05:05:28.000Z","updated":"2017-11-12T12:48:28.999Z","comments":true,"path":"2017/10/17/ablethon/","link":"","permalink":"http://KKimSangHeon.github.io/2017/10/17/ablethon/","excerpt":"","text":"ABLETHON 참가 시각장애인의 App 사용에 관심이 많아 관련 공모전을 알아보던 중 에이블톤이 눈에 띄어 참가하게 되었다. 지도에서 붉은 부분은 저소득층 국가가 많으며 이에 해당하는 국가의 시각장애인은 안드로이드의 talkback 기능을 많이 이용하고 있으며, 상대적으로 소득이 높은 파랑색 국가의 시각장애인은 아이폰에서 제공하는 voiceover 기능을 많이 이용하고 있다. 안드로이드는 자체적으로 아이폰의 voiceover와 같은 기능을 제공하지 않기 때문에 아이폰에 비해 상대적으로 낮은 접근성을 갖는다. 우리팀은 이를 해결하고자 안드로이드 앱 개발을 하기로 결정하였다. 시연영상 날씨조회기능 버스도착정보 조회기능 전화기능 길 안내기능 길 안내 도움요청기능 수상 많은 분들이 좋게 봐준 덕분에 우수상을 받을 수 있었다. 소스코드 (Github Repository)-안드로이드 어플리케이션 소스코드","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"ABLETHON","slug":"ABLETHON","permalink":"http://KKimSangHeon.github.io/tags/ABLETHON/"},{"name":"시각장애인도 이용가능한 App","slug":"시각장애인도-이용가능한-App","permalink":"http://KKimSangHeon.github.io/tags/시각장애인도-이용가능한-App/"}]},{"title":"4.모듈","slug":"python4","date":"2017-10-10T06:11:53.000Z","updated":"2018-09-03T05:58:11.517Z","comments":true,"path":"2017/10/10/python4/","link":"","permalink":"http://KKimSangHeon.github.io/2017/10/10/python4/","excerpt":"","text":"파이썬 모듈이란? 1) 파이썬 프로그램 파일로 따로 함수나 변수를 정의한다.2) 모듈안에는 어떤 코드도 작성 가능하다.(함수, 클래스, 변수등)3) 다른 모듈에 의해서 호출되고 사용된다.4) 표준모듈, 사용자 생성 모듈, 서드 파티 모듈 등으로 나눌 수 있다. 추 후 추가예정…","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Python","slug":"Language/Python","permalink":"http://KKimSangHeon.github.io/categories/Language/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://KKimSangHeon.github.io/tags/Python/"}]},{"title":"인천~부산 국토종주","slug":"riding1","date":"2017-10-06T07:51:55.000Z","updated":"2017-10-06T11:14:44.985Z","comments":true,"path":"2017/10/06/riding1/","link":"","permalink":"http://KKimSangHeon.github.io/2017/10/06/riding1/","excerpt":"","text":"오래전부터 버킷리스트였던 국토종주를 완료하였다. 4박5일의 기간동안 혼자 고군분투하며 유일한 친구 네이버 지도와 함께했던 기억.. 잊지않기 위해 사진위주로 정리해본다. 출발전 필요한 짐만 챙겼는데도 불구하고 뒤의 가방의 무게가 상당하다.. 약 8kg정도 되는것 같다. 1일차 5월3일인천아라뱃길 ~ 여주보 오전 7시 부천에서 출발해서 아라뱃길로 가기위해서는 굴포천을 통과해야한다. 가는 도중에 만났던 2마리의 개님들.. 나를 반겨주길래 사진찍으려 하니 도망가버린다. 귀여워서 뒷모습이라도 찍었다.. 조금 더 가다보니 이번엔 오리?를 만나게 되었다. 꽥꽥거리는게 기여워서 한컷찍었다. 참새는 짹짹.. 부천, 인천을 거쳐 드디어 한강에 도착했다. 날씨가 좋아서 달리기 좋았는지 찍은사진은 이것뿐이다.. 꽉찬 헬멧이 보기좋다.. 한강을 달리고 달려 한강의 거의 끝지점인 팔당대교에 도착했다. 편의점에서 파워에이드와 스니커즈를 사먹었다.. 군대이후로 스니커즈가 이렇게 맛있는건 처음이었다.. 조금 더 가니 팔당댐에 도착하였다. 팔당댐 옆에는 터널이 있었다. 들어가면 추울정도로 시원했다. 터널을 나와 달리다 보니 철길이 등장하였다. 아직까진 힘들진 않았지만 어릴때부터 이유없이 철길을 좋아했던 나는 여기서 잠깐 쉬어갔다. 아무생각없이 달리다보니 양평에 도착하였다.! MT의 장소로서 기차로만 갈 수있다고 생각한 곳을 자전거타고 오니 새로웠다. 이제 폐 철길을 개조한 자전거길이 펼쳐졌다. 지나갈때마다 드르륵 거리는게 뭔가 듣기 좋았다. 철길을 지나니 아트터널이 등장하였다. 역시 용담 아트터널이다. 형형색색의화려한 불빛들이나를 반겨준다.. 갓트터널..4박5일간 일정중 여기가 제일 최고였던것 같다.이 후 양평을 지나 7시쯤 여주에 도착하여 인근 모텔에서 치킨을 먹고 기절했다. 친절한 모텔주인 아저씨는 익숙한듯이 자전거를 방까지 옮겨다 주셨던게 인상깊었다. 2일차 5월 4일강천보 ~ 문경 불정역 숙소에서 6시반에 출발하여 자전거 도로로 진입했을 때가 6시 50분쯤이었다. 해가 뜨기 시작하고 물안개가 이뻣었다. 상쾌한 공기가 좋긴했지만 전날의 휴유증으로 엉덩이, 허벅지, 등, 종아리 아프지 않은곳이 없었다. 비상용으로 사간 타이레놀을 먹을까 고민했지만 몸을 생각해서 몸을 혹사시켰다?. 많은 분들의 국토종주 후기를 보면 이 구간이 등장한다. 나 또한 사진을 찍어보았다. 자전거에 내려서 가라는 의미로 장애물을 설치해 두었을 것이다. 자전거를 끌고가도 자전거를 제어하기 힘든 경사구간이었다.. 사진을 찍은 부분이 경사진 구간이라 자전거에서 내려 걸어가고 있는데 뒤에서 50대 정도로 보이는 동호회분들께서 앞질러 나가셨다.. 그리고는 사진속의 경사진 구간도 낙오자 없이 통과하셨다.. 체력좀 많이 길러야겠다고 뼈저리게 느꼈다.(나는 가방무게 때문에 힘든거였을거야) 해가 뜨고 그림자가 진 모습이 이뻐보여서 찍었다. 문득 어제 먹은 양념반 후라이드 반의 치킨이 생각났다.. 열심히 달리다 보니 앞서나간 분들을 따라잡았지만 빠르게 멀어져갔다… 아침이라 그런지 힘들어서 그런지는 모르겠지만 많이 힘들어보인다. 조금 더 가니 아름다운 충북, 도민이 행복한 충북에 도착하였다. 출발 전 후기들을 통해 접했던 죽음의 구간인 백두대간이화령의 시작점이다. 이름부터가 “넌 못올라 올껄?” 이라는 느낌이 뿜어져 나온다. 역시나 나는 걸어서 올라가고 있고 외국인 커플이 가볍게 날 앞질러 나간다. 자전거에서 내려서 열심히 올라가던준 반사경이 있어 내모습을 담아봤다.. 많이 올라왔다. 금방끝나겠지 라는 생각으로 열심히 페달을.. 아니 걸었다. 금방 끝날것이라는 나의 경기도 오산 아래 경치를 잠깐 즐기며 사진을 찍었다. 역시 경기도 오산은 오산이었다. 이런 언덕이 끝도없이 펼쳐진다. 한시간이면 끝날줄 알았지만 끝이없다.. 정말 많이 올라왔다. 날씨가 선선해서 다행이었다.. 여름이였으면 큰일날 뻔 했다. 땀으로 머리가 다 젖었다.. 하루사이에 살이 빠졌는지 턱끈이 느슨해졌다..ㅋㅋㅋㅋㅋ 드디어 이화령을 정복했다.. 이틀차에 맛본 지옥이었다. 친구로 보이는 50대 아저씨 두분께 사진을 부탁하여 사진을 찍었다.. 국토종주를 하다보면 젊은사람보다 50대 60대 분들이 더 많은것 같다. 4시간 가량 걸어서 올라간 거리를 자전거 타고 15분만에 내려왔다. 뭔가 힘들게 완성한 도미노를 무너뜨리는것만큼 시원하고 쾌감이 넘쳤다. 자전거 도로를 따라 달리다 보니 폭포가 등장하였다. 처음보는 폭포가 신기해서 찍어보았다. 조금 더 가니 불정역에 도착하였다. 불정역에는 이화령에서 사진찍어주신 두분이 계셨다. 인사를 건네고 이런저런 이야기를 나누었다. 혼자온것에 대해 칭찬과 격려를 많이 해주셔서 힘이 많이 났었다. 불정역에는 저런 기차도 있었다. 도착시간이 늦어서 들어가보지는 못하였다. 불정역에서 숙소로 출발하여 도착 후 짐을 내팽겨치고 간단하게 밥을 먹고 8시쯤 잠에들었다. 3일차 5월5일문경불정역 ~ 강정 고령보 마찬가지로 6시쯤 출발하였다. 처음부터 만난 오르막에 당황하였지만 이번에는 끝까지 잘 타고 올라왔다. 오르막의 끝에선 지쳐 내가 올라온 오르막을 감상하며 휴식을 취해주었다. 반사경이 있어서 사진을 한번 더 찍어주었다. 반사경 작가미상의 벽화?가 눈에 띈다. 3일차는 지루했다고 느낀점이 자전거 도로는 좋으나 이런 길이 쭉 반복이다.. 이날은 오후3시부터 6시까지 비가 많이왔다.. 우비를 입을까 하다 걸리적거릴까 입지는 않고 살기위해 달렸다. 덕분에 덥지는 않았으나 많이 찝찝했던 기억이 난다. 비로인해 더이상 찍은 사진이 존재하지 않는다.. 근처 여관에 도착하여 이날도 7시쯤 일정을 마무리하고 잠에 들었다. 4일차 5월6일강정고령보 ~ 양산물문화관 갈대가 이뻐보여서 사진을 찍었다. 신세계의 이중구의 대사가 생각나기도 한 구간이었다.찍을때는 몰랐는데 허벅지가 많이 탄 것을 사진을 통해 알수있다.. 또 다시 길의 반복바로옆에 낙동강이 있는데 역풍으로 인해 페달밟기가 매우 힘들었다. 길을 반복하다 만나게된 고라니다.. 정말 빠르다.. 나도모르게 감탄사가 나왔다. 또 다시 길의 반복 이화령의 두려움이 채 가시기도 전에 산이 등장하였다. 그나마 이화령보다는 수월하고 구간도 그나마 짧았었다. 잠깐 휴식시간에 경치를 찍어보았다. 이번에는 소를 만났다.. 신기해서 찍어보았다.. 해가 점점 저물어간다. 사진을 찍은 시간이 6시반. 밀양이었다. 앞만 보다 위를 한번보니 구름이 신기했다. 두 마리의 새가 싸우는 형상을 하고 있었고 반대편에는 천사가 날개짓 하는 구름이 있었다.. 이건 약간 억지같긴 하다.. 길을 따라가다 만난 가족이다. 아버지, 딸(첫째),아들(둘째) 로 추정되는데 아버지는 킥보드 딸은 MTB, 아들은 미니벨로를 타고있었다. 아버지는 가벼운 몸을 이끌고 저 멀리가고있었고 남매는 옥신각신하며 달리고 있었다. 남매가 매우 귀여웠고 아버지가 남매를 강력하게 키우는 것이 인상깊었다. 간식이라도 줄걸그랬다.. 마지막 종점인 부산 낙동강 하굿둑까지 약 50KM남은 곳에서 휴식을 취했다. 5일차 5월 7일양산 물문화관 ~ 부산 낙동강 하굿둑대망의 마지막날 아침 7시에 출발하여 갈대밭을 지나 마지막이라 생각하니 페달이 더욱 무겁게 느껴졌다.. 혼자오신 아저씨께 사진을 부탁하고 여기서도 찍어야 된다며 강제로 한장을 더 찍어주셨다. 참 감사했다.역시나 인천에서 출발한점에 대해 칭찬을 많이해주셨다. 기념촬영 후 인증센터에 들어가 금뱃지를 받고 메달을 신청하였다.이로서 4박5일간의 국토종주는 끝났고 부산 터미널의 모텔에서 4시간 정도 휴식을 취하다 버스를 타고 부천으로 올라왔다. 그리고 얼마지나지 않아 어김없이 찾아온 국가의 부름 하하하하 또 얼마지나지 않아 인증메달과 인증서가 도착하였다. 인상깊었던점 맞은편에서 달려오는 사람들의 안녕하세요, 수고하세요 라는 인사말은 참 많은 힘이되었던것 같다. 가는 방향도 다른 1초의 인연이지만 서로 힘내자는 무언의 메세지가 느껴졌다. 4박5일의 짧은 기간이었지만 많은 사람들의 따듯함을 느낄수 있었다. 그 분들의 말 한마디 한마디가 힘을 낼 수있는 좋은 원동력이었고 그 덕분에 탈 없이 완주할 수 있었던것 같다. 그리고 가장 인상깊었던 사건이 하나 있다. 자전거 길이 쭉 나있는 저멀리서 내 또래로 보이는 사람이 휠체어를 끌고 걸어오고 있었다. 휠체어엔 그 누구도 타고있지 않아 멀리서부터 궁금증을 유발하였다. 멀쩡한 내 또래가 왜 휠체어를 끌고오지라는 궁금증을 갖고 점점 맞은편의 휠체어와 가까워 졌을 때 뭉클함을 느끼지 않을 수 없었다. 아버지로 추정되는 사진이 휠체어 위에 올려져있었다. 그 친구의 말못할 사정을 알지는 못하지만 정말 착하구나라는 생각과 동시에 나를 돌아볼 수 있었던 기회가 되었던것 같다. 후기 우선 내 오랜 버킷리스트를 완료한것에 대해 뿌듯했고 시간이 된다면 긴 기간동안 경치를 즐기며 다시한번 도전하고 싶다. 이번에는 완주를 목표로 주변 경치를 즐기지 못한것이 매우 아쉬웠다. 4박5일이라는 기간동안 많은 것을 배우고 느낄 수 있었던 좋은 기회였으며 나 자신에 대해 다시한번 평가할 수 있었던 좋은기회였던것 같다.","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"Travel","slug":"About-Me/Travel","permalink":"http://KKimSangHeon.github.io/categories/About-Me/Travel/"}],"tags":[{"name":"국토종주","slug":"국토종주","permalink":"http://KKimSangHeon.github.io/tags/국토종주/"}]},{"title":"Spring 기반 그룹웨어 개발","slug":"groupware","date":"2017-10-03T17:55:55.000Z","updated":"2017-11-09T02:45:23.750Z","comments":true,"path":"2017/10/04/groupware/","link":"","permalink":"http://KKimSangHeon.github.io/2017/10/04/groupware/","excerpt":"","text":"그룹웨어 개발그룹웨어는 회원가입, 로그인, 게시판, 일정관리, 사원조회, 쪽지, 마이페이지 기능을 갖고있다. ERD 그룹웨어에서 사용하는 ERD는 위과 같다. 보안그룹웨어 내의 모든 페이지이동은 INTERCEPTOR을 활용하여 페이지 이동 전 권한을 확인한다. 로그인하지 않은 회원이 URL로 페이지 이동을 할 경우 다음과 같은 화면이 출력된다. 회원가입그룹웨어를 이용하기 위해서는 회원가입을 거쳐야 한다. 회원가입 후 관리자의 승인 후 로그인이 가능하다.위의 화면에서 회원가입 버튼을 누르면 다음과 같은 폼이 출력된다. 정보를 입력하고 가입 요청하기 버튼을 클릭하자. 정상적으로 가입이 완료되면 다음과 같은 화면이 출력된다. 해당 아이디로 로그인이 불가능하나 관리자의 승인 후 로그인이 가능해진다. 승인되지 않은 아이디로 로그인 할 경우 위와 같은 화면이 출력된다. 관리자의 가입 승인사전에 지정해 놓은 아이디로 로그인 하여 관리자 화면에 접속하고 신규 가입한 회원에 한해 승인을 해줄 수 있다. 관리자 계정으로 로그인을 할 경우 우측 상단에 관리페이지가 출력된다. 이는 EMPLOYEE 테이블의 ROLE 컬럼값을 통해 판단한다. ROLE컬럼의 값은 USER, ADMIN으로 나뉜다. 관리자가 아님에도 불구하고 URL로 관리자 페이지로 접속할 경우 다음과 같은 화면이 출력된다. 다시 돌아와서 관리자가 로그인을 하고 우측상단의 관리페이지를 접속할 경우 다음과 같은 화면이 출력된다. 관지자는 가입 승인하기 버튼을 클릭하여 가입승인을 할 수 있다. 이후 해당 사용자는 로그인이 가능해진다. 가입승인 버튼을 누를 경우 alert창이 생성되며 가입이 승인된다. 로그인이전에 생성한 아이디로 로그인을 진행하자. 위와 같이 로그인이 되었다. 게시판게시판은 공지사항, 자유게시판, 팀 게시판이 존재한다.게시판 테이블(BOARD)에는 BOARD_AUTHORITY, IS_TEAM 컬럼이 존재하는데 BOARD_AUTHORITY는 글쓰기 권한을 의미한다. 해당 게시판의 BOARD_AUTHORITY가 3일경우 POSITION_ID가 3(전무) 이상인 회원만 게시물 작성이 가능하다.IS_TEAM 컬럼은 팀게시판 유무이며 TEAM_ID가 같은 즉 같은팀이 작성한 글만 볼 수 있도록 하는 역할이다. 조금전 가입한 에두는 직급이 사원(POSITION_ID = 10)이므로 공지사항 게시판에 글쓰기 버튼이 나타나지 않는다. 자유게시판에는 글씨기 버튼이 나타나며 글 작성이 가능하다.글 쓰기 버튼을 누를 경우 다음과 같은 화면이 출력된다. 위와 같이 글을 작성하는 폼을 통해 글작성이 가능하다. 글을 작성하게되면 게시판으로 돌아오며 위와같이 출력된다. 해당 글을 클릭하여 위와같이 자세히 볼 수 있으며 자신의 글인경우 삭제하기 버튼이 보인다. 일정관리자신의 일정을 추가하여 관리할 수 있는 페이지이다. full callendar 라는 오픈소스를 사용하여 구현하였다. 위와같이 일정등록이 가능하다 일정을 등록하게 되면 위와 같이 일정이 달력에 표시된다. 여러개의 일정을 등록할 경우 다음과같이 한눈에 파악이 가능하다. 사원조회모든 사원의 조회가 가능한 페이지이다. jqgrid라는 오픈소스를 활용하였다.디폴트로 전체 사원이 검색된다. 또한 메세지 보내기 버튼을 통해 메세지 전송이 가능하다. 팀명 또는 이름으로 조회가 가능하며 위는 팀명으로만 조회한 경우이다. 위는 김상헌을 조회한 경우이다. 메세지 보내기 버튼을 누르면 위와 같은 팝업창이 생성된다. 위와 같이 메세지를 입력후 전송하기 버튼을 누르면 메세지가 전송된다. 쪽지김상헌의 계정으로 로그인하여 쪽지 탭으로 들어갈 경우 다음과 같이 화면이 출력된다.글자수가 23자 이상일 경우 …이 붙게되며 내용이 생략된다.해당 메세지를 눌러 자세한 내용을 확인할 수 있으며 답장버튼을 눌러 답장할 수 있으며, 삭제 또한 가능하다. 위와 같이 쪽지의 내용이 자세히 보인다. 답장 버튼을 누를 경우 위와같이 화면이 출력되며 답장이 가능하다. 위와 같이 답장을 보내고 에두의 계정으로 로그인 할 경우 위와 같이 메세지가 온 것을 확인할 수 있다. 마이페이지개인정보를 수정할 수 있는 마이페이지이다.사번, 소속, 직급은 수정 불가능하며 비밀번호, 사진, 이름, 이메일이 수정가능하다.비밀번호를 제외한 모든 데이터는 마이페이지에 접속할 경우 입력되어 있다. 소스코드 (Github Repository)github Repository","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"Spring Framework","slug":"Spring-Framework","permalink":"http://KKimSangHeon.github.io/tags/Spring-Framework/"},{"name":"Java Script","slug":"Java-Script","permalink":"http://KKimSangHeon.github.io/tags/Java-Script/"},{"name":"JQgrid","slug":"JQgrid","permalink":"http://KKimSangHeon.github.io/tags/JQgrid/"},{"name":"fullcallendar","slug":"fullcallendar","permalink":"http://KKimSangHeon.github.io/tags/fullcallendar/"}]},{"title":"3. 리스트","slug":"python3","date":"2017-09-29T02:30:31.000Z","updated":"2018-09-03T05:58:04.920Z","comments":true,"path":"2017/09/29/python3/","link":"","permalink":"http://KKimSangHeon.github.io/2017/09/29/python3/","excerpt":"","text":"리스트순서를 가지는 객체들의 집합, 파이썬 자료형들 중에서 가장 많이 사용한다.시퀀스 자료형이기 때문에 시퀀스의 연산(인덱싱, 슬라이싱, 연결(+), 반복(*), len(), in, not in) 등의 연산이 가능하다. 특히, list는 del() 함수를 통한 삭제도 가능하다. PythonExam.pi12345678910111213141516171819202122232425262728293031323334l = [1, 2, 'python']print(l[-2], l[-1], l[0], l[1], l[2])print(l[1:3])print(l * 2)print(l + [3, 4, 5])print(len(l))print(2 in l)del l[0]print(l)리스트는 변경 가능(Mutable)한 자료형이다.a = ['apple', 'banana', 10, 20]a[2] = a[2] + 90print(a)슬라이스를 통한 치환a = [1, 12, 123, 1234]a[0:2] = [10, 20]print(a)a[0:2] = [10]print(a)a[1:2] = [20]print(a)a[2:3] = [30]print(a)","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Python","slug":"Language/Python","permalink":"http://KKimSangHeon.github.io/categories/Language/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://KKimSangHeon.github.io/tags/Python/"}]},{"title":"2. 제어문","slug":"python2","date":"2017-09-29T02:24:02.000Z","updated":"2018-09-03T05:58:01.829Z","comments":true,"path":"2017/09/29/python2/","link":"","permalink":"http://KKimSangHeon.github.io/2017/09/29/python2/","excerpt":"","text":"If문PythonExam.pi123456789101112131415161718192021222324252627a = 10if a &gt; 5: print(\"big\")else: print(\"small\")n = -2if n &gt; 0: print('양수')elif n &lt; 0: print('음수')else: print('0')order = 'spam'if order == 'spam': price = 1000elif order == 'egg': price = 500elif order == 'spagetti': price = 2000else: price = 0print(price) For문 PythonExam.pi123456789a = ['cat', 'cow', 'tiger']for animal in a: print(animal)for x in range(10): print(x, end=\" \") while문PythonExam.pi123456count = 1while count &lt; 11: print(count, end=' ') count += 1else: print('') break, continue, elsePythonExam.pi123456789101112131415161718192021i = 0while i &lt; 10: i += 1 if i &lt; 5: continue print(i, end=' ') if i &gt; 10: breakelse: print('else block')print('done')i = 0while True: print(i) if i &gt; 5: break i += 1","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Python","slug":"Language/Python","permalink":"http://KKimSangHeon.github.io/categories/Language/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://KKimSangHeon.github.io/tags/Python/"}]},{"title":"1. 변수명과 예약어","slug":"python","date":"2017-09-27T04:43:58.000Z","updated":"2018-09-03T05:57:58.015Z","comments":true,"path":"2017/09/27/python/","link":"","permalink":"http://KKimSangHeon.github.io/2017/09/27/python/","excerpt":"","text":"소개1991년 귀도 반 로섬( Guido van Rossum ) 이 발표한 인터프리터 언어귀도가 구글에 입사하고 구글의 3대 개발언어 중 하나로 채택되면서 유명세를 탔다. 특징대화 기능의 인터프리터 언어동적타이핑(동적인 데이터 타입 결정 지원)플랫폼 독립적 언어(Unix, Linux, Window9x/NT 계열, DOS, OS/2, Mac OS, Nokia 등) 간단하고 쉬운 문법가독성( 코드블러의 들여쓰기 구분 )비교적 짧은 개발 시간고수준의 내장 객체 자료형 제공(List, Dictionary, String, Turple 등의 자료구조)메모리 자동 관리무료(비영리의 파이썬 소프트웨어 재단이 관리하는 개방형, 공동체 기반 개발 모델)많은 수의 풍부한 라이브러리 제공높은 확장성(접착성, Glue Language)유니코드 파이선의 종류CpythonC로 작성된 파이썬 인터프리터 JythonJava로 작성된 파이썬 인터프리터 IronPython.Net 플랫폼 용 파이썬 인터프리터, C#으로 구현 PyPy파이썬으로 작성된 파이썬 인터프리터 PythonExam.pi12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364가장 바깥쪽에 있는 블록의 코드는 1열부터 시작해야 한다.&gt;&gt;&gt; a=1&gt;&gt;&gt; a=1SyntaxError: unexpected indent내부 블록은 같은 거리만큼 들여 쓰기를 해야 한다.&gt;&gt;&gt; if( a &gt; 1 ): print( \"big\" ) print( \"really?\" )SyntaxError: unexpected indentfrom __future__ import print_function# -*- coding: utf-8 -*-# 치환문의 예a = 1b = a + 1print(a , b, sep=',')# 여러 변수를 한번에 치환e, f =3, 7print(e ,f )# 하나의 값을 여러 변수에 할당x = y = z = 1# 값 교환f, e = e, fprint(e, f)# 동적 타이핑a = 1print(type(a))a = 'hell'print(type(a))# -*- coding: utf-8 -*-import keyword# 변수 이름은 문자, 숫자, _ 로 구성해야 한다.friend = 1a = 10my_name = '김상헌'_yourName = '둘리'member1 = '도우넛'# 에러# $friend = 2# a! = 1# 1abc = 10# 에러: 예약어는 사용할 수 없다.# def = 10print(keyword.kwlist)# 한글 이름의 변수도 가능하다.가격1 = 2000print(가격1 - 200) 파이썬 변수 이름 규칙1)문자(유니코드), 숫자, 밑줄(_)로 구성2)숫자는 처음에 올 수 없다.3)대소문자 구분4)예약어 사용 불가5)함수 이름, 클래스 이름도 같은 규칙이 적용된다.PythonExam.pi123456789101112131415161718192021222324252627282930313233343536373839# 참이나 거짓을 나타내는 True, False 두 상수를 갖는다a = 1b = a &lt; 10print(b,type(b),sep=\",\")b1 = Trueb2 = Falseprint(b1 + 10)print(b2 + 10)print(True + True )if a &lt; 10: print(a)a = 23print(type(a))print(isinstance(a,int))print(isinstance(a,bool))b = 0b1101c = 0o23d = 0x23print(a, b, c, d, sep=' ')# 3.x 에서는 int 와 long이 합쳐졌다# 따라서 표현 범위가 굉장히 크다e = 2 ** 1024print(e)print(type(e))# 변환 함수print(oct(38))print(hex(38))print(bin(38))","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Python","slug":"Language/Python","permalink":"http://KKimSangHeon.github.io/categories/Language/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://KKimSangHeon.github.io/tags/Python/"}]},{"title":"13. Logging, IoC / DI","slug":"spring5","date":"2017-09-18T00:26:03.000Z","updated":"2018-09-03T05:57:42.527Z","comments":true,"path":"2017/09/18/spring5/","link":"","permalink":"http://KKimSangHeon.github.io/2017/09/18/spring5/","excerpt":"","text":"로깅이란?-비 기능적 요구사항 ( Non Functional Requirement )하지만, 프로그램 개발 중 디버깅 및 개발완료 후 문제점 추적 및 분석을 위해 필수적으로 갖추어야 할 요구 조건,로그(Log) 는 프로그램 개발이나 운영 시 발생하는 문제점을 추적 하거나 운영 상태를 모니터링 하는 정보,로깅(logging)이란 로그(log)를 생성하도록 시스템을 작성하는 활동-얻을 수 있는 것1.재현하기 힘든 ( 테스트 환경이 아닌 개발 완료된 환경에서 발생하는 ) 버그에 대한 유용한 정보를 제공2.성능에 관한 통계와 정보를 제공할 수 있다. Inversion of Control( 제어역전 ) 이란 프로그램 코드 내에서 참조하려는 객체를 직접 생성 하지 않고 외부의 다른 존재가 생성하여 제공한다는 개념외부의 다른 존재(객체) 를 Container 라고 하며 IoC 오브젝트 또는 IoC Container 라고 한다","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Spring","slug":"Web-App/Spring","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://KKimSangHeon.github.io/tags/Spring/"}]},{"title":"12.AOP","slug":"spring4","date":"2017-09-15T00:11:03.000Z","updated":"2018-09-03T05:57:39.651Z","comments":true,"path":"2017/09/15/spring4/","link":"","permalink":"http://KKimSangHeon.github.io/2017/09/15/spring4/","excerpt":"","text":"AOP 개요(A)spect (O)riented (P)rogramming : 관점 지향 프로그래밍가장 기초가 되는 개념은 관심의 분리(Separation of Concern)AOP는 OOP를 수정하는 것이라 보면 된다.가장 기초가 되는 개념은 관심의 분리(Separation of Concern)1.핵심관심 : 시스템의 핵심 가치와 목적이 그대로 드러난 관심영역 2.횡단관심: 핵심관심 전반에 걸쳐 반복적으로 나오게 되는 로깅, 트랜잭션, 보안, 인증, 리소스 풀링, 에러체크 등의 관심영역 3.관심의 분리: 여러 핵심관심에 걸쳐 등장하는 횡단관심을 분리하여 독립적인 모듈로 만들고 핵심관심이 실행되는 동안 횡단관심을 호출하는 코드를 직접 명시하지 않고 선언적으로 처리 4.핵심관심 모듈의 중간중간에서 필요한 횡단관심 모듈을 직접 호출하지 않고 위빙(Weaving)이라 불리는 작업을 이용하여 횡단관심 코드가 삽입되도록 만든다. 5.핵심관심모듈에서는 횡단관심모듈이 무엇인지 조차 인식할 필요가 없음 AOP의 구성요소1) JoinPoint(언제)-횡단관심모듈은 코드의 아무 때나 삽입이 되는 건 아니다.-조인포인트라 불리는 특정 시점에서만 삽입이 가능하다. 2) PointCut (어디에서)-어느 조인포인트에 횡단관심모듈을 삽입할지를 결정하는 기능-횡단관심이 삽입될 특정 클래스의 특정 메소드를 선택하는 방법 정의 3) Advice(or Interceptor, 무엇을 )횡단관심모듈(로깅, 보안, 트랜잭션 등) 4) Weaving(위빙)-어드바이스(횡단관심)를 삽입하는 과정-위빙작업이 일어나는 시간컴파일 시 - 특별한 컴파일러 필요클래스 로딩시 - 특별한 클래스로더 필요런타임시 - 프록시를 이용한 방법(스프링) ####실습project 생성 - new maven project - 다음 - quick start 다음 - 그룹ID:com.bigdata2017 / 아티클아이디:aoptest 프로젝트 우클릭 - 프로퍼티스- 자바빌드패스 - JRE 수정프로젝트 우클릭 - 프로퍼티스- project facets - Runtimes탭 - jre 선택 후 어플라이 아래와 같이 수정pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.bigdata2017&lt;/groupId&gt; &lt;artifactId&gt;aoptest&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;aoptest&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;org.springframework-version&gt;4.1.1.RELEASE&lt;/org.springframework-version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- spring context --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring aspect --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 프로젝트 우클릭- 뉴 - 소스폴더 -src/main/resource생성된 소스폴더안에 config패키지 추가패키지 안에 applicationContext.xml applicationContext.xml123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- AOP AutoProxy --&gt; &lt;aop:aspectj-autoproxy /&gt; &lt;context:annotation-config /&gt; &lt;context:component-scan base-package=\"com.bigdata2017.aoptest\"&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Repository\" /&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Service\" /&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Component\" /&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; App.java에 입력 App.java123456789101112131415161718package com.bigdata2017.aoptest;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123; public static void main( String[] args )&#123; ApplicationContext ac = new ClassPathXmlApplicationContext(\"config/applicationContext.xml\"); ProductService ps = ac.getBean( ProductService.class ); ProductVo vo = ps.find( \"camera\" ); //System.out.println( vo ); &#125;&#125; ProductService.java 생성 pom.xml123456789101112131415161718package com.bigdata2017.aoptest;import org.springframework.stereotype.Service;@Servicepublic class ProductService &#123; public ProductVo find( String keyword ) &#123; System.out.println(\"finding....\");// if( 1 == 2-1 ) &#123;// throw new RuntimeException( \"exceptionoccrs\" );// &#125; return new ProductVo( keyword ); &#125;&#125; ProductVo생성 ProductVo.java123456789101112131415161718192021222324package com.bigdata2017.aoptest;public class ProductVo &#123; private String name; public ProductVo( String name ) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return \"ProductVo [name=\" + name + \"]\"; &#125;&#125; MyAspect생성MyAspect.java123456789101112131415161718192021222324252627282930313233343536package com.bigdata2017.aoptest;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.AfterThrowing;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.springframework.stereotype.Component;@Aspect@Componentpublic class MyAspect &#123; @Before( \"execution(public ProductVo com.bigdata2017.aoptest.ProductService.find(..))\" ) public void beforeAdvice() &#123; System.out.println( \"beforeAdvice() called\" ); &#125; @After( \"execution(* com.bigdata2017.aoptest.*.find(..))\" ) public void afterAdvice() &#123; System.out.println( \"afterAdvice() called\" ); &#125; @AfterReturning( \"execution(* *..ProductService.find(..))\" ) public void afterReturning() &#123; System.out.println( \"afterReturning() called\" ); &#125; @AfterThrowing( value=\"execution(* *..*.*(..))\", throwing=\"ex\" ) public void afterThrowing( Throwable ex ) &#123; System.out.println( \"afterThrowing() called:\" + ex ); &#125;&#125;","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Spring","slug":"Web-App/Spring","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://KKimSangHeon.github.io/tags/Spring/"}]},{"title":"11.Spring. annotation의 활용","slug":"spring3","date":"2017-09-11T00:15:08.000Z","updated":"2018-09-03T05:57:32.943Z","comments":true,"path":"2017/09/11/spring3/","link":"","permalink":"http://KKimSangHeon.github.io/2017/09/11/spring3/","excerpt":"","text":"-JDBC를 통해 DB를 사용하려면, Connection 타입의 DB 연결 객체가 필요하다.-엔터프라이즈 환경에서는 각 요청마다 Connection을 새롭게 만들고 종료시킨다.-애플리케이션과 DB사이의 실제 커넥션을 매번 새롭게 만드는 것은 비효율적이고 성능저하-풀링(pooling) 기법 사용 정해진 개수의 DB Connection Pool에 준비하고 애플리케이션 요청때 마다 꺼내서 할당하고 돌려받아 pool에 저장. -Spring에서는 DataSource를 하나의 독립된 빈으로 등록하도록 강력하게 권장. -엔터프라이즈 시스템에서는 반드시 DB 연결 풀 기능을 지원하는 DataSource를 사용해야 한다. 요약쿼리를 보내는것보다 연결하는데 더 많은 자원이 사용된다. 그래서 사용한는것이 Connection Pool이다. 이는 커넥션을 만들어 놓고 요청이 있을 때 마다 하나 빼서 쓰고 반납하고 쓰고 반납하고 하는 방식이다. 이를 통해 성능이 좋아진다.여기서 Connection Pool을 Datasource라 한다. JREBEL의 활용소스코드가 변경되면 서버를 다시시작해야되는 번거로움이 존재하지만 JREBEL로 극복 가능하다https://my.jrebel.com/ 에 접속하여 가입하고 라이센스키를 받아서 활용하자 Window-Preferences-JRebel에 접속해서 설정하자! 인터셉터스피링에서 서블릿 디스패처와 컨트롤러 사이에 존재하여 가로채는 역할을 한다. Servlet의 앞과 뒤에서 HTTP Request와 HTTP Response를 가로채는 필터와 유사하며 Interceptor를 구현하기 위해서는 HandlerInterceptor 인터페이스를 구현하여야 한다.","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Spring","slug":"Web-App/Spring","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://KKimSangHeon.github.io/tags/Spring/"}]},{"title":"10.Spring. annotation의 활용","slug":"spring2","date":"2017-09-07T02:29:09.000Z","updated":"2018-09-03T05:57:30.725Z","comments":true,"path":"2017/09/07/spring2/","link":"","permalink":"http://KKimSangHeon.github.io/2017/09/07/spring2/","excerpt":"","text":"리턴 은 주로 String, ModelActivew, Object로 한다.메소드 단독매핑MainController.java12345678910111213141516171819202122232425262728package com.bigdata2017.springex.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class MainController &#123; // request mapping (method 단독 매핑) // 접속시 MainController:main 출력됨 @ResponseBody @RequestMapping(\"/main\") public String main() &#123; return \"MainController:main\"; &#125; @ResponseBody @RequestMapping(\"/main2/a/b/c\") public String main2() &#123; return sendMessage(\"main2\"); &#125; private String sendMessage( String message) &#123; return \"MainController:\"+message; &#125;&#125;타입+ 메소드 메핑UserController.java1234567891011121314151617181920212223242526272829303132333435363738394041package com.bigdata2017.springex.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;/* request mapping( type + method) */@Controller@RequestMapping(\"/user\")public class UserController &#123; @ResponseBody @RequestMapping(\"/joinform\") public String joinform() &#123; return \"UserController:joinfrom\"; &#125; @ResponseBody @RequestMapping(&#123;\"/join\",\"/doJoin\"&#125;) public String join() &#123; return \"UserController:join\"; &#125; @ResponseBody @RequestMapping( value = \"/loginform\", method=RequestMethod.GET) public String loginform() &#123; return \"UserController:loginform\"; &#125; @ResponseBody @RequestMapping( value = \"/login\", method=RequestMethod.GET) public String login() &#123; return \"UserController:login\"; &#125;&#125; 타입단독 메핑GuestbookController.java12345678910111213141516171819202122232425package com.bigdata2017.springex.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;//Request Mapping (type 단독 매핑)@Controller@RequestMapping(\"/guestbook/*\")public class GuestbookController &#123; @ResponseBody @RequestMapping public String list() &#123; return \"GuestbookController:list\"; &#125; @ResponseBody @RequestMapping public String insert() &#123; return \"GuestbookController:insert\"; &#125;&#125; 정리타입+메소드 매핑이 가장 많이 쓰인다.!","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Spring","slug":"Web-App/Spring","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://KKimSangHeon.github.io/tags/Spring/"}]},{"title":"9.Spring이란? helloSpring실습","slug":"spring","date":"2017-09-06T05:01:31.000Z","updated":"2018-09-03T05:57:27.834Z","comments":true,"path":"2017/09/06/spring/","link":"","permalink":"http://KKimSangHeon.github.io/2017/09/06/spring/","excerpt":"","text":"스프링이란?자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크 프레임워크?소프트웨어를 만드는 데 기본이 되는 골격 코드반제품완전한 애플리케이션 소프트웨어가 아니다.문제 영역(도메인)을 해결하기 위한 잘 설계된 재사용 가능한 모듈확장하여 비즈니스 요구사항에 맞는 완전한 애플리케이션으로 완성이 요구된다. 스프링을 이용하여 웹을 만들면 Spring MVC를 사용DB어플리케이션 프레임 워크는 MyBatis,Spring DAO가 존재기타(지원) 프레임워크로는 로깅(Log4J), 빌드/배포(Ant), 단위테스트(JUnit)가 존재 객체에 대한 의존성,생성,소멸 등에 대한 것을 스프링 컨테이너에게 넘긴다. 이로 인해 개발자는 비즈니스만 잘 만들면 된다. 이로인해 생산성이 향상된다. EJBEnterprise Java Bean의 약자.자바 빈즈 스펙에 맞게 구현된 자바코드를 웹에서 쉽게 이용하기 위해 JSP 표준액션 태그 지원인터페이스 구현 등 불편한 점이 많았다. POJO(Plain Old Java Object)EJB를 대체하여 특정클래스를 상속하거나 인터페이스를 구현하지 않는 평범한 자바 클래스(느슨한 Java Bean, Spring Bean)를 이용하며 단순하지만 EJB에서 제공하는 고급 기술을 제공한다.-자바 언어와 꼭 필요한 API외에는 특정 규약에 종속되지 않는다.-특정 환경에 종속되지 않는다. (기술과 비즈니스 분리)(서블릿은 서블릿 컨테이너에 종속적이였음)-스프링에서는 스프링에 특화된 인터페이스 구현을 요구하지 않음-스프링 자체에 의존성이 높은 클래스 확장을 거의 요구 하지 않음 Spring1.POJO를 이용한 가볍고(lightweight) 비침투적(non-invasive) 개발2.DI와 인터페이스 지향을 통한 느슨한 결합도(loose coupling)3.Aspect와 공통 규약을 통한 선언적(declarative) 프로그래밍4.Aspect와 템플릿(template)을 통한 반복적이고 상투적인(boilerplate) 코드 제거 AOP는 OOP를 더 OOP답게 쓰는것 3.1 IoC( 제어역전 ,Inverse of Control (Object) ) 과 DI( 의존관계 주입)Spring Container = IoC(DI) Container = Bean Container = Application Contextnew를 하지 않아도 컨테이너가 알아서 만들고 소멸해주고 다한다!! AOP (Aspect Oriented Programming)클래스의 관심에 따라 클래스를 구성하게되는데(ex:DAO는 DB접근에 관심) 횡단관심: 여러곳에서 공통으로 필요한 모듈횡단관심은 클래스로 빼내서 모듈로 만든다.관심의 분리 ( Separation of Concern )횡단 관심( Crosscutting Concern )과 핵심관심( Core Concern )핵심관심 모듈과 횡단 관심 모듈이 긴밀하게 결합 ( 핵심 모듈이 필요한 시점에..)OOP 문제점 : 중복코드, 지저분한 코드, 생산성 저하, 재활용성의 문제점필요한 시점에 횡단 관심 모듈을 삽입하여 동작하게 하는 기술. EJB AOP, JDK Dynamic Proxy, AspectJ, Spring AOP 실습다이나믹 웹 프로젝트를 생성해서 메이븐으로 바꿔줄것이다.1.dynamic web project - next - src를 remove 하고 src/main/java 추가 -next - directory를 webapp로 변경하고 체크하고 finish2.프로젝트 우클릭 configure- convert to maven project -그룹 id에 com.bigdata2017입력작업이 끝나고 나면 프로젝트 옆 이미지에 m이 생긴다. 라이브러리 의존성을 추가하자1.pom.xml을 열자. 다음과 같이 수정하자 pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.bigdata.2017&lt;/groupId&gt; &lt;artifactId&gt;springex&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;properties&gt; &lt;org.springframework-version&gt;4.1.1.RELEASE&lt;/org.springframework-version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Spring Core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring Web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring MVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jstl --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.6.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;configuration&gt; &lt;warSourceDirectory&gt;webapp&lt;/warSourceDirectory&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; web.xml을 수정하자webapp/WEB-INF/web.xml pom.xml1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" id=\"WebApp_ID\" version=\"3.0\"&gt; &lt;display-name&gt;springex&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;spring&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; spring-servlet.xml 생성WEB-INF 폴더내에 생성하자spring-servlet.xml1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns=\"http://www.springframework.org/schema/beans\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:annotation-config /&gt; &lt;context:component-scan base-package=\"com.bigdata2017.springex.controller\" /&gt;&lt;/beans&gt; javaResource에 com.bigdata2017.springex.controller 패키지 추가패키지에 다음 파일 추가HelloController.java123456789101112package com.bigdata2017.springex.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;@Controllerpublic class HelloController &#123; @RequestMapping(\"/hello\") public String hello() &#123; return \"/WEB-INF/views/hello.jsp\"; &#125;&#125; WEB-INF에 views폴더 추가 후 hello.jsp 추가hello.jsp123456789101112&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello Spring&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 추가적으로 해준 것들1) pom.xml 구성 2) DispatcherServlet 등록( web.xml ) 3) 서블릿 애플리케이션 컨텍스트 설정 (spring-servlet.xml) 4) Controller 작성 생략된 것들1) 서블릿 작성 2) 파라미터 처리 request.getParameter() 3) forwarding","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Spring","slug":"Web-App/Spring","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://KKimSangHeon.github.io/tags/Spring/"}]},{"title":"8.Ajax","slug":"ajax","date":"2017-09-06T00:10:29.000Z","updated":"2018-09-03T05:57:24.900Z","comments":true,"path":"2017/09/06/ajax/","link":"","permalink":"http://KKimSangHeon.github.io/2017/09/06/ajax/","excerpt":"","text":"Asynchronous Javascript XML AJAX는 비동기 통신이다. 동기클라이언트가 리퀘스트를 보내면 그에 대한 리스폰스가 와야 다른 리퀘스트를 보낼 수 있다.서버에서 리퀘스트에 대한 응답이 오지 않으면 block상태에 빠진다는 단점 존재. 비동기리퀘스트에 대한 응답을 기다리지 않고 다른 동작을 처리할 수 있다.단점은 어느 요청이 어느 요청에 대한 응답인지 알기 어려울 수 있다. 도착순서도 정해져있지 않고 많은 응답이 있기 때문에..ajax를 이용하지 않고 통신1234567891011121314151617181920212223242526272829303132333435363738394041424344454647$(function()&#123; $(\"button\").click(function()&#123; //1.XMLHttpRequest 객체 생성 var xhr = new XMLHttpRequest(); //2. 통신 상태 변화에 따른 콜백함수 정의 xhr.onreadystatechange = function()&#123; if( this.readyState == 0 )&#123; //open() 호출 전 console.log( \"readyState(0) - unset\" ); &#125;else if(this.readyState ==1)&#123; //open() 호출 후 console.log( \"readyState(1) - set\" ); &#125;else if(this.readyState ==2)&#123; //send() 호출 후 console.log( \"readyState(2) - sent\" ); &#125;else if(this.readyState ==3)&#123; //loading... console.log( \"readyState(3) - loading\" ); &#125;else if(this.readyState ==4)&#123; //done console.log( \"readyState(4) - done\" ); console.log( xhr.responseText); var response = eval(xhr.responseText); console.log(response); $.each(response,function(index,vo)&#123; console.log( index +\":\" + vo.name) &#125;) &#125; &#125;; //3. open xhr.open(\"GET\",\"/wp_js2/sample.json\") //4. send request xhr.send(); &#125;);&#125;)ajax를 이용하여 통신1234567891011121314151617181920$(function()&#123; $(\"button\").click(function()&#123; $.ajax( &#123; async: true, url : \"/wp_js2/sample.json\", type: \"get\", dataType: \"json\", data: \"\", contentType: 'application/json', success: function(response)&#123; $.each (response,function(index,vo)&#123; console.log(vo.name) &#125;) &#125;, error: function( jqXHR, status, e )&#123; alert( status + \" : \" + e ); &#125; &#125;); &#125;);&#125;);","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Spring","slug":"Web-App/Spring","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Spring/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://KKimSangHeon.github.io/tags/Ajax/"}]},{"title":"7.jquery","slug":"jquery1","date":"2017-09-05T00:09:56.000Z","updated":"2018-09-03T05:57:34.824Z","comments":true,"path":"2017/09/05/jquery1/","link":"","permalink":"http://KKimSangHeon.github.io/2017/09/05/jquery1/","excerpt":"","text":"2006년 Mozila의 자바스크립트 에반젤리스 Jhon Resig에 의해 개발 / 공개여러 자바스크립트 라이브러리 ( prototype.js, Mootool.js 등) 중에 가장 주목 받고 있다.jQuery로 코딩하면 자바스크립트 코드가 간결해 진다.가볍다 ( 90KB)IE6.0 이상, Firefox2.0 이상, Safari 3 이상, Opera 9이상, Google Chrome등의 주요 브라우저를 지원하여 클로스브라우징을 가능케 한다. 엘리먼트를 골라야 하는 시점들123456789101112131415161718//엘리먼트를 골라야 하는 시점 1(Vanilla JS)window.onload = function()&#123; console.log(document.getElementBy(\"my-p\"));&#125;//엘리먼트를 골라야 하는 시점 2 (jQuery)jQuery( document ).ready( function()&#123; console.log( document.getElementById(\"my-p\"));//엘리먼트를 골라야 하는 시점 3 (jQuery)$( document ).ready( function()&#123; console.log(document.getElementById(\"my-p\"));&#125;)//엘리먼트를 골라야 하는 시점 4 (jQuery)$(function()&#123; console.log(document.getElementById(\"my-p\"));&#125;); jQuery 함수를 이용한 색 변경12345678910111213141516171819202122232425$(function()&#123; setTimeout( function()&#123; var $li = $(\"li\"); $li.css(\"color\",\"#f00\" ); //jQuery Object 뭐냐? console.log($li.length); console.log($li[0]); //HTMLElement Object //에러유발 //$li[0].css(\"font-weigth\",\"bold\") $li[0].style.fontWeight = \"bold\"; //jQuery API를 호출 하고 싶으면 //jQuery 함수(=$)로 매핑한다 $($li[0]).css(\"text-decoration\",\"underline\") //get api함수를 사용해서 HTMLElement 가져오기 $($li.get(1)).css(\"backgroundColor\",\"#ccc\"); &#125;,2000)&#125;); jQuery 활용방법123456789101112131415161718$(\"#first\").css(\"color\",\"red\");$(\"#secnod\").css(\"color\",\"blue\");$(\"#second\").css(\"fontWeight\",\"bold\");var $li3 = $(\"#third\");$li3.css(\"color\",\"blue\");$li3.css(\"fontWeigth\",\"bold\");//메소드 체인$(\"#third\").css(\"color\",\"blue\").css(\"fontWeight\",\"bold\");// 파라미터로 JSON을 사용하는 방법$(\"#fifth\").css(&#123; \"color\":\"blue\", \"fontWeight\":\"bold\"&#125;); 다양한 선택방법12345678910111213$(\".red strong\").css(\"color\",\"red\").text(\"text\");$(\".blue #s1\").css(\"color\",\"blue\"); //자손 선택$(\".blue &gt; #s2\").css(\"color\",\"red\"); //자식선택 (바로아래)$(\"#second + li\").css(\"color\",\"red\"); //인접선택$(\"li:first-child\").css(\"color\",\"red\"); //첫번째 자식$(\"li:last-child\").css(\"color\",\"red\"); //마지막 자식$(\"li[id]\").css(\"color\",\"red\"); //id 속성이 있는 애만$(\"li[class]\").css(\"color\",\"red\"); //class속성이 있는애만","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Spring","slug":"Web-App/Spring","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Spring/"}],"tags":[{"name":"JQuery","slug":"JQuery","permalink":"http://KKimSangHeon.github.io/tags/JQuery/"}]},{"title":"6.웹표준","slug":"servlet6","date":"2017-08-30T00:00:10.000Z","updated":"2018-09-03T05:57:05.810Z","comments":true,"path":"2017/08/30/servlet6/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/30/servlet6/","excerpt":"","text":"초창기 웹은 넷스케이프가 독주하는 상황이었지만, 윈도우98 부터 IE브라우저가 기본 탑재되어 IE6.0는 브라우저 시장의 90%를 점유 했었다. IE의 ActiveX (자사 기술 독점)에 따른 웹 환경의 폐해MS는 COM(Component Object Model)이라는 기술 제공한다. 이 중 UI가 있는 컴포넌트를 ActiveX라 한다. IE이외의 사파리, 크롬, 파이어폭스, 오페라 등 다양한 브라우저가 데스트탑 환경에서 영향력이 커졌다특히, 모바일 환경에서는 사파리, 크롬, 파이어폭스가 주도권을 잡았다.특정 웹 브라우저에 종속되는 웹 페이지는 더 이상 설 자리가 없음을 의미웹 페이지 제작 기술에 표준의 필요성이 대두 웹 표준을 주도하는 W3C( World Wide Web Consortium )-http://www.w3.org-웹 기술의 표준화를 담당하는 기구-HTML, CSS, XML 등 웹과 관련된 다양한 기술에 대해 논의하며 관련기술 표준 재정-웹 표준은 W3C의 목표와 비전에 따라 연구한 결과를 웹에 반영시키기 위한 권고 사항 웹 접근성어떤 장비, 어떤 브라우저를 사용하던지 해당 사이트를 얼마나 볼 수 있는냐를 의미일반인이건 장애인이건 어떤 사용자도 해당 사이트 사용에 어려움이 없어야 한다는 의미웹 표준을 지켜 작성한 HTML 문서는 웹 접근성을 준수하는 데 비표준 문서들 보다 쉽다.표현을 CSS로 분리 시킨 HTML 문서는 웹 접근성을 준수하는 데 표현과 정보가 섞여 있는 문서들 보다 쉽다. 웹 2.0의 개념-웹2.0이란 이용자가 적극적으로 참여하여 정보/지식을 만들고 공유하는 열린 인터넷을 의미한다-웹 2.0은 웹과 관련된 새로운 기술, 문화, 그리고 경제 현상의 복합적인 변화를 포함하는 개념이다. 즉, 사용자 편의성을 강화한 새로운 기술의 활용, 정보의 생성 및 개방/ 공유를 통한 직접적 가치 창출, 이를 통해 만들어진 새로운 문화 및 경제 현상을 통틀어 웹2.0으로 이해할 수 있다 웹 2.0의 목표앞서 웹2.0의 개념을 살펴보았습니다. 그렇다면 웹2.0은 어떤 배경에서 등장하게 되었고, 이 새로운 패러다임으로 이루고자하는 것은 무엇일까요? 웹2.0의 기본적인 목적은 ‘사람들을 다양하고 새로운 방식으로 연결하고 연결 된 사람들의 집단지성을 활용하는 것’입니다. 웹 2.0 출처 : http://visualize.tistory.com/267 웹언어 ( = HTML )-웹페이지를 만들기 위해 HTML(Hyper Text Markup Language)를 사용하여 파일을 생성하고, 웹 서버에 그 파일을 올려 놓아야 한다. -HTML은 페이지를 보여주기 위해서 알아야 할 필요가 있는 모든 것을 브라우저에게 알려준다. 하이퍼텍스트 (HTML)-웹 전체의 기초가 되는 것-단일 페이지에서 벗어나 다른 페이지와 연결할 수 있게 해주는 것- 엘리멘트에 의해 구현-콘텐츠 이런 식으로 링크가 걸리며, href 속성은 목적지를 명시 DOMDocument Object Model로 웹페이지를 자바스크립트로 제어하기 위한 객체 모델을 의미한다. window 객체의 document 프로퍼티를 통해서 사용할 수 있다. Window 객체가 창을 의미한다면 Document 객체는 윈도우에 로드된 문서를 의미한다고 할 수 있다. DOM의 하위 수업에서는 문서를 제어하는 방법에 대한 내용을 다룬다. DOM 출처 : https://opentutorials.org/course/1375/6655 시맨틱 검색시맨틱 검색은 검색로봇이 검색어 의미를 스스로 분석하고 추리해 원하는 정보를 더 정교하게 찾아주는 검색방식 시맨틱 마크업시맨틱 마크업이란 HTML의 태그를 사용하여 문서 안의 내용이 담고 있는 의미가 무엇인지 표현할 수 있도록 구조를 작성하는 것을 말함 http://www.greeneclipse.com/eclipsepalette.html 에 접속해서 설치하면 DOCTYPE-DOCTYPE은 html의 태그는 아니지만 웹페이지에서 맨 처음에 선언되어 어떤 종류의 html을 사용할지 웹브라우저에게 알려줄 목적으로 사용-브라우저는 DOCTYPE 선언을 확인하고 브라우저 모드를 결정한다.-브라우저 모드는 표준 호환 모드, 비표준 호환 모드-웹 표준에서는 웹 페이지를 제대로 표현하기 위해서는 올바른 문서 형태를 정의해주어야 한다.-가장 많이 사용되고 있는 HTML 버전은 HTML4.01 과 XHTML1.0-최신 버전인 HTML5를 문서형식으로 사용하는 웹사이트도 증가 추세 CSS ( Cascading Style Sheet ) 이해-워드프로세스의 스타일 적용과 유사-cascading : ‘계단형’ 의 의미로 스타일 적용에 특정도, 또는 우선순위가 있고 우선 순위가 정해지는 것이 계단식 스타일 시트라는 의미무조건 맨 아래 있는게 적용되는게 아니라 P{…} body P{….} body P.aaa{…} 일 경우 가장 길이가 긴 body P.aaa{…} 가 적용됨","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Servlet/JSP","slug":"Web-App/Servlet-JSP","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Servlet-JSP/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://KKimSangHeon.github.io/tags/Servlet/"}]},{"title":"5. EL, JSTL","slug":"servlet5","date":"2017-08-28T05:13:23.000Z","updated":"2018-09-03T05:57:03.003Z","comments":true,"path":"2017/08/28/servlet5/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/28/servlet5/","excerpt":"","text":"EL기존에 사용하는 스크립트릿을 &lt;%= %&gt;를 대체할 수 있따.&lt;%= vo.getName %&gt;를 $ { vo.name } 으로 대체 가능하다 이를 EL(Expression Language)이라 한다.웹 페이지에 값을 표시(표현),하는 데 사용되는 태그JSP의 출력 문법을 보완하는 역할${} 를 사용한다.표현언어의 식을 계산해서 출력한다.null 는 공백으로 출력한다. 스클릿틀릿 사용예시1234567&lt;% if( null == session.getAttribute( \"authUser\" ) ) &#123;%&gt; &lt;p&gt;로그인을 하지 않았습니다.&lt;/p&gt;&lt;% &#125;%&gt; 위의 코드는 다음과 같다EL의 사용예시123&lt;c:if test=\"$&#123; empty authUser &#125;\"&gt; &lt;p&gt;로그인을 하지 않았습니다.&lt;/p&gt;&lt;/c:if&gt;EL로 내장객체 접근하기-pageScope : 페이지 범위에 빈을 저장-requestScope : 요청 범위에서 빈을 저장-sessionScope : 세션 범위에서 빈을 저장-applicationScope : 어플리케이션 범위에서 빈을 저장 JSTLJSP에서 사용 가능한 표준 태그 라이브러리JSP 코드가 깔끔해지고 가독성이 좋아진다.JSTL 라이브러리 -기본기능 ( core ) -형식화(format) -데이터베이스(sql) -XML 처리(xml) -함수처리(function) jstl.jar 파일을 구해서 프로젝트 우클릭 후 자바빌드패스의 라이브러리탭에서 추가하고 deployment assembly에 추가 아래 3개는 추가해놓고 사용하여야 한다.-기본기능 ( core ) :&lt;%@ taglib uri=”http://java.sun.com/jsp/jstl/core“ prefix=”c”%&gt; -형식화(format) :&lt;%@ taglib uri=”http://java.sun.com/jsp/jstl/fmt“ prefix=”fmt”%&gt; -함수처리(function) :&lt;%@ taglib uri=”http://java.sun.com/jsp/jstl/functions“ prefix=”fn”%&gt; JSTL은 if문을 제공하나 else if , else를 제공하지 않는다. 이를 대체하여 사용할 수 있는것이 choose이다. choose사용예시1234567891011121314151617&lt;c:choose&gt; &lt;c:when test=\"$&#123;param.color == 1&#125;\"&gt; &lt;span style=\"color: red\"&gt;빨강&lt;/span&gt; &lt;/c:when&gt; &lt;c:when test=\"$&#123;param.color == 2&#125;\"&gt; &lt;span style=\"color: green\"&gt;초록&lt;/span&gt; &lt;/c:when&gt; &lt;c:when test=\"$&#123;param.color == 3&#125;\"&gt; &lt;span style=\"color: blue\"&gt;파랑&lt;/span&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;span style=\"color: black\"&gt;검정&lt;/span&gt; &lt;/c:otherwise&gt;&lt;/c:choose&gt; -변수에 값을 설정한다.","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Servlet/JSP","slug":"Web-App/Servlet-JSP","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Servlet-JSP/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://KKimSangHeon.github.io/tags/Servlet/"}]},{"title":"4. 서블릿의 Life Cicle, MVC, Model1","slug":"servlet4","date":"2017-08-25T00:07:35.000Z","updated":"2018-09-03T05:56:59.562Z","comments":true,"path":"2017/08/25/servlet4/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/25/servlet4/","excerpt":"","text":"첫번째 호출 때는init() calledservice() calleddoGet() called순으로 이어진다. 두번 째 호출때는service() calleddoGet() called순으로 이어진다 즉 변수를 선언 할 때는 init() 메소드 안에 선언해주는것이 좋으나 동기화를 잘 해줘야하는단점이 있다. MVC아키텍쳐 패턴 중에 하나로 GUI 기반 Application 설계, 패턴클라이언트 요청을 받아 처리하여 응답하는 로직을 Model, View, Controller 로 나누어 설계하고 구현 Model애플리케이션 정보(데이터) 또는 정보를 처리하는 모듈(객체)ex) DAO View텍스트, 체크박스, 입력창 등과 같은 사용자 인터페이스 요소를 나타냄ex) HTML Controller클라이언트 요청, Model, View 사이의 상호동작을 관리 한다. 라우팅만 한다고 생각하자ex) java로직 Model1M + VC 이라고 생각하면 된다.※모델1은 컨트롤 뷰가 하나로 이루어짐. 모델1은 요청마다 서블릿이 만들어져 관리해야할 jsp가 많아진다. Model2M(DAO) + V(JSP) + C(Servlet)주로 복잡한 요구사항을 처리하는 웹 애플리케이션에서 MVC(Model-View-Controller pattern) 패턴을 사용한다. MVC 패턴은 코딩과 유지보수를 쉽게 하고, Model 2 아키텍처라고도 불린다.","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Servlet/JSP","slug":"Web-App/Servlet-JSP","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Servlet-JSP/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://KKimSangHeon.github.io/tags/Servlet/"}]},{"title":"3. Servlet & JSP 응용실습","slug":"servlet3","date":"2017-08-24T02:07:50.000Z","updated":"2018-09-03T05:56:49.513Z","comments":true,"path":"2017/08/24/servlet3/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/24/servlet3/","excerpt":"","text":"JSPjsp파일은 내부적으로 서블릿으로 변환 된다는 점을 잊지말자.톰캣이 자동으로 해준다. 리다이렉트 포워드의 차이포워드 - 새로운 페이지는 이전 페이지에서 처리하던 것과 같은 요청을 처리하게 하고 응답하여 브라우저는 하나 이상의 페이지가 연관 된 것을 알 수 없다. 리다렉트 - 첫번째 페이지는 브라우저에게 새로운 페이지로 다시 요청해야 한다는 내용의 응답을 보낸다. 브라우저는 이 응답을 받으면 즉시 새로운 페이지로 다시 요청을 보낸다. 실습다이나믹 웹 프로젝트 생성-서버우클릭 add and remove 프로젝트 추가 프로젝트 우클릭 후 - 프로퍼티스 -JAVA BUILD PATH - add library 후 ojdbc 추가프로젝트 우클릭 후 - 프로퍼티스 -deployment assembly - add -jdbc 추가 후 apply JSTLjsp standard tag library EmailListDao.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127package com.bigdata2017.emaillist.dao;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.ArrayList;import java.util.List;import com.bigdata2017.emaillist.vo.EmailListVo;public class EmailListDao &#123; public int insert( EmailListVo vo) &#123; int count = 0; Connection conn= null; PreparedStatement pstmt = null; try &#123; conn = getConnection(); String sql = \"INSERT \" +\"INTO EMAILLIST \" + \"VALUES (SEQ_EMAILLIST.NEXTVAL,?,?,?)\"; pstmt = conn.prepareStatement(sql); pstmt.setString(1, vo.getFirstName()); pstmt.setString(2, vo.getLastName()); pstmt.setString(3, vo.getEmail()); count = pstmt.executeUpdate(); &#125; catch (SQLException e) &#123; System.out.println( \"error\" + e ); &#125; finally &#123; //3. 자원정리 try &#123; if( pstmt != null ) &#123; pstmt.close(); &#125; if( conn != null ) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return count; &#125; public List&lt;EmailListVo&gt; getList()&#123; List&lt;EmailListVo&gt; list = new ArrayList&lt;EmailListVo&gt;(); Connection conn = null ; Statement stmt = null; ResultSet rs = null; try &#123; conn = getConnection(); //3. Statement 객체 생성 stmt = conn.createStatement(); //4. SQL문 실행 String sql =\"SELECT NO,FIRST_NAME,LAST_NAME,EMAIL\\r\\n\" + \"FROM EMAILLIST ORDER BY NO DESC\"; rs = stmt.executeQuery(sql); System.out.println(\"connection 성공\"); //5. 결과 사용하기 while( rs.next() ) &#123; Long no = rs.getLong( 1 ); String firstName = rs.getString(2); String lastName = rs.getString(3); String email = rs.getString(4); EmailListVo vo = new EmailListVo(); vo.setNo(no); vo.setFirstName(firstName); vo.setLastName(lastName); vo.setEmail(email); list.add(vo); &#125; &#125; catch (SQLException e) &#123; System.out.println( \"error\" + e ); &#125; finally &#123; //3. 자원정리 try &#123; if( rs != null ) &#123; rs.close(); &#125; if( stmt != null ) &#123; stmt.close(); &#125; if( conn != null ) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return list; &#125; private Connection getConnection() throws SQLException &#123; Connection conn = null ; //1. JDBC 드라이버 로딩 try &#123; Class.forName( \"oracle.jdbc.driver.OracleDriver\" ); //2. Connection 얻어오기 String url = \"jdbc:oracle:thin:@localhost:1521:xe\"; conn = DriverManager.getConnection(url, \"webdb\", \"webdb\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return conn; &#125;&#125; form.jsp12345678910111213141516171819202122232425&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;메일 리스트 가입&lt;/h1&gt; &lt;p&gt; 메일 리스트에 가입하려면,&lt;br&gt; 아래 항목을 기입하고 등록 버튼을 클릭하세요. &lt;/p&gt; &lt;form method=\"post\" action=\"&lt;%=request.getContextPath() %&gt;/insert.jsp\" &gt; First name: &lt;input type=\"text\" name=\"fn\" value=\"\" /&gt;&lt;br&gt; Last name: &lt;input type=\"text\" name=\"ln\" value=\"\" /&gt;&lt;br&gt; Email address: &lt;input type=\"text\" name=\"email\" value=\"\"/&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"submit\"&gt; &lt;/form&gt; &lt;br&gt; &lt;p&gt; &lt;a href = \"&lt;%=request.getContextPath()%&gt;\"&gt;리스트 바로가기&lt;/a&gt; &lt;/p&gt;&lt;/body&gt;&lt;/html&gt; index.jsp123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;%@page import=\"com.bigdata2017.emaillist.vo.EmailListVo\"%&gt;&lt;%@page import=\"java.util.List\"%&gt;&lt;%@page import=\"com.bigdata2017.emaillist.dao.EmailListDao\"%&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;% EmailListDao dao = new EmailListDao(); List&lt;EmailListVo&gt; list = dao.getList();%&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;메일 리스트에 가입되었습니다.&lt;/h1&gt; &lt;p&gt;입력한 정보 내역입니다.&lt;/p&gt; &lt;!-- 메일정보 리스트 --&gt; &lt;%-- list에서 하나씩 빼서 테이블를 채운다--%&gt; &lt;% for(EmailListVo vo : list )&#123; %&gt; &lt;table border=\"1\" cellpadding=\"5\" cellspacing=\"2\"&gt; &lt;tr&gt; &lt;td align=right&gt;First name: &lt;/td&gt; &lt;td&gt;&lt;%=vo.getFirstName() %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=right width=\"110\"&gt;Last name: &lt;/td&gt; &lt;td width=\"110\"&gt;&lt;%=vo.getLastName()%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=right&gt;Email address: &lt;/td&gt; &lt;td&gt;&lt;%=vo.getEmail()%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;br&gt; &lt;%&#125; %&gt; &lt;p&gt; &lt;a href=\"&lt;%=request.getContextPath() %&gt;/form.jsp\" &gt;추가메일 등록&lt;/a&gt; &lt;/p&gt; &lt;br&gt;&lt;/body&gt;&lt;/html&gt; insert.jsp123456789101112131415161718192021222324252627282930&lt;%@page import=\"com.bigdata2017.emaillist.dao.EmailListDao\"%&gt;&lt;%@page import=\"com.bigdata2017.emaillist.vo.EmailListVo\"%&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt; &lt;% request.setCharacterEncoding( \"utf-8\"); String firstName = request.getParameter( \"fn\" ); String lastName = request.getParameter( \"ln\" ); String email = request.getParameter(\"email\"); EmailListVo vo = new EmailListVo(); vo.setFirstName(firstName); vo.setLastName(lastName); vo.setEmail(email); new EmailListDao().insert(vo); response.sendRedirect( request.getContextPath() ); %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;성공적으로 등록되었습니다.&lt;/h1&gt; &lt;a href=\"index.jsp\"&gt;리스트 돌아가기&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Servlet/JSP","slug":"Web-App/Servlet-JSP","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Servlet-JSP/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://KKimSangHeon.github.io/tags/Servlet/"}]},{"title":"2. Servlet & JSP 기본실습","slug":"servlet2","date":"2017-08-24T00:02:51.000Z","updated":"2018-09-03T05:56:55.257Z","comments":true,"path":"2017/08/24/servlet2/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/24/servlet2/","excerpt":"","text":"JSP도 곧 서블릿임을 잊지말자. GET 방식 : http://naver.com?이름=shkim&amp;암호=1234 get방식으로 한글을 보낼경우 글이 깨지는데 이때는 server을 열고 server.xml을 열자. 65라인에 URIEncoding=”utf-8”을 추가해주자 WebContent에 form.jsp 생성form , 절대경로, 상대경로에 대해 알아보자form.jsp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- h1태그는 블록 태그라 아래로 내려감 --&gt; &lt;h1&gt;폼테스트&lt;/h1&gt; &lt;h2&gt;폼테스트&lt;/h2&gt; &lt;h3&gt;폼테스트&lt;/h3&gt; &lt;h4&gt;폼테스트&lt;/h4&gt; &lt;h5&gt;폼테스트&lt;/h5&gt; &lt;!-- 상대경로(form.jsp의 위치부터) --&gt; &lt;img src = \"images/java.png\"&gt; &lt;!-- 절대경로 --&gt; &lt;a href = \"/helloweb/index.jsp\"&gt;메인으로 가기&lt;/a&gt; &lt;!-- 절대경로를 처리하는 안정적인 방법 --&gt; &lt;a href = \"&lt;%=request.getContextPath() %&gt;/index.jsp\"&gt;메인으로 가기&lt;/a&gt; &lt;!-- form 태그는 디폴트로 겟방식으로 날린다. --&gt; &lt;form method=\"post\" action=\"&lt;%= request.getContextPath() %&gt;/join\"&gt; &lt;!-- input 태그는 인라인 태그라 옆으로간다. --&gt; &lt;input type=\"hidden\" name=\"type\" value=\"나쁜놈\"/&gt; 이메일: &lt;input type=\"text\" name=\"email\" value=\"\"&gt; &lt;br&gt;&lt;br&gt; 비밀번호: &lt;input type=\"password\" name=\"password\" value=\"\"&gt; &lt;br&gt;&lt;br&gt; 이름: &lt;input type=\"text\" name=\"name\" &gt; &lt;br&gt;&lt;br&gt; 성별: &lt;!-- radio는 name속성을 같게 해줘야 하나만 선택된다. --&gt; &lt;input type=\"radio\" name=\"gender\" value=\"female\"/&gt; 여 &lt;input type=\"radio\" name=\"gender\" value=\"male checked=checked\"/&gt; 남 &lt;br&gt;&lt;br&gt; 생년: &lt;select name = \"birth-year\"&gt; &lt;option value=\"1995\"&gt;1995&lt;/option&gt; &lt;option value=\"1994\"&gt;1994&lt;/option&gt; &lt;option value=\"1993\"&gt;1993&lt;/option&gt; &lt;option value=\"1992\"&gt;1992&lt;/option&gt; &lt;option value=\"1991\"&gt;1991&lt;/option&gt; &lt;option value=\"1990\" selected&gt;1990&lt;/option&gt; &lt;/select&gt; &lt;br&gt;&lt;br&gt; 취미: &lt;input type=\"checkbox\" name=\"hobby\" value=\"reading\"/&gt;독서 &lt;input type=\"checkbox\" name=\"hobby\" value=\"sleeping\"/&gt;잠자기 &lt;input type=\"checkbox\" name=\"hobby\" value=\"swimming\"/&gt;수영 &lt;input type=\"checkbox\" name=\"hobby\" value=\"coding\"/&gt;코딩 &lt;br&gt;&lt;br&gt; 자기소개: &lt;br&gt;&lt;br&gt; &lt;textarea rows=\"15\" cols=\"80\" name=\"self-intro\"&gt;123412341234&lt;/textarea&gt; &lt;br&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"가입\"&gt; &lt;br&gt;&lt;br&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; Java Resource에 서블릿 파일 생성join.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.bigdata2017.helloweb.servlet;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Servlet implementation class join */@WebServlet(\"/join\")public class join extends HttpServlet &#123; private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding( \"utf-8\"); //post 방식으로 데이터를 전달 받는 경우 //encoidng charset를 지정 String type = request.getParameter(\"type\"); System.out.println(type); String email = request.getParameter(\"email\"); System.out.println(email); String password = request.getParameter(\"password\"); System.out.println(password); String name = request.getParameter(\"name\"); System.out.println(name); String gender = request.getParameter(\"gender\"); System.out.println(gender); String birthYear = request.getParameter(\"birth-year\"); System.out.println(birthYear); String hobbies[] = request.getParameterValues( \"hobby\" ); if( hobbies != null) &#123; for( String hobby : hobbies) &#123; System.out.println( hobby ); &#125; &#125; String selfIntro = request.getParameter(\"self-intro\"); System.out.println(selfIntro); response.setContentType( \"text/html; charset=utf-8\" ); //setContentType() 메소드를 호출하고 getWriter()을 호출해야 글이 안꺠진다. PrintWriter out = response.getWriter(); out.println(\"&lt;h1&gt;성공적으로 가입되었습니다&lt;/h1&gt;\"); out.print(\"&lt;a href='/helloweb/form.jsp'&gt;폼으로가기&lt;/a&gt;\"); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125;","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Servlet/JSP","slug":"Web-App/Servlet-JSP","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Servlet-JSP/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://KKimSangHeon.github.io/tags/Servlet/"}]},{"title":"1. servlet이란? 실습","slug":"servlet1","date":"2017-08-23T04:05:38.000Z","updated":"2018-09-03T05:56:53.179Z","comments":true,"path":"2017/08/23/servlet1/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/23/servlet1/","excerpt":"","text":"톰켓을 서블릿 콘테이너, WAS라 부른다. JSP - HTML을 아는사람들이 쉽게 만들 수 있는것.결국 이도 서블릿 클래스로 변한다.톰캣은 web.xml파일의 매핑 정보를 보고 요청에 대한 응답을 날려준다. 서버 생성하고 - 프로젝트 익스플로러 탭에서 우클릭- web프로젝트 생성 - next-next-맨 아래 체크 - finish 이클립스가 프로젝트명.war파일을 올려놓으면 톰켓이 그것을 풀어서 활용한다. web-info는 찾아갈 수 없다. 실습 1서버 생성하고 - 프로젝트 익스플로러 탭에서 우클릭- web프로젝트 생성(이름:helloweb) - next-next-맨 아래 체크 - finish이미지파일을 Web-Content안에 넣는다.서버 우클릭add and remove 클릭서버실행 (에러난다 8080쓰고 있어서 에러남(오라클))서버패키지의 server.xml 파일을 찾아가 65라인의 8080을 8088로 수정http://localhost:8088/helloweb/java.png 접속해보자 WebContent 우클릭 후 jsp 파일생성하고 접속해보자hello.jsp 생성http://localhost:8088/helloweb/hello.jsp 접속해보자 WebContent 우클릭 후 images 폴더생성그안에 이미지 붙여넣자http://localhost:8088/helloweb/images/java.png 접속해보자 java Resource에 com.bigdata2017.helloweb.servlet패키지를 생성하자.패키지 선택하고 우클릭 서블릿 생성 HelloServlet로 하고 next - URL mapping에 add 선택- /hello 입력- next - doget , dopost 선택 후 finish HelloServlet.java12345678910111213141516171819202122232425262728293031323334package com.bigdata2017.helloweb.servlet;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Servlet implementation class HelloServlet */@WebServlet(&#123; \"/hello\" &#125;) //얘는 표준은 아니다. web.xml을 열어서 해야함!public class HelloServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html; charset=utf-8\"); PrintWriter pw = response.getWriter(); pw.println(\"&lt;h1&gt;Hello World&lt;/h1&gt;\"); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); // doPost를 doGet로 처리 &#125;&#125; http://localhost:8088/helloweb/hello 에 접속해보자 JSP 로만 짜는것 -모델1JSP - servlet 를 혼용해서 짜는것을 모델2 MVC라고 한다. 실습2HelloServlet.java의 @WebServlet({ “/hello” })을 지우고 해보자어노테이션을 이용한 것이 표준은 아니다.web.xml파일을 열자 web.xml12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" id=\"WebApp_ID\" version=\"3.0\"&gt; &lt;display-name&gt;helloweb&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.bigdata2017.helloweb.servlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 실습3jsp는 서블릿 코드가 내장되어있다고 생각하면 된다. WebContent의 우클릭 후 table.jsp 생성table.jsp1234567891011121314151617181920212223242526272829303132333435363738&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt; &lt;% String sRow = request.getParameter( \"r\" ); String sCol = request.getParameter( \"c\" ); int nRow = Integer.parseInt( sRow ); int nCol = Integer.parseInt( sCol ); %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=\"1px\" cellspacing=0 cellpadding=\"10px\"&gt; &lt;% for(int i = 0; i&lt; nRow; i++)&#123; %&gt; &lt;tr&gt; &lt;% for(int j=0; j&lt;nCol;j++) &#123; %&gt; &lt;td&gt;cell(&lt;%=j %&gt;,&lt;%=i %&gt;)&lt;/td&gt; &lt;td&gt;cell(&lt;%=j %&gt;,&lt;%=i %&gt;)&lt;/td&gt; &lt;td&gt;cell(&lt;%=j %&gt;,&lt;%=i %&gt;)&lt;/td&gt; &lt;% &#125; %&gt; &lt;/tr&gt; &lt;% &#125; %&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 실습4실습3과 동일한 코드를 서블릿으로 작성해보자TableServelt.java1234567891011121314151617181920212223242526272829303132333435363738394041package com.bigdata2017.helloweb.servlet;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet(&#123; \"/table\" &#125;)public class TableServelt extends HttpServlet &#123; private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String sRow = request.getParameter( \"r\" ); String sCol = request.getParameter( \"c\" ); int nRow = Integer.parseInt( sRow ); int nCol = Integer.parseInt( sCol ); response.setContentType( \"text/html; charset=utf-8\" ); PrintWriter out = response.getWriter(); out.println(\"&lt;table border=\\\"1px\\\" cellspacing=0 cellpadding=\\\"10px\\\"&gt;\"); for(int i=0; i&lt; nRow; i++) &#123; out.println(\"&lt;tr&gt;\"); for(int j=0; j&lt;nCol; j++) &#123; out.println(\"&lt;td&gt;cell(\"+j+\",\"+ i + \")&lt;/td&gt;\"); &#125; out.println(\"&lt;/tr&gt;\"); &#125; out.println(\"&lt;/table&gt;\"); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125;","categories":[{"name":"Web/App","slug":"Web-App","permalink":"http://KKimSangHeon.github.io/categories/Web-App/"},{"name":"Servlet/JSP","slug":"Web-App/Servlet-JSP","permalink":"http://KKimSangHeon.github.io/categories/Web-App/Servlet-JSP/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"http://KKimSangHeon.github.io/tags/Servlet/"}]},{"title":"12. 정규화","slug":"database12","date":"2017-08-23T00:07:28.000Z","updated":"2018-09-03T05:54:21.163Z","comments":true,"path":"2017/08/23/database12/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/23/database12/","excerpt":"","text":"데이터 베이스 설계의 주된 목적중복성 제거, 정규화 데이터 모델데이터베이스 설계를 도식화한 도표로서 엔티티, 속성, 관계 3가지 요소로 구성 정규화갱신이상, 데이터의 중복성을 제거. 데이터 모델을 좀 더 구체적으로 해준다. 제 1 정규형(1NF)모든속성이 하나의 값을 가질 때 제 1 정규형이라 한다.(도메인이 원자값 임) 제 2 정규형(2NF)하나의 엔티티가 이미 1NF로 되어 있고 모든 식별되지 않은 속성들이 엔티티의 유일한 식별자에 종속적이면 “제 2 정규형(2nd Normal form)” 이라 한다.(부분적 함수 종속 제거 됨) 제 3 정규형(3NF)하나의 엔티티가 이미 2NF로 되어 있고 식별할 수 없는 어떠한 속성도 어떤 다른 식별할 수 없는 속성들에게 종속적이지 않으면 “제 3 정규형(3nd Normal form)” 이라 한다.(이행적 함수 종속 제거 됨)","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"SQL(Oracle)","slug":"Language/SQL-Oracle","permalink":"http://KKimSangHeon.github.io/categories/Language/SQL-Oracle/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"11. DAO","slug":"database11","date":"2017-08-22T04:48:18.000Z","updated":"2018-09-03T05:54:18.752Z","comments":true,"path":"2017/08/22/database11/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/22/database11/","excerpt":"","text":"DAOData Access Object데이터베이스 접근 부분을 캡슐화하여 메소드를 이용하여 데이터베이스에 접근한다. 이때 결과는 VO객체를 통해 얻는다.AuthorDao.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import java.util.ArrayList;import java.util.List;import com.bigdata2017.jdbc.bookshop.vo.AuthorVo;public class AuthorDao &#123; private Connection getConnection() throws SQLException &#123; Connection conn = null ; //1. JDBC 드라이버 로딩 try &#123; Class.forName( \"oracle.jdbc.driver.OracleDriver\" ); //2. Connection 얻어오기 String url = \"jdbc:oracle:thin:@localhost:1521:xe\"; conn = DriverManager.getConnection(url, \"hr\", \"hr\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return conn; &#125; public int delete( ) &#123; int count = 0 ; Connection conn = null ; Statement stmt = null; ResultSet rs = null; try &#123; conn = getConnection(); //3. Statement 객체 생성 stmt = conn.createStatement(); //4. SQL문 실행 String sql =\"DELETE FROM AUTHOR\"; count = stmt.executeUpdate(sql); &#125; catch (SQLException e) &#123; System.out.println( \"error\" + e ); &#125; finally &#123; //3. 자원정리 try &#123; if( rs != null ) &#123; rs.close(); &#125; if( stmt != null ) &#123; stmt.close(); &#125; if( conn != null ) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return count; &#125; public int insert( AuthorVo vo ) &#123; int count = 0; Connection conn = null; PreparedStatement pstmt = null; try &#123; conn = getConnection(); //3. Statement 준비 String sql = \" insert\" + \" into author\" + \" values (seq_author.nextval, ?, ?)\"; pstmt = conn.prepareStatement( sql ); //4. binding pstmt.setString( 1, vo.getName() ); pstmt.setString( 2, vo.getProfile() ); //5. SQL문 실행 count = pstmt.executeUpdate(); &#125; catch (SQLException e) &#123; System.out.println( \"error :\" + e ); &#125; finally &#123; //3.자원 정리 try &#123; if( pstmt != null ) &#123; pstmt.close(); &#125; if( conn != null ) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return count; &#125; public List&lt;AuthorVo&gt; getList()&#123; List&lt;AuthorVo&gt; list = new ArrayList&lt;AuthorVo&gt;(); Connection conn = null ; Statement stmt = null; ResultSet rs = null; try &#123; conn = getConnection(); //3. Statement 객체 생성 stmt = conn.createStatement(); //4. SQL문 실행 String sql =\"SELECT NO, NAME, PROFILE FROM AUTHOR ORDER BY NO\"; rs = stmt.executeQuery(sql); System.out.println(\"connection 성공\"); //5. 결과 사용하기 while( rs.next() ) &#123; Long no = rs.getLong( 1 ); String name = rs.getString( 2 ); String profile = rs.getString( 3 ); AuthorVo vo = new AuthorVo(); vo.setNo(no); vo.setName(name); vo.setProfile(profile); list.add(vo); &#125; &#125; catch (SQLException e) &#123; System.out.println( \"error\" + e ); &#125; finally &#123; //3. 자원정리 try &#123; if( rs != null ) &#123; rs.close(); &#125; if( stmt != null ) &#123; stmt.close(); &#125; if( conn != null ) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; return list; &#125;&#125; AuthorDaoTest.java12345678910111213141516171819202122232425262728293031323334package com.bigdata2017.jdbc.test;import java.util.List;import com.bigdata2017.jdbc.bookshop.dao.AuthorDao;import com.bigdata2017.jdbc.bookshop.vo.AuthorVo;public class AuthorDaoTest &#123; public static void main(String[] args) &#123; testInsert(); testGetList(); &#125; public static void testGetList() &#123; AuthorDao dao = new AuthorDao(); List&lt;AuthorVo&gt; list = dao.getList(); for(AuthorVo vo: list) &#123; System.out.println(vo); &#125; &#125; public static void testInsert() &#123; AuthorDao dao = new AuthorDao(); AuthorVo vo = new AuthorVo(); vo.setName( \"공자\" ); vo.setProfile( \"....\" ); new AuthorDao().insert(vo); &#125;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"SQL(Oracle)","slug":"Language/SQL-Oracle","permalink":"http://KKimSangHeon.github.io/categories/Language/SQL-Oracle/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"10. JDBC","slug":"database10","date":"2017-08-22T00:08:22.000Z","updated":"2018-09-03T05:54:16.309Z","comments":true,"path":"2017/08/22/database10/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/22/database10/","excerpt":"","text":"JDBC-자바를 이용한 데이터베이스 접속과 SQL 문장의 실행, 그리고 실행 결과로 얻어진 데이터의 핸들링을 제공하는 방법과 절차에 관한 규약-자바 프로그램내에서 SQL문을 실행하기 위한 자바 API-SQL과 프로그래밍 언어의 통합 접근 중 한 형태 Class.forName메소드란?클래스를 로딩하는 메소드이다.//왜 new OralcDriver()을 하지 않고 forName() 메소드를 사용할 까?//new 를 이용할 경우 벤더별로 다를것이므로! MyDriver.java123456789101112131415161718192021222324252627282930313233343536package com.bigdata2017.jdbc;...public class MyDriver implements Driver&#123; static &#123; System.out.println( \"static code area\" ); //외부에서 드라이버 접근이 가능토록 드라이버 등록 try &#123; DriverManager.registerDriver(new MyDriver()); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; @Override public boolean acceptsURL(String arg0) throws SQLException &#123; // TODO Auto-generated method stub return false; &#125; @Override public Connection connect(String url, Properties info) throws SQLException &#123; System.out.println( url ); System.out.println( info ); //이작업은 DB마다 다를것이다. /*연결 작업*/ return new MyConnection(); &#125;...&#125; ConnectionTest.java123456789101112131415161718192021222324252627import java.sql.DriverManager;import java.sql.SQLException;public class ConnectionTest &#123; public static void main(String[] args) &#123; try &#123; //1. JDBC 드라이버 로딩// Class.forName( \"oracle.jdbc.driver.OracleDriver\" ); Class.forName( \"com.bigdata2017.jdbc.MyDriver\" ); //클래스를 강제 로딩 //왜 new OralcDriver()을 하지 않고 forName() 메소드를 사용할 까? //new 를 이용할 경우 벤더별로 다를것이므로! //2. Connection 얻어오기 String url = \"jdbc:oracle:thin:@localhost:1521:xe\"; DriverManager.getConnection(url, \"hr\", \"hr\"); &#125; catch (ClassNotFoundException e) &#123; System.out.println( \"드라이버 로딩 실패:\" + e ); &#125; catch (SQLException e) &#123; System.out.println( \"연결실패\" + e ); &#125; &#125;&#125; MyConnection.java1234567package com.bigdata2017.jdbc;public class MyConnection implements Connection&#123; ...&#125; 실습프로젝트 우클릭 - 자바 빌드 패스 - 라이브러리탭- add library - user library 선택 -new - jdbc(아무거나 가능) - add external jar - ojdbc 파일 찾기 - apply - finish SelectTestSelectTest.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class SelectTest &#123; public static void main(String[] args) &#123; Connection conn = null ; Statement stmt = null; ResultSet rs = null; try &#123; //1. JDBC 드라이버 로딩 Class.forName( \"oracle.jdbc.driver.OracleDriver\" ); //2. Connection 얻어오기 String url = \"jdbc:oracle:thin:@localhost:1521:xe\"; conn = DriverManager.getConnection(url, \"hr\", \"hr\"); //3. Statement 객체 생성 stmt = conn.createStatement(); //4. SQL문 실행 String sql = \"select EMPLOYEE_ID,\" + \" FIRST_NAME,\" + \" LAST_NAME,\" + \" SALARY \" + \" from employees\"; rs = stmt.executeQuery(sql); System.out.println(\"connection 성공\"); //5. 결과 사용하기 while( rs.next() ) &#123; Long employee_id = rs.getLong( 1 ); //rs.getLong( \"employee_id\" ) 도 가능 String first_Name = rs.getString( 2 ); String last_Name = rs.getString( 3 ); int salary = rs.getInt(4); System.out.println( employee_id+ first_Name + last_Name + salary); &#125; &#125; catch (ClassNotFoundException e) &#123; System.out.println( \"드라이버 로딩 실패:\" + e ); &#125; catch (SQLException e) &#123; System.out.println( \"error\" + e ); &#125; finally &#123; //3. 자원정리 try &#123; if( rs != null ) &#123; rs.close(); &#125; if( stmt != null ) &#123; stmt.close(); &#125; if( conn != null ) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; UpdateTestStatement를 사용함. 아래 Insert에서는 Prepared Statement를 사용 한다.비교해보자UpdateTest.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class UpdateTest &#123; public static void main(String[] args) &#123; Connection conn = null ; Statement stmt = null; try &#123; //1. JDBC 드라이버 로딩 Class.forName( \"oracle.jdbc.driver.OracleDriver\" ); //2. Connection 얻어오기 String url = \"jdbc:oracle:thin:@localhost:1521:xe\"; conn = DriverManager.getConnection(url, \"dev\", \"dev\"); //3. Statement 객체 생성 stmt = conn.createStatement(); //4. SQL문 실행 String name = \"도우넛\"; Long no = 12L; String sql = \"update author \" + \" set name = '\"+ name +\"'\" + \" where no = \"+ no; //쿼리문이 복잡한데 Prepared Statement를 통해 좀더 수월하게 할 수 있다. int count = stmt.executeUpdate(sql); //5. 성공유무 System.out.println( count == 1 ? \"성공\" : \"실패\"); &#125; catch (ClassNotFoundException e) &#123; System.out.println( \"드라이버 로딩 실패:\" + e ); &#125; catch (SQLException e) &#123; System.out.println( \"error\" + e ); &#125; finally &#123; //3. 자원정리 try &#123; if( stmt != null ) &#123; stmt.close(); &#125; if( conn != null ) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; InsertTest보통 PreparedStatement를 많이 쓴다.select의 경우 바인드만 안하면 되니까!InsertTest.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.SQLException;public class InsertTest &#123; public static void main(String[] args) &#123; Connection conn = null ; PreparedStatement pstmt = null; try &#123; //1. JDBC 드라이버 로딩 Class.forName( \"oracle.jdbc.driver.OracleDriver\" ); //2. Connection 얻어오기 String url = \"jdbc:oracle:thin:@localhost:1521:xe\"; conn = DriverManager.getConnection(url, \"dev\", \"dev\"); //3. Statement 준비 String sql = \"insert\" + \"into author\" + \"values(seq_author.nextval,?,?)\"; pstmt = conn.prepareStatement(sql); //4. 바인딩 pstmt.setString( 1, \"공자\"); pstmt.setString( 2, \"어쩌구저쩌구\"); //5. SQL문 실행 int count = pstmt.executeUpdate(); //파라미터로 sql이 들어가면 안된다. //5. 성공유무 System.out.println( count == 1 ? \"성공\" : \"실패\"); &#125; catch (ClassNotFoundException e) &#123; System.out.println( \"드라이버 로딩 실패:\" + e ); &#125; catch (SQLException e) &#123; System.out.println( \"error\" + e ); &#125; finally &#123; //3. 자원정리 try &#123; if( pstmt != null ) &#123; pstmt.close(); &#125; if( conn != null ) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"SQL(Oracle)","slug":"Language/SQL-Oracle","permalink":"http://KKimSangHeon.github.io/categories/Language/SQL-Oracle/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"9. Data Dictionary, DCL, ROLE","slug":"database9","date":"2017-08-21T05:17:43.000Z","updated":"2018-09-03T05:54:14.221Z","comments":true,"path":"2017/08/21/database9/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/21/database9/","excerpt":"","text":"Data Dictionary란?모든 스키마 객체 정보, 스키마 객체의 공간 정보, 컬럼의 기본값, 제약조건 정보, 오라클 사용자 정보, 권한 및 롤 정보, 기타 데이터베이스 정보 … SELECT * FROM DICTIONARY;–데이터 딕셔너리 조회 SELECT * FROM USER_OBJECTS; SELECT * FROM USER_OBJECTS WHERE OBJECT_TYPE = ‘TABLE’; SELECT * FROM DICTIONARY;–데이터 딕셔너리 조회 SELECT * FROM USER_OBJECTS; SELECT * FROM USER_OBJECTS WHERE OBJECT_TYPE = ‘TABLE’; SELECT * FROM USER_USERS;–로그인한 유저만 보여줌 SELECT * FROM ALL_USERS;–전체 유저 보여줌 SELECT * FROM DBA_USERS;–CONN /AS SYSDBA로 로그인 후 가능 SELECT *FROM USER_CONSTRAINTSWHERE TABLE_NAME = ‘BOOK’;–제약조건 조회 SELECT * FROM USER_USERS; DCL–사용자 생성CREATE USER SHKIM IDENTIFIED BY “SHKIM”; –접속권한GRANT CREATE SESSION TO SHKIM; –SELECT 권한 부여 (DEV에 있는 BOOK테이블에 SELECT 할수있는..)GRANT SELECT ON DEV.BOOK TO SHKIM; –접속권한 없애기REVOKE CREATE SESSION FROM SHKIM; –롤 단위이렇게만 해도 접속 가능GRANT CONNECT, RESOURCE TO SHKIM; REVOKE CONNECT RESOURCE FROM SHKIM; ROLE 생성여러개의 권한을 묶어놓은것!CONN /AS SYSDBACREATE ROLE VIEWER;GRANT CREATE SESSION TO VIEWER;GRANT SELECT ON DEV.BOOK TO VIEWER;GRANT VIEWER TO SHKIM;CONN SHKIN/SHKIM;SELECT * FROM DEV.BOOK; CONN /AS SYSDBA;REVOKE VIWER FROM SHKIM; transaction트랜잭션은 DML의 집합으로 이루어진다.논리적 작업단위, 일련의 연산 집합을 의미한다. –DML–암시적(컬럼 지정X) 인 경우에는 순서와 , 개수 정확해야 함INSERT INTO AUTHOR VALUES(SEQ_AUTHOR.NEXTVAL, ‘둘리’,NULL); –명시적(컬럼 지정O)인 경우 지정한 순서와 개수 대로 입력해야 한다.INSERT INTO AUTHOR(NAME, NO) VALUES(‘둘리’,SEQ_AUTHOR.NEXTVAL); 트랜잭션은 다음과 같은 특징을 가져야 한다.Atomicity: all or nothing. 하나의 단위로 처리되어야 함. (중간까지만 처리됨은 불가)Consistency: 데이터베이스의 일관성(무결성)을 깨지 않아야 함Isolation: 다른 transaction과 동시에 수행되더라도 독립적으로 영향을 받지 않아야 함Durability: 한번 수행 완료(commit)되면 영원히 반영되어 있어야 함 (시스템 crash에서라도) DDL이나 DCL은 한 문장이 트랜잭션으로 처리됨 DeadLock둘 이상의 트랜잭션이 서로 상대방의 Lock을 순환 대기하여 어떤 트랜잭션도 더 이상 진행할 수 없는 상태","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"SQL(Oracle)","slug":"Language/SQL-Oracle","permalink":"http://KKimSangHeon.github.io/categories/Language/SQL-Oracle/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"8. Commit, Transaction, Delete, Update, CONSTRAINT","slug":"database8","date":"2017-08-21T00:23:06.000Z","updated":"2018-09-03T05:54:10.984Z","comments":true,"path":"2017/08/21/database8/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/21/database8/","excerpt":"","text":"Commit일련의 과정을 거친 후 커밋을 해줘야 데이터베이스에 반영이 된다.오라클의 경우 DDL은 자동으로 커밋이 되며 DML은 직접 커밋을 해줘야 한다.커밋의 과정중 에러가 나면 롤백시킨다. Transaction여러개의 job를 묶어 놓은것을 Transaction이라 한다. DELETEDELETEFROM BOOKWHERE NO = 1; COMMIT; // 커밋한다.ROLLBACK; //다시 롤백한다. UPDATEUPDATE BOOKSET TITLE = ‘토지2’WHERE NO = 1; Subquery를 이용한 테이블 생성백업용 테스트용으로 많이 쓰인다. Subquery의 결과와 동일한 테이블 생성됨질의 결과 레코드들이 포함됨NOT NULL 제약 조건 만 상속됨 CREATE TABLE EMPLOYEES_BAK01AS ( SELECT * FROM EMPLOYEES WHERE JOB_ID = ‘FI_ACCOUNT’); char, varcharchar - 10바이트를 만들고 ‘ab’를 입력하면 10바이트 할당됨varchar - 10바이트를 만들고 ‘ab’를 입력하면 2바이트 할당됨 모든 데이터가 고정크기일 때 (ex 주민번호, 학번) - char모든 데이터가 고정크기가 아닐 때 (ex 이메일) - varchar varchar, varchar2기능상의 다른점은 없지만 varchar2에서 성능개선이 이뤄짐.varchar는 곧 없어질 것이라 예고를 하고있다. NUMBER(x,y)y는 실수부분을 의미한다. varchar2(5), nvarchar2(5)varchar2(5)는 5바이트를 할당nvarchar2(5) 는 5글자를 할당한글은 UTF-8을 사용하기 떄문에 문제가 된다. –NVARCHAR2 , VARCHAR2와 비교 CREATE TABLE BOOK( NO NUMBER(10), TITLE VARCHAR2(120), AUTHOR VARCHAR2(5), –MAX 4000 BYTE TEST NVARCHAR2(2000), –MAX 2000자( 내부적으로 6000 BYTE ) PUB_DTAE DATE); INSERT INTO BOOK VALUES(1, ‘토지’, ‘가나’, SYSDATE);– 가나가 6바이트라 에러가 발생.. INSERT INTO BOOK VALUES(1, ‘토지’, ‘가’, SYSDATE);– 정상적으로 INSERT 가능 ALTERALTER TABLE BOOK ADD(PUBS VARCHAR(120));–컬럼추가ALTER TABLE BOOK MODIFY(PUBS VARCHAR(200));–컬럼 변경ALTER TABLE BOOK RENAME COLUMN PUBS TO PUBLISHINGS;–컬럼명 변경ALTER TABLE BOOK DROP(PUBLISHINGS);–컬럼 제거ALTER TABLE BOOK MODIFY(AUTHOR VARCHAR(300) NOT NULL);–컬럼 변경ALTER TABLE BOOK SET UNUSED(AUTHOR);–컬럼을 보이지 않게 만듦ALTER TABLE BOOK DROP UNUSED COLUMNS;–보이지 않게 만든 컬럼을 삭제함 SEQUENCE값이 1씩 증가한다CREATE TABLE BOOK( NO NUMBER(10), TITLE VARCHAR2(200) NOT NULL, AUTHOR VARCHAR2(50) NOT NULL, –MAX 4000 BYTE PUB_DATE DATE, PRIMARY KEY(NO) ); CREATE SEQUENCE SEQ_BOOKSTART WITH 1 –1부터 시작INCREMENT BY 1 –1씩 증가MAXVALUE 999999999 –MAX가 다차면 1로 돌아감–PRIMARY KEY 자동증가 SELECT SEQ_BOOK.NEXTVAL FROM DUAL; –증가SELECT SEQ_BOOK.CURRVAL FROM DUAL; –최근값 INSERT INTO BOOK VALUES( SEQ_BOOK.NEXTVAL, ‘토지2’, ‘박경리’, SYSDATE);–INSERT 문에서의 시퀀스 활용 CHECKCREATE TABLE BOOK( NO NUMBER(10), TITLE VARCHAR2(200) NOT NULL, AUTHOR VARCHAR2(50) NOT NULL, –MAX 4000 BYTE PUB_DATE DATE, STATE VARCHAR2(12) NOT NULL, PRIMARY KEY(NO), CONSTRAINT C_BOOK_CHECK CHECK(STATE IN (‘대여중’, ‘대여가능’))); INSERT INTO BOOK VALUES( SEQ_BOOK.NEXTVAL, ‘토지2’, ‘박경리’, SYSDATE, ‘대여가능’ –대여중, 대여가능만 들어갈 수 있다. ); 외부키CREATE SEQUENCE SEQ_AUTHORSTART WITH 1INCREMENT BY 1MAXVALUE 999999999–시퀀스 생성 CREATE TABLE AUTHOR( NO NUMBER(10), NAME VARCHAR2(200) NOT NULL, PROFILE VARCHAR2(2000), PRIMARY KEY(NO)) CREATE TABLE BOOK( NO NUMBER(10), TITLE VARCHAR2(200) NOT NULL, AUTHOR_NO NUMBER(10) , –MAX 4000 BYTE STATE VARCHAR2(12) NOT NULL, PUB_DATE DATE, PRIMARY KEY(NO), CONSTRAINT C_BOOK_FK FOREIGN KEY (AUTHOR_NO) REFERENCES AUTHOR(NO) ON DELETE CASCADE , –AUTHOR 테이블의 박경리 데이터가 삭제도면 BOOK테이블의 토지 데이터도 삭제된다. ON DELETE SET NULL, –AUTHOR 테이블의 박경리 데이터가 삭제도면 BOOK테이블의 AUTHOR_NO는 NULL이 된다.. CONSTRAINT C_BOOK_CHECK CHECK(STATE IN (‘대여중’, ‘대여가능’))); INSERT INTO AUTHOR VALUES(SEQ_AUTHOR.NEXTVAL,‘박경리’,NULL); INSERT INTO BOOK VALUES(SEQ_BOOK.NEXTVAL,‘토지’,1,‘대여가능’,SYSDATE); CONSTRAINT제약조건은 보통 ALTER테이블을 통해 모아서 준다.아래와 같이..CREATE TABLE AUTHOR( NO NUMBER(10), NAME VARCHAR2(200) NOT NULL, PROFILE VARCHAR2(2000)) ALTER TABLE AUTHORADD CONSTRAINT C_AUTHOR_PKPRIMARY KEY(NO); CREATE TABLE BOOK( NO NUMBER(10), TITLE VARCHAR2(200) NOT NULL, AUTHOR_NO NUMBER(10) NOT NULL, –MAX 4000 BYTE STATE VARCHAR2(12) NOT NULL, PUB_DATE DATE); ALTER TABLE BOOKADD CONSTRAINT C_BOOK_PKPRIMARY KEY(NO); ALTER TABLE BOOKADD CONSTRAINT C_BOOK_CHECKCHECK(STATE IN (‘대여중’, ‘대여가능’)); ALTER TABLE BOOKADD CONSTRAINT C_BOOK_FKFOREIGN KEY (AUTHOR_NO) REFERENCES AUTHOR(NO) ON DELETE CASCADE ;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"SQL(Oracle)","slug":"Language/SQL-Oracle","permalink":"http://KKimSangHeon.github.io/categories/Language/SQL-Oracle/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"7. TOP - K","slug":"database7","date":"2017-08-18T04:04:24.000Z","updated":"2018-09-03T05:54:08.138Z","comments":true,"path":"2017/08/18/database7/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/18/database7/","excerpt":"","text":"– TOP -KSELECT ROWNUM,EMPLOYEE_ID, SALARY FROM EMPLOYEES WHERE HIRE_DATE LIKE ‘06%’ ORDER BY SALARY원하는대로 출력이 되지 않을 것이다. 이를 원하는대로 출력하기 위해서는 다음과 같이!SELECT ROWNUM, EMPLOYEE_ID, SALARYFROM ( SELECT EMPLOYEE_ID, SALARY FROM EMPLOYEES WHERE HIRE_DATE LIKE ‘06%’ ORDER BY SALARY ); SELECT ROWNUM, EMPLOYEE_ID, SALARYFROM ( SELECT EMPLOYEE_ID, SALARY FROM EMPLOYEES WHERE HIRE_DATE LIKE ‘06%’ ORDER BY SALARY ) WHERE ROWNUM &lt;= 3 ;–앞에서 3개 뽑는것 SELECT ROWNUM, EMPLOYEE_ID, SALARYFROM ( SELECT EMPLOYEE_ID, SALARY FROM EMPLOYEES WHERE HIRE_DATE LIKE ‘06%’ ORDER BY SALARY ) WHERE 6 &gt;= ROWNUM AND ROWNUM &lt;= 10;–이것은 원하는 결과가 나오지 않는다.1이 찍히지 않으므로 그렇다. 이로인해 ROWNUM이 증가하지 않음 SELECT * FROM ( SELECT ROWNUM AS RN, EMPLOYEE_ID, SALARY FROM ( SELECT EMPLOYEE_ID, SALARY FROM EMPLOYEES WHERE HIRE_DATE LIKE ‘06%’ ORDER BY SALARY ) ) WHERE RN &gt;=6 AND RN &lt;=10; – 위의 문제를 이렇게 해결함.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"SQL(Oracle)","slug":"Language/SQL-Oracle","permalink":"http://KKimSangHeon.github.io/categories/Language/SQL-Oracle/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"6. SUBQUERY","slug":"database6","date":"2017-08-18T01:22:43.000Z","updated":"2018-09-03T05:54:04.658Z","comments":true,"path":"2017/08/18/database6/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/18/database6/","excerpt":"","text":"서브쿼리Lex보다 많이 받는 사원 구하기 SELECT FIRST_NAME, SALARYFROM EMPLOYEESWHERE SALARY &gt; (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = ‘Lex’); SELECT A.FIRST_NAME, B.SALARYFROM EMPLOYEES A, (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = ‘Lex’) BWHERE A.SALARY &gt; B.SALARY;– 조인으로도 처리 가능 SELECT FIRST_NAME, SALARYFROM EMPLOYEESWHERE SALARY &gt; (SELECT AVG(SALARY) FROM EMPLOYEES ); –SINGLE LOW SUB QUERY – 문_ JOB_ID가 ‘IT_PROG’인 직원이 받는 월급보다 많이 받고 있는 직원의 이름과 월급 SELECT FIRST_NAME, SALARYFROM EMPLOYEESWHERE SALARY &gt; ALL (SELECT SALARY FROM EMPLOYEES WHERE JOB_ID = ‘IT_PROG’) – MULTI ROW SUB QUERY –문) 각 부서별로 최고 월급을 받는 직원의 이름과 직원의 이름과 월급 출력 WHERE을 활용 SELECT FIRST_NAMEFROM EMPLOYEESWHERE (SALARY,DEPARTMENT_ID) IN ( SELECT MAX(SALARY),DEPARTMENT_ID FROM EMPLOYEES GROUP BY DEPARTMENT_ID ); FROM을 활용SELECT A.DEPARTMENT_ID, FIRST_NAME, SALARYFROM EMPLOYEES A, ( SELECT DEPARTMENT_ID, MAX(SALARY) AS MAX_SALARY FROM EMPLOYEES GROUP BY DEPARTMENT_ID ) BWHERE A.DEPARTMENT_ID = B.DEPARTMENT_IDAND A.SALARY = B.MAX_SALARY; CORELATED 활용SELECT DEPARTMENT_ID, FIRST_NAME, SALARYFROM EMPLOYEES AWHERE SALARY = ( SELECT MAX(SALARY) FROM EMPLOYEES WHERE A.DEPARTMENT_ID = DEPARTMENT_ID); – CORELATED SUBQUERY 자기 부서의 평균월급 보다 적은 월급을 받는 사원을 구하라","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"SQL(Oracle)","slug":"Language/SQL-Oracle","permalink":"http://KKimSangHeon.github.io/categories/Language/SQL-Oracle/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"5. ROLLUP, CUBE","slug":"database5","date":"2017-08-18T00:05:47.000Z","updated":"2018-09-03T05:54:02.330Z","comments":true,"path":"2017/08/18/database5/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/18/database5/","excerpt":"","text":"ROWNUMSELECT ROWNUM, EMPLOYEE_IDFROM EMPLOYEES; 트리 형태 구조를 추출하기 위한 질의– START WITH ~ CONNECT BY 절SELECT LEVEL MANAGER_ID, EMPLOYEE_IDFROM EMPLOYEESSTART WITH MANAGER_ID IS NULLCONNECT BY PRIOR EMPLOYEE_ID = MANAGER_IDORDER BY LEVEL, MANAGER_ID, EMPLOYEE_ID; ROLLUP부서별 직책별 평균월급, 사원수 평균월급을 출력하시오ROLLUP (A, B): group by (A, B) &amp; group by (A) &amp; ALL SELECT CASE GROUPING(DEPARTMENT_ID) WHEN 1 THEN ‘모든 부서’ ELSE NVL(TO_CHAR(DEPARTMENT_ID),’없음’) END AS “부서”, CASE GROUPING(JOB_ID) WHEN 1 THEN &apos;모든 직업&apos; ELSE NVL(TO_CHAR(JOB_ID),&apos;없음&apos;) END AS &quot;직업&quot; ,COUNT(*),ROUND(AVG(SALARY),0) FROM EMPLOYEESGROUP BY ROLLUP(DEPARTMENT_ID, JOB_ID)ORDER BY DEPARTMENT_ID, JOB_ID GROUPINGSELECT CASE GROUPING(DEPARTMENT_ID) WHEN 1 THEN ‘모든 부서’ ELSE NVL(TO_CHAR(DEPARTMENT_ID),’없음’) END AS “부서”, CASE GROUPING(JOB_ID) WHEN 1 THEN &apos;모든 직업&apos; ELSE NVL(TO_CHAR(JOB_ID),&apos;없음&apos;) END AS &quot;직업&quot; ,COUNT(*),ROUND(AVG(SALARY),0) FROM EMPLOYEESGROUP BY CUBE(DEPARTMENT_ID, JOB_ID)ORDER BY DEPARTMENT_ID, JOB_ID CUBEgroup by (A,B) &amp; group by (A) &amp; group by (B) &amp; ALLSELECT CASE GROUPING(DEPARTMENT_ID) WHEN 1 THEN ‘모든 부서’ ELSE NVL(TO_CHAR(DEPARTMENT_ID),’없음’) END AS “부서”, CASE GROUPING(JOB_ID) WHEN 1 THEN &apos;모든 직업&apos; ELSE NVL(TO_CHAR(JOB_ID),&apos;없음&apos;) END AS &quot;직업&quot; ,COUNT(*),ROUND(AVG(SALARY),0) FROM EMPLOYEESGROUP BY CUBE(DEPARTMENT_ID, JOB_ID)ORDER BY DEPARTMENT_ID, JOB_ID","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"SQL(Oracle)","slug":"Language/SQL-Oracle","permalink":"http://KKimSangHeon.github.io/categories/Language/SQL-Oracle/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"4. CASE, DECODE, GROUP BY","slug":"database4","date":"2017-08-17T01:59:31.000Z","updated":"2018-09-03T05:53:58.816Z","comments":true,"path":"2017/08/17/database4/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/17/database4/","excerpt":"","text":"CASESELECT EMPLOYEE_ID, SALARY, JOB_ID, CASE JOB_ID WHEN ‘AC_ACCOUNT’ THEN SALARY + SALARY 0.5 WHEN ‘AC_MGR’ THEN SALARY + SALARY 0.3 WHEN ‘AD_VP’ THEN SALARY + SALARY * 0.2 ELSE SALARY END AS SALARYFROM EMPLOYEES; DECODESELECT EMPLOYEE_ID, SALARY, JOB_ID, DECODE( JOB_ID , ‘AC_ACCOUNT’ , SALARY + SALARY 0.5 , ‘AC_MGR’ ,SALARY + SALARY 0.3 , ‘AD_VP’ , SALARY + SALARY * 0.2 , SALARY) AS “이번달 월급”FROM EMPLOYEES; SELECT EMPLOYEE_ID,AVG(SALARY) , MAX(SALARY)FROM EMPLOYEES;– ERROR– 집계함수 이외의 칼럼은 프로젝션 될 수 없다 GROUP BYSELECT JOB_ID,AVG(SALARY), MAX(SALARY)FROM EMPLOYEESWHERE MANAGER_ID IS NOT NULLGROUP BY JOB_ID;– GROUP BY 절에 참여하고 있는 컬럼은 프로젝션 할 수 있다.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"SQL(Oracle)","slug":"Language/SQL-Oracle","permalink":"http://KKimSangHeon.github.io/categories/Language/SQL-Oracle/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"3. 함수 NVL,SYSDATE,IN,BETWEEN,IS NULL,LIKE,LOWER,INITCAP,LPAD,TRIM,REPLACE,CEIL,FLOOR,ROUND,TRUNC,MOD,POWER,SIGN,ADD_MONTHS,TO_CHAR","slug":"database3","date":"2017-08-16T04:19:24.000Z","updated":"2018-09-03T05:53:55.752Z","comments":true,"path":"2017/08/16/database3/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/16/database3/","excerpt":"","text":"SELECT FIRST_NAME || ‘ ‘ || LAST_NAME AS NAME FROM EMPLOYEES; ||은 CONCAT SELECT SALARY AS “본봉”, SALARY + SALARY * 0.3 AS “보너스”FROM EMPLOYEES; SELECT -SALARY FROM EMPLOYEES; NVL, NVL2SELECT EMPLOYEE_ID, NVL(MANAGER_ID,’0’)FROM EMPLOYEES; NVL함수 내의 두 형태는 같아야함 SELECT NVL(NULL, ‘0’) FROM DUAL; SELECT NVL2(NULL,10, 20) FROM DUAL;–NULL이면 10 SELECT NVL2(0, 10, 20) FROM DUAL;–NULL이 아니면 20 SELECT SALARY AS “본봉”, SALARY + SALARY * NVL(COMMISSION_PCT,0) AS “보너스”FROM EMPLOYEES; SELECT SALARY AS “본봉”, NVL2(COMMISSION_PCT,SALARY + SALARY * COMMISSION_PCT, SALARY) AS “보너스”FROM EMPLOYEES; NULLIFSELECT NULLIF( 10 , 5 + 5 ) FROM DUAL; COALESCESELECT COALESCE(NULL, NULL,1,2,3) FROM DUAL;– 1출력 SYSDATESELECT SYSDATE FROM DUAL; SELECT JOB_IDFROM EMPLOYEESWHERE JOB_ID = ‘AD_PRES’ OR JOB_ID = ‘AD_VP’; INSELECT JOB_IDFROM EMPLOYEESWHERE JOB_ID IN(‘AD_PRES’,’AD_VP’); BETWEENSELECT EMPLOYEE_ID, SALARYFROM EMPLOYEESWHERE SALARY BETWEEN 10000 AND SALARY ; IS NULLSELECT EMPLOYEE_ID, COMMISSION_PCTFROM EMPLOYEESWHERE COMMISSION_PCT IS NULL; LIKESELECT FIRST_NAMEFROM EMPLOYEESWHERE FIRST_NAME LIKE ‘A%’;–A로 시작하는 문자열에 대해서 SELECT FIRST_NAMEFROM EMPLOYEESWHERE FIRSTNAME LIKE ‘A‘;–A로시작하는 두글자 검색 SELECT EMPLOYEE_ID, FIRST_NAMEFROM EMPLOYEESORDER BY FIRST_NAME DESC; SELECT EMPLOYEE_ID, HIRE_DATEFROM EMPLOYEES; LOWERSELECT FIRST_NAMEFROM EMPLOYEESWHERE LOWER(FIRST_NAME) LIKE ‘al%’; INITCAPSELECT INITCAP(‘database managemaent system’) from dual;–맨앞만 대문자로 SELECT INSTR( ‘DATABASE MANAGEMENT SYSTEM’ , ‘BASE’ ) FROM DUAL;– BASE의 위치 찾기 (DB는 대부분 시작 인덱스가 1이다. )SELECT CEIL( 4.99) FROM DUAL;SELECT CEIL( 4.01) FROM DUAL;– 해당 수보다 큰 정수값 (5 출력됨) SELECT FLOOR( 4.99 ) FROM DUAL;SELECT FLOOR( 4.00001) FROM DUAL;– 해당 수보다 작은 정수값 SELECT ROUND(3.3364,3) FROM DUAL;– 넷째자리에서 반올림함(3.336 출력됨) SELECT MOD (9999,6) FROM DUAL;– 나머지SELECT POWER ( 2,10) FROM DUAL;–2의 10승 LPADSELECT EMPLOYEE_ID, LPAD(SALARY, 10 , ‘‘) FROM EMPLOYEES;– 10칸을만들되 왼쪽 나머지는 로 채울것 TRIMSELECT TRIM( ‘#’ FROM ‘####DATA#BASE####’) FROM DUAL;– 앞뒤 특정문자 제거 SELECT TRIM( ‘ ‘ FROM ‘ DATA BASE ‘) FROM DUAL;– 앞뒤 공백 제거 SELECT LTRIM(‘ DATA BASE ‘,’ ‘) FROM DUAL;– 왼쪽 공백 제거 REPLACESELECT REPLACE(‘ DATA BASE ‘, ‘ ‘ ,’’) FROM DUAL;– 공백 제거 CEILSELECT CEIL( 4.99) FROM DUAL;SELECT CEIL( 4.01) FROM DUAL;– 해당 수보다 큰 정수값 (5 출력됨) FLOORSELECT FLOOR( 4.99 ) FROM DUAL;SELECT FLOOR( 4.00001) FROM DUAL;– 해당 수보다 작은 정수값 ROUNDSELECT ROUND(3.3364,3) FROM DUAL;– 넷째자리에서 반올림함(3.336 출력됨) TRUNCSELECT TRUNC( 3.3864,1) FROM DUAL;– 1자리만 남기고 버림(3.3나옴) MODSELECT MOD (9999,6) FROM DUAL;– 나머지 POWERSELECT POWER ( 2,10) FROM DUAL;–2의 10승 SIGNSELECT SIGN(9999) FROM DUAL;– 1나옴 SELECT SIGN(-9999) FROM DUAL;– -1나옴 SELECT SIGN(0) FROM DUAL;– 0나옴 ADD_MONTHSSELECT ADD_MONTHS( SYSDATE, 3 ) FROM DUAL;SELECT ADD_MONTHS( ‘15/01/01’,3 ) FROM DUAL; SELECT LAST_DAY( SYSDATE ) FROM DUAL;–해당월에 마지막 일 SELECT MONTHS_BETWEEN( ADD_MONTHS(SYSDATE,3), SYSDATE) FROM DUAL; SELECT EMPLOYEE_ID, JOB_ID, ROUND(MONTHS_BETWEEN( END_DATE, START_DATE))FROM JOB_HISTORY; SELECT NEXT_DAY( SYSDATE, 7) FROM DUAL;– 1-&gt;SUN 7-&gt;SAT TO_CHARSELECT EMPLOYEE_ID, TO_CHAR(SALARY, ‘99999’ )FROM EMPLOYEES;– 숫자 &lt;-&gt; 문자– 5자리가 넘어가면 #####으로 표시된다. SELECT EMPLOYEE_ID, TO_CHAR(SALARY, ‘000099999’ )FROM EMPLOYEES;– 숫자 &lt;-&gt; 문자–앞에 0000으로 채운다. SELECT EMPLOYEE_ID, TO_CHAR(SALARY, ‘999,999’ )FROM EMPLOYEES;– 숫자 &lt;-&gt; 문자 SELECT TO_CHAR( 3.141592, ‘9.99’) FROM DUAL;– 3.14 나옴 SELECT TO_CHAR( 3.141592, ‘9999.9999’) FROM DUAL;– 3.1416 나옴 SELECT EMPLOYEE_ID, TO_CHAR(SALARY,’FM99999999’)FROM EMPLOYEES;– 왼쪽으로 다 땡겨준다 SELECT EMPLOYEE_ID, TO_CHAR(SALARY,’FM$99999999’)FROM EMPLOYEES;– 왼쪽으로 다 땡겨준다 SELECT EMPLOYEE_ID, TO_CHAR(SALARY,’FML99999999’)FROM EMPLOYEES;– 왼쪽으로 다 땡기고 원화를 넣어준다. SELECT TO_CHAR(-12345,’99999MI’) FROM DUAL;– 12345- SELECT TO_CHAR(-12345,’S99999’) FROM DUAL;– -12345 출력 SELECT TO_CHAR(12345,’S99999’) FROM DUAL;– +12345 출력 SELECT TO_CHAR(-12345,’99999PR’) FROM DUAL;– 출력 SELECT TO_CHAR(12345,’99999PR’) FROM DUAL; SELECT TO_CHAR( 1234, ‘RN’) FROM DUAL;–로마자로 표기 SELECT TO_CHAR( 1234, ‘XXXX’ ) FROM DUAL;–16진수 대문자로 표기 SELECT TO_CHAR( 1234, ‘xxxx’ ) FROM DUAL;–16진수 소문자로 표기 SELECT TO_NUMBER( ‘1234567’,’99999999’) FROM DUAL; SELECT EMPLOYEE_ID,TO_CHAR(HIRE_DATE, ‘yyyy-mm-dd’)FROM EMPLOYEES; SELECT EMPLOYEE_ID,TO_CHAR(HIRE_DATE, ‘yyyy”년”-mm”월”-dd”일”‘)FROM EMPLOYEES; SELECT EMPLOYEE_ID,TO_CHAR(HIRE_DATE, ‘yyyy”년”-mm”월”-dd”일” hh24”시”:mi:ss’)FROM EMPLOYEES; SELECT EMPLOYEE_ID,TO_CHAR(HIRE_DATE, ‘yyyy”년”-mm”월”-dd”일” day pm hh:mi:ss’)FROM EMPLOYEES; SELECTTO_CHAR(SYSDATE, ‘yyyy”년”-mm”월”-dd”일” ddd”일째 되는날”‘)FROM DUAL; SELECT TO_CHAR(SYSDATE, ‘RR’)FROM DUAL; SELECT TO_CHAR(TO_DATE(‘30’,’RR’), ‘YYYY’) FROM DUAL;– 현재 세기 SELECT TO_CHAR(TO_DATE(‘60’,’RR’), ‘YYYY’) FROM DUAL;– 이전 세기","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"SQL(Oracle)","slug":"Language/SQL-Oracle","permalink":"http://KKimSangHeon.github.io/categories/Language/SQL-Oracle/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"2. 데이터베이스 기본","slug":"database2","date":"2017-08-16T00:05:42.000Z","updated":"2018-09-03T05:53:52.738Z","comments":true,"path":"2017/08/16/database2/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/16/database2/","excerpt":"","text":"데이터베이스의 기본개념 (정의)-데이터의 집합 ( a Set of Data )-여러 응용 시스템(프로그램)들의 통합된 정보들을 저장하여 운영할 수 있는 공용(share) 데이터의 집합-효율적으로 저장, 검색, 갱신할 수 있도록 데이터 집합들끼리 연관시키고 조직화되어야 한다. DBMS가 하는일데이터 통합, 저장, 운영, 공유 기능 담당. 이를 위해 조직화 되어있어야 함. 데이터베이스의 특성-실시간 접근성(Real-time Accessability) 사용자의 요구를 즉시 처리할 수 있다.-계속적인 변화(Continuous Evolution) 정확한 값을 유지하려고 삽입·삭제·수정 작업 등을 이용해 데이터를 지속적으로 갱신할 수 있다.-동시 공유성(Concurrent Sharing) 사용자마다 서로 다른 목적으로 사용하므로 동시에 여러 사람이 동일한 데이터에 접근하고 이용할 수 있다.-내용 참조(Content Reference) 저장한 데이터 레코드의 위치나 주소가 아닌 사용자가 요구하는 데이터의 내용, 즉 데이터 값에 따라 참조할 수 있어야 한다. 데이터베이스 관리 시스템 장점데이터 중복이 최소화데이터의 일관성 및 무결성 유지데이터 보안 보장 데이터 베이스의 종류객체 관계형 데이터베이스 ( Object Relation DataBase = ORDB ) -관계형 데이터베이스에서 사용하는 데이터를 확장 -관계형 데이터베이스를 객체 지향 모델링과 데이터를 관리하는 기능을 갖도록 확장한 것NoSQL(Not Only SQL - SQL문 만을 이용하지 않아도 된다.) -대용량 데이터의 웹 서비스와 SNS, 클라우드 컴퓨팅의 확대 보급과 대중화로 최근 주목 받는 데이터베이스 기술 PK다른 행과 구분하기 위해 필요.PK를 설정할 땐 비즈니스와 상관없는 컬럼을 지정하는것이 좋다.(비즈니스 변경시 귀찮아 질 수 있다.)PK는 인덱싱이 자동으로 잡혀 빠르다.릴레이션에서 튜플(행)을 구분하기 위하여 사용하는 기본 키하나의 애트리뷰트, 또는 애트리뷰트의 집합(복합키) 가능관리자에 의해 릴레이션 생성시 정의됨 (자동으로 Index생성됨)동일한 PK를 지닌 레코드가 존재할 수 없음 기타Candidate Key (후보키): 튜플을 식별할 수 있는 최소한의 애트리뷰트 집합하나의 릴레이션에는 PK가 될 수 있는 키가 여러 개 있을 수 있음유일성과 최소성이 있으면 candidate key가 될 수 있음.Alternative Key (대체키): 후보키 중 기본키가 아닌것Composite key (복합키): 둘 이상의 애트리뷰트가 하나의 Key를 이루는 경우","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"SQL(Oracle)","slug":"Language/SQL-Oracle","permalink":"http://KKimSangHeon.github.io/categories/Language/SQL-Oracle/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"Whole in 밴드","slug":"wholin","date":"2017-08-11T06:55:24.000Z","updated":"2017-08-11T07:13:18.046Z","comments":true,"path":"2017/08/11/wholin/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/11/wholin/","excerpt":"","text":"App 소개 및 개발배경-GIF 2016 에 참가하면서 개발하였던 어플리케이션 입니다. 주제는 성공적인 개최를 위한 IOT 서비스 활용방안이였으며 저희팀은 NFC를 이용하여 국적별 다용도로 활용할 수 있는 팔찌(Wholin 밴드)를 제작하였습니다.프로토 타입 어플리케이션이므로 밴드를 통한 국적별 메뉴판 조회, 음식주문 기능을 구현하였습니다. 밴드소개 밴드 속에는 NFC칩이 존재하며 메뉴주문 및 결제, 사각지대 VR 생중계 등의 기능을 제공하며 프로토 타입이므로 국적별 메뉴판 조회기능만 제공합니다. 작동화면 처음 언어를 설정하고 자신의 기본정보를 입력하고 추가정보를 입력후 밴드를 스마트폰에 갖다대면 밴드 등록이 완료됩니다. -시연영상github Repository","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://KKimSangHeon.github.io/tags/Android/"},{"name":"NFC","slug":"NFC","permalink":"http://KKimSangHeon.github.io/tags/NFC/"}]},{"title":"동국대학교 경주캠퍼스 채팅봇","slug":"dg-chat-bot","date":"2017-08-11T06:20:24.000Z","updated":"2018-06-02T01:13:31.070Z","comments":true,"path":"2017/08/11/dg-chat-bot/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/11/dg-chat-bot/","excerpt":"","text":"프로그램 개발배경-기숙사 외박계가 서비스 되지 않은점이 아쉬웠으며 유용하게 쓰일 수 있는 프로그램을 만들어 보고싶어 학교 채팅봇을 만들어보게 되었습니다. 프로그램 소개플러스 친구 추가 후 통학버스 조회, 기숙사 식단조회, 도서관 좌석조회, 홈페이지 조회 기능을 사용할 수 있습니다.또한 AWS EC2인스턴스를 활용하여 서비스하며 동국대학교 경주캠퍼스 채팅봇을 검색 후 친구추가가 가능합니다. 프로그램 동작화면 플러스 친구 추가 후 통학버스 조회, 기숙사 식단조회, 도서관 좌석조회, 홈페이지 조회 기능을 사용할 수 있습니다. 서버2018-06-02기존 AWS를 사용했지만 무료이용기간이 만료되어 구글클라우드 플랫폿을 이용. github Repository","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://KKimSangHeon.github.io/tags/Node-js/"},{"name":"Kakao talk open API","slug":"Kakao-talk-open-API","permalink":"http://KKimSangHeon.github.io/tags/Kakao-talk-open-API/"},{"name":"챗봇","slug":"챗봇","permalink":"http://KKimSangHeon.github.io/tags/챗봇/"},{"name":"MySQL","slug":"MySQL","permalink":"http://KKimSangHeon.github.io/tags/MySQL/"},{"name":"CentOS","slug":"CentOS","permalink":"http://KKimSangHeon.github.io/tags/CentOS/"}]},{"title":"데이터 프리 기프티콘","slug":"defcon","date":"2017-08-11T06:07:04.000Z","updated":"2017-08-11T06:15:14.135Z","comments":true,"path":"2017/08/11/defcon/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/11/defcon/","excerpt":"","text":"참가배경-두 번째 참가한 해커톤 입니다. 첫 해커톤에 흥미를 느껴 다시한번 참가하게 되었습니다. IdeaVPN을 이용하여 스마트폰 데이터 사용량을 감소시키는 어플리케이션입니다.데이터 사용량을 감소시키기 위해 서버에 데이터를 전송하기 전 압축하여 보내고 서버에서 클라이언트로 데이터를 보낼때도 압축을 진행하게 됩니다.서버, 클라이언트는 toyVPN이라는 오픈소스를 활용하였습니다. 동작화면 서버의 주소, 포트, 암호를 입력하고 데.프.콘 바로가기 버튼을 누르면 VPN서버에 접속하게됩니다. github Repository","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"ID 해커톤","slug":"ID-해커톤","permalink":"http://KKimSangHeon.github.io/tags/ID-해커톤/"}]},{"title":"엄마가 보고있다","slug":"Mother-Is-Looking","date":"2017-08-11T05:53:02.000Z","updated":"2017-08-11T06:06:16.469Z","comments":true,"path":"2017/08/11/Mother-Is-Looking/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/11/Mother-Is-Looking/","excerpt":"","text":"참가배경-해커톤을 통해 다양한 사람을 만나고 해커톤이라는 콘테스트에 한번쯤 참가 해 보고싶었습니다. Idea에너톡 플러그인을 사용하여 현재 문제가 되는 청소년 인터넷 중독문제를 해결하고자 하였습니다. 또한 실시간 전력량을 확인할 수 있는 기능또한 추가하였습니다. 동작화면 어플리케이션을 실행시켜면 다음과 같이 “우리 집 PC 확인”, “우리집 전력 확인”을 선택할 수 있습니다. 우리 집 PC 확인 버튼을 눌러 현재 PC의 사용유무를 확인할 수 있으며 전원버튼을 눌러 컴퓨터를 종료할 수 있습니다. 우리 집 전력 확인 버튼을 누르면 실시간 전력량을 확인할 수 있습니다. github Repository","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"에너지 해커톤","slug":"에너지-해커톤","permalink":"http://KKimSangHeon.github.io/tags/에너지-해커톤/"}]},{"title":"1. 오라클 설치","slug":"database1","date":"2017-08-11T04:39:31.000Z","updated":"2018-09-03T05:53:44.025Z","comments":true,"path":"2017/08/11/database1/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/11/database1/","excerpt":"","text":"run sql command line을 켜고 conn system/manager 입력 // manager가 비번 conn /as sysdba //관리자로 로그인 mysql은 데이터베이스를 각각 생성하지만오라클을 테이블 스페이스가 존재하며 자신의 테이블스페이스에 테이블 생성 alter user hr account unlock; //hr계정을 언락함(사용하기 위해)alter user hr identified by “hr”; //비번을 hr로함 conn hr/hr //hr 계정으로 로그인 이클립스 - help - market place - toad 설치 자바가 데이터베이스에 접근하기 위해서는 jdbc가 필요. Connections탭에가서 new connection선택 User에 hr입력비번에 hr입력 OK클릭","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"SQL(Oracle)","slug":"Language/SQL-Oracle","permalink":"http://KKimSangHeon.github.io/categories/Language/SQL-Oracle/"}],"tags":[{"name":"Data Base","slug":"Data-Base","permalink":"http://KKimSangHeon.github.io/tags/Data-Base/"}]},{"title":"12. UDP 소켓","slug":"bigdata13","date":"2017-08-11T00:08:02.000Z","updated":"2018-09-03T05:53:18.980Z","comments":true,"path":"2017/08/11/bigdata13/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/11/bigdata13/","excerpt":"","text":"UDP1.비 연결 지향 프로그래밍2.TCP와 달리 연결되지 않은 상태로 데이터 통신을 하기 때문에 패킷이 유실될 가능성이 있다3.속도 면에서는 큰 장점이 있다. ( 처음 반응속도가 빠르다 ) TCP 서버 포트 6000 / UDP 서버 포트 6000 일 때 충돌이 날까?나지않는다. 다른 프로토콜이라서 그렇다. UDP Echo ServerUDPEchoServer.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class UDPEchoServer &#123; private static final int PORT = 6000; private static final int BUFFER_SIZE = 1000; public static void main(String[] args) &#123; DatagramSocket socket = null; try &#123; //1. Socket 생성 socket = new DatagramSocket(PORT); //2. 데이터 수신 DatagramPacket receivePacket = new DatagramPacket(new byte[BUFFER_SIZE], BUFFER_SIZE); while( true ) &#123; //3. 데이터 수신 대기 socket.receive( receivePacket ); //block //4. 수신 String message = new String( receivePacket.getData(), 0, receivePacket.getLength(), \"UTF-8\"); System.out.println( message ); //5. 데이터 송신 byte[] sendData = message.getBytes( \"UTF-8\" ); DatagramPacket sendPacket = new DatagramPacket( sendData, sendData.length, receivePacket.getAddress(), receivePacket.getPort() ); socket.send( sendPacket ); &#125; &#125; catch (SocketException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if( socket != null &amp;&amp; socket.isClosed() == false) &#123; socket.close(); &#125; &#125; &#125;&#125;UDP Echo ClientUDPEchoClient.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class UDPEchoClient &#123; private static final String SERVER_IP = \"192.168.111.1\"; private static final int SERVER_PORT = 6000; private static final int BUFFER_SIZE = 1024; public static void main(String[] args) &#123; DatagramSocket socket = null; Scanner scanner = null; try &#123; // 0. 키보드 연결 scanner = new Scanner(System.in); // 1. 소켓생성 socket = new DatagramSocket(); while (true) &#123; System.out.print(\"&gt;&gt;\"); String message = scanner.nextLine(); if( \"\".equals(message)) &#123; continue; &#125; if( \"quit\".equals( message )) &#123; break; &#125; //2. 전송패킷 생성 byte[] sendData = message.getBytes(\"utf-8\"); DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, new InetSocketAddress(SERVER_IP, SERVER_PORT)); //3. 전송 socket.send(sendPacket); //4. 메세지 수신 DatagramPacket receivePacket = new DatagramPacket( new byte[ BUFFER_SIZE], BUFFER_SIZE); socket.receive(receivePacket); message = new String( receivePacket.getData(), 0, receivePacket.getLength(), \"UTF-8\") ; System.out.println(\"&lt;&lt;\"+message); &#125; &#125; catch (SocketException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (socket != null &amp;&amp; socket.isClosed() == false) &#123; socket.close(); &#125; scanner.close(); &#125; &#125;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"11.소켓과 스레드의 결합","slug":"bigdata12","date":"2017-08-09T04:15:08.000Z","updated":"2018-09-03T05:53:16.051Z","comments":true,"path":"2017/08/09/bigdata12/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/09/bigdata12/","excerpt":"","text":"여러 클라이언트가 접속가능한 서버EchoServerReceiveThread.java123456789101112131415161718192021222324252627282930313233343536373839public class EchoServer &#123; private static final int SERVER_PORT = 5000; public static void main(String[] args) &#123; ServerSocket serverSocket = null; try &#123; // 1. 서버 소켓 생성 serverSocket = new ServerSocket(); // 2. 바인딩( Binding ) InetAddress inetAddress = InetAddress.getLocalHost(); String localhostAddress = inetAddress.getHostAddress(); serverSocket.bind(new InetSocketAddress(localhostAddress, SERVER_PORT)); System.out.println(\"[Server] binding \" + localhostAddress); while(true) &#123; // 3. 연결 요청 기다림( accept) Socket socket = serverSocket.accept(); // 반복문 내에서 blocking이 되기떄문에 CPU를 많이먹지 않는다. new EchoServerReceiveThread( socket ).start(); &#125; &#125; catch (IOException e) &#123; // 서버소켓과 관련된 캐치 e.printStackTrace(); &#125; finally &#123; try &#123; if (serverSocket != null &amp;&amp; serverSocket.isClosed() == false) &#123; serverSocket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private static void consoLog( String log ) &#123; System.out.println( \"[server:\" ); &#125;&#125; EchoServerReceiveThread.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class EchoServerReceiveThread extends Thread &#123; private Socket socket; public EchoServerReceiveThread( Socket socket ) &#123; this.socket = socket; &#125; @Override public void run() &#123; // 4. 연결성공 InetSocketAddress remoteSocketAddress = (InetSocketAddress) socket.getRemoteSocketAddress(); int remoteHostPort = remoteSocketAddress.getPort(); String remoteHostAddress = remoteSocketAddress.getAddress().getHostAddress(); consoleLog(\"connected from \"+ remoteHostAddress); try &#123; // 5. I/O Stream 받아오기 InputStream is = socket.getInputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(is, \"UTF-8\")); PrintWriter pw = new PrintWriter(socket.getOutputStream(), true); // auto flush를 true로 한다. true로 안하면 // 버퍼가 다찬다음 나가기 때문에 늦게나간다. while (true) &#123; // 6. 데이터 읽기 String message = br.readLine(); if (message == null) &#123; // 정상종료 consoleLog(\"disconnection by client\"); break; &#125; consoleLog(\" received : \" + message); // 7. 데이터 쓰기 pw.println(message); &#125; &#125; catch (SocketException e) &#123; // 상대편이 소켓을 정상적으로 닫지 않고 종료한 경우 consoleLog(\"sudden closed by client\"); &#125; catch (IOException e) &#123; // 소켓과 관련된 캐치 e.printStackTrace(); &#125; finally &#123; try &#123; if (socket != null &amp;&amp; socket.isClosed() == false) &#123; socket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private void consoleLog(String log) &#123; System.out.println(\"[Server: \"+getId() + \"]\" + log); &#125;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"10.쓰레드","slug":"bigdata11","date":"2017-08-09T02:42:34.000Z","updated":"2018-09-03T05:53:13.935Z","comments":true,"path":"2017/08/09/bigdata11/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/09/bigdata11/","excerpt":"","text":"MultiThreadEx.java12345678910111213141516171819202122232425public class MultiThreadEx &#123; public static void main(String[] args) &#123; Thread thread1 = new AlphabetThread(); //쓰레드 생성방법1 Thread thread2 = new Thread( new DigitThread()); //쓰레드 생성방법2 //매개변수로 Runnable이 구현된 객체를 받음 new Thread( new Runnable() &#123; //쓰레드 생성방법3 @Override public void run() &#123; for( char c = 'A'; c&lt;= 'z'; c++) &#123; System.out.print( c ); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;).start();; thread1.start(); thread2.start(); &#125;&#125; DigitThread.java12345678910111213public class DigitThread implements Runnable&#123; public void run() &#123; for(int i = 0; i &lt; 10; i++) &#123; System.out.print( i ); try &#123; Thread.sleep( 1000 ); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; AlphabetThread.java1234567891011121314public class AlphabetThread extends Thread&#123; @Override public void run() &#123; for( char c = 'a'; c &lt;= 'z'; c++) &#123; System.out.print( c ); try &#123; Thread.sleep( 1000 ); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"9. TCP 소켓 프로그래밍1","slug":"bigdata10","date":"2017-08-09T00:05:06.000Z","updated":"2018-09-03T05:53:11.577Z","comments":true,"path":"2017/08/09/bigdata10/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/09/bigdata10/","excerpt":"","text":"TCPTCP : 스트림(stream) 통신 프로토콜양쪽의 소켓이 연결된 상태에서 통신이 가능하다. (연결지향 프로토콜)신뢰성 있는 데이터 통신한 번 연결이 되면 연결이 끊어 질 때까지 송신한 데이터는 차례대로 목적지의 소켓에 전달자바는 java.net 패키지에 TCP 소켓 프로그래밍을 쉽게 하도록 관련 클래스를 제공하고 있다.라이브러리의 사용법과 동작순서를 정확하게 이해하고 있어야 한다.ServerSocket과 Socket 클래스를 사용하게 된다. TCPServer.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class TCPSever &#123; private static final int SERVER_PORT = 5000; public static void main(String[] args) &#123; ServerSocket serverSocket = null; try &#123; // 1. 서버 소켓 생성 serverSocket = new ServerSocket(); // 2. 바인딩( Binding ) InetAddress inetAddress = InetAddress.getLocalHost(); String localhostAddress = inetAddress.getHostAddress(); serverSocket.bind(new InetSocketAddress(localhostAddress, SERVER_PORT)); System.out.println(\"[Server] binding \" + localhostAddress); // 3. 연결 요청 기다림( accept) Socket socket = serverSocket.accept(); // blocking // 4. 연결성공 InetSocketAddress remoteSocketAddress = (InetSocketAddress) socket.getRemoteSocketAddress(); int remoteHostPort = remoteSocketAddress.getPort(); String remoteHostAddress = remoteSocketAddress.getAddress().getHostAddress(); System.out.println(\"[server] connected from \" + remoteHostAddress + remoteHostPort); try &#123; // 5. I/O Stream 받아오기 InputStream is = socket.getInputStream(); OutputStream os = socket.getOutputStream(); while (true) &#123; // 6. 데이터 읽기 byte[] buffer = new byte[256]; int readByteCount = is.read(buffer); // block if (readByteCount &lt;= -1) &#123; //정상종료 System.out.println(\"[server] disconnection by client\"); break; &#125; String data = new String(buffer, 0, readByteCount, \"utf-8\"); System.out.println(\"[server] received : \" + data); // 7. 데이터 쓰기 os.write(data.getBytes(\"utf-8\")); &#125; &#125; catch(SocketException e) &#123; // 상대편이 소켓을 정상적으로 닫지 않고 종료한 경우 System.out.println(\"[server] sudden closed by client\"); &#125;catch (IOException e) &#123; // 소켓과 관련된 캐치 e.printStackTrace(); &#125; finally &#123; try &#123; if (socket != null &amp;&amp; socket.isClosed() == false) &#123; socket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; catch (IOException e) &#123; // 서버소켓과 관련된 캐치 e.printStackTrace(); &#125; finally &#123; try &#123; if (serverSocket != null &amp;&amp; serverSocket.isClosed() == false) &#123; serverSocket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; TCPClient.java123456789101112131415161718192021222324252627282930313233343536373839404142434445public class TCPClient &#123; private static final String SERVER_IP = \"192.168.111.1\"; private static final int SERVER_PORT = 5000; public static void main(String[] args) &#123; Socket socket = null; try &#123; // 1. Socket 생성 socket = new Socket(); // 2. 서버 연결 socket.connect(new InetSocketAddress(SERVER_IP, SERVER_PORT)); // 3. I/O 받아오기 InputStream is = socket.getInputStream(); OutputStream os = socket.getOutputStream(); // 4. 쓰기 / 읽기 String data = \"hello\"; os.write( data.getBytes( \"utf-8\" )); byte[] buffer = new byte[256]; int readByteCount = is.read( buffer ); if( readByteCount &lt;= -1) &#123; System.out.println( \"[client] disconnection by server\"); return; &#125; data = new String( buffer, 0, readByteCount, \"utf-8\"); System.out.println(\"[client] received:\"+ data); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (socket != null &amp;&amp; socket.isClosed() == false) &#123; socket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 에코서버, 클라이언트 만들기 EchoServer.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class EchoServer &#123; private static final int SERVER_PORT = 5000; public static void main(String[] args) &#123; ServerSocket serverSocket = null; try &#123; // 1. 서버 소켓 생성 serverSocket = new ServerSocket(); // 2. 바인딩( Binding ) InetAddress inetAddress = InetAddress.getLocalHost(); String localhostAddress = inetAddress.getHostAddress(); serverSocket.bind(new InetSocketAddress(localhostAddress, SERVER_PORT)); System.out.println(\"[Server] binding \" + localhostAddress); // 3. 연결 요청 기다림( accept) Socket socket = serverSocket.accept(); // blocking // 4. 연결성공 InetSocketAddress remoteSocketAddress = (InetSocketAddress) socket.getRemoteSocketAddress(); int remoteHostPort = remoteSocketAddress.getPort(); String remoteHostAddress = remoteSocketAddress.getAddress().getHostAddress(); System.out.println(\"[server] connected from \" + remoteHostAddress + remoteHostPort); try &#123; // 5. I/O Stream 받아오기 InputStream is = socket.getInputStream(); BufferedReader br = new BufferedReader( new InputStreamReader( is, \"UTF-8\" )); PrintWriter pw = new PrintWriter(socket.getOutputStream(), true); // auto flush를 true로 한다. true로 안하면 //버퍼가 다찬다음 나가기 때문에 늦게나간다. while (true) &#123; // 6. 데이터 읽기 String message = br.readLine(); if ( message == null ) &#123; //정상종료 System.out.println(\"[server] disconnection by client\"); break; &#125; System.out.println(\"[server] received : \" + message); // 7. 데이터 쓰기 pw.println(message); &#125; &#125; catch(SocketException e) &#123; // 상대편이 소켓을 정상적으로 닫지 않고 종료한 경우 System.out.println(\"[server] sudden closed by client\"); &#125;catch (IOException e) &#123; // 소켓과 관련된 캐치 e.printStackTrace(); &#125; finally &#123; try &#123; if (socket != null &amp;&amp; socket.isClosed() == false) &#123; socket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; catch (IOException e) &#123; // 서버소켓과 관련된 캐치 e.printStackTrace(); &#125; finally &#123; try &#123; if (serverSocket != null &amp;&amp; serverSocket.isClosed() == false) &#123; serverSocket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; EchoClient.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class EchoClient &#123; private static final String SERVER_IP = \"192.168.111.1\"; private static final int SERVER_PORT = 5000; static Scanner scanner; public static void main(String[] args) &#123; Socket socket = null; try &#123; // 1. Socket 생성 socket = new Socket(); // 2. 서버 연결 socket.connect(new InetSocketAddress(SERVER_IP, SERVER_PORT)); // 3. I/O 받아오기 BufferedReader br = new BufferedReader( new InputStreamReader(socket.getInputStream())); PrintWriter pw = new PrintWriter( new OutputStreamWriter(socket.getOutputStream(),\"UTF-8\"),true); // 4. 쓰기 / 읽기 scanner = new Scanner(System.in); while(true) &#123; System.out.print( \"&gt;&gt;\" ); String message = scanner.nextLine(); if(\"exit\".equals(message)) &#123; break; &#125; //메세지 보내기 pw.println( message ); //에코 메시지 받기 String echoMessage = br.readLine(); if( echoMessage == null) &#123; System.out.println(\"[client] Disconnection by Server\"); &#125; //출력 System.out.println( \"&lt;&lt;\" + echoMessage ); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (socket != null &amp;&amp; socket.isClosed() == false) &#123; socket.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; scanner.close(); &#125; &#125;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"8. 네트워크와 소켓의 이해","slug":"bigdata9","date":"2017-08-07T05:01:36.000Z","updated":"2018-09-03T05:53:09.107Z","comments":true,"path":"2017/08/07/bigdata9/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/07/bigdata9/","excerpt":"","text":"네트워크란?“유/무선 으로 연결되어 있는 Device들의 집합 ” 네트워킹?디바이스들 간에 미리 정의된 프로토콜을 사용하여 데이터를 교환 하는것.이를위해서는 프로토콜이 필요하다. 클라이언트 서버구조Client -&gt; Serverrequest Server -&gt; Clientresponse(ACK) 서버 : 서버프로그램이 돌고있는 장비 프로토콜디바이스간 데이터 통신을 위해 필요한 규약Hyper Text Transfer ProtocolFile Transfer ProtocolSMTP 등등. 패킷패킷은 Header, Body부분으로 나뉜다.Header은 Address, checksum 등 으로 구성되고Body는 Data로 구성된다. 소켓소켓?TCP / IP 프로토콜의 프로그래머 인터페이스를 의미네트워크 프로그래밍에서 개발자에게 네트워크에 접근할 수 있는 인터페이스 제공 포트?프로세스를 구분할 수 있는 주소16비트 정수를 사용한다. Address =&gt; IP Address Socket Address =&gt; IP Address + Port LocalHost.java123456789101112131415161718192021222324public class LocalHost &#123; public static void main(String[] args) &#123; try &#123; InetAddress inetAddress = InetAddress.getLocalHost(); String hostName = inetAddress.getHostName(); String hostAddress = inetAddress.getHostAddress(); byte[] addresses = inetAddress.getAddress(); //byte배열로 ip 받아오는 함수 System.out.println(hostName); //컴퓨터이름 System.out.println(hostAddress); //ipconfig의 결과와 같음 for( int i = 0 ; i &lt; addresses.length ; i++) &#123; System.out.print( addresses[i] &amp; 0x000000ff); //MSB로 인해 음수가 나와 마스킹을 해주는것. if( i &lt; 3 ) &#123; System.out.print(\".\"); &#125; &#125; &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; &#125;&#125; NSLookup기능을 구현해보자. NSLookup.java12345678910111213141516171819202122232425262728public class NSLookup &#123; public static void main(String[] args) &#123; String host = \"\"; Scanner sc = new Scanner(System.in); while (!(host.equals(\"exit\"))) &#123; try &#123; System.out.print(\"&gt;\"); host = sc.nextLine(); InetAddress[] inetAddresses = InetAddress.getAllByName(host); for (InetAddress inetAddress : inetAddresses) &#123; System.out.println(inetAddress.getHostAddress()); &#125; &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; System.out.println(); &#125; &#125;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"7. 스트림","slug":"bigdata8","date":"2017-08-07T00:17:29.000Z","updated":"2018-09-03T05:53:02.245Z","comments":true,"path":"2017/08/07/bigdata8/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/07/bigdata8/","excerpt":"","text":"InputStream - 1 byte 단위로 읽는놈ByteInputStreamFileInputStream FilterInputStream(보조스트림) OutputStream - 1 byte 단위로 쓰는놈ByteOutputStreamFileOutputStream FilterOutputStream(보조스트림) Reader - char(2byte, 자바에서는 3byte(UTF-8)) 단위로 읽는놈FileReader(InputStreamReader을 상속)BufferedReader Writer - char(2byte, 자바에서는 3byte(UTF-8)) 단위로 쓰는놈FileWriterBufferedWriter 사용방법1.주 스트림을 소스에 꽂는다.2.보조스트림은 주 스트림에 꽂는다.3.프로그램에서 보조스트림을 사용해서 읽는다. IOExample.java12345678910111213141516171819202122232425public class IOExample &#123; public static void main(String[] args) &#123; byte[] src = &#123;0, 1, 2, 3&#125;; byte[] dest = null; try &#123; InputStream is = new ByteArrayInputStream( src ); OutputStream os = new ByteArrayOutputStream(); int data = -1; while( (data = is.read()) != -1 ) &#123; //data에 1바이트식 저장됨 os.write(data); &#125; dest = ((ByteArrayOutputStream)os).toByteArray(); System.out.println( Arrays.toString( src )); System.out.println( Arrays.toString( dest )); &#125; catch( IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; FileCopy.java1234567891011121314151617181920212223242526272829303132public class FileCopy &#123; public static void main(String[] args) &#123; InputStream is = null; OutputStream os = null; try &#123; is = new FileInputStream( \"./dooly.png\" ); os = new FileOutputStream( \"./dooly2.png \"); int data = 1; while( (data = is.read()) !=-1 ) &#123; os.write( data ); &#125; &#125; catch (FileNotFoundException e) &#123; System.out.println(\"파일없음\" + e); &#125; catch (IOException e) &#123; System.out.println(\"I/O 에러\" + e); &#125; finally &#123; try&#123; if( is != null) &#123; is.close(); &#125; if( os != null) os.close(); &#125;catch(IOException e) &#123; &#125; &#125; &#125;&#125; 123.txt를 UTF-8로 만들고(직접만들자)FileReader로 1바이트씩 읽어보고FileInputStream으로 3(UTF-8이므로..) 바이트씩 읽어보자 FileReaderTest.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class FileReaderTest &#123; public static void main(String[] args) &#123; Reader reader = null; InputStream is = null; try &#123; //비교를 위해서 두개를 만들었다. reader = new FileReader( \"./hello.txt\" ); //char 기반 is = new FileInputStream( \"./hello.txt \"); //바이트기반 int count = 0; int data = -1; while( (data = reader.read()) != -1 ) &#123; count++; System.out.println( (char)data ); &#125; System.out.println( \"\\n읽은 회수: \" + count ); System.out.println(\"=========\"); count = 0; data = -1; while( (data = is.read() )!= -1) &#123; count++; System.out.println( (char) data); &#125; &#125; catch (FileNotFoundException e) &#123; System.out.println( \"파일 없음 \" + e ); &#125; catch (IOException e) &#123; System.out.println(\"I/O 에러:\" + e); &#125; finally &#123; try &#123; if( reader != null) &#123; reader.close(); &#125; if( is != null) &#123; is.close(); &#125; &#125;catch(IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 보조스트림을 사용하여 보자 BufferedOutputStreamTest.java12345678910111213141516171819202122232425262728public class BufferedOutputStreamTest &#123; public static void main(String[] args) &#123; BufferedOutputStream bos = null; try &#123; bos = new BufferedOutputStream( new FileOutputStream( \"./123.txt\" ), 5 ); //버퍼가 5의 크기를 갖는다 5만큼 차면 flush(비우기)가 발생함 for(int i='1' ; i &lt;= '9' ; i++) &#123; bos.write( i ); //bos.flush(); //한번쓰고 플러시하고를 반복.(버퍼를 5로 설정한 의미가 없어짐..) &#125; &#125; catch (FileNotFoundException e) &#123; System.out.println(\"파일 없음: \" + e); &#125; catch (IOException e) &#123; System.out.println(\"I/O 에러\" + e); &#125; finally &#123; try &#123; if( bos!= null) &#123; bos.close(); &#125; &#125; catch( IOException e) &#123; &#125; &#125; &#125;&#125; 주스트림 FileReader을 꽂고보조스트림 BufferedReader을 꽂음. BufferedOutputStreamTest.java123456789101112131415161718192021222324252627282930public class BufferedReaderTest &#123; public static void main(String[] args) &#123; BufferedReader br = null; try &#123; br = new BufferedReader( new FileReader(\"./src/io/BufferedReaderTest.java\")); int index = 0; String line = null; while((line = br.readLine())!= null) &#123; System.out.println(++index + \" : \" + line); &#125; &#125; catch( FileNotFoundException e) &#123; System.out.println(\"파일없음: \" + e); &#125; catch( IOException e) &#123; System.out.println(\"I/O 에러\" + e); &#125; finally &#123; try &#123; if(br != null) &#123; br.close(); &#125; &#125;catch(IOException e) &#123; System.out.println(\"파일없음\"+e); &#125; &#125; &#125;&#125; MS 949로 텍스트 파일을 하나만들자.FileInputStream 주 스트림을 바이트단위로 꽂고 InputStreamReaderTest.java12345678910111213141516171819202122232425262728293031public class InputStreamReaderTest &#123; public static void main(String[] args) &#123; Reader reader = null; try &#123; reader = new InputStreamReader( new FileInputStream(\"./ms949.txt\"), \"MS949\" ); int data = -1; while( ( data = reader.read()) != -1 ) &#123; System.out.println( (char)data ); &#125; &#125; catch (UnsupportedEncodingException e) &#123; System.out.println(\"지원하지 않는 charset\"); &#125; catch (FileNotFoundException e) &#123; System.out.println(\"파일이 없음:\" + e); &#125; catch (IOException e) &#123; System.out.println(\"IOException:\"+e); &#125; finally &#123; try &#123; if( reader!=null) &#123; reader.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; System.in으로 부터 스트림을 생성해보자KeyboardTest.java12345678910111213141516171819202122232425262728293031323334353637383940public class KeyboardTest &#123; public static void main(String[] args) &#123; BufferedReader br = null; try &#123; br = new BufferedReader(new InputStreamReader(System.in, \"UTF-8\")); //키보드에서 라인 단위로 읽기 위해 br사용 //readLine() 메소드를 쓰기위해 while(true) &#123; System.out.print( \"&gt;&gt;\" ); String line = br.readLine(); if (line == null ) &#123; break; &#125; if( \"exit\".equals( line )) &#123; break; &#125; System.out.println(line); &#125; &#125; catch (UnsupportedEncodingException e) &#123; System.out.println(\"지원하지 않는 charset : \"+e); &#125; catch (IOException e) &#123; System.out.println(\"I/O 에러\" + e); &#125; finally &#123; try &#123; if(br != null) &#123; br.close(); &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;&#125; 파일 객체사용해보자.tokenizer도 사용해보자PhoneList01.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class PhoneList01 &#123; public static void main(String[] args) &#123; BufferedReader br = null; try &#123; File file = new File( \"./phone.txt\" ); if( file.exists() == false ) &#123; System.out.println( \"파일이 존재하지 않습니다\" ); return; &#125; System.out.println( \"========== 파일정보 =========\" ); System.out.println( \"경로\" + file.getAbsolutePath() ); System.out.println( \"크기: \"+ file.length()+\"Bytes\" ); Date date = new Date( file.lastModified() ); SimpleDateFormat sdf = new SimpleDateFormat (\"yyyy-MM-dd hh:mm:ss\"); System.out.println( \"마지막 수정일:\" + sdf.format(date)); System.out.println( \"전화번호\"); br = new BufferedReader( new InputStreamReader( new FileInputStream(file),\"UTF-8\") ); String line = null; while((line = br.readLine())!=null) &#123; //System.out.println(line); StringTokenizer st = new StringTokenizer(line, \"\\t \"); int index = 0; while( st.hasMoreTokens() ) &#123; String s = st.nextToken(); if(index == 0 ) &#123; System.out.print( s + \":\"); &#125; else if( index ==1 ) &#123; System.out.print( s+ \"-\"); &#125; else if( index == 2) &#123; System.out.print( s+ \"-\"); &#125; else &#123; System.out.print( s); &#125; index++; &#125; System.out.print(\"\\n\"); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch ( UnsupportedEncodingException e) &#123; System.out.println(\"지원하지 않는 charset\"); &#125; catch(IOException e) &#123; &#125; finally &#123; if( br !=null) &#123; try &#123; br.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;위에서 했던 작업을 Scanner로 간편하게 해보자PhoneList02.java1234567891011121314151617181920212223242526272829303132333435363738394041424344public class PhoneList02 &#123; public static void main(String[] args) &#123; Scanner scanner = null; try &#123; File file = new File(\"./phone.txt\"); if (file.exists() == false) &#123; System.out.println(\"파일이 존재하지 않습니다\"); return; &#125; System.out.println(\"========== 파일정보 =========\"); System.out.println(\"경로\" + file.getAbsolutePath()); System.out.println(\"크기: \" + file.length() + \"Bytes\"); Date date = new Date(file.lastModified()); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\"); System.out.println(\"마지막 수정일:\" + sdf.format(date)); System.out.println(\"전화번호\"); // 여기까지는 PhoneList01과 같다 scanner = new Scanner(file); while( scanner.hasNext() ) &#123; String name = scanner.next(); String phone1 = scanner.next(); String phone2 = scanner.next(); String phone3 = scanner.next(); System.out.println(name + \":\" + phone1 + \"-\" + phone2 + \"-\" + phone3); &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if ( scanner != null ) &#123; scanner.close(); &#125; &#125; &#125;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"6. 제네릭, 가변변수, 익명클래스, Collection프레임워크","slug":"bigdata7","date":"2017-08-07T00:04:17.000Z","updated":"2018-09-03T05:52:59.798Z","comments":true,"path":"2017/08/07/bigdata7/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/07/bigdata7/","excerpt":"","text":"제네릭오버로딩을 대체할 수 있으며 유용하다. 메소드에 제네릭을 적용12345678public &lt;T,P,Q,R&gt; void println( T t ) &#123; System.out.println(t);&#125;public static void main(String args[]) &#123; println( 10 ); println( true );&#125; 메소드 반환형에 제네릭 적용1234567public &lt;T, P&gt; List&lt;P&gt; println( T t ) &#123; System.out.println( t ); List&lt;P&gt; list = new ArrayList&lt;P&gt;(); return list;&#125; 제네릭 배열을 어떻게 동적으로 생성하느냐12345678910111213public MyStack( E[] objects, int capacity ) &#123; //buffer = new E[ capacity ]; 오류발생 //방법1. buffer = ( E[] ) Array.newInstance(objects.getClass(), capacity); //방법2. 방법2가 더 선호된다. 객체를 생성하지 않아도 된다는점 때문에 buffer = ( E[] )Array.newInstance(Object.class, capacity); //방법3. 방법 2와 일치하는방식이다. buffer = ( E[] )new Object[capacity]; //방법 3을 제일 많이 쓴다. this.capacity = capacity; currentIndex = 0;&#125; 제네릭 호출 방식123456789101112131415public static void main(String[] args) &#123; MyStack&lt;String&gt; stack = new MyStack&lt;String&gt;(3); //String의 스택을 생성한다. MyStack&lt;?&gt; stack = new MyStack&lt;String&gt;(3); //모든 타입의 객체를 생성하겠다.&#125;public .... f(List&lt;? extends Shape&gt;)&#123; // Shape를 상속한 것들의 리스트를 파라미터로 받음 //와일드 카드를 사용해서 제네릭 타입 제한하기. ...&#125; 가변변수가변변수를 배우기 전에는 파라미터에 배열을 넣을 생각을 할 것이다. 하지만 이를 대체할 수 있는것이 가변변수이다. 1234567891011121314public static void main(String args[]) &#123; println2( \"둘리\" ); println2( \"둘리\", \"마이콜\" ); println2( \"둘리\", \"마이콜\", \"또치\"); //println3( new String[]&#123;\"둘리\", \"마이콜\", \"또치\"&#125;); 배열사용 &#125; public static void println2(String ... params) &#123; for( String s : params)&#123; System.out.println(s); &#125; &#125; 아래의 경우 Object를 파라미터로 주면 캐스팅을 계속 해줘야한다.1234567public &lt;T&gt; void println( T t) &#123; System.out.println(t);&#125;public void println(Object o ) &#123; System.out.println(o);&#125; 익명클래스파라미터를 전달하는 부분에서 객체를 생성하여 메소드를 호출.객체를 생성하지 않고 메소드 호출부분에서 객체를 생성함.123456789//anonymous class objectdraw( new Drawable() &#123; @Override public void draw() &#123; // TODO Auto-generated method stub System.out.println(\"한 번만 만들고 버릴 도형을 그렸습니다\"); &#125; &#125;); CollectionCollection인터페이스는 inteator() 메소드를 갖고 있다.List, Set 클래스는 Collection클래스를 구현하며 List는 중복허용, 순서를 갖는다. 그러나 Set는 중복을 허용하지 않으며 순서를 갖지 않는다.List인터페이스는 add, get, remove를 갖는다.LinkedList, ArrayList가 List 인터페이스를 구현한다. ArrayList는 빈번한 삽입,삭제가 일어나는 경우 사용하면 안된다. 그 과정이 길기 떄문에.LinkedList는 삽입삭제가 유용하나 10000번째 놈이면 10000번을 next해야한다. 멀티스레드에서 ArrayList, LinkedList의 add를 사용할 때는 동기화 처리를 해줘야한다. 하지만 Vector은 멀티스레드 환경에서 동기화를 해주지 않아도 된다. ArrayList , LinkedList, VectorTest21234567891011121314151617181920212223242526272829303132333435public class ArrayListTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); LinkedList&lt;String&gt;(); Vector&lt;String&gt;(); //삽입 list.add( \"둘리\" ); list.add( \"마이콜\" ); list.add( \"도우넛\" ); //순회1 int count = list.size(); for( int i = 0; i &lt; count ; i++) &#123; String s = list.get( i ); System.out.println(i); &#125; //제거 list.remove( 1 ); //순회2 Iterator&lt;String&gt; it = list.iterator(); while( it.hasNext() ) &#123; String s = it.next(); System.out.println( s ); &#125; //순회3 for( String s : list) &#123; System.out.println( s ); &#125; &#125;&#125; Vector1.2 시대의 Vector인터페이스는 addElement, elementAt, removeElement, elements메소드를 갖고 있다. 그 후 1.2이후에 생긴 List를 구현하여 List의 메소드를 갖는다. Vector를 사용하려면 Vector 메소드를 사용하거나 List 인터페이스 내부의 메소드만 사용하든가 해야 복잡해지지 않는다. 과거 Vector을 사용하는 방식. 호환성 때문에 존재할뿐.. 사용일 지양하자.VectorTest.java123456789101112131415161718192021222324252627public class VectorTest &#123; public static void main(String[] args) &#123; Vector&lt;String&gt; v = new Vector&lt;String&gt;(); v.addElement( \"둘리\" ); v.addElement( \"마이콜\" ); v.addElement( \"도우넛\" ); //순회1 Enumeration&lt;String&gt; e = v.elements(); while( e.hasMoreElements() ) &#123; String s = e.nextElement(); System.out.println( s ); &#125; //삭제 v.removeElementAt( 1 ); System.out.println(\"=====================\"); //순회2 int count = v.size(); for( int i=0; i&lt; count; i++) &#123; String s = v.elementAt( i ); System.out.println( s ); &#125; &#125;&#125; SetSet 인터페이스는 key, value로 구성된다. key를 통해 value에 접근할 수 있다.HashSet, TreeSet가 Map인터페이스를 구현한다.hashCode를 오버라이드 하여 사용하여야 한다. 123456789101112131415161718192021222324252627282930public class HashSetTest &#123; public static void main(String[] args) &#123; Set&lt;Value&gt; set = new HashSet&lt;Value&gt;(); Value v1 =new Value(10); Value v2 =new Value(5); Value v3 =new Value(10); Value v4 =new Value(20); set.add(v1); set.add(v2); set.add(v3); set.add(v4); //존재여부 확인 System.out.println(set.contains(new Value(10))); //삭제 set.remove( new Value(10) ); //순회 Iterator&lt;Value&gt; it = set.iterator(); while( it.hasNext() )&#123; Value v = it.next(); System.out.println(v); &#125; &#125;&#125; 성능향상을 위해 hash를 오버라이드 한다.12345678910111213141516171819202122232425262728293031323334public class Value &#123; private int value; public Value( int value ) &#123; this.value = value; &#125; @Override public String toString() &#123; return \"Value [value=\" + value + \"]\"; &#125; @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + value; return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Value other = (Value) obj; if (value != other.value) return false; return true; &#125; Stack12345678910111213141516171819202122public class StackTest &#123; public static void main(String[] args) &#123; Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); stack.push(\"둘리\"); stack.push(\"마이콜\"); stack.push(\"도우넛\"); stack.push(\"길동\"); System.out.println( stack.isEmpty() ); System.out.println( stack.pop() ); System.out.println( stack.pop() ); System.out.println( stack.peek() ); //pop을 하지않고 확인만 System.out.println( stack.pop() ); System.out.println( stack.pop() ); //스택은 비어있는 경우 pop호출 시 예외가 발생한다. System.out.println( stack.pop() ); &#125;&#125; Queue123456789101112131415161718192021222324public class QueueTest &#123; public static void main(String[] args) &#123; Queue&lt;String&gt; queue = new LinkedList&lt;String&gt;(); queue.offer(\"둘리\"); queue.offer(\"마이콜\"); queue.offer(\"도우너\"); queue.offer(\"길동\"); System.out.println( queue.isEmpty() ); System.out.println( queue.poll() ); System.out.println( queue.poll() ); System.out.println( queue.peek() ); System.out.println( queue.poll() ); System.out.println( queue.poll() ); System.out.println( queue.isEmpty() ); System.out.println( queue.poll() ); //스택은 예외가 발생했지만 큐는 null이 리턴된다. &#125;&#125; MapMap 인터페이스가 존재하는데 HashMap, HashTable가 이를 구현한다. 1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); map.put(\"둘리\", 100); map.put(\"마이콜\", 50); map.put(\"도우넛\", 80); map.put(\"길동\", 90); //중복 map.put( \"둘리\" , 0); //덮어쓴다. //auto unboxing int score = map.get( \"둘리\" ); System.out.println(score); map.remove( \"둘리\" ); //평균 ( 키를 모르는데 어떻게할까?) int sum = 0; Set&lt;String&gt; keySet = map.keySet(); Iterator&lt;String&gt; it = keySet.iterator(); while( it.hasNext() ) &#123; String key = it.next(); System.out.println( key ); int s = map.get( key ); sum += s; &#125; System.out.println( \"평균 : \"+ sum / keySet.size() );&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"5.자바기본API(유틸리티API)","slug":"bigdata6","date":"2017-08-04T05:10:31.000Z","updated":"2018-09-03T05:52:57.347Z","comments":true,"path":"2017/08/04/bigdata6/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/04/bigdata6/","excerpt":"","text":"날짜date 보다는 calendar을 쓰라고 권고한다. DateWrapperClassTest.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class DateTest &#123; public static void main(String[] args) &#123; Date now = new Date(); System.out.println( now ); printDate1(now); printDate2(now); // 특정시간 세팅(200/08/04) Date d1 = new Date(100, 7, 4, 14, 30, 30); printDate2( d1 ); //1970년 1월 1일 00:00:00 기준 //milliseconds 값을 세팅 Date d3 = new Date( 24L * 60 * 60 * 1000 * 365 * 30); printDate2(d3); &#125; private static void printDate1( Date date ) &#123; SimpleDateFormat sdf = new SimpleDateFormat( \"YYYY년 MM월 dd일 hh시 mm분 ss초\" ); System.out.println(sdf.format(date)); &#125; private static void printDate2( Date date) &#123; //년도 (+1900) int year = date.getYear(); //월(0~11) int month = date.getMonth(); //일 int day = date.getDay(); //시 int hour = date.getHours(); //분 int minutes = date.getMinutes(); //초 int seconds = date.getSeconds(); System.out.println( (year + 1900) + \"년 \" + (month + 1)+ \"월 \" + day + \"일 \" + hour + \"시 \" + minutes + \"분\" + seconds + \"초\" ); &#125;&#125; 싱글톤어플리케이션에서 객체 하나만 유지하고 싶을 떄 이 방법을 쓴다.Singleton.java123456789101112131415public class Singleton &#123; private static Singleton instance; public static Singleton getInstance() &#123; if(instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; private Singleton() &#123; //생성자를 private로 하여 객체 생성을 외부에서 불가능하도록 &#125;&#125;싱글톤 클래스를 활용해보자SingletonTest.java123456789101112public class SingletonTest &#123; public static void main(String[] args) &#123; Singleton s1 = Singleton.getInstance(); Singleton s2 = Singleton.getInstance(); Singleton s3 = Singleton.getInstance(); System.out.println(s1 == s2); System.out.println(s2 == s3); &#125;&#125; CalendarCalendar클래스는 추상클래스이다.(객체생성 불가능)WrapperClassTest.java12345678910111213141516171819202122232425262728293031323334public class CalendarTest &#123; public static void main(String[] args) &#123;// Calendar cal = new Calendar(); //추상클래스라 객체생성 불가능 Calendar cal = Calendar.getInstance(); //어플리케이션에서 이 객체 하나만 유지하고 싶을 떄 이 방법을 쓴다. 싱글톤 패턴이라함 printDate( cal ); &#125; public static void printDate( Calendar cal ) &#123; String[] days = &#123;\"일\",\"월\",\"화\",\"수\",\"목\",\"금\",\"토\"&#125;; int year = cal.get( Calendar.YEAR ); int month = cal.get( Calendar.MONTH ); int date = cal.get( Calendar.DATE ); //1(일요일) ~ 7(토요일) int day = cal.get( Calendar.DAY_OF_WEEK); int hour = cal.get( Calendar.HOUR ); int minute = cal.get( Calendar.MINUTE ); int seconds = cal.get( Calendar.SECOND ); System.out.println( (year) + \"년 \" + (month + 1)+ \"월 \" + date + \"일 \" + \"(\" + days[day-1] + \")\" + hour + \"시 \" + minute + \"분\" + seconds + \"초\" ); &#125;&#125; WrapperClassTest.java1","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"4. 자바기본 API(equals, wrapper클래스)","slug":"bigdata5","date":"2017-08-03T02:25:31.000Z","updated":"2018-09-03T05:52:53.412Z","comments":true,"path":"2017/08/03/bigdata5/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/03/bigdata5/","excerpt":"","text":"StringString 인스턴스 안에는 char 배열이 존재하는것이다.String은 toString를 오버라이딩 하여 안에 내용이 출력된다.toString를 오버라이딩 하여 인스턴스에 대한 정보를 확인할 수 있게 만드는 것은 좋은 습관이다. 디버깅할때 편하다는 장점이 있다. equals결과를 예측해보자12345678910111213141516171819202122232425262728293031public class EqualsTest &#123; public static void main(String[] args) &#123; Point point1 = new Point(10, 20); Point point2 = new Point(10, 20); Point point3 = point2; // ==연산자에서 두 개의 항이 객체 참조 변수 인 경우 // 두 개체의 동일 여부(동일성) System.out.println( point1 == point2 ); //false System.out.println( point2 == point3 ); //true //equals는 오버라이딩이 되지 않았을 경우 참조값 비교를 함.(동질성 비교) //해쉬코드를 갖고와서 비교를함(해쉬코드==참조값) System.out.println( point1.equals(point2) ); //false System.out.println( point2.equals(point3) ); //true System.out.println(\"================\"); //String 객체와 비교 //String는 equals가 오버라이딩 되어있다. String s1 = new String( \"hello\" ); String s2 = new String( \"hello\" ); String s3 = s2; System.out.println( s1 == s2 ); //false System.out.println( s2 == s3 ); //true System.out.println( s1.equals(s2) ); //true System.out.println( s2.equals(s3) ); //true &#125; equals를 오버라이딩 해보자hashCode()메소드도 오버라이딩이 필요하다.자바에서는 hashCode() equal() 메소드를 동시에 오버라이드 해야한다.equals 조건을 제곱으로 한다면 hashCode도 제곱으로 변경해주어야 한다.그렇지 않으면 해쉬맵 해쉬 셋을 쓸 때 어려워진다.Point.java123456789101112131415161718192021222324252627282930public class Point &#123; private int x; private int y;.. @Override public int hashCode() &#123; final int prime = 31; int result = 1; result = prime * result + x; result = prime * result + y; return result; &#125; @Override public boolean equals(Object obj) &#123; if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Point other = (Point) obj; if (x != other.x) return false; if (y != other.y) return false; return true; &#125; 결과를 예측해보자12345678910// String Literal // 문자열 상수 Pool에 있는것을 재사용함// 문자열 상수 Pool을 공유하기 때문에 문자열의 수정이 불가능하다.// str1의 변경은 가능하나 문자열 상수인 hello의 값이 변경 불가능하다는것.String str1 = \"hello\";String str2 = \"hello\";String str3 = str2;System.out.println( str1 == str2 ); //trueSystem.out.println( str2 == str3 ); //true new String(“문자열”) “문자열”의 차이는?위의 결과를 보고 잘 생각해 보자문자열은 변경되지 않는다는점을 잘 생각하자.변한다면 참고하고 있는 다른 참조변수들이 피해를 본다.. 잘생각해보자12345678910111213141516171819202122public static void main(String[] args) &#123; String str1 = \"abc\"; String str2 = \"cde\"; String str3 = str2; str2 = str3.toUpperCase(); System.out.println(str1); System.out.println(str2); System.out.println(str3); String str4 = str2.concat(\"??\"); System.out.println(str2); System.out.println(str4);// String s = \"!\";// String str5 = s.concat(str2);// Method chain String str5 = \"!\".concat(str2); //위의 코드와 별다른 차이가 없다. System.out.println(str5);&#125; String 메소드의 사용법 및 활용123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class StringTest03 &#123; public static void main(String[] args) &#123; String s= \"abcAbcabcABC\"; //charAt char c = s.charAt( 2 ); System.out.println( c ); //indexOf System.out.println( s.indexOf( \"Abc\" ) ); //3 System.out.println( s.indexOf(\"ab\") ); //0 System.out.println( s.lastIndexOf(\"ab\") ); //6 System.out.println( s.indexOf( \"XYZ\" )); //-1 반환 //replace System.out.println( s.replace(\"bc\", \"12\") ); //s가 바뀌지는 않음 System.out.println( s.replaceAll(\"bc\", \"12\") ); //s가 바뀌지는 않음 //substring System.out.println( s.substring( 3, 7) ); //3~6까지 나온다 //case System.out.println( s.toLowerCase() ); System.out.println( s.toUpperCase() ); //concat String str1 = \" ab cd \"; String str2 = \",efg\"; str1 = str1.concat(str2); //trim System.out.println( \"---\" + str1 + \"---\" ); //--- ab cd ,efg--- System.out.println( \"---\" + str1.trim() + \"---\" );//---ab cd ,efg--- //split String[] tokens = str1.split(\",\"); for( String token : tokens) &#123; // ab cd System.out.println( token ); // efg &#125; //split 예외 tokens = \"abcdefg\".split( \",\" ); for( String token : tokens) &#123; System.out.println( token ); //abcdefg &#125; tokens = \"\".split( \",\" ); System.out.println( tokens.length ); // 1 &#125;&#125; StringBufferStringBuffer는 가변크기의 버퍼를 가짐.“abc” + “cde” (String) 보다는 StringBuffer를 쓰는게 낫다.전자의 경우 런타임 때 “abc”를 스트링 버퍼로 만들고 append(“cde”)후 toString()를 통해 값을 반환한다.String를 사용해도 되지만 append의 작업이 많을 경우 StringBuffer사용하는것이 빠르다.123456789101112131415161718192021222324252627282930313233public static void main(String[] args) &#123;//생성StringBuffer sb = new StringBuffer( \"this\" );System.out.println(sb.length() + \":\" + sb.capacity()); //4:20//버퍼의 크기를 문자의 크기보다 크게 생성함(append를 염두)//문자열추가sb.append(\" is pencil\");System.out.println( sb );//삽입sb.insert(7, \" my\");System.out.println( sb ); //this is my pencil//치환sb.replace( 8, 10, \"your\" );System.out.println( sb );//버퍼 크기sb.setLength( 3 );System.out.println( sb );//문자열 + 연산은 내부적으로 StringBuffer 객체로 변환String s1 = \"Hello\" + \" World\" + 10 +true;System.out.println(s1); //Hello World10true//다음과 코드가 같은것.String s2 = new StringBuffer( \"Hello\" ).append( \" World\" ).append( 10 ).append( true ).toString();System.out.println(s1); //Hello World10trueSystem.out.println(s2); //Hello World10true&#125; Wrapper 클래스기본형 보다는 Wrapper 클래스를 쓰고자하는 움직임이 많이 발생하고 있다. WrapperClassTest.java1234567891011121314151617181920public class WrapperClassTest &#123; public static void main(String[] args) &#123; Integer i = new Integer(10); Character c = new Character( 'c' ); Float f = new Float ( 3.14 ); Boolean b = new Boolean( true ); //Auto Boxing Integer j = 10; //int k = 20 + j.intValue(); //Auto Unboxing int k = 20 + j; &#125; public static void swap( Integer a, Integer b ) &#123; // 상수풀 운영원칙 때문에 객체이지만 내부를 수정할 수 없다. &#125;&#125; 정규식을활용하여 정수인지 확인WrapperClassTest2.java12345678910111213141516171819202122public class WrapperClassTest2 &#123; public static void main(String[] args) &#123; System.out.println( Character.toLowerCase( 'a' )); System.out.println( Character.isDigit( '1' )); System.out.println( Character.isDigit( '@' )); //String는 isdigit가 존재하지 않는다. String s = \"1234\"; if(s.matches(\"-?\\\\d+\") == false ) &#123; System.out.println(\"숫자가 아닙니다\"); &#125; else &#123; int i = Integer.parseInt(s); &#125; // 프로그램 로직(변수 검증) 할 때는 // try - catch 문으로 하지 말것. // 비용이 많이든다. //정규식을 활용하자 &#125;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"3. 패키지, 예외","slug":"bigdata4","date":"2017-08-03T01:41:54.000Z","updated":"2018-09-03T05:52:48.248Z","comments":true,"path":"2017/08/03/bigdata4/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/03/bigdata4/","excerpt":"","text":"LinkedList탐색의 경우 O(n) / 삽입 삭제의 경우 간단. ArrayList탐색의 경우 O(1) / 삽입 삭제의 경우 쭉~ 밀려남 패키지java.lang.* - 명시적으로 지정하지 않아도 자동으로 import 되는 패키지.자바 프로그램이 기본적으로 필요로 하는 클래스와 인터페이스 포함 java.io.* - 데이터를 입력받고 출력할 수 있도록 하는 클래스 포함 java.net.* - 네트워크를 통하여 통신할 수 있도록 해주는 클래스 포함 java.util.* - 날짜/시간 조작, 난수 발생 등 각종 유틸리티 클래스와 인터페이스 포함 예외처리예외프로그램이 실행되는 동안 발생할 수 있는 비정상적인 조건번역시의 에러가 아닌 실행시의 에러를 예외라 함 자바에서의 예외처리예외처리를 위한 Exception 클래스 정의기본적인 예외는 자바에 미리 정의된 예외를 통해 처리 가능사용자가 필요한 예외를 직접 정의할 수 있음예상되는 예외는 미리 처리해주면 무조건적인 프로그램의 종료를 피할 수 있음예외처리의 사용은 프로그램의 신뢰성을 높여줌 try catch 문catch문에서 예외가 발생하면 복구시키는게 목표이다. 하지만 그게 말이 쉽지 복구라는건 불가능한 경우가 많이있다.try catch는 가독성을 떨어뜨린다는 단점이 있다.ex) 상대방이 랜선을 뽑아서 캐치에 왔다면 어쩔래 finally는 옵션이다.주로 자원정리가 목적이다. 예외가 발생하던 안하던 들어감.심지어 try에서 return 을 해도 finally가 실행된다. 123456789101112int result=0;int a = 1;try &#123; result = 1000 / a; return;&#125;catch(ArithmeticException e) &#123; System.out.println(\"예외발생\"); return;&#125; finally &#123; System.out.println(\"자원정리\"); //실행된다.&#125; checked Exception메소드를 사용하기 위해서는 반드시 예외를 처리해 줘야함 (ex&gt; FileInputStream) 실습1.1234567891011121314public static void main(String[] args) &#123; FileInputStream fis = null; try &#123; fis = new FileInputStream( \"./hello.txt\" ); int data = fis.read(); &#125; catch(FileNotFoundException|NullPointerException e) &#123; /*여러개의 예외를 처리*/ &#125; catch (Exception e) &#123; /*모든예외를 처리하고 싶을 때*/ &#125; 실습2. 나의 Exception 정의MyException 정의MyException.java12345678910public class MyException extends Exception&#123; public MyException() &#123; super( \"MyException Occurs\" ); &#125; public MyException( String message ) &#123; super( message ); &#125;&#125; MyClass 정의 MyClass.java123456789101112131415public class MyClass &#123; public void danger() throws MyException &#123; System.out.println( \"some code1\" ); System.out.println( \"some code2\" ); if( 1==1 ) &#123; throw new MyException(\"MyClass Exception 발행\"); &#125; System.out.println( \"some code3\" ); System.out.println( \"some code4\" ); &#125;&#125; MyClassTest 정의MyClassTest.java1234567891011public class MyClassTest &#123; public static void main(String[] args) &#123; try &#123; MyClass myClass = new MyClass(); myClass.danger(); &#125; catch (MyException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"2. 오버로드,오버로딩,추상클래스,인터페이스","slug":"bigdata3","date":"2017-08-03T00:27:12.000Z","updated":"2018-09-03T05:52:44.872Z","comments":true,"path":"2017/08/03/bigdata3/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/03/bigdata3/","excerpt":"","text":"오버로드아래는 다 다른 메소드이다.12345678void a (int a, int b)..void a (int a, float b)...void a (float a, int b)... 아규먼트 , 파라미터아규먼트는 int ,float 등 형을 의미파라미터는 실제적인 데이터 10, 0.5 등을 의미. 식별자클래스 이름, 변수이름, 메소드 이름을 식별자라 한다.대소문자 가능 숫자 가능 하지만 앞에는 안되고 특수문자는 $ _ 만 사용가능. 생성자기본으로 디폴트 생성자가 만들어지지만 생성자가 하나라도 정의되어 있으면 디폴트 생성자가 생성되지 않는다. 다형성외부에서 사용할 땐 일관되게 사용하는것.오버로딩, 오버라이딩을 통해 구현 thisthis 키워드는 메소드 호출을 받는 객체를 의미한다.현재 사용중인 객체 그 자체를 의미한다.this() 는 클래스의 한 생성자에서 다른 생성자를 호출 할 때 사용할 수 있다 오버로딩부모에있는 메소드와 시그니쳐가 동일(접근제어자 , 반환형, 메소드이름, 아규먼트) 생성자 관련 문제상속관계에서 자식 클래스의 인스턴스를 생성하면 부모 혹은 자식 생성자중 어떤것이 먼저 호출될까? 12345678910부모 생성자public Parent()&#123; syso(\"부모 호출됨\");&#125;자식 생성자public Child()&#123; syso(\"자식 호출됨\");&#125; 부모 생성자가 먼저 호출된다.즉 자식 메소드의 생성자 안에(8행) super(); (기본생성자 호출)가 자동으로 삽입된것이다. int형 매개변수가 존재하는 부모 생성자를 호출하려면 8행에 super(35); 를 넣어주면 된다. 캐스팅형은 높은데에서 낮은곳으로 가면 명시적으로 알려줘야 하지만 , 인스턴스는높은곳(부모) 낮은곳(자식) 으로 가려면 명시를 해줘야 한다.다운캐스팅의 예(Explicity Casting 명시적 캐스팅)123456//방법 1Person p = new Student();Student s1 = (Student)p;//방법 2((Student)p).set(); 업캐스팅의 예(Implicity Casting 암시적 캐스팅)1Person p2 = s1; 추상클래스추상화객체들이 가지고 있는 속성과 기능 중에 중요한 것들은 남기고 필요 없는 불필요한 것은 없애는것. 또는 공통된 것들을 그룹핑해서 한곳에다 모아놓는것. 추상클래스new를 통해 객체를 생성하지는 못한다.필드를 갖을 수 있고, 구현된 메소드를 갖을 수 있다.추상 클래스를 상속하는 클래스는 반드시 추상 클래스의 추상 메소드를 구현해야 함추상 클래스간의 상속에서는 추상클래스를 구현하지 않아도 됨추상 클래스의 활용여러 클래스들이 상당수 공통점을 가지고 있으나 부분적으로 그 처리 방식이 다를 경우 부모 클래스를 추상 클래스로 정의하여 자식 클래스들이 각각 해당 메소드를 구현 실습부모클래스Shape.java1234567891011abstract class Shape &#123; private String fillColor; private String lineColor;.. public abstract void draw(); public abstract int calcArea();&#125; Shape 클래스를 상속Rectangle.java12345678910111213141516public class Rectangle extends Shape &#123; private int x1; private int y1; private int x2; private int y2; @Override public void draw() &#123; System.out.println(\"사각형을 그렸습니다.\"); &#125; @Override public int calcArea() &#123; return ((x1+x2)*(y1+y2)); &#125;&#125; Shape 클래스를 상속Circle.java123456789101112131415161718192021222324public class Circle extends Shape&#123; private int x1; private int y1; private int radius; public Circle(int x1, int y1, int radius) &#123; this.x1 = x1; this.y1 = y1; this.radius = radius; &#125;.. @Override public void draw() &#123; System.out.println(\"원을 그렸습니다.\"); &#125; @Override public int calcArea() &#123; return (int)(Math.PI * radius * radius); &#125;&#125; main 메소드PaintApp.java1234567891011121314package paint;public class PaintApp &#123; public static void main(String[] args) &#123; drawShape( new Rectangle()); drawShape( new Circle(10, 20, 5)); &#125; private static void drawShape( Shape shape ) &#123; shape.draw(); &#125;&#125; 인터페이스객체를 사용할 수 있는 목록. 즉 메소드 목록이다.UML 에서는 &lt;&gt; 라고 하고 그림.기능의 명세이다. Drawable라는 인터페이스를 구현하여 draw 메소드를 오버라이딩하여 사용.Drawable 인터페이스를 구현하면 그릴수 있다는 것을 암시.서로 관계가 없는 물체들이 상호 작용을 하기 위해서 사용하는 장치나 시스템클래스 구조상의 관계와 상관 없이 클래스들에 의해 구현되어질 수 있는 규약인터페이스 안에서는 인터페이스 끼리 다중상속이 된다.public interface Drivable extends A,B{…..} 실습인터페이스 정의Drawable.java123public interface Drawable &#123; public void draw(); //자동으로 abstract가 됨&#125; Point클래스가 Drawable 인터페이스를 구현함Paint.java123456789101112131415public class Point implements Drawable&#123; private int x; private int y; public Point() &#123; &#125; public void show() &#123; System.out.println( \"점[x=\" + x + \",y=\" + y +\"]을 그렸습니다.\"); &#125; ... public void draw() &#123; show(); &#125;&#125; ColorPoint가 Point클래스를 상속하여 Drawable를 구현한 효과를 갖음ColorPoint.java1234567891011121314151617181920package paint;public class ColorPoint extends Point &#123; private String color; public ColorPoint(int x, int y, String color) &#123; super(x, y); this.color = color; &#125;.. @Override public void show() &#123; //완전 super.show(); System.out.println( \"color \" + color); &#125;&#125; 메인메소드PaintApp.java12345678910public class PaintApp &#123; public static void main(String[] args) &#123; draw(new ColorPoint(200,200,\"yellow\")); &#125; private static void draw( Drawable drawable ) &#123;//Drawable를 구현하고 있으면 draw를 해줄게 drawable.draw(); &#125;&#125; 인터페이스 추상클래스 차이인터페이스는서로 관계가 없는 물체들이 상호 작용을 하기 위해서 사용하는 장치나 시스템클래스 구조상의 관계와 상관 없이 클래스들에 의해 구현되어질 수 있는 규약하나 또는 그 이상의 클래스들에서 똑같이 구현되어질 법한 메소드를 선언하는 경우 추상클래스는객체들이 가지고 있는 속성과 기능 중에 중요한 것들은 남기고 필요 없는 불필요한 것은 없애는것. 또는 공통된 것들을 그룹핑해서 한곳에다 모아놓는것. 정리일반클래스 : 모두 완결한 메소드 / 필드를 가질 수 있음 / 객체화 가능 추상클래스 : 완결한 메소드, 추상메소드 / 필드 가질 수 있음 / 객체화 불가 인터페이스 : 모든 추상 메소드 / 필드 가질 수 없음 / 객체화 불가 instanceof1234567891011// 객체가 Circle 클래스의 인스턴스 인가?System.out.println( c instanceof Circle );// 객체가 Drawable 인터페이스를 구현하였는가?System.out.println( c instanceof Drawable );// 객체가 Rectangle 클래스의 인스턴스 인가?System.out.println( c instanceof Rectangle );// 객체가 Shape 클래스의 인스턴스 인가?System.out.println( c instanceof Shape );","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"깃허브 사용","slug":"bigdata2","date":"2017-08-01T04:04:28.000Z","updated":"2018-09-03T05:52:41.055Z","comments":true,"path":"2017/08/01/bigdata2/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/01/bigdata2/","excerpt":"","text":"깃허브란 형상관리 툴이다. A(팀장,a모듈담당) B(b모듈담당) C(c모듈담당) 개발자가 하나의 프로젝트를 개발중이다. A 가 프로젝트(모듈 a,b,c 포함)를 올린다. 그 후 B C 에게 그 사실을 알린다. B C 는 프로젝트를 내려받고 B,C가 자신의 모듈을 수정 후 커밋을 한다. A,B,C는 수정된 것을 내려 받은 후 테스트를 한다. git가 있으며 내부에는 Repository가 있다. git는 레파지토리가 2개 존재한다.하나는 로컬이고 하나는 원격이다. 로컬 레파지토리에 프로젝트를 올리는것을 commit 라고 하며 로컬 레파지토리를 원격 레파지토리에 맞추는 것을 push 라고 한다. 원격 레파지토리에서 프로젝트를 로컬레파지토리로 갖고오는것을 full 내 프로젝트로 반영하는것은 fetch라고 한다. 하지만 보통 로컬레파지토리와 프로젝트를 같이 놓는다.(편의상)1.내 프로젝트 올리기이클립스에서 실행1.이클립스 - show view - git Repository 선택2.프로젝트 우클릭 후 - team - share …-체크-create누름(로컬레파지토리 프로젝트를 같이하는것.) 깃허브에서 실행1.레파지토리 new - 프로젝트 이름이랑 동일하게 생성(굳이 안해도되나 편의상)2.깃 주소를 복사 이클립스에서 실행1.git Repository탭 - remote - Configure fetch 체크(push 체크하면 올리기만 되고 받기는 안된다.) - change 버튼 클릭 - save Fetch 클릭2.project explorer탭으로 - team - commit - Unsatage Changes에 있는 것들을 staged Changed로 내림. 커밋메세지는 추가할 수 있도록 하자. - commit and push 클릭 - next - finish 2.타 프로젝트 받기.방법1. 깃허브에서 다운받아서 임포트하기. 방법2. 프로젝트를 fork한다. 깃허브에서 실행원하는 프로젝트로 가서 fork를 누르고내 레파지토리로 가보자. 자신의 레파지토리에 생성되있는게 있을것임.이제 자기 레파지토리에 있는것을 잡아 땡겨보자clone or download 에서 url 복사 이클립스에서 실행git Repository탭으로 가서 컨트롤+vnext-next - browse 눌러서 자기 워크스페이스 선택 (로컬 레파지토리와 프로젝트저장소를 하나로 합치는것.)working tree 선택 후 오른쪽 누르고 import .. 클릭 후 finish Project explorer 탭으로 가서 보면 에러가 난다. (환경설정이 달라서 나는 에러이다.)프로젝트 우클릭 후 - properties - java build path 선택- Libraries 탭 선택 - 더블클릭 후 - alternate JRE 에서 선택 3.레파지토리 삭제해당레파지토리로 가서 - 세팅 - 레파지토리 이름 입력 이클립스에서 실행team - disconnect 후 delete Repository 클릭하나로 뭉쳐놨기 때문에 맨위 하나만 선택하면 된다.","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"}],"tags":[]},{"title":"1.자바프로그래밍 기본","slug":"bigdata1","date":"2017-08-01T00:05:28.000Z","updated":"2018-09-03T05:52:34.717Z","comments":true,"path":"2017/08/01/bigdata1/","link":"","permalink":"http://KKimSangHeon.github.io/2017/08/01/bigdata1/","excerpt":"","text":"특징많은 클래스, 파일로 프로그램이 구성된다. 클래스는 데이터를 갖고 있고 메소드는 데이터를 다루게 된다. 객체의 데이터를 다루기 위해서는 외부에서 메소드를 호출해야 한다. 하드웨어는 컴포넌트화로 인해 빠른 발전이 이루어졌다. 소프트웨어 또한 이에 따라 컴포넌트화로 발전하게 되었다. 객체지향은 설계분석이 가능하다. 요구사항 분석-&gt;추상화-&gt;객체관계 분석(상속,의존 등) 캡슐화, 상속, 다형성의 특징을 갖는다. 코드의 재사용성이 높다. 추상화 과정으로 인해 가능해지는것. 상속을 통해 부모에 존재하는 메소드 사용가능.잘못된 예: 홈쇼핑 프로젝트에서 만든 Person 클래스를 ERP를 만드는곳에서 Person을 만드는데 사용한다. 예외처리를 통해 신뢰성이 높아진다. java는 운영체제에 영향을 받지 않는다는 특징. JRE + API + javac + rt.jar = JDK 객체와 클래스객체는 정보를 효율적으로 관리하기 위하여 의미를 부여하고 분류하는 논리적 단위클래스를 사용자 데이터 타입 이라고도 한다. 객체의 구성요서는 속성(필드,인스턴스 변수)이 필요하다.클래스 내부에 있는 변수는 필드 혹은 속성이라 한다.!기능은 메소드라 한다. 컴파일 과정네비게이터로 bin 폴더를 보자.코들를 짜면 bin 폴더 내부에 클래스파일이 컴파일되어 생성된다. 메소드 영역필드정보(클래스에 대한 정보. getClass() 메소드를 통해 얻을 수 있다.), 메소드 코드, main메소드, static 변수, static 메소드 stack지역변수. 자바는 전역변수의 개념이 없으므로 모든 변수는 여기에 생성됨. heap객체 접근자public - 내부, 같은 패키지, 자식접근, 외부 가능. protected - 내부, 같은 패키지, 자식접근 가능. (default) - 쓰지않는것을 권고한다. 내부, 같은 패키지에서 접근가능. private - 내부에서만 접근 가능. 정보은닉데이터는 private를 넣고 접근할 때 메소드를 쓴다. 엔터프라이즈에서는 이러한 메소드를 빈이라고 부른다. finalfinal은 클래스 앞, 변수앞 , 필드 앞에도 정의할 수 있다.final은 여기가 마지막이라는 뜻.상수는 대문자로 만들라는 관례가 있다.!따지고 보면 변수와는 별 다른게 없지만 알아보기 편하게!123final int VALUE = 10;VALUE = 30; //에러발생 1234public final class Test&#123;.....&#125;이 경우 다른클래스가 Test클래스를 상속할 수 없음. 1234public final Sring getName() &#123; return name;&#125;오버라이딩 금지!! 생각해보자12345678910public void show() &#123; System.out.println( \"점[x=\" + x + \",y=\" + y +\"]을 그렸습니다.\"); &#125;public void show(boolean visible) &#123; //외부에서 매개변수를 통해 보이고 안보이고를 show메소드로만 통제 if(visible) &#123; show(); &#125;else &#123; System.out.println( \"점[x=\" + x + \",y=\" + y +\"]을 지움.\"); &#125; 코드를 위와 같이 구현 시 사용자는 show라는 메소드에 접근하고 boolean 값만을 통해 출력 미출력을 통제할 수 있다. 이 형태가 좋은 이유는 show , notShow 와 같은 메소드를 만들어서 사용자가 모든 메소드를 알고 있어야하는 상황을 없앨 수 있다.","categories":[{"name":"Language","slug":"Language","permalink":"http://KKimSangHeon.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://KKimSangHeon.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://KKimSangHeon.github.io/tags/Java/"}]},{"title":"Chat-Bot","slug":"Chat-Bot","date":"2017-07-17T08:49:17.000Z","updated":"2018-11-14T09:37:34.995Z","comments":true,"path":"2017/07/17/Chat-Bot/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/17/Chat-Bot/","excerpt":"","text":"과정GCP 우분투로 생성 후123456sudo apt-get install -y build-essentialcurl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -sudo apt-get install -y nodejs 초기화1npm init 후 엔터 쭈욱 1npm install --save cheerio node.js에서 제이쿼리의 선택자를 쓸 수 있게되어 설치.1npm install --save request url에 접속하여 html을 다운받을 수 있게된다. 1npm install --save async 비동기 방식을 사용할 수 있게 된다.1npm install --save node-cron 주기적인 작업을 실행시키기 위해 설치하였다.1npm install --save iconv html을 가져 왔을 때 한글 깨짐을 막을 수 있다.1sudo npm install pm2 -g 서버가 문제가 생겼을 경우 재시작 시켜주며 성능향상에 기여한다.pm2의 명령어는 다음과 같다.12345678pm2 start 서버.js --name 별칭 //실행하면서 별칭을 붙여준다.pm2 list //실행되고 있는 pm2리스트를 조회pm2 stop 별칭 // pm2를 중지한다.pm2 restart 별칭 //pm2 재시작한다.pm2 delete 별칭 //pm2 종료pm2 show 별칭// 정보확인","categories":[{"name":"Etc","slug":"Etc","permalink":"http://KKimSangHeon.github.io/categories/Etc/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"}]},{"title":"19장. PXE 서버, 킥스타트","slug":"ThisIsLinux42","date":"2017-07-16T12:22:55.000Z","updated":"2018-09-03T05:52:00.768Z","comments":true,"path":"2017/07/16/ThisIsLinux42/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/16/ThisIsLinux42/","excerpt":"","text":"Centos를 100개 깔아야 하는 상황에는 여러가지 방법이 있겠지만 PXE 설치서버를 구성해놓는다면 쉽게 설치가 가능하다!1.DHCP 서버, TFTP 서버, syslinux부팅파일, FTP 또는 웹서버를 PXE 설치 서버에 구성해 놓는다. 즉 PXE는 하나의 프로그램이 아니라 여러개의 프로그램을 잘 조합해 놓은것을 의미2.Centos를 설치할 PC의 전원을 켠다.3.설치할 파일을 네트워크로 전송해서 자동으로 설치 PXE는 초기 설치화면 즉 언어설정 전 까지만 완료해 주지만 킥스타트는 초기설정까지 해준다. 1.PXE 설치1.1 서버에서 설정1# yum -y install syslinux dhcp tftp-server vsftpd //관련패키지 설치 1.1 DHCP 설정12345678910111213141516# systemctl stop firewalld# systemctl disable firewalld# vi /etc/dhcp/dhcpd.conf맨아래 다음 입력subnet 192.168.111.0 netmask 255.255.255.0 &#123; option routers 192.168.111.2; option subnet-mask 255.255.255.0; range dynamic-bootp 192.168.111.120 192.168.111.199; option domain-name-servers 192.168.111.2; allow booting; allow bootp; next-server 192.168.111.100; filename &quot;pxelinux.0&quot;;&#125;입력 후 종료 1.2 TFTP 설정123# vi /etc/xinetd.d/tftpdisable = no 로 변경저장후 종료 1.3 ftp로 iso이미지 접근가능하게오른쪽위 cd모양 우클릭 - 세팅 - Use ISO image… - Centos이미지 찾고 위에 Connected, Connect at power on 체크 - OK123# umount /dev/cdrom# mount /dev/cdrom /var/ftp/pub ftp를 접속할 경우 cd롬파일을 접근가능 1.4 부팅에 필요한 파일 준비tftp는 부팅파일을 전송하는 역할이다.123456789101112131415161718# cp /var/ftp/pub/images/pxeboot/vmlinuz /var/lib/tftpboot/# cp /var/ftp/pub/images/pxeboot/initrd.img /var/lib/tftpboot/# cp /usr/share/syslinux/pxelinux.0 /var/lib/tftpboot/# ls -l /var/lib/ftpboot# mkdir /var/lib/tftpboot/pxelinux.cfg# cd /var/lib/tftpboot/pxelinux.cfg# touch default //부팅에 관련된 파일 생성# vi default 다음을 입력DEFAULT CentOS7_Auto_InstallLABEL CentOS7_Auto_Install kernel vmlinuz APPEND initrd=initrd.img repo=ftp://192.168.111.100/pub# ps -ef | grep dnsmasq //충동하는 프로세스 kill위해# kill -9 1696# systemctl disable dnsmasq 1.5 관련 서비스 시작123456# systemctl restart dhcpd //서비스 시작# systemctl restart vsftpd# systemctl restart xinetd //tftp임# systemctl enable dhcpd //상시가동# systemctl enable vsftpd# systemctl enable xinetd 1.6 VMware에서 제공하는 DHCP를 끄자워크스테이션 키고 - Edit - Virtual Network Editor - change setting 누르고-VMnet8선택 - Use local DHCP .. 체크 해제 후 - OK이제 서버에서만 DHCP 서버를 제공한다. 1.7 새로운 PC를 만들자버츄어 머신에서 진행하자버츄어머신 네임을 TestCom으로로케이션을 Centos 폴더 내 TestCom으로 하자그 후 부팅하면 설치가 된다. 2.킥스타트 설치킥스타트는 교재를 참고하자.","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"18장. 방화벽 컴퓨터를 만들자","slug":"ThisIsLinux41","date":"2017-07-16T02:04:12.000Z","updated":"2018-09-03T05:51:58.265Z","comments":true,"path":"2017/07/16/ThisIsLinux41/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/16/ThisIsLinux41/","excerpt":"","text":"방화벽은 내부, 외부를 차단해주는 장비 또는 컴퓨터라고 생각하면 된다. 방화벽으로 인해 외부에서 내부 네트워크로 함부러 침입할 수 없다. 그 기법중 많이 쓰이는 것이 사설IP이다.방화벽 컴퓨터는 랜카드가 두개여야 된다. 내부와 결합되는(사설 IP) 랜카드 외부와 연결되는 랜카드(공인IP) 실습에서 192.168.xxx는 공인 ip10.1.xxx 는 내부ip로 사용한다책 737을 통해 네트워크 구성을 확인하자 1. 서버 B 설정(웹서버로 사용할것임)서버B의 네트워크 세팅에 들어가서 네트워크 어댑터 클릭 후 Bridged 클릭그러면 네트워크가 Bridged네트워크 안으로 들어옴(사설ip로 사용하기로 함)그 후 ip를 변경하자 123456789# nmtui edit ens32Address를 10.1.1.20/24로 변경Gateway를 10.1.1.1로 변경Dns 168.126.63.1로 변경 //kt에서 운영하는 dns 서버ok버튼# reboot# ip addr inet이 10.1.1.20 인지 확인 2. 클라이언트 설정(클라이언트에서 실행)클라이언트의 네트워크 세팅에 들어가서 네트워크 어댑터 클릭 후 Bridged 클릭 그러면 네트워크가 Bridged네트워크 안으로 들어옴123456789# nmtui edit ens33IPv4 CONFIGURATION을 Manual로 바꾸고 Show 엔터Address를 10.1.1.10/24Gateway는 10.1.1.1DNS Server는 168.126.63.1 OK 엔터# reboot# ip addr 3. 서버B,클라이언트 사설네트워크 테스트현재까지 구현한것(서버B,클라이언트)은 게이트웨이가 구현되어있지 않으므로 외부로 나갈 수 없다. 하지만 사설네트워크로 안에서는 연결되어 있으므로 ping이 왔다갔다 하는지 확인해보자 클라이언트에서 실행1# ping -c 3 10.1.1.20 4. 서버 구성(서버에서 실행)4.1 랜카드 하나가 외부로 연결 잘 되어있는지 확인해보자123# nmtui edit ens32게이트웨이, DNS Servers가 192.168.111.2로 잘 되어있다.# halt -p 서버에 랜카드를 하나 더 달자.vmware 워크스테이션에서 Edit virtual machins settings를 눌러 Add 후 Network Adapter 선택 다음 후 Bridged 선택하고 Finish 그 후 부팅추가한 장치가 ens32인지 확인해보자날짜 옆에 랜카드 모양을 누르면 ens34가 추가되어 있다. 네트워크설정 클릭 후 오른쪽 아래 톱니모양(유선연결1)을 누르고 신원을 누르자. 그 후 ens34로 입력하자다음 IPv4를 선택하여 자동을 수동으로 변경하자그 후 주소 10.1.1.1네트마스크 255.255.255.0게이트웨이 10.1.1.1네임서버 끄자IPv6로 가서 끄자이제 적용을 누르고 재부팅하자 12345# vi /etc/sysconfig/network-scripts/ifcfg-ens346,7행 지워버리기# systemctl restart network# ifconfigens32 는 192.168.111.100번으로 ens34는 10.1.1.1 이제 하드웨어 설정은 끝났다 5. 클라이언트에서 핑을 날려보자1# ping 10.1.1.1 6. 서버에 정책을 적용시켜보자1234567891011121314151617181920212223242526272829303132# vi /etc/sysctl.confnet.ipv4.ip_foward=1 맨아래 입력# echo 1 &gt; /proc/sys/net/ipv4/ip_forward //아무 메세지 안나오면 성공# cat /proc/sys/net/ipv4/ip_forward //1출력됨포워딩성공!# iptables --policy FORWARD DROP# iptables --policy INPUT DROP# iptables --policy OUTPUT DROPens34 장치를 설정해주자input 설정# iptables --append INPUT --in-interface ens34 --source 10.1.1.0/24 --match state --state NEW,ESTABLISHED --jump ACCEPToutput 설정# iptables --append OUTPUT --out-interface ens34 --destination 10.1.1.0/24 --match state --state NEW,ESTABLISHED --jump ACCEPT# iptables --append FORWARD --in-interface ens34 --source 10.1.1.0/24 --destination 0.0.0.0/0 --match state --state NEW,ESTABLISHED --jump ACCEPTens32 설정# iptables --append FORWARD --in-interface ens32 --destination 10.1.1.0/24 --match state --state ESTABLISHED --jump ACCEPT# iptables --table nat --append POSTROUTING --out-interface ens32 --jump MASQUERADE설정한것 저장# service iptables save# firewall-config영구적 - 마스커레이딩 - 마스커레이딩영역 체크 - 옵션 다시불러오기 7.클라이언트에서 인터넷 해보자이 경우 클라이언트는 자신의 ip(10.1.1.0)이 아닌 Server IP(192.168.111.100)으로 접속하게 된다. 이를 확인해보자 7.1 윈 클라이언트를 켜자파일질라서버를 카페에서 받자에딧 -유저- 오른쪽add -centos 입력- password centos -ok왼쪽 add 아무 디렉토리 선택- write/delete 선택 -okcmd 열고 netsh advfirewall firewall add rule name=”FTP서버” dir=in action=allow protocol=tcp localport=21방화벽 설정 입력ipconfig아이피를 기억하자 (지금은 192.168.111.128임) 7.2 클라이언트에서 FTP 접속해보자1234567# su# yum -y install ftp# ftp 192.168.111.128centoscentos&gt;pwd&gt;ls 7.3 윈도우 클라이언트에서 누가 접속했는지 확인해보자netstat /an찾다 보면 192.168.111.100이 들어온것을 확인할 수 있다.즉 사설네트워크 컴퓨터는 외부로 나갈 때 192.168.111.100으로 나간다! 8. 서버B를 웹서버로 만들고 윈 클라이언트로 접속해보자8.1 서버 B에서 실행12345678910# yum -y install httpd# firewall-cmd --add-service=http //포트열자# cd /var/www/html# touch index.html# vi index.htmlCentos7-Web Server 입력저장 후 종료# systemctl restart httpd# systemctl enable httpd 8.2 서버에서 80번 포트로 연결오면 서버 B로 연결해라를 설정서버에서 실행12# iptables --table nat --append PREROUTING --proto tcp --in-interface ens32 --dport 80 --jump DNAT --to-destination 10.1.1.20# service iptables save //저장 8.3 윈도우 클라이언트에서 접속해보자192.168.111.100 으로 접속하자","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"17장. 프록시 서버 설치와 운영","slug":"ThisIsLinux40","date":"2017-07-15T09:55:25.000Z","updated":"2018-09-03T05:51:55.792Z","comments":true,"path":"2017/07/15/ThisIsLinux40/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/15/ThisIsLinux40/","excerpt":"","text":"프록시서버?웹서핑을 할 경우 웹브라우저가 외부로 가서 파일을 가져와 읽게 되는것이다. 두 브라우져가 같은곳을 접속하면 따로 가져오게 되는 현상이 발생할 수 있다. 하지만 프록시 서버를 지정해놓으면 프록시 서버가 캐시에 a사이트 데이터를 저장 해놓고 다른 웹브라우져가 a서버를 요청하면 a 데이터를 보내준다. 프록시서버 구현(서버에서)123456789101112131415161718# yum -y install squid //설치# vi /etc/squid/squid.conf:set nu:26acl centos7 src 192.168.111.0/255.255.255.0 //c클래스 지정:54http_access allow centos7:62주석 제거 하고 100을 1000으로맨아래 다음추가visible_hostname centos7# firewall-config영구적 선택 - 포트 - 추가 3128 - 다시불러오기# systemctl stop firewalld //맘편하게 방화벽 끄는것# systemctl restart squid# systemctl enable squid# systemctl status squid 웹브라우저에서 프록시서버 지정(클라이언트)파이어폭스를 켜고 - 편집 - 환경설정 -고급 - 네트워크 - 설정 - 프록시 수동설정 192.168.111.100 포트 3128 입력 - 확인 윈도우클라이언트에서 지정(윈클라이언트)도구 -인터넷옵션 -LAN설정 프록시서버 192.168.111.100 3128 입력 1","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"16장. DHCP 서버 설치와 운영","slug":"ThisIsLinux39","date":"2017-07-15T07:09:22.000Z","updated":"2018-09-03T05:51:53.401Z","comments":true,"path":"2017/07/15/ThisIsLinux39/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/15/ThisIsLinux39/","excerpt":"","text":"DHCP(Dynamic Host Configuration Protocol) 서버는 자동으로 네트워크 정보(IP주소, 서브넷 마스크, 게이트웨이 주소,DNS 서버 주소)를 할당해 주는것이다. 일반 PC는 자신에게 고정IP가 할당되어있지 않아도 DHCP서버가 할당해준다. 그러므로 일반사용자는 IP에 대한 지식 없이도 인터넷 사용이 가능해진다. Vmware에서 제공하는 DHCP 서버의 기능은 중지시켜야 한다. 클라이언트 설정1234# ifconfigip를 DHCP로부터 할당받은것.# cat /etc/resolv.confnameserver 또한 DHCP로 부터 할당받은것. 1. DHCP 기능중지워크스테이션 - Edit - Virtual Network Editor - change setting 선택 - VMnet8선택 - DHCP Setting 선택128부터 254까지를 할당하는 것을 확인 Use local DHCP …. 클릭 해제Apply이제 IP를 자동으로 할당받지 못한다. 2. DHCP 서버 설정하자.12345678910111213141516171819202122232425262728293031323334353637# yum -y install dhcp# ps -ef | grep dnsmasq //dhcp와 충돌하므로 죽이자.nobody 1696 1 0 18:21 ? 00:00:00 /sbin/dnsmasq --conf-file=/var/lib/libvirt/dnsmasq/default.confroot 3514 2462 0 18:28 pts/0 00:00:00 grep --color=auto dnsmasq# kill -9 1696 //다를 수 있다.# systemctl disable dnsmasq //껏다켜도 실행 되지 않도록.# vi /etc/dhcp/dhcpd.conf //dhcp 설정파일아래를 추가하자. (엔터로 인한 공백이 존재하면 안된다)ddns-update-style interim;subnet 192.168.111.0 netmask 255.255.255.0 &#123; option routers 192.168.111.2; //라우터설정 option subnet-mask 255.255.255.0; //서브넷마스크설정 range dynamic-bootp 192.168.111.30 192.168.111.50; //ip범위 설정 30~50까지 20개 option domain-name-servers 192.126.63.1; //dns설정(kt에서 제공하는것) default-lease-time 10000; //디폴트 임대시간 max-lease-time 50000; //최대임대시간&#125; # ls /var/lib/dhcpddhcpd.leases에 ip를 임대해준것에 대한 기록이 있다.# systemctl restart dhcpd# systemctl enable dhcpd //상시가동# systemctl status dhcpd //잘 작동하는지 확인# systemctl stop firewalld# systemctl restart dhcpd 3. 클라이언트에서 IP 할당받아보자1234# su -c &apos;systemctl restart network&apos;password 입력# ifconfig //아이피 확인해보자192.168.111.30을 받았다. (아까 30~50을 지정해줌) 4. 윈도우 클라이언트에서 IP 할당받아보자네트워크 - 공유센터 - 어댑터 - 로컬 영역 연결을 사용안함으로 했다가 사용으로 변경 - cmd를 켜고 ipconfig 를 입력하면192.168.111.31을 받은것을 확인할 수 있다. 5. 서버에서 빌려간것들을 확인해보자12# cat /var/lib/dhcpd/dhcpd.leasesIP를 언제빌려갔고 누가 빌려갔고 맥어드레스 등을 확인할 수 있다. 6. 다시 워크스테이션의 DHCP를 켜자워크스테이션 - Edit - Virtual Network Editor - change setting 선택 - VMnet8선택 - DHCP Setting 선택 - Use local DHCP …선택","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"15장. Samba 서버 설치와 운영","slug":"ThisIsLinux38","date":"2017-07-15T05:37:36.000Z","updated":"2018-09-03T05:51:50.707Z","comments":true,"path":"2017/07/15/ThisIsLinux38/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/15/ThisIsLinux38/","excerpt":"","text":"NFS 유닉스와 유닉스 유닉스와 리눅스간 파일공유이고삼바는 유닉스(리눅스)와 윈도우즈간에 공유하는것. 1.윈도우가 삼바 서버1.1 윈도우 클라이언트를 삼바 서버로 만들자(윈클라이언트실행)C 드라이브에 smbShare 폴더만든다. 그 폴더 속성 들어가서 공유탭의 공유버튼 누르고 Everyone 선택하고 추가 그 후 Everyone은 읽기/쓰기로 선택 명령프롬프트 관리자 모드로 열고 net user root 1234 /add 입력. //윈도우즈 사용자 추가ipconfig192.168.11.131임을 기억하자 1.2 삼바 클라이언트로 접속해보자(서버에서 실행)123456789101112# rpm -qa | grep samba# smbclient -L 192.168.111.1311234입력# mkdir /sambaMount# mount -t cifs //192.168.111.131/smbShare /sambaMount //윈도우는 //로 해야함1234입력# ls -l /sambaMount# cp /boot/vmlinuz-* /sambaMount 2. 리눅스가 삼바 서버윈도우는 삼바 클라이언트라는 개념이 없다. 그래서 리눅스가 윈도우인척 폴더를 공유해 놓으면 윈도우 클라이언트는 해당폴더가 윈도우가 공유했는지 리눅스가 공유한지 모르고 그냥 쓰게 된다. 2.1 리눅스 서버를 삼바 서버로 만들자(서버에서 실행)12345678910111213141516171819202122232425262728# yum -y install samba관련파일 카페에서 받자# cd 다운로드# yum -y localinstall system-config-samba*여기서 에러날 경우 카페 자료실을 참고하자# systemctl restart smb# systemctl enable smb# ls /share / //share 폴더를 공유하자# chmod 707 /share# system-config-samba설정- 서버설정 - workgroup/centOS 7 입력- 보안탭가서 인증모드 공유로 하고 확인workgroup은 윈도우의 그룹이다.+를 누르고 폴더는 /share로 하고 쓰기가능,보이기 체크접근탭을 눌러서 모든사용자에게 접근부여 선택설정 - samba사용자 눌러서 사용자 추가.유닉스 사용자명은 centOS / winuser /1234 /1234 입력 후 확인# systemctl stop firewalld# firewall-config //삼바, 삼바 클라이언트 열기 //지금은 방화벽을 꺼둔상태라 하지 않아도 된다.# systemctl restart smb 2.2 윈도우에서 접속해보자컴퓨터 -&gt; 네트워크 드라이브 연결드라이브 Q로 선택폴더에 \\\\192.168.111.100\\share 입력centos1234 2.3 서버에 접속한 사용자를 보자(서버에서 실행)1# smbstatus","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"14장. NFS 서버 설치와 운영","slug":"ThisIsLinux37","date":"2017-07-15T03:11:36.000Z","updated":"2018-09-03T05:51:48.695Z","comments":true,"path":"2017/07/15/ThisIsLinux37/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/15/ThisIsLinux37/","excerpt":"","text":"NFS 서버리눅스 사이에 파일이나 폴더를 공유하는것NFS를 구현하면 다양한 클라이언트가 공유 디렉터리에 접근할 수 있다.서버에서는 서버를 구현하고 클라이언트는 그것을 마운트하여 사용한다. 서버를 NFS 서버로 구현(서버로 실행)1234567891011121314# rpm -qa nfs-utils //설치 확인(깔려있다.)# vi /etc/exports //공유할 폴더를 지정하는 파일/share 192.168.111.*(rw,sync) 입력 //리드 라이트, 싱크까지 시킴# mkdir /share# chmod 707 /share/# cp /boot/vmlinuz-3* /share/file1# ls -l /share/# systemctl restart nfs-server //서비스 시작# systemctl enable nfs-server //상시가동# exportfs -v //공개된 폴더 보임# systemctl stop firewalld //방화벽 끄기.. //관련된 것이 많아서 끄는게 낫다. 클라이언트로 NFS 접속(클라이언트로 실행)123456789101112131415# rpm -qa nfs-utils //패키지 설치여부 확인(깔려있다)# showmount -e 192.168.111.100 //서버에서 마운트한 폴더 조회# cd# mkdir myShare# su password 입력# cd /home/centos# mount -t nfs 192.168.111.100:/share myShare //마운트# ls -l myShare# cd myShare/# touch abc# touch bcd 클라이언트가 생성한게 서버에도 있나 확인1# ls -l /share //abc,bcd 파일이 존재한다 윈도우로 접속해보자일반적으로는 NFS는 제공을 안하지만 엔터프라이즈의 경우엔 제공해준다.제어판 - 프로그램 - 기능 사용/사용안함 클릭- nfs용 클라이언트 체크확인재부팅관리자로 cmd를 열자mount 192.168.111.100:/share *내컴퓨터를 누르면 접속 가능 NFS서버의 그래픽 설정도구를 사용해보자1234567페도라20에서 제공하므로 카페에서 다운받자# yum -y install# cd 다운로드# yum -y localinstall system-config-nfs-1.4.2-1.fc20.noarch.rpm# mkdir /share2# system-config-nfs","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"13장. FTP 서버 설치와 운영","slug":"ThisIsLinux36","date":"2017-07-15T02:04:42.000Z","updated":"2018-09-03T05:51:46.152Z","comments":true,"path":"2017/07/15/ThisIsLinux36/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/15/ThisIsLinux36/","excerpt":"","text":"네임서버, 이메일서버, 웹서버 보다는 훨신 간단하다.FTP 는 file transfer protocol의 약자로 파일을 전송하기 위한 서비스. 대용량 파일을 전송 할 때 FTP 서버는 성능이 좋다. ftp서버의 종류는 몇가지가 있는데 CentOS에서는 vsftpd를 제공한다. 페도라, 레드헷 엔터프라이즈 쪽에서 인기가 좋다.proftpd는 주로 대형 사이트에서 오래동안 인기가 많았다.pure-ftpd는 Troll-FTPd를 기반으로 프랭크 데니스가 2001년에 제작함.사실 사용자입장에서는 어떤 ftp이든 관계가 없다. 1.vsftpd실습1.1 vsftpd 설치 및 운영(서버실행)12345678910111213# yum -y install vsftpd //165kb 밖에 안되는데 성능이 좋다!# cd /var/ftp //vsftpd의 홈 디렉토리# ls -l //일반적으로 pub라는 디렉토리에 파일을 넣어놓는다. //우리회사가 A라는 파일을 배포해야하면 일반적으로 pub폴더에 넣음.# cd pub# ls# cp /boot/vmlinuz-3* file1# systemctl restart vsftpd //ftp 시작# systemctl enable vsftpd //상시가동# firewall-config //방화벽 열기영구적탭 . ftp 선택 . 옵션 firewalld다시불러오기 실습1.2 vsftpd 윈도우에서 접속해보자(윈클라이언트실행)알드라이브 설치192.168.111.100 입력포트 21익명로그인 체크연결파일 업로드가 안된다. 이유 : ftp는 기본적으로 다운로드만 가능하다. 아무나 업로드 가능하면 악성코드를 올릴 수 도 있다!하지만 허용할 수 있다. 실습1.3 vsftpd 업로드 가능하게 변경(서버에서 실행)12345678# vi /etc/vsftpd/vsftpd.conf29행 어나니머스가 업로드하는것을 허락한다. 주석해제33행 어나니머스가 디렉토리를 만드는것을 허락한다. 주석해제# chown ftp.ftp /var/ftp/pub //펍 소유주 변경# ls -l# systemctl restart vsftpd //서비스재시작 실습1.4 vsftpd 명령어로 파일을 올리고 받아보자(서버B에서 실행)123456789101112# yum -y install epel-release //레드헷에 접속해서 다운받을수 있도록 설치# yum -y install ncftp# ncftp 192.168.111.100&gt;cd pub&gt;get file1 //file1 다운로드&gt;put anaconda-ks.cfg //아나콘다파일 업로드&gt;ls -l &gt;bye //종료 2.proftpd실습2.1 proftpd 설치(서버실행)1234567891011121314151617# yum -y remove vsftpd //충돌 나니까 제거# yum -y install epel-release //proftpd도 레드헷에 있어서 해줘야함.# yum -y install proftpd //proftpd 설치# vi /etc/proftpd.conf //설정파일 열기:set nu :356 주석처리:425 주석처리 &lt;/IfDefine&gt;:383 DenyAll을 AllowAll로 변경//이제 어나니머스도 접속 가능# systemctl restart proftpd # systemctl enable proftpd 방화벽은 아까 열었으므로 안열어도 된다. 실습2.2 윈클라이언트에서 접속(윈클라이언트 실행)3. pure-ftpd실습3.1 pure-ftpd 설치(서버실행)123456789# yum -y remove proftpd# yum -y install pure-ftpd //레드햇에서 제공한다.# vi /etc/pure-ftpd/pure-ftpd.conf:set nu:77 익명사용자가 허용이 되어있다.:286 yes를 no로 변경# systemctl restart pure-ftpd# systemctl enable pure-ftpd","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"12장. 웹서버 설정파일,APM 컴파일 설치","slug":"ThisIsLinux35","date":"2017-07-14T09:45:57.000Z","updated":"2018-09-03T05:51:37.717Z","comments":true,"path":"2017/07/14/ThisIsLinux35/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/14/ThisIsLinux35/","excerpt":"","text":"x윈도를 통해 httpd.conf파일을 설정해보자httpd.conf는 웹서버 설정파일이다. 책을 통해 이 내용을 알아보자.1234카페에서 system-config-httpd 파일을 받자.# yum -y localinstall system-config-httpd-1.5.5-6.fc20.noarch.rpm# system-config-httpd 소스를 컴파일해서 APM을 설치최적화된 APM을 구성할 수 있는 장점. 아파치 설치12345678910111213141516171819202122232425262728293031323334353637383940# yum -y remove httpd //컴파일 한것을 쓰기위해 깔린것을 지움# yum -y install gcc gcc-c++ //컴파일러 설치# cd 다운로드/# tar xfj pcre* //압축풀기# cd pcre-8.36/# ./configure ; make; make install //세개의 명령어 한꺼번에# cd 다운로드/# tar xfj httpd-2.4.10.tar.bz2# tar xfj apr-1.5.1.tar.bz2# tar xfj apr-util-1.5.4.tar.bz2# mv apr-1.5.1 httpd-2.4.10/srclib/apr //파일이름을 apr로 srclib에저장# mv apr-util-1.5.4 httpd-2.4.10/srclib/apr-util //파일이름을 apr-util로 srclib에 저장# ls httpd-2.4.10/srclib# cd httpd-2.4.10/# ./configure --with-included-apr --with-pcre=/usr/local/bin/pcre-config --prefix=/web/httpd2/ ; make ; make install # vi /etc/ld.so.conf마지막에 다음 두줄 추가/web/httpd2/lib/web/httpd2/modules# ldconfig //방금 추가한 내용 적용# cp /web/httpd2/bin/apachectl /etc/init.d/httpd2 //아파치 시작스크립트 복사# vi /etc/init.d/httpd2맨 아래 다음 두줄 추가# chkconfig: -85 15# description: 아파치 웹서버 입니다.# chkconfig httpd2 on //부팅될때마다 시작되도록# systemctl restart httpd2# systemctl status httpd2localhost로 접속해보자APM 중 아파치 설치 완료! 마리아 db 설치12345678910111213141516171819202122232425262728293031323334353637두번째 마리아 db는 컴파일된 바이너리 코드를 설치하자(카페에서 미리 받아놓자)# cd /root/다운로드# tar xfz mariadb-10.0.15-linux-x86_64.tar.gz# mv mariadb-10.0.15-linux-x86_64 /web/mariadb# groupadd mysql //mysql 그룹 추가# adduser -M -d /web/mariadb -g mysql -s /bin/false -r mysql //실제 사용하지 않는 유저 생성# /web/mariadb/scripts/mysql_install_db --user=mysql --basedir=/web/mariadb --datadir=/web/mariadb/data//마리아 디비 초기화# cp -a /web/mariadb/support-files/my-huge.cnf /etc/my.cnfy# vi /etc/my.cnf29행에 다음 두줄 추가basedir = /web/mariadbdatadir = /web/mariadb/data# cp -a /web/mariadb/support-files/mysql.server /etc/init.d/mariadb //실행스크립트 복사# systemctl restart mariadb# chkconfig mariadb on //상시가동되도록# /web/mariadb/bin/mysqladmin -u root -p password엔터12341234//마리아 디비 관리자 암호 변경# PATH=$PATH:/web/mariadb/bin# mysql -u root -p1234 입력//정상작동하는지 접속 php 설치123456789101112131415161718192021222324252627282930# cd /root/다운로드# yum -y install libxml2-devel openssl-devel libjpeg-devel libpng-devel//관련 패키지 설치# tar xfj php-5.6.4.tar.bz2# cd php-5.6.4# ./configure --with-mysql=/web/mariadb --with-apxs2=/web/httpd2/bin/apxs --with-mysqli=/web/mariadb/bin/mysql_config --with-imap-ssl --disable-debug --with-iconv --with-gd --with-jpeg-dir --with-png-dir --with-libxml-dir --with-openssl ; make ; make install //컴파일 및 설치# ls -l /web/httpd2/modules/libphp5.so//제일 중요한 파일. 이파일을 위해 컴파일을 했다.# vi /web/httpd2/conf/httpd.conf147행에 모듈이 추가 된것을 확인376행에 AddType application/x-httpd-php .php .php3 .php4 .php5 .htm .html .inc아파치 웹서버가 376행의 타입까지 인식을 하도록 만듬# cp php.ini-production /etc/php.ini# systemctl stop httpd2# systemctl start httpd2# systemctl status httpd2# firewall-config영구적 . http 선택 옵션 firewalld 다시불러오기# cd /web/httpd2/htdocs/ //웹서버의 홈폴더# vi phpinfo.php //샘플파일 만들기다음 한줄 추가&lt;?php phpinfo(); ?&gt;http://192.168.111.100/phpinfo.php 접속해보자 과연 이 과정들을 거쳐 만들어진것들이 최고의 성능을 낼까?그것은 확실히 모른다. 현재 패키지들이 잘 만들어져 나오기 때문에 굳이 컴파일을 통해 진행된것들이 훨신 좋은 성능을 얻거나 하지는 않는다.학습차원에서 컴파일을 진행해 보았다. 12장은 활용도가 높으므로 익혀두자","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"12장. 클라우드 서비스 구축","slug":"ThisIsLinux34","date":"2017-07-14T08:04:41.000Z","updated":"2018-09-03T05:51:40.600Z","comments":true,"path":"2017/07/14/ThisIsLinux34/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/14/ThisIsLinux34/","excerpt":"","text":"클라우드 서비스를 구축해봅시다.클라우드 서비스는 서버에 파일이 있고 각각의 PC마다 폴더를 지정하여 동기화가 된다. 즉 웹하드는 업로드 다운로드를 하지만 클라우드는 자동으로 동기화가 되는점이 다르다. 카페에서 관련 서버 두개를 깔자.123456789# cd /root/다운로드# yum -y localinstall owncloud- *# ls -l /var/www/html // owncloud가 깔렸나 확인# systemctl restart httpd //서비스 재시작# firewall-config//영구적 선택 - http,https//방화벽 설정 열기클라이언트에서 192.168.111.100/owncloud 접속admin 1234 입력자세한 사용법은 책을 참고하자!","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"12장. 웹하드 설치와 운영","slug":"ThisIsLinux33","date":"2017-07-14T05:26:47.000Z","updated":"2018-09-03T05:51:30.606Z","comments":true,"path":"2017/07/14/ThisIsLinux33/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/14/ThisIsLinux33/","excerpt":"","text":"웹하드는 웹서버상에서 파일을 저장할 수 있는것. 웹하드에 파일을 저장해 놓으면 전세계 어디서든지 내려받고 수정할 수 있다. 설정하자1234567891011121314151617181920212223# cd /var/www/html# ls -l# mv /root/다운로드/pydio-core-6.0.2.tar.gz / .# tar xfz pydio-core-6.0.2.tar.gz# mv pydio-core-6.0.2 webhard //폴더명 변경# chmod 707 webhard/ //일반사용자가 접근할 수 있게 권한변경# chown -R apache.apache webhard/# ls -l# yum -y --skip-broken install php-* //php관련 패키지 설치 //--skip-broken 설치하다 에러나면 그냥 무시해라# yum -y install php-mcrypt //레드헷 엔터프라이즈에 존재 //지금은 설치 안될것이다.# yum -y install epel-release//레드헷 엔터프라이즈도 yum으로 깔 수 있게됨 # yum -y install php-mcrypt //이젠 설치가 된다.# vi /etc/httpd/conf/httpd.conf151 행 AllowOverride All로 변경# systemctl restart httpd 리눅스 클라이언트에서 접속해보자http://192.168.111.100/webhard/ 접속click here 클릭한국어 하고 start wizardadmin admin 12345678 12345678 global option 클릭default language만 한국어로 변경 configurations storage 클릭하고database system 선택database에 xeDB 입력User에 xeUser 입력Password에 1234 입력Try connecting…. 클릭 add some users 클릭centoscentos@hanbit.co.kr센토스사용자12341234Install pydi 클릭웹브라우져 껏다 켜서http://192.168.111.100/webhard/ 접속 centos1234 후 로그인업로드를 해보자! 업로드 용량 제한을 풀자서버에서 실행하자123456789101112131415161718vi /etc/php.ini //현재는 8m이상 업로드가 안되는데 제한을 풀자.:384 (384라인으로감!)30초가 넘어가면 종료되도록 설정되어있다 300초로 수정하자:6728M를 100M으로 수정:8002M 를 100M으로 수정:wq# cd /var/www/html/webhard/data/cache/ //캐쉬로 인해 제대로 작동하지 않을 수 있으므로 캐쉬를 지우자 //지금 캐쉬폴더가 없는데 실행을 안해서 그런가..?# rm -f plugin*# systemctl restart httpd 업로드를 다시 해보자리눅스 클라이언트에서.. 1","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"12장. APM 개념과 설치, XE 설치와 운영","slug":"ThisIsLinux32","date":"2017-07-14T02:14:09.000Z","updated":"2018-09-03T05:51:33.665Z","comments":true,"path":"2017/07/14/ThisIsLinux32/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/14/ThisIsLinux32/","excerpt":"","text":"리눅스에서 가장 많이 활용하는것중 하나가 웹서버이다.APM = Apache 웹서버 + 프로그래밍언어 PHP + 데이터베이스 MaraiaDB리눅스 환경에서 사용될 경우 LAPM(Linux Apache,PHP,MariaDB)라고도 부름.APM 이라는 소프트웨어는 존재하지 않으며 이 3가지가 서로 잘 연동되어 운영되도록 만든 환경을 APM이라 함 APM 설치설치를 해보자서버에서 진행12345# rpm -qa httpd php mariadb-serverhttpd만 깔려있으므로 나머지를 깔자# yum -y install mariadb-server mariadb php php-mysqlnd# rpm -qa httpd php mariadb-server //깔린버전 확인해보자# yum -y install php-gd 가동해보자12345678910111213# systemctl restart httpd# systemctl restart mariadb# systemctl restart php // php는 서비스가 아니라 httpd에 포함되는 기능이라 시작이 안된다.# systemctl enable httpd //상시가동# systemctl enable mariadb # firewall-config영구적 선택 - http,httpsmysql은 안열어도 됨. 어차피 안에서만 접근하고외부에서 접근하지 않을것이므로 옵션- 다시불러오기 접속해보자파이어폭스 키고 localhost php 하나를 만들어보자12345678# cd /var/www/html# pwd# ls# touch phpinfo.php# vi phpinfo.php아래 한줄 입력&lt;?php phpinfo(); ?&gt; 파이어 폭스 켜고 http://localhost/phpinfo.php 접속해보자 mariadb 확인해보자1# mysql XE 설치123456789101112# vi /etc/httpd/conf/httpd.conf //XE 외부에서 접근 가능하게:set number151 none 를 All로 변경# systemctl restart httpd# cd /var/www/html# mv /root/다운로드/xe.zip .# unzip xe*# chmod 707 xe //권한 변경# cd /var/www/html/xe/modules/# ls //board는 게시판임 XE 실습123456# mysql&gt;GRANT ALL PRIVILEGES ON xeDB.* TO xeUser@localhost IDENTIFIED BY &apos;1234&apos;;&gt;exit# mysql -u xeUser -p1234&gt; CREATE DATABASE xeDB; XE 설정외부에서 해도되고 내부에서 해도된다. 즉 관계 없다.윈 클라이언트로 하자.192.168.111.100/xe 접속한국어 . 다음동의. 다음다음mysql 선택 다음xeUser /1234 /xeDB 다음kora선택 다음aa@aa.com / 4321 /4321 관리자임. / admin 게시판 추가는 책을보자","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"11장. 쇼핑몰 데이터베이스 구축, Oracle 설치, Oracle에서 쇼핑몰 DB 구축","slug":"ThisIsLinux31","date":"2017-07-13T09:09:57.000Z","updated":"2018-09-03T05:51:27.835Z","comments":true,"path":"2017/07/13/ThisIsLinux31/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/13/ThisIsLinux31/","excerpt":"","text":"서버에서 실행해도 되고 윈 클라이언트에서 해도된다. 그러나 윈 클라이언트에서 해보자 윈도우에서 실행cmd 열기cd “c:\\Program Files (x86)”cd “MariaDB 10.0”cd MariaDB 10.0cd bin mysql -h 192.168.111.100 -u winuser -p4321 입력쿼리문은 책을 참조하자….. 오라클을 설치해보자서버에서 실행하자 카페에서 링크타고 오라클을 들어가서 깔자123456789101112131415161718192021222324252627# cd 다운로드/# ls -l# unzip oracle* //압축을 풀자# ls -l Disk1/# cd Disk1/오라클을 설치하기 위해서는 가상메모리 2기가가 필요함.그래서 추가적으로 2기가를 추가한다.# dd if=/dev/zero of=/swapfile bs=1024 count=4194304# mkswap /swapfile //스왑메모리로 만들자# swapon /swapfile //스왑을 키자# swapon -s //스왑 확인 총 (6기가 임을 확인)스왑을 껏다 켜도 유지되도록 하자# cd /etc/rc.d # chmod 755 rc.local# vi rc.local맨 밑에swapon /swapfile 추가# reboot# swapon -s //스왑 확인 총 (6기가 임을 확인)오라클을 본격적으로 설치하자# cd 다운로드/Disk1/# pwd# ls -l# yum -y localinstall oracle* 오라클을 설정하자123456# service oracle-xe configure엔터(8080은 외부로 접속하는 포트)엔터(1521은 sql+로 접속하는 포트)1234엔터1234엔터y 엔터(자동으로 실행할꺼냐) 오라클 서비스를 시작하자123456789101112131415# /etc/init.d/oracle-xe start //오라클 시작# vi /etc/bashrc //맨아래 다음을 입력.# . /u01/app//oracle/product/11.2.0/xe/bin/oracle_env.sh //오라클 환경설정하는 스크립트 실행하는것. //껏다켜면 이 한줄을 입력해야 하지만 //그 과정을 없애기 위해 /etc/bashrc에 추가# firewall-config영구적 선택.포트 탭 선택추가 8080 tcp추가 1521 tcp(오라클을 센토스에서 만든것이 아니라 등록이 되어있지 않다.)옵션 - Firewalld 다시불러오기 오라클에 접속해보자웹브라우저 실행192.168.111.100:8080/apexinternaladmin1234로그인123412341234applyreturn1234 로그인 마리아db에서 입력한 쿼리문을 오라클에서 실행해보자.123456# mkdir /oradata //데이터베이스가 생성될 디렉토리# chmod 777 /oradata# sqlplus //오라클에서 데이터베이스 시작system 입력 //오라클에서 가장 높은 관리자는 system1234 입력책보고 쿼리 입력","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"11장. MariaDB 설치/운영 , Windows에서 접속","slug":"ThisIsLinux30","date":"2017-07-12T09:21:35.000Z","updated":"2018-09-03T05:51:25.577Z","comments":true,"path":"2017/07/12/ThisIsLinux30/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/12/ThisIsLinux30/","excerpt":"","text":"마리아 DB 운영DBMS 설치12345678910111213141516171819카페에 올려놓은 마리아 db를 세개 다 받자.# yum -y remove mariadb-libs // 버전이 달라 새로 설치하면 충돌우려..# yum -y localinstall Maria*# systemctl restart mysql //mysql이 오라클로 들어가자 //개발자들이 마리아를 만들어냄.. # systemctl status mysql# checkconfig mysql on // systemctl enable mysql 과 동일 //상시가동하도록 설정# firewall-config //방화벽 열기영구적 탭 -&gt; 다시불러오기# mysql // 마리아디비 실행&gt; showdatabases; //그냥 확인차원칙은# mysql -u root -p 라고 입력 후 비번입력해야함지금은 비번을 설정 하지 않았으므로 엔터만 누르면 된다. 마리아 디비 암호 설정123456# mysqladmin -u root password &apos;1234&apos;마리아 디비 사용자인 root는 비번이 1234# mysql -u root -p //로그인1234 입력&gt;exit 윈도우 클라이언트에서 마리아DB 접속카페 접속해서 마리아디비 설치리눅스는 서버 클라이언트 따로지만 윈도우용은 하나다.다른건 설치하지 말고 클라이언트만 설치하자 서버에서 실행1234567# mysql -u root -p&gt; USE mysql&gt;SELECT user,host FROM user WHERE user NOT LIKE &apos;&apos;;루트 사용자는 외부에서 접속할 수 없다는 것을 확인.&gt;GRANT ALL PRIVILEGES ON *.* TO winuser@&apos;192.168.111.%&apos; IDENTIFIED BY &apos;4321&apos;; //192.168.111.XXX 는 허용하겠다.(윈도우 유저의 아이피의 마지막이 변동가능성이 있기 때문에 %로 처리) 윈도우에서 실행cmd 열기cd “c:\\Program Files (x86)”cd “MariaDB 10.0”cd MariaDB 10.0cd bin mysql -h 192.168.111.100 -u winuser -p4321 입력show databases;","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"10장. 웹 메일의 설치 및 사용","slug":"ThisIsLinux29","date":"2017-07-11T18:40:05.000Z","updated":"2018-09-03T05:51:23.317Z","comments":true,"path":"2017/07/12/ThisIsLinux29/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/12/ThisIsLinux29/","excerpt":"","text":"웹 메일의 설치 및 사용10장의 지금까지의 구현내용은 문제가 있다. 일반사용자는 POP3, SMTP 등에 대한 설정하는것에 대한 지식이 없으며 원하지도 않는다.즉. 이메일 서버를 구축하려면 웹 메일까지 설정을 해주어야 한다.우리는 이를 위해 다람쥐 메일이라고 불리는 squirrelmail을 사용한다. 다람쥐 메일 설치(서버)센토스에서 다람쥐는 제공하지 않으므로 페도라것을 사용해야한다. (페도라의 거의 모든 패키지는 센토스에서 돌아간다.)1234567891011121314151617181920212223242526272829303132333435363738394041# wget http://download.hanbit.co.kr/centos/7/squirrelmail-1.4.22-13.fc20.noarch.rpm# yum -y localinstall squi* //로컬설치# chown apache.apache -R /usr/share/squirrelmail/ //웹사용자인 아파치로 소유주 변경# chown apache.apache -R /var/lib/squirrelmail/# chown apache.apache -R /var/spool/squirrelmail/# chown apache.apache /etc/squirrelmail/config.php# /usr/share/squirrelmail/config/conf.pl //설정할 수 있는 실행파일2입력1 (도메인 변경)naver.comA4mail.naver.com8othersr101ko_KR2euc-krsrsq간단하게 다람쥐 메일을 들어올 수 있게 설정# vi /etc/httpd/conf/httpd.conf 맨위에 다음 한줄 추가Alias /webmail/ /usr/share/squirrelmail/# systemctl restart httpd # systemctl enable httpd 포트를 추가해야하는데 방화벽을 아까 꺼놨기 때문에 따로 하지 않겠다.웹을 www로 들어가기 떄문에 웹주소도 네임서버에 추가# vi /var/named/naver.com.db 맨뒤에 다음 한줄 추가www IN A 192.168.111.100# systemctl restart named 클라이언트에서 테스트 해보자파이어폭스에서 www.naver.com/webmail/ 입력맨아래 예외 추가 -&gt; 보안예외 확인lee / lee 입력편지쓰기-&gt; kim@daum.net -&gt;전송윈도우 클라이언트에서 받기를 눌러보자, 그 후 답장을 눌러 보내보자","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"10장. 센드메일 서버의 구현","slug":"ThisIsLinux28","date":"2017-07-11T08:30:49.000Z","updated":"2018-09-03T05:51:19.504Z","comments":true,"path":"2017/07/11/ThisIsLinux28/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/11/ThisIsLinux28/","excerpt":"","text":"네임서버를 만들었으니 이메일을 보내는 메일서버를 만들어 보자. 1.서버 메일서버를 만들자(naver)1.1 서버에서 메일 서버를 만들자(서버에서 진행)123456789101112131415161718192021222324252627282930313233# yum -y install sendmail-cf dovecot //sendmail-cf 보내는메일서버 //devoct 받는 메일서버# vi /etc/mail/sendmail.cf :set number85를 Cwnaver.com 으로 수정264 Addr=127.0.0.1 를 지운다저장외부 호스트가 메일을 전달할 수 있도록 허가# vi /etc/mail/access 다음을 추가naver.com RELAYdaum.net RELAY192.168.111 RELAY# makemap hash /etc/mail/access &lt; /etc/mail/access //변경내용 적용사용자의 메일박스에서 메일을 꺼내 사용자에게 전달하는 도베캇 설정# vi /etc/dovecot/dovecot.conf:set number24행 30행 33행 주석제거저장# vi /etc/dovecot/conf.d/10-ssl.conf:set number8행 ssl=yes로 수정저장# vi /etc/dovecot/conf.d/10-mail.conf:set number25행 주석제거119행 mail_access_groups =mail 으로 수정159행 주석제거저장 1.2 서버에 사용자를 만들자(서버에서 진행)1234# adduser lee# passwd lee암호 lee 이 사용자는 lee@naver.com 1.3 서비스를 시작하자(서버에서 진행)12345# systemctl restart sendmail# systemctl enable sendmail# systemctl restart dovecot# systemctl enable dovecot 1.4 서버에서 만든 메일서버가 잘 작동하나 확인해보자(클라이언트에서 진행)이를 위해 클라이언트에서 메일을 보낸다.(클라이언트에서 실행)12345678910111213141516171819202122232425262728293031323334# su# vi /etc/resolv.confnameserver 192.168.111.100# yum -y install evolution //이메일 클라이언트 프로그램프로그램-&gt;오피스-&gt;에볼루션계속-&gt;계속 전체이름: 이네이버전자메일 주소: lee@naver.com계속서버종류 pop선택서버: mail.naver.com사용자이름: lee포트: 995암호화방식: SSL특정방식사용계속계속서버 mail.naver.com계속이름 : 네이버 메일계속적용계속 허용 //꼭 해야한다.암호: lee로그인 암호:centos새로만들기받는사람 lee@naver.com새로만들기를 눌러 lee@naver.com으로 메일을 하나 보내보자. 그러면 보낸편지함에 하나 들어있고 메일박스로 들어가있는상태. 그 후 보내기/받기를 누르면 받은편지함에 메일이 하나 생성된다. 2.서버B 메일서버를 만들자(daum)2.1 서버B에 메일 서버를 만들자(서버B에서 진행)123456789101112131415161718192021222324252627282930313233# yum -y install sendmail-cf dovecot //sendmail-cf 보내는메일서버 //devoct 받는 메일서버# vi /etc/mail/sendmail.cf :set number85를 Cwdaum.net 으로 수정264 Addr=127.0.0.1 를 지운다저장외부 호스트가 메일을 전달할 수 있도록 허가# vi /etc/mail/access 다음을 추가naver.com RELAYdaum.net RELAY192.168.111 RELAY# makemap hash /etc/mail/access &lt; /etc/mail/access //변경내용 적용사용자의 메일박스에서 메일을 꺼내 사용자에게 전달하는 도베캇 설정# vi /etc/dovecot/dovecot.conf:set number24행 30행 33행 주석제거저장# vi /etc/dovecot/conf.d/10-ssl.conf:set number8행 ssl=yes로 수정저장# vi /etc/dovecot/conf.d/10-mail.conf:set number25행 주석제거119행 mail_access_groups =mail 으로 수정159행 주석제거저장 2.2 서버B에 사용자를 만들자(서버B에서 진행)1234# adduser kim# passwd kim암호 kim 이 사용자는 kim@daum.net 2.3 서비스를 시작하자(서버B에서 진행)12345678# systemctl restart sendmail# systemctl enable sendmail# systemctl restart dovecot# systemctl enable dovecot# systemctl stop firewalld //방화벽 끄기# systemctl disable firewalld //방화벽 끄기 3. 최종테스트를 해보자3.1 윈도우 클라이언트에서 해보자썬더버드를 받자. 이때 네이버에 접속되지 않는데 아까 도메인 서버를 100으로 세팅해놔서 그렇다..이름 : 김다음메일주소 : kim@daum.net암호 : kimPOP3 선택하고 완료lee@naver.com 으로 메일을 보내보자클라이언트로 돌아와 보내기/받기를 눌러보자 그 후 회신을 눌러보자그 후 윈도우 클라이언트로 와서 받기를 눌러보자.","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"10장. 메일서버 개념, 메일서버를 위한 네임서버 구현","slug":"ThisIsLinux27","date":"2017-07-10T15:56:35.000Z","updated":"2018-09-03T05:51:16.962Z","comments":true,"path":"2017/07/11/ThisIsLinux27/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/11/ThisIsLinux27/","excerpt":"","text":"메일서버네임서버에 대한이해가 필수적이므로 이해하고 넘어올것.E-mail의 송수신에서 사용되는 프로토콜 다음, 네이버의 메일서버 계정을 갖고있다면 kim@daum.net / lee.naver.com 가 있다. kim@daum.net -&gt; lee.naver.com 메일전송smtp를 통해 kim 메일서버의 큐에 들어가고 여유가 있을 때 smtp 프로토콜을 이용해 lee의 메일서버로 보내놓는다. 메일서버는 메일 박스에 넣어놓고 lee는 pop3 imap프로토콜을 써서 자신의 컴퓨터로 확인한다.보내는 프로토콜 : smtp받는 프로토콜 : POP3 IMAP 실습계획Server : naver 메일서버, 네임서버 역할을 한다.Server(B) : daum 메일 서버WinClient : 메일 클라이언트Client : 메일 클라이언트 1. 메일서버를 구현하기 전에 네임서버를 구현하자1.1 다음을 서버에서 실행하자123456789101112131415# vi /etc/hostname 첫줄 지우고 mail.naver.com 입력# vi /etc/hosts 맨 뒤에 다음 입력 192.168.111.100 mail.naver.com# yum -y install sendmail //메일서버를 구현하려면 sendmail이 설치되어 있어야함# vi /etc/mail/local-host-names 아래 mail.naver.com 입력# vi /etc/sysconfig/network HOSTNAME=mail.naver.com 입력# reboot 1.2 다음을 서버 B에서 실행하자12345678910111213141516# yum -y install sendmail# vi /etc/hostname 첫줄 지우고 mail.daum.net 입력# vi /etc/hosts 맨 뒤에 다음 입력 192.168.111.200 mail.daum.net# vi /etc/mail/local-host-names 아래 mail.daum.net 입력# vi /etc/sysconfig/network HOSTNAME=mail.daum.net 입력# reboot 1.3 서버를 마스터네임 서버로 만들자 (서버에서 실행하자)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# yum -y install bind bind-chroot# vi /etc/named.conf:set number11행 127.0.0.1 지우고 any로12행 ::1 지우고 none로17행 localhost 지우고 any로여기까지만 하면 캐싱전용 네임서버이다.우리가 만들것은 마스터 네임서버이므로 맨아래 다음을 추가zone &quot;naver.com&quot; IN &#123; type master; file &quot;naver.com.db&quot;; allow-update &#123; none; &#125;;&#125;;zone 위에 커서 올리고 5yy 누르고 p(5줄 복사)zone &quot;daum.net&quot; IN &#123; type master; file &quot;daum.net.db&quot;; allow-update &#123; none; &#125;;&#125;;저장 후 종료# cd /var/named# touch naver.com.db# vi naver.com.db$TTL 3H@ SOA @ root. ( 2 1D 1H 1W 1H ) IN NS @ IN A 192.168.111.100 IN MX 10 mail.naver.com. //달라진부분; mail exchange 메일이 오면 mail.naver.com한테 메일처리를 하게해라mail IN A 192.168.111.100# cp naver.com.db daum.net.db //내용이 비슷하니까 복붙# vi daum.net.db$TTL 3H@ SOA @ root. ( 2 1D 1H 1W 1H ) IN NS @ IN A 192.168.111.200 IN MX 10 mail.daum.net.mail IN A 192.168.111.200으로 수정# named-checkconf //name.conf파일을 확인 //아무메세지가 없으면 문법문제 없음# named-checkzone naver.com naver.com.db# named-checkzone daum.net daum.net.db포트는 여러개 열어야 하는데 복잡하므로 아얘포트문제는 생기지 않도록 다 열어놓자. 즉 방화벽을 꺼놓자.# systemctl stop firewalld //방화벽 끄기# systemctl disable firewalld //재부팅해도 꺼지도록# systemctl restart named //네임서버 시작# systemctl enable named //재부팅해도 켜지도록# systemctl status named //잘 돌고있는지 확인# nslookup //실제 내부에서 잘동작하는지 확인&gt;server 192.168.111.100&gt;mail.naver.comAddress: 192.168.111.100 //성공&gt;mail.daum.netAddress: 192.168.111.200 //성공 2.각 컴퓨터의 로컬네임 서버를 생성한 네임서버로 지정하자2.1 서버의 네임서버를 지정123456# cd /etc/sysconfig/network-scripts/# ls //수정할 파일을 확인하자 ens....# # vi ifcfg-ens32 // 껏다 켜도 유지되도록 설정DNS1=192.168.111.100 으로 하자# systemctl restart network# cat /etc/resolv.conf //확인 서버 B의 네임서버를 지정123456# cd /etc/sysconfig/network-scripts/# ls //수정할 파일을 확인하자 ens....# # vi ifcfg-ens32 // 껏다 켜도 유지되도록 설정DNS1=192.168.111.100 으로 하자# systemctl restart network# cat /etc/resolv.conf //확인 2.2 클라이언트의 네임서버 지정클라이언트는 고정ip가 아니기 때문에 껏다 켜면 vmware가 제공하는 2번으로 바뀌기 때문에 클라이언트는 껏다 켜지 않겠다. 그러므로 conf파일만 수정하자123456789101112$ su -# vi /etc/resolv.confnameserver 192.168.111.100으로 수정# exit# nslookup&gt; mail.daum.netAddress: 192.168.111.200 //확인&gt; mail.naver.comAddress: 192.168.111.100 //확인 2.3 윈도우 클라이언트 설정12345678cmd 열기ipconfig //이더넷 어댑터 로컬 영역 연결netsh interface ip set dns &quot;로컬 영역 연결&quot; static 192.168.111.100ping mail.daum.net 1#","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"9장. 마스터 네임서버 구축, 라운드 로빈 방식 네임서버","slug":"ThisIsLinux26","date":"2017-07-09T05:49:08.000Z","updated":"2018-09-03T05:51:14.691Z","comments":true,"path":"2017/07/09/ThisIsLinux26/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/09/ThisIsLinux26/","excerpt":"","text":"앞에한건 캐싱전용이었다.캐싱전용네임서버 - 자기가 관리하는건 없고 무조건 밖에 나가서 알아다가 알려줌. 마스터 네임 서버 - 자기가 관리하는 것들이 있다. 마스터 네임 서버 구축1. 웹서버 하나 간단하게 만들자(서버)1234567# rpm -qa httpd //설치가 되어있다.# systemctl status httpd //시작되어있나 확인# systemctl restart httpd //시작# firewall-config영구적 - http 체크 - firewalld 다시불러오기# vi /var/www/html/index.html&lt;h1&gt; CentOS 7 홈피 입니다&lt;/h1&gt; //삽입 2. ftp서버 간단하게 만들자(서버B)서버 B를 켠다.123# yum -y install vsftpd# firewall-cmd --permanent --add-service=ftp //방화벽설정# firewall-cmd --reload 3. 환경설정을 해주자(서버)서버에서12345678910# vi /etc/named.conf:set number맨아래 가서zone &quot;centos.com&quot; IN &#123;type master; file &quot;centos.com.db&quot;; allow-update&#123;none;&#125;;&#125;;입력. 이 의미는 서버컴퓨터는 centos.com의 마스터 네임서버다. 그리고 상세정보는 centos.com.db(임의로 지은것)에 들어있다.# named-checkconf //방금작성한것 문법적으로 잘못된것 없나 확인 4. centos.com.db를 만들자(서버)123456789101112131415161718192021# cd /var/named# pwd# ls# touch centos.com.db# vi centos.com.db아래 추가$TTL 3H@ SOA @ root. (2 1D 1H 1W 1H) IN NS @ IN A 192.168.111.100www IN A 192.168.111.100ftp IN A 192.168.111.200위 세줄은 항상 써주는것.네번째는 자기 자신의 ip 입력나머지 아래 두줄은 알려줄것.# named-checkzone centos.com centos.com.db //오류있는지 확인# systemctl restart named방화벽 설정은 앞에서 해줬으니 안해도됨 5. 접속 테스트해보자클라이언트 켜자12345$ su -$ vi /etc/resolv.conf맨 아래 192.168.111.100 으로 수정www.centos.com 접속해보자ftp 접속해보자서버 B에서 다음을 실행하자(ftp서비스 시작)12# systemctl restart vsftpd# systemctl status vsftpd클라이언트에서 접속해보자123# ftp ftp.centos.com // anonymous //엔터 라운드 로빈 방식의 네임 서버이전에 실습한 방식은 여러명이 동시에 접속할 경우 서버 하나에 부하가 걸린다. 그래서 웹 서버를 여러개 만들어서 요청이 들어올 때마다 번갈아가면서 요청처리. 네이버가 이 방식을 쓴다.123# nslookupwww.naver.com두개가 넘어온다. 실습.www.john.com 으로 접속 했을 때 각각 다른 페이지를 뿌려주는실습.(라운드로빈 방식 확인가능) 1234# nslookup&gt; www.yes24.com //아이피 주소를 확인하기위해&gt; www.danawa.com //아이피 주소를 확인하기위해&gt; www.nate.com //아이피 주소를 확인하기위해 1234567891011121314151617# cd /var/named# vi centos.com.db아래 두줄 지우고 다음으로 대체www IN CNAME webserver.centos.com.webserver 100 IN A 61.111.13.51 200 IN A 119.205.194.11 300 IN A 120.50.131.112순차적으로 주소를 알려준다. 100,200,300 은 순차번호이다.# systemctl restart named# nslookup&gt;server 192.168.111.100&gt;www.centos.com결과가 세개가 온다. 클라이언트에서 접속해보자123# vi /etc/resolv.conf//192.168.111.100 이 맞나 확인//아니면 설정하기 웹 브라우져 닫고www.centos.com 들어가보자(여러번)","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"9장. 도메인 이름 체계 개념, 캐싱 전용 네임서버 구축","slug":"ThisIsLinux25","date":"2017-07-09T01:29:00.000Z","updated":"2018-09-03T05:51:12.346Z","comments":true,"path":"2017/07/09/ThisIsLinux25/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/09/ThisIsLinux25/","excerpt":"","text":"초창기 인터넷에서는 1대의 네임 서버만으로 충분히 IP주소와 이름의 관리가 가능했다. 하지만 인터넷이 확장되면서 그것이 도메인 이름 체계가 고안되었다. 원칙은 www.nate.com. 이다. 맨 뒤에 .을 붙여줘야 한다. 로컬 네임서버가 작동하는 순서www.nate.com. 접속과정1./etc/hosts 를 보고 없으면 /etc/resolv.conf 에 있는 로컬 네임서버를 참고한다.2.하지만 이 로컬네임서버도 많은것을 알지 못하므로 얘도 루트 네임서버한테 물어본다. 이렇게. “내가지금 www.nate.com으로 가려한다.”3.그러면 루트네임서버가 “그건 내가 모르지만 내가 관리하는 com의 네임서버 ip를 줄게”4.그러면 로컬네임서버는 다시 com네임서버에게 다시 물어본다5.그러면 com네임서버가 nate ip를 알려준다. 그러면 nate.com아이피는 www의 ip를 응답해준다. www.daum.net. 접속과정루트네임서버 -&gt; net 네임서버 -&gt;daum네임서버 -&gt;www네임서버 이제 우리가 할 실습!/etc/resolv.conf 에 있는 로컬네임서버를 만드는것.서버컴퓨터 : 캐싱전용 네임서버 (PC에서 URL로 IP주소를 얻고자 할 때 해당하는 URL의 IP주소를 알려주는 네임 서버를 말함) 클라이언트,서버B 에서 /etc/resolv.conf의 주소를 서버컴퓨터로 한다. 서버 설정1. 관련 패키지 설치1# yum -y install bind bind-chroot 2. 누가 서버컴퓨터로 물어보든 응답해주게 설정123456# vi /etc/named.conf //캐싱정보관련 설정파일:set number11행 보면 127.0.0.1 지우고 any로 변경 //누가 서비스를 요청하던 제공하겠다12행 ::1 지우고 none로 변경17행 localhost any로 변경named.conf 파일을 수정함으로서 누가 서버컴퓨터가 누가물어보든 응답을 해준다. 3. 서비스 재시작 및 환경설정123456789101112# systemctl restart named //네임서버의 서비스 이름은 named# systemctl status named //작동여부 확인disable 가 있다는건 껏다켜도 동작하지 않는다는것.# systemctl enable named //껏다켜도 작동하도록 설정# firewall-config영구적 선택 -&gt; dns 선택-&gt; 옵션/firewalld다시불러오기# nslookup //내부적으로 잘돌아가는지 테스트&gt;server 192.168.111.100&gt;www.daum.net&gt;exit 클라이언트 설정Client 켜고 실행123456# su -c &apos;vi /etc/resolv.conf&apos;password 입력192.168.111.100 으로 수정파이어폭스로 아무데나 접속해보자 Server B 켜고 실행123456789# vi /etc/resolv.confpassword 입력192.168.111.100 으로 수정# ping -c 3 www.yahoo.com# yum -y install elinks //텍스트모드의 웹브라우져# elinks //실행 윈도우에서 설정제어판 열기네트워크 상태 및 작업보기로컬영역 연결 클릭속성IPv4 속성다음 dns 서버 주소 사용기본 설정 DNS 서버에 192.168.111.100 입력 윈도우에서 원래대로 돌리기cmd 열고ipconfig 입력이더넷 어댑터 뒤에있는 글자 복사. netsh interface ip set dns “로컬 영역 연결” dhcp//로컬 영역 연결은 (이더넷 어댑터 뒤에있는 글자)","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"9장. 네임서버 개념, IP주소 획득 흐름","slug":"ThisIsLinux24","date":"2017-07-09T00:07:45.000Z","updated":"2018-09-03T05:51:10.168Z","comments":true,"path":"2017/07/09/ThisIsLinux24/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/09/ThisIsLinux24/","excerpt":"","text":"네임서배 개요네임서버=DNS(Domain Name System)서버도메인 이름을 IP주소로 변환시켜 주는 역할 = 이름해석12345678910# nslookup //컴퓨터에 연결된 네임서버를 조회&gt; server //도메인 이름을 칠 때 물어보는 주소 조회Default server: 192.168.111.2Address: 192.168.111.2#53&gt; www.nate.comServer: 192.168.111.2Address: 192.168.111.2#53exit 네임서버의 위치를 저장해 놓는곳은?123# cat /etc/resolv.confGenerated by NetworkManagernameserver 192.168.111.2 실습123456789101112131415# vi /etc/resolv.conf#을 넣어 두줄 다 주석처리.저장 후 종료www.nate.com 접속되지 않음# vi /etc/hosts211.234.241.205 www.nate.com 추가저장 후 종료www.nate.com 접속 가능네임서버가 죽어있는데 열린다. /etc/hosts에 먼저 접근 후resolv.conf파일에 접근한다.즉 수첩에 전화번호가 적혀있으면 114에 전화하지 않는것. nate.com 접속방식웹브라우저에서 www.nate.com을 치면 /etc/hosts에 접근하여 해당 ip가 있는지 확인을 한다. 존재 할 경우 그 ip로 접속하고 존재하지 않을 경우 /etc/resolv.conf 로 가서 네임서버를 확인하고 해당 ip주소를 알아온다.","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"8장. SSH서버, VNC서버","slug":"ThisIsLinux23","date":"2017-07-08T09:16:00.000Z","updated":"2018-09-03T05:51:07.639Z","comments":true,"path":"2017/07/08/ThisIsLinux23/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/08/ThisIsLinux23/","excerpt":"","text":"SSH서버텔넷과 용도는 동일하지만 보안이 강화되어있음명령문을 입력 시 암호화 되어서 날라간다. SSH서버를 쓰는것이 권장사항이다. CentOS에서 쓰는 SSH서느는 openSSH 서버라 함. 실습1.서버가 설치되었는지 확인12# rpm -qa | grep openssh설치되어있다. 2.가동되고 있는지 확인12345# systemctl status sshdLoaded: loaded (/usr/lib/systemd/system/sshd.service; enabled) //enable는 상시가동이라는 뜻Active: active (running) since 토 2017-07-08 17:43:06 KST; 1h 5min ago //돌고 있다.즉 ssh는 기본적으로 centos에서 깔려있고 가동되어 있다.기본적으로 쓰인다!!! 3.방화벽 열렸는지 여부 확인12# firewall-config쭉 내리면 ssh가 켜져있다. 4.새로운 리눅스(Client)에서 접속해보자클라이언트 켜자.1234# rpm -qa | grep openssh //깔려있나확인# ssh teluser@192.168.111.100 //telnet와 접속방법이 다름# ifconfig //서버컴퓨터의 아이피 확인 5.윈도우에서 접속해보자Putty 설치192.168.111.100 접속참고로 ssh는 포트 22 telnet는 23한글이 깨지면 오른쪽 누르고 유니코드로 전환abc.txt를 하나 만들고 gedit abc.txt를 실행하면 되질 않는다.왜냐하면 텔넷,SSH는 텍스트 모드로만 전송이 되기 때문에.즉 그래픽 명령어는 아얘 쓸 수 없다. 그럼 telnet ssh 다른점이 없는건가?그렇다. 기능은 같으나 ssh가 보안이 추가된 것이다. VNC 서버X 윈도우 환경으로 원격접속을 사용하고 싶을 때.telnet ,ssh 보다 많이 느리다. 그래픽이 왔다갔다하기 때문에! 1.VNC 설치 및 설정123# rpm -qa | grep tiger //설치유무 확인//미니멈 버전이 깔려있다. 다시깔자# yum -y install tigervnc-server VNC는 사용자한테 너 접속해, 너 화면번호 몇번 써 를 지정해야한다. 2.센토스 사용자 너 1번화면으로 접속해를 설정123456# cp /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@:1.service//1번화면을 쓰기위한 작업# vi /etc/systemd/system/vncserver@\\:1.service :set number40행,41행 의 &lt;USER&gt;을 지워버리고 centos로 고침 그리고 저장 후 종료 3.방화벽 열기1# firewall-config 설정에서 영구적 선택쭉 내려서 vnc-server체크옵션에서 firewalld 다시불러오기 클릭 4.centos사용자가 1번화면으로 들어올 때 전용 비밀번호를 생성즉 vnc 전용 비밀번호 생성123# su - centos# vncserver암호는 123456으로 설정 5.접속해보자리눅스 클라이언트에서 접속12345# rpm -qa | grep tiger //깔려있지 않은것을 확인# su -c &apos;yum -y install tigervnc&apos; //루트 권한으로 실행하는것.# vncviewer 192.168.111.100:1 //1은 디스플레이 번호 password 입력윈도우 클라이언트에서 접속카페이서 tigervnc 설치파일 깔기옵션해서 해상도를 낮추면 사용할만 함(color level)tigervnc vncviewer을 켜고192.168.111.100:1 입력하고 암호 123456","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"8장. 텔넷서버","slug":"ThisIsLinux22","date":"2017-07-08T08:32:45.000Z","updated":"2018-09-03T05:51:04.785Z","comments":true,"path":"2017/07/08/ThisIsLinux22/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/08/ThisIsLinux22/","excerpt":"","text":"이번장은 상당히 중요하다. 앞으로의 모든 장은 네트워크 서버를 구축하는데 8장이 첫 구축이다. 그러므로 8장을 잘 이해하면 큰 흐름을 이해 할 수 있다. 텔넷서버오랫동안 전통적으로 사용되어 온 원격 접속 방법이다.텔넷 서버에 접속하려면 텔넷 클라이언트를 쓰면 된다. 각 서버마다 해당되는 클라이언트가 존재한다. 텔넷 서버 구축 단계1.텔넷 서버 설치2.텔넷 서비스 시작3.텔넷 전용 사용자 생성4.방화벽 설정(포트 열기)5.텔넷 서비스 상시가동6.클라이언트에서 접속 실습모든 가상머신을 초기화하자! 1.텔넷 서버 설치12# rpm -qa | grep telnet //텔넷이 설치되었나 확인# yum -y install telnet-server //설치되어있지 않아 설치 2.텔넷 서버 서비스 시작12345# systemctl restart telnet.socket //restart는 시작이 안되어있으면 새로 시작하고 시작되어있으면 재시작함.# systemctl status telnet.socket //가동여부 확인 3.텔넷 전용 사용자 생성12# adduser teluser# passwd teluser //1234로 설정 4.방화벽 설정(포트 열기)외부에서 접속이 가능하기 위해서 여는 것이므로 일단 내부에서 잘 접속이 되는지 확인 후 에 방화벽을 열자1234567891011# yum -y install telnet //텔넷 클라이언트 프로그램 설치# telnet 127.0.0.1 //자기 자신으로 접속 teluser / 1234 입력# exit //종료 이제 방화벽 설정하자# firewall-config //설정차을 띄우자 설정 영구적 탭 선택 //서버는 한번 쓰는게 아니라 영원히 쓰기 때문에. 영역 탭의 public 선택 후 서비스에서 telnet 체크 옵션-&gt;Firewall 다시불러오기 이제 포트가 열렸다. 5.텔넷 서비스 상시가동포트가 열렸지만 컴퓨터가 껏다 켜면 제대로 작동안하기 때문에 다음을 입력1# systemctl enable telnet.socket //껏다 켜도 유지됨 6.클라이언트에서 접속이제 윈 클라이언트를 부팅하고 접속해보자.접속을 위해서는 서버의 IP주소가 필요하다. 서버에서 다음을 입력1# ifconfig //192.168.111.100IP주소 확인 했으니 윈 클라이언트로 가서 제어판-프로그램-프로그램 및기능Windows 기능 사용/사용안함 가서 맨아래 텔넷 클라이언트 기능 설치 윈도우 cmd를 열자그 후 telnet 192.168.111.100teluser /1234 입력 후 엔터접속이 된다.exit로 종료","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"7장. 셸 스크립트 프로그래밍","slug":"ThisIsLinux21","date":"2017-07-08T01:54:28.000Z","updated":"2018-09-03T05:51:02.355Z","comments":true,"path":"2017/07/08/ThisIsLinux21/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/08/ThisIsLinux21/","excerpt":"","text":"Centos의 기본 셸은 bash셸은 명령어를 해석 해 주는 것이다. -Alias, History, 연산 등의 기능을 갖는다. 환경변수12# echo $PATH //명령어를 실행하면 //명령어를 찾는 폴더들이 출력됨. 셸 스크립트 프로그래밍C언어와 유사하다.변수, 반복문,제어문 등의 사용이 가능vi, gedit으로 작성 가능 12345678910111213# vi name.sh //셸의 약자로 sh다음과 같이 입력#!/bin/sh //셸은 이것을 무조건 쓴다.echo &quot;사용자이름: &quot;$USERNAMEexit 0vi를 빠져나와서# sh name.sh //실행 방법 1# chmod u+x name.sh //실행방법2# ./name.sh //실행방법2 변수의 기본변수를 사용하기 전에 미리 선언하지 않으며, 변수에 처음 값이 할당되면서 자동으로 변수가 생성모든 변수는 ‘문자열(String)’로 취급변수 이름은 대소문자를 구분변수를 대입할 때 ‘=’ 좌우에는 공백이 없어야함 12345678910111213141516# testval = Hello //에러발생. 공백존재# testval=Hello# echo $testval //Hello 출력됨# testval=Yes Sir //에러발생# testval=&quot;Yes Sir&quot;# echo $testval //Yes Sir 출력# testval=7+5# echo testval //7+5 출력# testval=&apos;expr 7+5&apos;# echo testval //12 출력","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"6장 사용자별 공간 할당(쿼터)","slug":"ThisIsLinux20","date":"2017-07-07T14:55:51.000Z","updated":"2018-09-03T05:50:59.979Z","comments":true,"path":"2017/07/07/ThisIsLinux20/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/07/ThisIsLinux20/","excerpt":"","text":"쿼터사용자마다 용량 제한을 두는것이다.ex.클라우드 서비스를 가입하면 데이터 양이 한정되어있음. 쿼터 실습설치 직후로 초기화하자. 새로운 디스크를 추가해서 쿼터 전용 디스크로 하자사용자의 홈 디렉토리는 별도의 디스크로 하는것이 효과적이다. 그리고 사용자별 쿼터도 지정해보자 1. 20기가짜리 하나 디스크 달자1234567# fdisk /dev/sdb# mkfs.ext4 /dev/sdb1# mkdir /userHome //앞으로 추가되는 사용자는 userHome를 홈 디렉토리로 함# mount /dev/sdb1 /userHome/# vi /etc/fstab/dev/sdb1 /userHome ext4 defaults 1 2 추가 2. 유저 두명 추가하자12345678910# useradd -d /userHome/john john //홈디렉토리를 지정하면서 유저생성# useradd -d /userHome/bann bann //홈디렉토리를 지정하면서 유저생성 # ls -l /userHome //확인# passwd john //암호는 1234로 설정# passwd bann //암호는 1234로 설정 3. 아까 추가한 디스크를 쿼터용으로 설정하자1234567# vi /etc/fstabdefaults 를 아래와 같이 변경defaults,usrjquota=aquota.user,jqfmt=vfsv0리부트 해도 되지만 귀찮으니까# mount --options remount /userHome# mount //맨아래서 확인 4. 쿼터디비생성명령어들에 대해 관심있으면 책을보자1234567891011# cd /userHome/# quotaoff -avug# quotacheck -augmn# rm -rf aquota.*# quotacheck -augmn# touch aquota.user aquota.group# chmod 600 aquota.*# quotacheck -augmn# quotaon -avug# ls -l //aquota.group , user 생긴것 확인 5. 개인별 쿼터 설정블록(block)이 현재 사용하는 키로바이트 수 소프트제한(soft)- 넘어갈수 있지만 기간이 있음하드제한(hard) -완전히 못넘어감 소프트를 100으로 주고 하드를 150을 주었을 때130을 저장하면 몇일 이내에 30메가를 줄여야함. inodes- 파일의 개수를 제한하는것123456789101112131415161718192021222324# edquota -u john //유저 존에 대해 쿼터를 수정하겠다.소프트 10240(10메가) 하드 15360(15메가)를 주고 저장# su - john //존으로 로그인# cp /boot/vmlinuz-3.10.0-123.el7.x86_64 test1 // 파일 복사# cp /boot/vmlinuz-3.10.0-123.el7.x86_64 test2# cp /boot/vmlinuz-3.10.0-123.el7.x86_64 test3쿼터가 넘어갔다고 경고 뜸# ls -l //데이터가 잘 들어갔다.# cp /boot/vmlinuz-3.10.0-123.el7.x86_64 test4sdb1: write failed, user block limit reached.cp: `test4&apos;에 쓰는 도중 오류 발생: 디스크 할당량이 초과됨cp: failed to extend `test4&apos;: 디스크 할당량이 초과됨 오류뜬다.# ls -l//마지막 데이터는 용량이 다름 즉 짤려있음# quota // 내가 얼마나쓰고 있는지 확인block 현재 사용량grace가 6일동안 봐준다는것. 6. 존이 한것을 밴한테 그대로 적용하기1234# exit //존 로그아웃# repquota /userHome //쿼터확인# edquota -p john bann","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"6장. LVM 개념과 구현, RAID에 CentOS 설치","slug":"ThisIsLinux19","date":"2017-07-07T03:42:04.000Z","updated":"2018-09-03T05:50:57.003Z","comments":true,"path":"2017/07/07/ThisIsLinux19/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/07/ThisIsLinux19/","excerpt":"","text":"LVMLogical Volume Manage여러개의 하드디스크를 합쳐서 한 개의 파일 시스템으로 사용하는것으로 필요에 따라 다시 나눌 수 있다.예로 2테라 두개를 합친 후 1테라 3테라로 나눠서 사용한다. 물리 볼륨:sda1, sdb1 등의 파티션 볼륨 그룹:물리 볼륨을 합쳐서 1개의 물리그룹으로 만드는것. 논리 볼륨:볼륨 그룹을 1개 이상으로 나눠서 논리 그룹으로 나눈 것 실습3기가, 2기가를 볼륨 그룹으로 만들고3기가, 1기가, 1기가 논리 볼륨으로 만들어보자 1. 2기가, 3기가 디스크 추가버츄어머신 에딧에서.. 2. 파티션 설정12345678910111213141516171819# fdisk /dev/sdbnp1엔터엔터t8ew# fdisk /dev/sdcnp1엔터엔터t8ew 3. 피지컬 볼륨으로 만들기12# pvcreate /dev/sdb1# pvcreate /dev/sdc1 4. 볼륨 그룹으로 만들기123# vgcreate myVG /dev/sdb1 /dev/sdc1# vgdisplay //볼륨그룹 확인 5. 1기가 3기가 1기가로 나누자123456# lvcreate --size 1G --name myLG1 myVG# lvcreate --size 3G --name myLG2 myVG# lvcreate --extents 100%FREE --name myLG3 myVG //나머지 다써라# ls -l /dev/myVG //확인 6. 포멧하자123# mkfs.ext4 /dev/myVG/myLG1# mkfs.ext4 /dev/myVG/myLG2# mkfs.ext4 /dev/myVG/myLG3 7. 마운트하자123456# mkdir /lvm1 /lvm2 /lvm3# mount /dev/myVG/myLG1 /lvm1# mount /dev/myVG/myLG2 /lvm2# mount /dev/myVG/myLG3 /lvm3# df //확인 8. fstab에 등록하자123456# vi /etc/fstab팁 yy 한다음에 pp하면 복붙이된다./dev/myVG/myLG1 /lvm1 ext4 defaults 1 2/dev/myVG/myLG2 /lvm2 ext4 defaults 1 2/dev/myVG/myLG3 /lvm3 ext4 defaults 1 2 RAID 1 방식으로 디스크에 CentOS를 설치하자392p 보고 하자 1234# mdadm --detail -scan //확인해보자# mdadm --detail /dev/md/root //자세히보자","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"6장. RAID6 와 RAID 1+0","slug":"ThisIsLinux18","date":"2017-07-07T00:47:34.000Z","updated":"2018-09-03T05:50:54.285Z","comments":true,"path":"2017/07/07/ThisIsLinux18/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/07/ThisIsLinux18/","excerpt":"","text":"RAID6패리티가 2개이기 때문에 신뢰성이 높다 RAID 1+0RAID 0,1 쓰는것 실습디스크 10개 스냅샷으로 돌아온 후 2기가 짜리 하나를 지워버린다. RAID 6 생성123456789# mdadm --create /dev/md6 --level=6 --raid-devices=4 /dev/sdb1 /dev/sdc1 /dev/sdd1 /dev/sde1# mkfs.ext4 /dev/md6 //포멧# mkdir /raid6# mount /dev/md6 /raid6# df //2기가 확인 RAID 1+0 생성이는 RAID 1을 두개 먼저 생성해야한다. md2 ,md3를 RAID1으로 만들고 이 두개를 RAID 0으로 묶는다. 12345678910111213141516# mdadm --create /dev/md2 --level=1 --raid-devices=2 /dev/sdf1 /dev/sdg1 //raid1 md2로 생성# mdadm --create /dev/md3 --level=1 --raid-devices=2 /dev/sdh1 /dev/sdi1 //raid1 md3로 생성# mdadm --create /dev/md10 --level=0 --raid-devices=2 /dev/md2 /dev/md3 //md2, md3로 raid0 생성# mkfs.ext4 /dev/md10 //포멧# mkdir /raid10# mount /dev/md10 /raid10# df 잘동작하나 확인12345678# cp /boot/vmlinuz-3.10.0-123.el7.x86_64 /raid6/testFile# cp /boot/vmlinuz-3.10.0-123.el7.x86_64 /raid10/testFile# vi /etc/fstab/dev/md6 /raid6 ext4 defaults 1 2/dev/md10 /raid10 ext4 defaults 1 2//재부팅되도 마운트 유지하기 위해 추가 고장내보자SCSI 3, 5 ,8, 9 디스크 없애고 부트 RAID 6 확인12345# mdadm --run /dev/md6 //md6 실행# df //확인# ls -l /raid6 //데이터 확인# mdadm --detail /dev/md6 RAID 1+0 확인1234# mdadm --run /dev/md2# mdadm --run /dev/md3# mdadm --detail /dev/md10","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"RAID 0,1,5 의 고장과 원상 복구","slug":"ThisIsLinux17","date":"2017-07-06T03:33:07.000Z","updated":"2018-09-03T05:50:51.341Z","comments":true,"path":"2017/07/06/ThisIsLinux17/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/06/ThisIsLinux17/","excerpt":"","text":"SCSI 2,4,6,9를 고장내 놓고 잘동작하는 지 확인 해 보겠다. 잘 동작하나 확인하기 위해 고장내기 전에 파일을 옮긴다.123456# cp /boot/vmlinuz-3* /raidLinear/testFile# cp /boot/vmlinuz-3* /raid0/testFile# cp /boot/vmlinuz-3* /raid1/testFile# cp /boot/vmlinuz-3* /raid5/testFile# halt -pvmplayer을 켜고 SCSI 2,4,6,9 디스크를 제거쫌 지나면 응급복구모드로 실행이됨암호를 입력해주자 ls -l /dev/sd* 을 하니까 당겨져 있다. sdc가 sdb 이런식으로 RAID 1, 5 는 데이터가 살아있어야 한다. RAID 1 확인1234567# df //마운트가 다 끊겨있다.# mdadm --run /dev/md1 //강제로 가동시키는 것시작되었다.# df //raid1가 마운트 된것을 확인.# ls -l /raid1 //데이터가 잘 있는지 확인# mdadm --detail /dev/md1 //하나는 살아있고 하나는 removed인것을 확인 RAID 5 확인12345# mdadm --run /dev/md5 //강제로 가동시키는 것시작되었다.# df //raid5가 마운트 된것을 확인.# ls -l /raid5 //데이터가 잘 있는지 확인# mdadm --detail /dev/md5 //하나는 살아있고 하나는 removed인것을 확인 RAIDLinear 확인12# mdadm --run /dev/md9 //강제로 가동시키는 것실행할 수 없다. 결함을 허용하지 않음 RAID 0 확인12# mdadm --run /dev/md0 //강제로 가동시키는 것실행할 수 없다. 결함을 허용하지 않음 시스템이 재대로 실행되도록 해보자1234567891011# mdadm --stop /dev/md9 //종료# mdadm --stop /dev/md0 //종료# vi /etc/fstabmd9,md0 주석 하고# reboot리부트를 했는데 복구모드로 실행이 된다면 컨트롤 D를 누르고실행한 다음에 재 마운트를 해주면 된다.# df //마운트가 되어있는것 확인. 새로운 디스크를 장착하여 원상복구를 시켜보자Linear RAID, RAID 0 은 데이터를 살릴 순 없다.그러나 RAID 1, RAID 5는 데이터를 살릴 수 있다. vmplayer에서 디스크 4개를 1기가씩 주고 추가하자. 알아서 빈곳을 잘 찾아간다. 우리가 조금전 추가했던것은 sdc, sde, sdg, sdi 이다.2,4,6,9 로 들어갔으므로.. RAID 0, Linear Raid는 새로 만들어주어야 한다.12345678910111213141516# ls -l /dev/sd* //# fdisk /dev/sdc~sdi 까지 n 입력 p 입력 엔터 엔터 t 입력 fd 입력 w 입력# mdadm --stop /dev/md9 //다시만들기위해 stop# mdadm --create /dev/md9 --level=linear --raid-devices=2 /dev/sdb1 /dev/sdc1#mdadm --detail /dev/md9 //확인해보자# mdadm --stop /dev/md0 //다시만들기위해 stop# mdadm --create /dev/md0 --level=0 --raid-devices=2 /dev/sdd1 /dev/sde1# mdadm --detail /dev/md9 //확인해보자 RAID 1, RAID 5는 새로만들면 안되고 추가해주어야 한다.1234567891011121314# mdadm /dev/md1 --add /dev/sdg1# mdadm /dev/md5 --add /dev/sdi1# vi /etc/fstab/dev/md9 /raidLinear ext4 defaults 1 2/dev/md0 /raid0 ext4 defaults 1 2/dev/md1 /raid1 ext4 defaults 1 2/dev/md5 /raid5 ext4 defaults 1 2이렇게 바꿔준다.# reboot# df //마운트 확인. 데이터를 한번 확인해보자. 123456789101112131415# ls -l /raid0drwx------ 2 root root 16384 7월 6 17:26 lost+found-rwxr-xr-x 1 root root 4902656 7월 6 17:31 testFile# ls -l /raid1drwx------ 2 root root 16384 7월 6 17:27 lost+found-rwxr-xr-x 1 root root 4902656 7월 6 17:31 testFile# ls -l /raid5drwx------ 2 root root 16384 7월 6 17:29 lost+found-rwxr-xr-x 1 root root 4902656 7월 6 17:31 testFile# ls -l /raidLineardrwx------ 2 root root 16384 7월 6 17:25 lost+found-rwxr-xr-x 1 root root 4902656 7월 6 17:31 testFile raid 1그리고 raid5 는 데이터가 있을것이라 예상했지만 raid0 그리고 raidLinear도 데이터가 존재한다. 어떻게 된 것일까? 운이 좋게 지워지지않은 영역에 존재하는 것일 것이다. 그러므로 데이터를 신뢰 할 수 없으며 이는 포멧을 해주는 것이 좋다. 12345678# umount /dev/md0 //포멧하기전에 마운트를 끊음# umount /dev/md9# mkfs.ext4 /dev/md0 //포멧# mkfs.ext4 /dev/md9# reboot //리부트를 하지않고 바로 마운트를 해줘도됨. //어차피 리부트하면 마운트되어있으니까 아무거나 선택! raid 1, raid 5 의 고장난 디스크에 대해서 따로 작업을 해 줘야할줄 알았는데 –add만 하면 되어서 생각보다 간단하다고 생각했다.","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"6장. RAID 정의 및 개념,구현","slug":"ThisIsLinux16","date":"2017-07-06T00:13:09.000Z","updated":"2018-09-03T05:50:48.837Z","comments":true,"path":"2017/07/06/ThisIsLinux16/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/06/ThisIsLinux16/","excerpt":"","text":"RAIDRedundant Array of Inexpensive Disks여러개의 디스크를 하나처럼 사용하는 RAID를 알아보자비용절감 + 신뢰성 향상 + 성능 향상1테라 디스크 3개를 하나로 묶어서 3테라 디스크처럼 쓴다 하드웨어 RAID여러개의 하드디스크를 가지고 장비를 만들어서 사용. 장비업체에서 제공하기 떄문에 사용법이 다를 수 있다. 그리고 상당히 고가이다. 하드웨어RAID가 안정성이 높다. 소프트웨어 RAID디스크를 장착만하면 운영체제 레벨에서 하나로 묶을 수 있다. Linear RAID (339p 그림보기)최소 2개이상의 디스크를 하나로 묶음앞 디스크 부터 차례로 저장100TB 100TB 100TB 를 사용하면 총 300TB가 된다. 즉 공간효율성이 100%임. RAID 0 (339p 그림보기)모든 디스크에 동시에 저장되는 개념그러므로 하드디스크가 3개면 /3 시간으로 저장됨신뢰성이 낮다.빠르지만 전부 잃어버려도 큰 문제가 되지 않는 자료가 적당하다.3TB 100TB 100TB 를 사용하면 총 9TB가 된다. 즉 디스크 크기가 다르면 공간효율성이 100%가 되지 않음.그래서 RAID를 구성할 떈 같은회사 같은 용량의 디스크로 구성한다.디스크 세개중에 하나만 고장나도 디스크를 못쓴다. RAID 1미러링이라 부름1TB 1TB 를 사용하면 1TB 사용가능결함 허용을 제공= 신뢰성 높음. 즉 둘중에 하나가 고장나도 데이터가 보존된다.공간효율이 나쁘므로 비용이 비싸다는 단점이 있다. RAID 5RAID 2,3,4의 장점을 포용하기 때문에 2,3,4를 사용할 필요가 없다.RAID1의 데이터 안정성 +RAID0의 공간 효율성을 추구 디스크 개수 -1개의 공간을 사용. 즉 4개일 경우 3개를 사용(75%) 100개일 경우 99개를 사용(99%)즉 가격이 저렴하면서 안정적인것.최소한 3개 이상의 하드디스크가 필요하며 오류가 발생했을 때는 패리티(Parity)를 이용해서 데이터를 복구결함 허용을 제공 - 즉 디스크 하나가 고장나도 사용 복구 가능하지만 디스크가 하나가 고장났을 때는 복구가 가능하지만 디스크가 2개가 고장날 경우에는 복구 불가능.그래서 100개를 사용하였을 경우에는 불안하다.(2개 이상 고장날 확률이 높아지므로)즉 적은 디스크를 활용할 경우 공간효율은 낮아지지만 신뢰도는 높아진다.일반적으로 RAID 5는 7개에서 10개정도의 디스크로 구성 RAID 6패리트를 2개 쓴다. 즉 디스크가 2개가 고장나도 복구가능. 최소 4개이상의 디스크가 필요함.(패리티를 2개 쓰므로)패리티를 2개 쓰는 알고리즘의 효율성이 떨어져서 성능이 떨어지는 단점이 있어 많이 사용하지는 않음. RAID1 + 0 = RAID + RAID0신뢰성(안정성)과 성능(속도)이 동시에 뛰어난 방법RAID1로 구성된것을 RAID 0 으로 묶음. 그림참고 실습SCSI 0:1 부터 0:10 까지 진행. SCSI 0:1 SCSI 0:2 - Linear RAID SCSI 0:3 SCSI 0:4 - RAID 0 SCSI 0:5 SCSI 0:6 - RAID 1 SCSI 0:8 SCSI 0:9 SCSI 0:10 - RAID 5 SCSI 0:1 만 2GB로 구성하고 나머지는 다 1GB로 구성 에디트 쪽에서 디스크 2기가 1개 1기가 8개 추가. 1# ls -l /dev/sd* //장착이 잘 되었나 확인 9번 반복12345678# fdisk /dev/sdb ~sdj 까지 반복n p 엔터 엔터p //로 확인해보면 시스템이 리눅스인데 RAID로 변경해야한다.t 엔터L 누르면 도움말이 나온다.fd를 입력 후 엔터p를 눌러 확인w를 눌러 저장 1# ls -l /dev/sd* //장착이 잘 되었나 확인 과정 설명1.mdadm 명령어로 논리 볼륨 생성2.mkfs.ext4 명령어로 파일시스템 생성(포멧)3.mount 적용위 3가지 과정은 6장에서 하드디스크 1개추가 과정과 같다. Linear RAID 만들기sdb1 sdc1 이용mdadm RAID를 만들고 없애는 명령어 1234567891011121314151617181920212223# fdisk -l /dev/sdb /dev/sdc // 아까 한것이 잘 적용되었나 확인# mdadm --create /dev/md9 --level=linear --raid-devices=2 /dev/sdb1 /dev/sdc1 //RAID md9를 만드는데 리니어로 디바이스는 //개수 2개로 2개는 /dev/sdb1 /dev/sdc1 로# mdadm --detail --scan //돌고있는지 확인# mdadm --detail /dev/md9 //md9에 대해 자세히 보자# mkfs.ext4 /dev/md9 //포멧하자# mkdir /raidLinear //디렉토리 생성# mount /dev/md9 /raidLinear/ //마운트# df //마운트 확인# vi /etc/fstab //재부팅하면 마운트가 풀리므로 설정/dev/md9 /raidLinear ext4 defaults 0 0 맨 아래 추가# reboot# df //마운트 확인 RAID 0 만들기sdd sde로 한다1234567891011121314151617# mdadm --create /dev/md0 --level=0 --raid-devices=2 /dev/sdd1 /dev/sde1# mdadm --detail --scan //돌고있는지 확인# mdadm --detail /dev/md0 //md9에 대해 자세히 보자# mkfs.ext4 /dev/md0 //포멧하자# mkdir /raid0 //디렉토리 생성# mount /dev/md0 /raid0/ //마운트# df //마운트 확인# vi /etc/fstab //재부팅하면 마운트가 풀리므로 설정/dev/md0 /raid0 ext4 defaults 0 0 추가 RAID 1sdf sdg 사용12345678910111213141516# mdadm --create /dev/md1 --level=1 --raid-devices=2 /dev/sdf1 /dev/sdg1y입력 // raid1은 부트 디바이스로 사용 할 수 없는데 만들겠냐는 뜻# mdadm --detail /dev/md1 //확인해보자# mkfs.ext4 /dev/md1 //포멧하자# mkdir /raid1 //디렉토리 생성# mount /dev/md1 /raid1/ //마운트# df //마운트 확인# vi /etc/fstab //재부팅하면 마운트가 풀리므로 설정/dev/md1 /raid1 ext4 defaults 0 0 추가 RAID 5sdh sdi sdj 사용1234567891011121314151617# mdadm --create /dev/md5 --level=5 --raid-devices=3 /dev/sdh1 /dev/sdi1 /dev/sdj1망가졌다는 메세지 나오는데 무시하면된다. (컴퓨터가 착각함!)# mdadm --detail /dev/md5 //확인해보자# mkfs.ext4 /dev/md5 //포멧하자# mkdir /raid5 //디렉토리 생성# mount /dev/md5 /raid5/ //마운트# df //마운트 확인# vi /etc/fstab //재부팅하면 마운트가 풀리므로 설정/dev/md5 /raid5 ext4 defaults 0 0","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"6장. IDE/SCSI 장치 구성, 하드디스크 1개 추가","slug":"ThisIsLinux15","date":"2017-07-05T07:33:36.000Z","updated":"2018-09-03T05:50:46.752Z","comments":true,"path":"2017/07/05/ThisIsLinux15/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/05/ThisIsLinux15/","excerpt":"","text":"하드디스크 관리는 관리자 입장에서 기본적인것이다.디스크가 모자르면 디스크를 추가해야한다.. 이런걸 어떻게 할지 알아보자 IDE SCSI 장치에 대해IDE는 케이블을 2개 꽂을수가 있다. 여기에 하드디스크를 장착하거나 DVD롬을 장착할 수 있다. 즉 두개의 IDE가 있으면 4개를 장착할 수 있다. 0:0 , 0:1, 1:0 , 1:1 이렇게 구분된다(4개일 경우) SCSI는 총 16개의 SCSI 하드디스크를 꽂을 수 있는 케이블이 따져있다. 0,7번은 VMware가 사용하므로 사용할 수 없다.마찬가지로 SCSI 0:0 ,0:1 로 구분된다. 326p를 통해 그림으로 확인가능 우리가 80GB 의 하드디스크를 추가했는데 이를 sda라 그런다만일 하나더 추가하면 sdb라 그런다.정식이름은 /dev/sda 이다.여기서 파티션을 나누면 sda1,sda2로 나뉜다. 즉 sda는 하드디스크 자체를 의미하며 sda1은 파티션1 sda2는 파티션2를 의미한다. 땅 자체를 사는것을 하드디스크를 추가하는것으로 보면되고 축구장으로 사용하기 위해 특정부분에 선을 긋는것을 파티션을 나눈다고 보면된다. 또한 파티션은 특정디렉터리에 마운트를 해줘야함. 하드디스크 1개 장착과정1.SCSI 0:1에 물리적인 하드디스크 하나 장착 이는 /dev/sdb이다. 2.fdisk 명령어를 통해 파티션을 나눔(실습에서는 파티션1개로)./dev/sdb1 파티션이 생긴다. 3.파티션을 사용하기 위해서는 포멧을 해줘야한다.(mkfs.ext4를 사용) 4.그러면 완전히 준비된 하드디스크가 생기는데 이를 특정 폴더에 마운트해야한다. 5.마운트는 컴퓨터를 끄면 마운트가 끊어지므로 /etc/fstab 파일을 편집해 주어야 한다. 1.SCSI 0:1에 물리적인 하드디스크 하나 장착 이는 /dev/sdb이다.에디트에서 애드를 선택하고 다음스카시를 선택하고 다음맨위를 하고 다음1기가로 선택하고 싱글파일 선택하고 다음어드밴스드를 눌러 0:1로 되어있는것을 확인 123456789# ls -l /dev/sd*brw-rw---- 1 root disk 8, 0 7월 5 18:02 /dev/sdabrw-rw---- 1 root disk 8, 1 7월 5 18:02 /dev/sda1brw-rw---- 1 root disk 8, 2 7월 5 18:02 /dev/sda2brw-rw---- 1 root disk 8, 16 7월 5 18:02 /dev/sdbsda는 초기 설정때 설정한것. 파티션을 두개로 나눠서 sda1, sda2로 나뉜다.왜 sdb1은 없지? 파티션을 나누지 않았으므로! 2.fdisk 명령어를 통해 파티션을 나눔(실습에서는 파티션1개로)./dev/sdb1 파티션이 생긴다.파티션을 나눠보자1234567891011121314151617181920# fdisk /dev/sdbn //새로운 파티션 추가p // p(primary)는 주 파티션 e(extended)는 확장파티션을 의미 //p는 4개까지 나눌 수 있음 //4개 이상하고싶으면 3개는 p로하고 하나는 e로 잡아서 //e 파티션안을 나눠서 늘리면 된다. 이는 굉장히 드문경우 //일반적으로는 p를 쓰면 충분하다.1 //sdb1로 하겠다. 엔터 // 2047까지는 시스템 부분이므로 // 어디서 부터 시작할꺼냐. 엔터하면 2048부터엔터 //끝까지 쓰겠다. p //최종확인w //적용 # ls -l /dev/sd* //생성된 것 확인brw-rw---- 1 root disk 8, 0 7월 5 18:02 /dev/sdabrw-rw---- 1 root disk 8, 1 7월 5 18:02 /dev/sda1brw-rw---- 1 root disk 8, 2 7월 5 18:02 /dev/sda2brw-rw---- 1 root disk 8, 16 7월 5 18:11 /dev/sdbbrw-rw---- 1 root disk 8, 17 7월 5 18:11 /dev/sdb1파일 시스템을 생성하자. 3.파티션을 사용하기 위해서는 포멧을 해줘야한다.(mkfs.ext4를 사용)1# mkfs.ext4 /dev/sdb1 4.그러면 완전히 준비된 하드디스크가 생기는데 이를 특정 폴더에 마운트해야한다.12345678# mkdir /mydata# mount /dev/sdb1 /mydata# df // 마운트 된것을 확인# cp /boot/vmlinuz-3.10.0-123.el7.x86_64 /mydata/data1 // 새로운 디스크에 데이터 복사# df //확인 (용량 늘어난것 확인) 5.마운트는 컴퓨터를 끄면 마운트가 끊어지므로 /etc/fstab 파일을 편집해 주어야 한다.123# vi /etc/fstab /dev/sdb1 /mydata ext4 defaults 0 0 입력 후 vi종료 //dev/sdb1을 /mydata에 마운트하는것. ext4를 이용해 1","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"5장. 리눅스에 Windows 설치 KDE데스크톱 설치","slug":"ThisIsLinux14","date":"2017-07-05T06:37:05.000Z","updated":"2018-09-03T05:50:44.091Z","comments":true,"path":"2017/07/05/ThisIsLinux14/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/05/ThisIsLinux14/","excerpt":"","text":"리눅스 안에서 윈도우를 깔아보자CentOS에서 제공하는 가상머신을 이용하자즉 가상머신에서 가상머신을 만드는…램 올리고, 가상화 켜주고 311p참고 iso 파일을 받고 내폴더에 붙여넣기 해준다. 123# mkdir /iso# mv 600* /iso //파일이름이 600으로 시작함.# ls -l /iso 실습에서는 313p 의 2-0을 생략한다.프로그램 -시스템 도구 -가상머진 관리자로컬 선택 후 새가상머신 생성 왼쪽위 그림(노란색)Win2008 입력후 로컬설치매체 선택후 앞으로iso파일 선택하고 윈도우서버 2008 선택하고 앞으로그대로 두고 앞으로설치전에 사용자 설정 선택 후 완료디스플레이를 VNC로 하고 적용왼쪽 위 설치시작 KDE 데스크톱을 설치해보자센토스는 기본적으로 그놈데스크탑이 들어있다. 윈도우와 비슷한 KDE 데스크탑을 운영할 수 있다.123456$ yum grouplist | grep KDE //KDE 패키지그룹을 조회su -c &apos;yum -y groupinstall &quot;KDE Plasma Workspaces&quot;&apos; //조회됨$ su -c &apos;yum -y groupinstall &quot;KDE Plasma Workspaces&quot;&apos; //루트권한으로 &apos;&apos;안에 있는 명령어 실행(KDE 설치)자동로그인 해제 . 321p 참고1$ reboot톱니 누르고 KDE Plasma 작업공간 선택후 암호 입력 후 로그인","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"5장. 노틸러스, FireFox업그레이드, 기타 X윈도 유틸리티","slug":"ThisIsLinux13","date":"2017-07-05T04:47:34.000Z","updated":"2018-09-03T05:50:41.940Z","comments":true,"path":"2017/07/05/ThisIsLinux13/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/05/ThisIsLinux13/","excerpt":"","text":"노틸러스윈도우 탐색기와 비슷하다.실행법 : 프로그램-보조프로그램-파일 내폴더가 홈 디렉토리이다.컴퓨터가 / 폴더이다.rpm 파일도 설치 가능복붙도 가능 컨트롤 씨브이289p 참고 파이어폭스 업그레이드설치하고압축풀고 12345678910# mv firefox /usr/local //압축푼것 위치이동# chown -R root.root /usr/local/firefox/ 루트에게 권한줌# cd /usr/local/bin# ln -s /usr/local/firefox/firefox . //링크를 걸어줌파폭을 실행하면 에러가 나는데# cd /usr/local/firefox/browser/extensions/# rm -rf *해주고 리부트 어도비리더 설치123# wget http://download.hanbit.co.kr/centos/7/AdobeReader_kor-8.1.7-1.i486.rpm# su -c &apos;yum -y localinstall Adobe*&apos;","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"5장. X윈도 테마, GRUB 배경화면","slug":"ThisIsLinux12","date":"2017-07-05T02:57:03.000Z","updated":"2018-09-03T05:50:39.688Z","comments":true,"path":"2017/07/05/ThisIsLinux12/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/05/ThisIsLinux12/","excerpt":"","text":"이 챕터는 책에서 중요도가 가장 떨어진다!서버관리자가 되었을 때 리눅스를 PC로 사용하는 사람에게 도움을 주기위해 알아둘 필요는 있다. 테마 설치하기12$ rpm -qa gnome-tweak-tool //설치되어있나 확인$ gnome-tweak-tool //툴 켜서 설정변경 GRUB 이미지 설정1234567891011121314$ su -c &apos;yum -y install grub2-starfield-theme&apos; //암호입력 //su -c는 슈퍼바이저 권한으로 실행하는것$ vi /etc/default/grubGRUB_TIMEOUT=5GRUB_DISTRIBUTOR=&quot;$(sed &apos;s, release .*$,,g&apos; /etc/system-release)&quot;GRUB_DEFAULT=savedGRUB_DISABLE_SUBMENU=true#GRUB_TERMINAL_OUTPUT=&quot;console&quot; //여기 주석처리GRUB_CMDLINE_LINUX=&quot;rd.lvm.lv=centos/swap vconsole.font=latarcyrheb-sun16 rd.lvm.lv=centos/root crashkernel=auto vconsole.keymap=us rhgb quiet&quot;GRUB_DISABLE_RECOVERY=&quot;true&quot;GRUB_THEME=&quot;/boot/grub2/themes/system/theme.txt&quot; //여기추가vi 저장후 종료 이미지 파일을 centos폴더에 저장 (ball.png)1mv /home/centos/ball.png /boot/grub2/themes/system실행하여 그림 이동 12345# vi /boot/grub2/themes/system/theme.txt //:set number34행가서 이미지 파일이름 변경# grub2-mkconfig -o /boot/grub2/grub.cfg //적용","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. 응급복구, GRUB, 커널 컴파일","slug":"ThisIsLinux11","date":"2017-07-04T07:09:17.000Z","updated":"2018-09-03T05:50:37.225Z","comments":true,"path":"2017/07/04/ThisIsLinux11/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/04/ThisIsLinux11/","excerpt":"","text":"응급복구261p 참고이게 문제가 될 소지가 있지않냐?그래서 처음 켤때 선택하는거에서 암호를 걸어야 한다. GRUB 부트로더/etc/default/grub 파일과 /etc/grup.d/ 디렉터리의 파일을 수정한 후 ‘grub2-mkconfig’ 명령어를 실행해 설정함 123456789101112131415161718# vi /etc/default/grubtimeout = 30 으로 변경distributor = &quot;Hello&quot; 로 변경# grub2-mkconfig -o /boot/grub2/grub.cfg // 변경사항 반영//여기서 부터 선택하는 곳에서 e 키 못누르게 비번 설정하는것# vi /etc/grub.d/00_header맨 아래 가서 다음코드 추가cat &lt;&lt; EOFset superusers=&quot;thisuser&quot;password thisuser 4321EOF여기까지!vi 빠져나와서# grub2-mkconfig -o /boot/grub2/grub.cfg // 변경사항 반영$ reboot선택하는곳에서 e 누르면 암호 누르도록 함 커널커널 : 하드웨어를 제어하는 기능모든 하드웨어를 제어하는 코드를 다 넣으면 커널이 너무 커지고 무거워진다. 그러므로 잘 안쓰는 하드웨어 코드는 모듈에 빼내서 필요할때마다 사용즉 모듈은 필요할때 쓸 수 있도록 커널의 코드를 밖으로 빼낸것이다! 1234567891011121314151617$ uname -r //커널버전확인$ wget &quot;https://kernel.org/pub/linux/kernel/v3.x/linux-3.17.4.tar.xz&quot; //교재와 동일한 커널 설치$ mv linux-3.17.4.tar.xz /usr/src$ cd /usr/src$ tar xfJ linux-3.17.4.tar.xz //압축을 풀자$ cd linux-3.17.4/커널은 c 코드이므로 설치를 위해 컴파일러를 깔자$ yum -y install gcc gcc-c++ qt qt-devel$ make mrproper // 커널설정 초기화$ make xconfig //커널의 환경설정 설정 후$ make clean$make ; make modules_install ; make install //순서대로 진행됨.","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. 파이프/필터, 프로세스, 서비스/소켓","slug":"ThisIsLinux10","date":"2017-07-04T05:52:52.000Z","updated":"2018-09-03T05:50:34.115Z","comments":true,"path":"2017/07/04/ThisIsLinux10/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/04/ThisIsLinux10/","excerpt":"","text":"파이프두개의 프로그램을 연결해주는 통로1$ ls -l /etc | more //앞에서 뒤로 넘김 필터필요한것만 걸러주는 명령어 123456$ ps -ef //현재 작동중인 프로세스 보여줌$ ps -ef | grep bash //bash와 관련된 프로세스만 //보여줌$ rpm -qa | grep gedit //gedit 관련된것만 보여줌 리다이렉션(보내는 것)123456789$ ls -l &gt; file.txt //결과를file.txt로 만드는것 //file.txt가 존재할 경우 덮어쓰고 //존재하지 않을경우 새로 만들고 작성$ ls -l &gt;&gt; file.txt //결과를file.txt로 만드는것 //file.txt가 존재할 경우 뒤에다 이어서 작성하고 //존재하지 않을경우 새로만들고 작성$ cat sort &lt; file.txt &gt; out.txt //file.txt를 정렬해서 out.txt에 넣어라 프로세스, 데몬프로세스는 하드디스크에 저장된 실행코드가 메모리에 로딩되어 활성화 된것. 포그라운드 프로세스실행하면 화면에 나타나서 사용자와 상호작용을 하는 프로세스 백그라운드 프로세스화면에 나타나지 않고 실행되는 프로세스백신 , 서버 데몬(=서비스,=서버 프로세스)등 프로세스번호각각의 프로세스는 할당된 번호가 있다.12345$ ps -ef | grep bash //bash관련된 프로세스만 보여줌root 693 1 0 13:43 ? 00:00:00 /bin/bash /usr/sbin/ksmtuned693은 자기 프로세스 번호고 1은 부모프로세스 번호이다. 작업 번호현재 실행되고 있는 백그라운드 프로세스의 순차번호 부모프로세스 ,자식프로세스모든 프로세스는 부모프로세스를 갖는다.부모 프로세스를 kill하면 자식프로세스도 자동으로 죽음. 프로세스 관련 명령ps 프로세스 보기1$ ps -ef | grep bash //bash 관련 프로세스 보여줌 kill 프로세스 종료파이어폭스 kill하기123456$ ps -ef | grep fire //파폭 관련 프로세스 보기root 2637 1934 0 13:49 ? 00:00:04 /usr/lib64/firefox/firefox//프로세스번호가 2637이다.$ kill 2637//가끔 킬 해도 죽지 않는 경우가 있는데 그경우 -9 옵션을 준다.$ kill -9 2637 pstree 프로세스 트리로 보기1$pstree //프로세스 구조를 트리로 보여줌 실습 (포그라운드-&gt;백그라운드-&gt;포그라운드)1234567$ yes &gt; /dev/null //y를 계속생성하는 프로세스 생성ctrl+ z 입력.$ bg //백그라운드 보는것. //처음에 했던 동작이 남아있다.[1]+ yes &gt; /dev/null &amp;$ fg 1 //1번작업을 다시 포그라운드로 갖고와라 실습 (포그라운드-&gt;백그라운드-&gt;포그라운드)1234567$ gedit &amp; //지에딧을 백그라운드로 돌려라. //콘솔을 계속 사용할 수 있게된다.$ vi &amp; //백그라운드로 돌아가긴 하는데 의미없다. //vi는 포그라운드로 돌려야 하므로 $ bg //vi의 백그라운드 번호를 알고$ fg 1 //vi를 포그라운드로 갖고옴 서비스와 소켓서비스웹 서버 = 웹 서비스FTP 서버 = FTP 서비스 서비스의 실행 스크립트 파일은 /usr/lib/systemd/system/ 디렉터리에 ‘서비스이름.service’라는 이름으로 확인할 수 있다. 예를들어 웹 서비스는 httpd.service라는 이름의 파일로 존재 소켓서비스는 항상 가동되지만 소켓은 필요할 떄만 구동된다. 외부에서 특정 서비스가 요청되었을 때. 그래서 약간 느리다./usr/lib/systemd/system/ 디렉터리에 소켓이름.socket 이름으로 존재","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. 네트워크 관련 개념과 명령어,SELinux","slug":"ThisIsLinux9","date":"2017-07-04T04:29:36.000Z","updated":"2018-09-03T05:50:31.012Z","comments":true,"path":"2017/07/04/ThisIsLinux9/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/04/ThisIsLinux9/","excerpt":"","text":"TCP/IP우리가 사용하는 인터넷은 tcp/ip 기반이다. 가장널리사용되는 프로토콜의 한 종류 호스트이름 도메인이름호스트이름 : 컴퓨터에 지정된 이름도메인 이름 : hanbit.co.kr rkxdms gudtlr IP 주소랜카드에 부여되는 중복되지 않는 유일한 주소 네트워크 주소같은 네트워크에 속해있는 공통된 주소 브로드캐스트 주소제일 뒤가 255인 주소내부 네트워크의 모든 컴퓨터가 듣게 되는 주소 게이트웨이, 라우터라우터=게이트웨이네트워크 간에 데이터를 전송하는 컴퓨터 또는 장비 넷마스크, 클래스넷마스크 : 네트워크의 규모를 결정ex(255.255.255.0) DNS 서버= 네임서버URL을 IP로 변환해주는 서버 12345678910111213141516$ nmtui //네트워크와 관련된 작업진행$ rdate -s time.bora.net //시간설정$ nmtui //설정 변경후 종료 네트워크매니저텍스트ui$ systemctl restart network //네트워크 재시작 (해줘야함)$ ifconfig //네트워크장치에 할당된 ip주소 확인$ ifdown ens32 //이거는 systemctl restart network //보다 강력하게 서버를 끄는것.$ ifup ens32 //서버 재시작 $ nslookup naver.com //DNS서버의 작동을 테스트$ ping www.yahoo.com //네트워크 응답 확인$ ping -3 www.yahoo.com //세번만 피을 때려라 주요 파일네트워크 기본적인 정보가 설정되어 있는 파일/etc/sysconfig/network /etc/sysconfig/network-scripts/ifcfg-ens32ens32 장치에 설정된 네트워크 정보가 모두 들어있는 파일ens32가 아니라 eno일수도 있다.BOOTPROTO = none 고정아이피를 쓰겠다.DNS1 DNS가 여러개 나올 수 있으므로 1이 필요ONBOOT =”yes” 네트워크를 쓰겠다 /etc/resolv.confDNS 서버의 정보와 호스트 이름이 들어있다.168.126.63.1 //kt에서 제공하는 네임서버이다 //네임서버가 없을 때 사용가능 SELinux보안에 취약한 리눅스를 보호하기 위해 탄생책에서는 실습을 위해 기능을 꺼두었다./etc/sysconfig/selinux를 편집하였다.SELINUX=disabled 이렇게..","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. 파일 압축과 묶기, CRON과 AT","slug":"ThisIsLinux8","date":"2017-07-04T00:26:28.000Z","updated":"2018-09-03T05:50:28.832Z","comments":true,"path":"2017/07/04/ThisIsLinux8/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/04/ThisIsLinux8/","excerpt":"","text":"파일 압축유닉스는 압축하는 파일이 여러개이다. 그래서 확장자도 여러개이다. 점점 개선이 되면서 여러개가 생긴것이다. 예전것도 쓰고 최신것도 쓰므로 모두 사용할줄 알아야함gzip-&gt;bzip2-&gt;xz 순으로 발전해옴 xz가 압축률도 제일좋다. 12345678910111213141516171819# cp glist.txt file1.txt //파일 복사# cp glist.txt file2.txt# cp glist.txt file3.txt# xz file1.txt# bzip2 file2.txt# gzip file3.txt# ls-l file*-rw-r--r-- 1 root root 1080 7월 4 09:31 file1.txt.xz-rw-r--r-- 1 root root 1072 7월 4 09:31 file2.txt.bz2-rw-r--r-- 1 root root 1053 7월 4 09:31 file3.txt.gz# xz -d file.txt.xz //압축해제# bzip2 -d file2.txt.bz2 //압축해제# gzip -d file3.txt.gz //압축해제# gunzip file3.txt.gz //위와 같음 gz로 압축한게 제일작은데? 파일마다 다르다!! 일반적으로는 gz가 효울이 제일 떨어진다. 그래서 일반적으로 커널파일을 xz로 배포한다.리눅스에서의 압축은 파일을 압축해서 원본파일이 사라진다는것을 주의하자. 파일 묶기리눅스는 압축, 묶기가 다르다묶기는 원본파일이 유지되며 하나로 묶은것이라 보면된다.12345678910# tar cvf bin.tar bin1 bin2 bin3 //bin1,2,3이 bin.tar로 묶임# rm -f bin? //bin1,2,3 제거# tar xvf bin.tar //풀기# ls -l-rw-r--r-- 1 root root 14714880 7월 4 09:41 bin.tar-rwxr-xr-x 1 root root 4902656 7월 4 09:40 bin1-rwxr-xr-x 1 root root 4902656 7월 4 09:40 bin2-rwxr-xr-x 1 root root 4902656 7월 4 09:40 bin3묶으면서 압축을 진행해보자12345678# rm -f bin.tar# tar cvfj bin.tar.bz2 bin1 bin2 bin3 //bz2형식으로 압축하면서 묶어줌# rm -f bin.tar.bz2# tar cvfJ bin.tar.xz bin1 bin2 bin3 //xz형식으로 압축하면서 묶어줌 //J가 대문자이다.# tar xvfJ bin.tar.xz /etc/sysconfig //xz압축해제 +tar 풀기 파일 위치 검색12345678910# find /etc -name &quot;*.conf&quot; //etc밑에 확장명이 conf 인것을 찾음# find /etc -name &quot;*.conf&quot; &gt; conf.txt //위 대상으로 conf.txt로 저장# find /home -user centos //centos 사용자의 파일들 검색# find /usr/bin -size +95k -size -100k //사이즈가 95kb 이상 //100kb 이하인것 검색# find /usr/bin -size +95k -size -100k -exec ls -l &#123;&#125; \\; // 윗줄의 결과가 중괄호 속에 들어가서 // ls -l 명령어 실행 시스템 설정123456# yum -y install system-config-date# system-config-date //날짜 설정 가능# nmtui //네트워크 설정# firewall-config CRON과 ATCRON : 주기적으로 반복되는 일을 자동적으로 실행될 수 있도록 실행 42 4 1 ** root run-parts /etc/cron.hourly42 : 42분4 : 4시1 : 1일* : 매 월* : 매 요일 01 * * * * root run-parts /etc/cron.daily맨 뒤는 요일이므로 제외하고매월매일매시1분마다. 02 4 * * * root run-parts /etc/cron.weekly매일 4시 2분마다 실행하라 03 4 * * 0 root run-parts /etc/cron.monthly일요일 4시 3분마다 실행해라 AT : 한번 실행되는것# at 3:00am tomorrow -&gt;내일 새벽 3시# at 11:00pm January 30 -&gt;1월 30일 오후 11시# at now + 1 hours -&gt;한시간 후그 후 예약 명령어 입력후 엔터완료되면 ctrl + d 쉘 스크립트 : 윈도우의 배치파일처럼 실행할 명령어가 쭉 나열되어있는것 CRON 실습123456789101112131415161718192021222324252627282930313233343536# systemctl status crond //크론이 돌고있는지 확인# vi /etc/crontab01 3 15 * * root run-parts /etc/cron.monthly //한줄 추가 매달 매 요일 15일마다 3시 1분에# cd /etc/cron.monthly/# vi myBackup.sh다음을 입력#!/bin/sh // 써줘야함set $(date) //날짜를 읽어옴fname=&quot;backup-$2$3.tar.xz&quot; //$2는 월 $3은 일tar cfJ /backup/$fname /home // /home폴더를 묶음vi 종료# chmod ugo+x myBackup.sh //쉘스크립트 파일 실행권한부여# mkdir /backup //백업파일 보관할 장소 생성# systemctl restart crond //예약하는 작업이 재시작된다.# date 011503002019 //테스트를 위해 시간을 변경 //월일시분년2019. 01. 15. (화) 03:00:00 KST 로 변경됨# systemctl restart crond // 시간적용을 위해 재시작1분이 지나고# ls-l /backup/ AT 실습12345678910111213# rdate -s time.bora.net //서버에 가서 정확한 시간을 세팅함# at 4:00 am tomorrow //내일 새벽 4시에 할 명령어 입력at&gt; yum -y updateat&gt; reboot입력 후 ctrl + d# at -l 예약된것 확인1 Wed Jul 5 04:00:00 2017 a root# atrm 1 //1번 목록 제거 1","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. RPM 사용법, YUM 사용법","slug":"ThisIsLinux7","date":"2017-07-03T09:58:51.000Z","updated":"2018-09-03T05:50:26.052Z","comments":true,"path":"2017/07/03/ThisIsLinux7/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/03/ThisIsLinux7/","excerpt":"","text":"RPM초창기 리눅스는 설치가 어려웠다 .소스코드를 갖고와서 적재적소에 컴파일을 해야했다. 그래서 일반사용자가 사용하기엔 거의 불가능했다. 이러한 이유로 외면을 받았었다. 결국 Redhat에서 RPM(Redhat Package Manager)을 내놓았다. 윈도우의 setup.exe 라고 생각하면 된다. gedit-3.8.3-6.el7.x86_64.rpm 패키지이름 : gedit -&gt; 패키지(프로그램)의 이름버전 : 3.8.3 -&gt; 대게 3자리수로 구성. 주버전, 부버전, 패치버전릴리즈번호 : 6 -&gt; 문제점을 개선할 때마다 붙여지는 번호 //noarch:모든CPUCentOS버전 : el7 -&gt; CentOS에서 배포할 경우에 붙여짐아키텍처 : x86_64 -&gt; 64비트 CPU를 의미 자주쓰는 RPM 명령어 옵션123456789101112131415$ rpm -Uvh 패키지파일이름.rpm // U -&gt; (대문자)패키지가 설치/업그레이드 // v -&gt; 설치진행과정의 확인 // h -&gt; 설치진행과정을 &quot;#&quot;마크로 화면에 출력$ rpm -e 패키지이름 //패키지 삭제$ rpm -qa 패키지이름 //패키지가 설치되었는지 확인$ rpm -qf 파일의 절대경로 // 파일이 어느 패키지에 포함된 것인지 확인$ rpm -qlp 패키지파일이름.rpm //패키지 파일에 어떤 파일들이 포함되었는지 확인$ rpm -qip 패키지파일이름.rpm //패키지 파일의 상세정보 실습12345678910111213$ rpm -qa mc //mc 패키지가 설치되었나 확인$ rpm -Uvh mc-4.8.7-8.el7.x86_64.rpm //설치$ rpm -qa mc //mc 패키지가 설치되었나 확인$ rpm -qi mc //mc 패키지 정보 출력$ rpm -e mc-4.8.7-8.el7.x86_64.rpm //삭제오류: mc-4.8.7-8.el7.x86_64.rpm 패키지가 설치되어 있지 않습니다//설치파일을 삭제하는것이다.!!!!$ rpm -e mc //패키지 이름만으로 삭제 YUM의 등장Yellowdog Updater Modified rpm의 경우 의존성 문제가 존재함. 이를 해결하기 위해 나온것이 YUM의존성 문제란? A를 설치하기 위해 B가 먼저 설치되어있어야 하는것.rpm은 B가 설치되어있지 않을 경우 A패키지 설치를 시도할 경우 B를 설치해야 한다고 알려주기는 하나 대략적으로 알려주고, B또한 다른 패키지에 의존성이 있을수도 있어 불편함을 유발한다. yum은 인터넷이 정상적으로 동작해야 작동함. yum은 의존성이 있는것을 모두 알아서 설치해준다!!! 즉 yum 명령어는 내부적으로 rpm명령을 실행하는것!! yum의 동작과정1.yum install을 입력한다2./etc/yum.repos.d/ 를 참고하여 URL을 확인하고3.전체 패키지 목록 파일을 요청한다(CentOS 7 패키지 저장소로)4.전체 패키지 목록 파일만 다운로드5.설치할 패키지와 관련된 패키지의 이름을 화면에 출력6.y를 입력하면 설치에 필요한 패키지 파일을 요청함7.설치할 패키지 파일을 다운로드해서 자동 설치12345678910111213141516$ yum install 패키지이름 //패키지 설치$ yum -y install 패키지이름 //패키지 설치(y안눌러도 됨)$ yum remove 패키지이름 //패키지 제거$ yum localinstall rpm파일이름.rpm //로컬에 존재하는 rpm으로 설치 // 만약 의존성이 있을경우 그 대상은 레파지토리에서 깐다.$ yum info mc //mc패키지에 관한 정보확인 $ yum groupinstall &quot;패키지 그룹이름&quot; //예로 자바를 깐다면 jdk //이클립스 등 한꺼번에 설치됭$ yum clean all //캐시를 지우는것. //yum이 이상할때 써보자 yum고급실습네트워크를 거치지 않고 마운트 시킨 dvd에서 받는다. 교재 221참고dvd에 없으면 네트워크에서 갖고온다. yum grouplist123456789101112$ yum grouplist //그룹리스트 조회$ yum grouplist hidden //숨겨진것까지 조회//영어로 그룹을 설치하는것이 좋다.. 그러므로$ chvt 2 //2번 가상터미널로 이동$ root password$ yum grouplist hidden &gt; glist.txt //glist.txt로 생성$ chvt 1 //x 윈도모드로 이동 226p 비타민퀴즈223p를 따라 설정 후 yum groupinstall “GNOME Desktop” 입력","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. 파일의 소유권/허가권, 링크","slug":"ThisIsLinux6","date":"2017-07-03T04:33:03.000Z","updated":"2018-09-03T05:50:22.782Z","comments":true,"path":"2017/07/03/ThisIsLinux6/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/03/ThisIsLinux6/","excerpt":"","text":"123# touch sample.txt //빈 파일생성# ls -l-rw-r--r-- 1 root root 0 7월 3 13:35 sample.txt 1.맨앞의 -는 파일의 유형을 의미. -: 일반파일 d: 디렉토리 l: 링크파일 2.rw-r–r–는 세개씩 끊어 읽으면 된다.2-1. 맨앞 세개는 소유자의 파일접근권한 (rw-)즉 소유자는 읽기, 쓰기 가능, 실행 불가 2-2. 두번째는 그룹의 파일접근권한읽기만 가능 2-3. 세번째는 그 외의 사용자의 파일접근권한이다.읽기만 가능또한 rw-r–r–는 3자리씩 끊어서 보면 644로 볼수 있다.rwxrwxrwx는? 666 3.1은 링크의 수 4.root는 파일 소유자 이름 5.root는 파일 소유 그룹이름 6.0은 파일의 크기 7.7월 3 13:35는 마지막 변경 날짜/시간 8.sample.txt는 파일이름 chmod 파일 허가권 변경1234567891011121314151617181920212223242526# chmod 655 sample.txt# ls -l sample.txt-rw-r-xr-x 1 root root 0 7월 3 13:35 sample.txt$ chmod o-x test //일반사용자(o : ordinary)는 -x (x:execute) 실행 못하도록$ ls -l test-rwxrwxrw- 1 centos centos 52 7월 3 13:52 test //마지막 x가 빠짐$ chmod ug-w test //소유주(u: user), 소유그룹(g: group) 쓰기권한 제거$ ls -l test-r-xr-xrw- 1 centos centos 52 7월 3 13:52 test //3번째 6번째 w가 빠짐$ chmod ugo-r test //전부다 읽기권한 제거$ ls -l test ---x--x-w- 1 centos centos 52 7월 3 13:52 test //r이 제거된것 확인$ chmod uo+rw test //소유주, 기타사용자에게 읽기,쓰기 허용$ ls -l test -rwx--xrw- 1 centos centos 52 7월 3 13:52 test//숫자를 넣지 않고 하는것을 심볼릭방법이라 하는데 이것이 더 편할 때가 있다.숫자로 할 경우 기존의 권한도 알아야 하기 때문에.. chown 파일 소유자 변경123# chown centos sample.txt //centos로 소유권을 넘김# ls -l sample.txt-rw-r-xr-x 1 centos root 0 7월 3 13:35 sample.txt //소유권 변경됨 chgrp 파일 소유 그룹 변경123# chgrp centos sample.txt# ls -l sample.txt-rw-r-xr-x 1 centos centos 0 7월 3 13:35 sample.txt chown 파일 소유자, 그룹 변경123# chown root.root sample.txt# ls -l sample.txt-rw-r-xr-x 1 root root 0 7월 3 13:35 sample.txt ./에 대한 이해파일을 실행하기 위해서는 아래의 명령어를 입력해야한다.1# ./파일명./는 왜 붙는것일까?그냥 파일명만 입력하면 찾지못하는데 그 이유는 현재 디렉토리가 경로에 없어서 그렇다.그래서 ./을 넣어주는 것이다. 앞에서 배웠듯이 . 은 현재 디렉토리를 의미하는것을 떠올려보자.즉 ./파일명 는 현재 디렉터리 아래에 있는 파일명을 실행하라는 것이다. su 해당사용자로 로그인1234# su - centos //centos계정으로 로그인 //루트계정일 경우 암호를 묻지않는다. //-를 붙이면 디렉토리가 centos디렉토리로 변경되가 //붙이지 않으면 변경되지 않는다. 실습해보자.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# touch test //test 파일 생성# vi test //이후 명령어(ex ls) 입력 그후 저장후 종료# ./test //test 파일 실행실행되지 않음. # chmod 755 test //실행권한을 모두 준다.# ./test //실행된다.현재 파일의 소유권은 root이다.# chown centos.centos test //소유자,그룹을 변경# su - centos //센토스 사용자로 접근 //이때 암호는 물어보지 않음. 루트에서 이동하는것이므로$ ls -l /root/test //허가 거부가 된다. //왜냐하면 /root 디렉토리가 일반사용자는 들어올수 없게 되어있음. //그러므로 파일을 이동시키거나, /root 디렉토리에 다른사용자가 들어 //올수 있게 허가해주어야 한다. 후자는 좋지 않은 방법이므로 전자를 //활용하자# exit //centos계정 로그아웃# mv test ~centos //centos 홈폴더로 test파일이동.# su - centos //다시 centos로 로그인$ chmod 777 test$ chown root.root test //소유권을 다시 root로 변경 //불가능하다. 어딜감히 root로 변경해 //악성코드를 심고 할 수도 있고..위험함.. //그래서 이 명령어는 루트사용자만 가능!!!$ chmod o-x test //일반사용자(o : ordinary)는 -x (x:execute) 실행 못하도록$ ls -l-rwxrwxrw- 1 centos centos 52 7월 3 13:52 test //마지막에 -가 들어간것을 확인$ chmod ug-w test //소유주(u: user), 소유그룹(g: group) 쓰기권한 제거$ ls -l test-r-xr-xrw- 1 centos centos 52 7월 3 13:52 test //3번째 6번째 w가 빠짐$ chmod ugo-r test //전부다 읽기권한 제거$ ls -l test ---x--x-w- 1 centos centos 52 7월 3 13:52 test //r이 제거된것 확인$ chmod uo+rw test //소유주, 기타사용자에게 읽기,쓰기 허용$ ls -l test -rwx--xrw- 1 centos centos 52 7월 3 13:52 test//숫자를 넣지 않고 하는것을 심볼릭방법이라 하는데 이것이 더 편할 때가 있다.숫자로 할 경우 기존의 권한도 알아야 하기 때문에.. 링크파일의 링크는 하드링크, 심볼릭 링크가 있다.윈도우의 바로가기처럼 연결되어있는것은 심볼릭링크 소프트 링크라 한다. 원본파일이 inode블록(실제 파일정보를 갖고있는것)을 가르키고 inode블록은 원본파일 데이터를 가르킨다. 하드링크파일은 inode를 직접 가르키며심볼링크파일은 새로운 inode를 만들고 새로운 inode는 원본파일 포인터를 하나 더만들고 그것을 가르킨다. 원본파일 포인터는 원본파일을 가르킨다. 교재 201p를 참고하자. 주로 하드링크보다는 심볼릭 링크를 생성한다. 실습해보기1234567891011121314151617181920212223242526272829# mkdir linktest# cd linktest/# vi basefile //아무거나 입력후 저장후 종료//원본파일이 생겼으므로 inode 블록이 생성되었을것이다.# ls -il basefile //inode 번호 확인405679049 -rw-r--r-- 1 root root 34 7월 3 14:36 basefile //405679049이 inode 번호# ln basefile hardlink //하드링크 생성# ln -s basefile softlink //소프트링크생성# ls -il405679049 -rw-r--r-- 2 root root 34 7월 3 14:36 basefile405679049 -rw-r--r-- 2 root root 34 7월 3 14:36 hardlink405679048 lrwxrwxrwx 1 root root 8 7월 3 14:40 softlink -&gt; basefile//basefile inode와 hardlink inode가 같다. softlink의 inode는 새로 만들어서 basefile을 가르킨다.# mv basefile ../ //원본파일을 앞 디렉토리로 이동시킴# ls -il# cat hardlink // 출력이 될까 안될까? //출력이 된다. 그 이유는 원본 inode를 가르키기 때문에!# cat softlink // 출력이 될까 안될까.? //안된다. 원본파일이 없어졌기 때문에.# mv ../basefile //다시 원상복구 시킴 (앞디렉토리로간 basefile 델꼬옴) 12","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. 사용자 및 그룹 관리","slug":"ThisIsLinux5","date":"2017-07-03T02:29:09.000Z","updated":"2018-09-03T05:50:20.339Z","comments":true,"path":"2017/07/03/ThisIsLinux5/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/03/ThisIsLinux5/","excerpt":"","text":"리눅스는 다중 사용자 시스템이다. 즉 서버 한대에 여러명이 접속한다. 그러므로 사용자를 관리하고 그룹을 관리하는게 중요한 이슈이다.기본적으로 rootㄹ는 슈퍼유저가 관리하며 모든 사용자는 하나 이상의 그룹에 소속되어야 한다.사용자는 /etc/passwd에 정의되어 있다.아래의 명령문을 실행시켜 vi 에디터로 확인해보자.1# vi /etc/passwd마지막 줄엔 다음과같은 코드가 존재한다.1centos:x:1000:1000:centos:/home/centos:/bin/bash이에 대해 자세히 알아보자. 1.centos = 사용자가 centos 이다. 2.x = 비밀번호 3.1000 = centos라는 사용자의 ID 4.1000 = centos사용자는 반드시 소속된 그룹이 있어야하는데 이는 소속된 그룹의 ID 즉 그룹번호이다.어떻게 그룹번호를 갖고 그룹명을 알까? /etc/group 파일에 정의되어 있다. 이 파일을 vi 에디터로 열면 그룹이름:그룹비밀번호:그룹의ID(그룹번호)의 형식을 갖는다.centos:x:1000:centos // 그룹이름:그룹비밀번호:그룹의ID(그룹번호)이게 무슨뜻일까? centos라는 사용자가 centos그룹에 속해 있다는 것이다. 마지막 centos 는 생략이 가능하며 신경쓰지 않아도 된다.예를 들면 홍길동이라는 부서에 홍길동 사원이 존재하는것이다. 회사에서는 부서를 만들고 사원을 뽑는다. 마찬가지로 centos도 새로운 사용자를 만들면 사용자 이름과 같은 그룹을 만들고 이 그룹에 해당시킨다.이것과 관련해 실습을 진행해보자.12345678# useradd myuser //유저 등록# tail -5 /etc/passwd //해당파일의 마지막 5줄만 보기myuser:x:1001:1001::/home/myuser:/bin/bash //그룹번호 1001을 기억# tail -5 /etc/group //해당파일의 마지막 5줄만 보기myuser:x:1001: //사용자 이름과 같은 그룹이 만들어졌고 그 그룹에 사용자가 속해있다. 5.centos = 전체이름이다. 생략이 가능하다 6./home/centos centos = 사용자의 홈 디렉토리 7./bin/bash = 사용할 기본 쉘 실습해보자디렉토리 설명/etc/passwd : 사용자 정보가 있음/etc/shadow : 사용자 비밀번호가 있음(비밀번호는 암호화되어서 저장됨)/etc/group : 그룹정보가 있음 실습 1유저 생성, 유저 그룹지정, 그룹생성1234567891011121314151617181920212223242526272829303132333435363738# useradd user1 //user1생성# tail -5 /etc/passwd //생성되었는지 확인user1:x:1001:1001::/home/user1:/bin/bash //잘생성됨# tail -5 /etc/shadow //사용자의 비밀번호를 확인해보자user1:!!:17350:0:99999:7::: //비밀번호를 설정하지 않았지만 암호화 되어있다.# tail -5 /etc/group //사용자의 그룹이 생성되었나 확인해보자user1:x:1001: //잘 생성되었다하지만 바람직하지 않다.! user1의 그룹이 user1이라니 말이되나!다시실습해보자 이번에는 그룹을 먼저 생성하고 사용자를 소속시키자# userdel -r user1 //보통 현업에선 -r옵션을 넣어 디렉토리까진 지우지 않는다. //하지만 실습이므로 과감하게 지운다.# groupadd centosGroup //그룹생성# tail -5 /etc/group //잘생성되었나 확인centosGroup:x:1001: //잘생성됨# useradd -g centosGroup user1 //centosGroup에 소속된 user1생성# useradd -g centosGroup user2 //centosGroup에 소속된 user2생성# tail -5 /etc/passwd //잘 생성되었나 확인.user1:x:1001:1001::/home/user1:/bin/bashuser2:x:1002:1001::/home/user2:/bin/bash //잘 생성되었고 사용자 ID는 다르지만 같은 그룹ID를 갖는다.# passwd user1 //암호지정. 이후 1234 1234입력 //일반사용자는 암호를 8자 미만으로 지정못하지만 //루트사용자는 8자 미만으로 지정해줄수 있다.# passwd user2 //암호지정. 이후 1234 1234입력# tail -5 /etc/shadow //user1,user2의 암호를 보자 //user1,user2의 암호를 1234로 지정하였지만 //암호화된 값이 다르다!! 실습 2x윈도에서 사용자권한관리 - x윈도가 없으면 안되므로 비추12# yum -y install system-config-users //system-config-users패키지 설치# system-config-users //x윈도우 상에서 사용자 관리가 가능하다! 관련 명령어189p 참고1234567891011121314151617181920212223242526-u : ID 지정-g : 그룹지정-d : 홈디렉터리지정-s : 쉘 지정# useradd shkim //새로운 사용자를 추가# passwd shkim //사용자의 비밀번호를 지정하거나 변경# usermod -g root shkim //사용자의 속성을 변경# userdel shkim //사용자는 지우나 디렉토리를 제거하지 않음. //-r 옵션이 존재. 이는 사용자가 사용하던 디렉토리까지 제거# change -m 2 shkim //사용자의 암호를 주기적으로 변경하도록 설정 //-m 2는 최소 이틀이상 써야한다.(189p 참고)# groups // 사용자가 속한 그룹을 보여줌# groupadd newgroup //새로운 그룹을 새성 # groupmod -n newgroup mygroup//그룹의 속성을 변경 newgroup을 mygroup로 변경# groupdel newgroup //그룹을 삭제# gpasswd newgroup //그룹의 암호설정","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. 리눅스 기본 명령어","slug":"ThisIsLinux4","date":"2017-07-02T06:25:50.000Z","updated":"2018-09-03T05:50:17.839Z","comments":true,"path":"2017/07/02/ThisIsLinux4/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/02/ThisIsLinux4/","excerpt":"","text":"기본명령어당연히 알고있어야 하는것들이다! 자연스럽게 사용할줄 알아야함! 폴더 == 디렉토리리눅스는 숨김파일일 경우 파일명 앞에 . 이 붙는다. (폴더도 마찬가지) $ ls -l 명령어를 실행하였을 때-로 시작하면 파일 d로 시작하면 디렉토리 ls 파일 목록보기123456789101112131415$ ls // 파일이나 폴더의 목록을 보는것 윈도우의 dir.$ ls /etc/sysconfig //특정 폴더내의 목록을 보는것$ ls -a //숨김파일까지 보는것.$ ls -l // 자세히 보는것 //-로 시작하면 파일 d로 시작하면 디렉토리$ ls *.cfg //확장자가 cfg인것$ ls ls my* // my로 시작하는것들 조회$ ls -al //숨김파일까지 자세히 조회 // -a, -l 의 결합 cd 디렉토리 이동x윈도가 있으면 편하겠지만 없으면 이동이 명령어로만 가능하기 때문에 익숙해지자. cd 명령어를 쓴 후에는 pwd 를 통해 현재 디렉토리를 보자. 리눅스의 디렉터리 구조를 이해 할 수 있게된다. 1234567891011121314151617181920212223$ cd /etc/sysconfig/$ pwd //현재 디렉터리 위치 출력$ cd / // 최상위폴더로 이동(루트 디렉토리라함) // $ cd / 명령어의 경우 다음 명령창이 아래와 같이 나온다. // [root@localhost /]#$ cd // &quot;/루트 디렉토리&quot;(현재 사용자의 홈폴더)로 이동 // $ cd 명령어의 경우 다음 명령창이 아래와 같이 나온다. // [root@localhost ~]$ cd /etc //루트 디렉토리의 etc로 이동(절대경로)$ cd etc //현재 디렉토리에서 etc로 이동 (상대경로)$ cd .. //현재 디렉토리의 바로 앞 디렉토리로 이동$ cd . //현재 디렉토리 반환$ cd ~centos //해당 사용자의 홈 디렉토리로 이동 //즉 $ cd~사용자 == $ cd 여기서 주의할점!우리가 서버에서 사용하는 계정은 root이라는 점을 잊지말자.$ cd / 명령어를 실행하면 루트 디렉토리 즉 최상위 폴더로 이동하는데 여기서 ls를 입력하면 root 폴더가 하나 있다. 이 두가지를 혼동하는 경우가 많은데 주의 하도록 하자. 루트 디렉토리 그리고 루트 디렉토리에 존재하는 root 폴더는 다르며 루트 디렉토리안의 root 폴더는 root계정이기 때문에 존재하는것이다. 강의에서는 루트 디렉토리 그리고 /root 디렉토리 로 구분한다. ..에 대한 이해다음을 이해해보자1234[root@localhost /]# cd /etc/sysconfig/network-scripts/[root@localhost network-scripts]# cd ../../../root[root@localhost ~]# pwd/root .에 대한 이해다음을 이해해보자이거를 어디다 쓸까 싶지만 현재 디렉토리의 어떤것을 실행하거나 어떤 것을 현재 디렉토리로 옮길 때 사용된다.123[root@localhost ~]# cd .[root@localhost ~]# pwd/root touch 비어있는 파일 생성1$ touch //비어있는 파일 생성 rm 파일 삭제123$ rm file1 // 삭제명령어 (삭제할것인지 재확인함)$ rm -f file1 // 삭제 명령어(삭제할것인지 확인하지 않고 삭제) cp 복사123$ cp file3 file4 //file3가 file4로 복사됨$ cp -r /etc/sysconfig . // /etc/sysconfig폴더를 현재 폴더에 복사한다. -r은 디렉토리 복사일 때 필요함 mv 이동 및 파일명 변경123$ mv myfile3.txt /root/sysconfig //myfile3.txt파일을 /root/sysconfig 로 이동$ mv file file3 //파일이름을 file에서 file3로 변경 mkdir 디렉토리 생성1234$ mkdir folder1 //folder1 디렉토리 생성$ mkdir -p dir1/dir2/dir3 // dir1/dir2/dir3 디렉토리를 생성 // 디렉토리가 3개가 만들어지는것이 아니라 dir1 안에 dir2 안에 dir3가 만들어진다. rmdir 디렉토리 제거1234567$ rmdir folder1 //디렉토리 제거 (폴더가 비어있을 경우 가능)$ rmdir -r folder1 //내부에 파일이 있는 디렉토리 제거 //(안에 들어있는 파일 하나하나 지울것인지 다물어본다.)$ rm -rf dir1 //묻지도 따지지도 않고 dir1 디렉토리 제거 //매우 위험하다!! 주의해서 사용 cat 파일 읽기사실 vi를 써도 되지만 그게 귀찮을 떄 사용1$ cat anaconda.ks.cfg head 파일 읽기맨 위의 10줄만 보기1$ head anaconda-ks.cfg tail 파일 읽기맨 밑의 10줄만 보기1$ tail anaconda-ks.cfg more,less 페이지 단위로 읽기페이지 단위로 끊어 읽기 스페이스는 다음페이지 B는 이전페이지 종료하려면 Q123$ more anaconda-ks.cfg$ less anaconda-ks.cfg //less more보다 몇가지 명령어가 더 존재함 file 파일이 어떤 파일인지 확인1$ file file1 //디렉터리인지, 링크인지, 비었는지 등을 알려준다. $ file /dev/cdrom 은 링크이다. 내 환경에서는 sr0을 가르키지만 다를 수 있다는 점을 알고있자. clear1$ clear //화면을 깨끗하게 해준다.","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. vi에디터, CD/DVD마운트","slug":"ThisIsLinux3","date":"2017-07-02T04:13:19.000Z","updated":"2018-09-03T05:50:15.264Z","comments":true,"path":"2017/07/02/ThisIsLinux3/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/02/ThisIsLinux3/","excerpt":"","text":"에디터gedit / vi 로 나뉜다. gedit는 윈도우의 메모장으로 생각하면 되며 단순하다. vi는 리눅스에서 자주 사용되므로 반드시 익혀야 한다. gedit1234$ gedit //gedit 실행 //윈도우 + 스페이스 : 한영전환$ gedit 파일명 // 파일열기 vi 에디터x윈도우가 설치되지 않은곳에서도 사용 가능하기에 공통적으로 사용가능하다!초기 실행시 vi에디터는 명령모드이다. 즉 입력이 불가능한 상태이다. 새파일 작성시 , 수정시 12345678$ vi 파일명 //vi 에디터가 실행된다.i 또는 a 입력 //이후 편집, 입력작업진행esc //작업이 끝난 후 명령모드로 변경:wq //저장하고 종료한다.:q! //수정사항 무시하고 종료.코드의 행 번호를 확인하고 싶을경우1$ :set number swp 파일?중간에 작업을 하다 터미널이 비정상적으로 종료될 경우 swp파일이 생성된다. vi를 실행하면 에러가 뜨는데 엔터를 누르면 작업이 가능하다. 이 파일을 확인하기 위해서는 다음명령어를 입력한다.1$ ls -a //숨김파일까지 조회 그 후 파일을 swp 파일을 지우려면 다음을 입력한다.1$ rm .myfile3.txt.swp 도움말기능도움말 사용방법1$ mas ls //ls에 대한 도움말을 확인 . 스페이스바로 페이지 이동가능 마운트물리적인 장치와 디렉터리를 연결시켜주는 과정무슨소리지? 윈도우는 CD를 넣으면 D 드라이드 등으로 연결시켜 주지만 리눅스는 이과정이 없어서 특정 디렉토리로 연결시켜 주는것이다. X윈도우에서 가능하며, 텍스트 모드에서 가능하다1.우선 vmware상으로 cd를 삽입해야 하므로 그 과정을 거친다. 좌측상단 Player을 누르고 Removable Decices -&gt; CD/DVD -&gt; Setting 을 들어간다.혹은 우측상단 CD 모양 누르고 Setting 2.CD/DVD 탭으로 가서 Connected 키고 Use ISO…. 에 iso 이미지 선택 3.자동으로 인식이 되는데???? 리눅스는 자동으로 안된다며…하지만 이게 되는 리눅스가 있고 안되는게 있다. 또한 텍스트 모드는 자동으로 인식이 되지 않으므로 수동으로 연습하는 것이 필요! 마운트 사용법사전지식 :dvd장치의 경로 : /dev/cdrom보통 /media/cdrom 디렉토리를 마운트 할 떄 많이씀 12345678910111213141516171819$ umount /dev/cdrom //마운트 된것을 끊는것. 연결이 되지 않았을 경우 오류메시지가 나온다. 하지만 상관없다.$ ls /media //마운트 대상 디렉터리를 생성하기 전에 존재유무 확인$ mkdir /media/cdrom //마운트 대상 디렉토리 생성$ mount /dev/cdrom /media/cdrom //마운트!$ cd /media/cdrom //디렉토리 이동$ ls //마운트가 잘 되었는지 확인$ umount /dev/cdrom //마운트 끊기 하지만 에러가 난다. 현재 cdrom 안에 존재하기 때문에.$ cd // 홈디렉토리로 이동$ umount /dev/cdrom //마운트 끊기 재시도$ ls /media/cdrom //정상적으로 끊어진것을 확인 ISO 파일 제작p180 보고 진행하세요~ 앞으로 사용할 일은 없지만 가볍게 실습해보세요ISO 파일을 생성하는 명령어는 genisoimage 이다. 또 iso 파일을 CD로 굽기 위한 명령어는 cdrecord이며 DVD로 굽는 명령어는 growisofs 이다. 먼저 아래의 명령어로 패키지가 설치되어있는지 확인해보자.1$ rpm -qa 패키지이름설치되어있지 않다면1$ yum -y install 패키지명 으로 설치를 한다. 그 후 아래와 같이 입력하자. /boot디렉토리의 모든 파일을 test1.iso파일로 만드는 것이다.-r -J 는 8글자 이상의 파일 이름 및 대소문자를 구분해서 인식하는 옵션이며 -o는 출력할 파일을 위한 옵션이다.1$ genisoimage -r -J -o test1.iso /boot 테스트 해보기 위해 디렉토리를 만들고 마운트 시킨다.1234$ mkdir /media/iso$ mount -o loop test1.iso /media/iso$ ls -l /media/iso$ ls -l /boot 테스트를 했으면 마운트를 취소시켜준다1$ umount /media/iso","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"4장. 시작과종료, 가상콘솔, 런레벨, 자동완성","slug":"ThisIsLinux2","date":"2017-07-01T13:53:50.000Z","updated":"2018-09-03T05:50:13.099Z","comments":true,"path":"2017/07/01/ThisIsLinux2/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/01/ThisIsLinux2/","excerpt":"","text":"참고사항lrwxrwxrwx. 어쩌구가 있을경우 맨앞의 l은 링크파일임을 의미한다. 윈도우의 바로가기를 생각하자! 종료관련 명령어리눅스는 기본개념이 멀티유저 이므로 함부러 누군가 종료하거나 재시작하면 문제의 소지가 있다. ex) 네이버 서버를 누군가 종료시킨다면? 리눅스를 서버로 사용할 경우 리눅스는 종료가 아닌 로그아웃이 일반적인 개념이다! 12345678910111213141516171819202122$ shutdown -P now // 종료$ shutdown -P +10 //10분후에 종료$ shutdown -c //종료예약한것 취소$ shutdown -r 23:00 //23시에 재부팅$ shutdown -r +10 //10분후에 재부팅$ shutdown -c // 리부팅예약한것 취소$ shutdown -k +15 //20분 후에 종료된다는 메세지가 날라감 //루트를 제외한 모든 사용자에게.. //실제 종료는 안됨. //필요한 이유: 서버에 많은 사용자가 접속하였을 경우 사용자들의 로그아웃을 유도.$ init 0~6 // 0-종료모드 2-멀티유저모드 5-그래픽모드의 다중사용자모드 6-리부트모드$ startx //x윈도우 모드로 변경 주의) 예로 단순히 init4에서 init1로가는것과 다르다. //명령어 모드에서 x윈도우 모드로 변경되는것 가상콘솔 명령어CentOS는 6개의 가상콘솔을 제공하는데 ctrl+alt+F2~F6으로 이동이 가능하다. F1은 X윈도우 모드이다. 1$ chvt 1~6 입력 //가상콘솔 이동 자동완성일부만 입력하고 탭을 누르면 자동완성된다.12345678910$ /abcdef를 입력하고자 할 경우$ /abc만 입력하고 탭키를 누르면$ /abcdef 가 입력된다.먄약 abcde, abcdef 라는 디렉토리가 존재할 경우에는$ /abc입력 후 탭키를 누르면 자동완성이 되지않는다. 이 경우 탭키를 두번누르면 abcde, abcdef 라는 디렉토리가 있다는 사실을 알려준다. 히스토리123$ history //자신이 입력했던 명령어들이 출력된다.$ history //히스토리 리스트를 제거한다.","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"리눅스 명령어","slug":"Instruction","date":"2017-07-01T04:57:06.000Z","updated":"2018-09-03T05:50:02.002Z","comments":true,"path":"2017/07/01/Instruction/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/01/Instruction/","excerpt":"","text":"참고사항 $: 일반사용자 #: 루트사용자 명령어123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228$ halt -p // 종료$ gedit 파일명 //편집기 열기$ ifconfig //윈도우 ipconfig와 동일$ reboot //리부트 명령어$ su - //루트사용자의 권한을 얻음(폴더가 이동됨)$ su //루트사용자의 권한을 얻음(폴더 이동되지 않고)$ setfont sun12x22 //글자크기 변경$ vi 파일명 //vi 에디터 열기$ ip addr //ip 확인$ clear //콘솔창 초기화$ yum 프로그램 //프로그램 설치$ cd //홈디렉터리로 이동$ shutdown -P now // 종료$ shutdown -P +10 //10분후에 종료$ shutdown -c //종료예약한것 취소$ shutdown -r 23:00 //23시에 재부팅$ shutdown -r +10 //10분후에 재부팅$ shutdown -c // 리부팅예약한것 취소$ shutdown -k +15 //20분 후에 종료된다는 메세지가 날라감 //루트를 제외한 모든 사용자에게.. //실제 종료는 안됨. //필요한 이유: 서버에 많은 사용자가 접속하였을 경우 사용자들의 로그아웃을 유도.$ init 0~6 // 0-종료모드 2-멀티유저모드 5-그래픽모드의 다중사용자모드 6-리부트모드$ startx //x윈도우 모드로 변경 주의) 예로 단순히 init4에서 init1로가는것과 다르다. //명령어 모드에서 x윈도우 모드로 변경되는것$ chvt 1~6 입력 //가상콘솔 이동$ gedit //gedit 실행 //윈도우 + 스페이스 : 한영전환$ gedit 파일명 // 파일열기$ vi 파일명 //vi 에디터가 실행된다.i 또는 a 입력 //이후 편집, 입력작업진행esc //작업이 끝난 후 명령모드로 변경:wq //저장하고 종료한다.:q! //수정사항 무시하고 종료$ :set number //코드의 행번호 확인$ ls -a //숨김파일까지 조회$ rm .myfile3.txt.swp //파일삭제$ mas ls //ls에 대한 도움말을 확인 . 스페이스바로 페이지 이동가능$ umount /dev/cdrom //마운트 된것을 끊는것. 연결이 되지 않았을 경우 오류메시지가 나온다.$ mount /dev/cdrom /media/cdrom //마운트!$ rpm -qa 패키지이름 //패키지 설치여부 확인$ yum -y install 패키지명 으로 설치를 한다.$ ls // 파일이나 폴더의 목록을 보는것 윈도우의 dir.$ ls /etc/sysconfig //특정 폴더내의 목록을 보는것$ ls -a //숨김파일까지 보는것.$ ls -l // 자세히 보는것 //-로 시작하면 파일 d로 시작하면 디렉토리$ ls *.cfg //확장자가 cfg인것$ ls ls my* // my로 시작하는것들 조회$ ls -al //숨김파일까지 자세히 조회 // -a, -l 의 결합$ cd /etc/sysconfig/$ pwd //현재 디렉터리 위치 출력$ cd / // 최상위폴더로 이동(루트 디렉토리라함) // $ cd / 명령어의 경우 다음 명령창이 아래와 같이 나온다. // [root@localhost /]#$ cd // &quot;/루트 디렉토리&quot;(현재 사용자의 홈폴더)로 이동 // $ cd 명령어의 경우 다음 명령창이 아래와 같이 나온다. // [root@localhost ~]$ cd /etc //루트 디렉토리의 etc로 이동(절대경로)$ cd etc //현재 디렉토리에서 etc로 이동 (상대경로)$ cd .. //현재 디렉토리의 바로 앞 디렉토리로 이동$ cd . //현재 디렉토리 반환$ cd ~centos //해당 사용자의 홈 디렉토리로 이동 //즉 $ cd~사용자 == $ cd $ touch //비어있는 파일 생성$ rm file1 // 삭제명령어 (삭제할것인지 재확인함)$ rm -f file1 // 삭제 명령어(삭제할것인지 확인하지 않고 삭제)$ cp file3 file4 //file3가 file4로 복사됨$ cp -r /etc/sysconfig . // /etc/sysconfig폴더를 현재 폴더에 복사한다. -r은 디렉토리 복사일$ mv myfile3.txt /root/sysconfig //myfile3.txt파일을 /root/sysconfig 로 이동$ mv file file3 //파일이름을 file에서 file3로 변경$ mkdir folder1 //folder1 디렉토리 생성$ mkdir -p dir1/dir2/dir3 // dir1/dir2/dir3 디렉토리를 생성 // 디렉토리가 3개가 만들어지는것이 아니라 dir1 안에 dir2 안에 dir3가 만들어진다.$ rmdir folder1 //디렉토리 제거 (폴더가 비어있을 경우 가능)$ rmdir -r folder1 //내부에 파일이 있는 디렉토리 제거 //(안에 들어있는 파일 하나하나 지울것인지 다물어본다.)$ rm -rf dir1 //묻지도 따지지도 않고 dir1 디렉토리 제거 //매우 위험하다!! 주의해서 사용$ cat anaconda.ks.cfg // 파일을 읽기$ head anaconda-ks.cfg //위에 10줄만 읽기$ head -5 anaconda-ks.cfg //위에 5줄만 읽기$ tail anaconda-ks.cfg //아래 10줄만 읽기$ more anaconda-ks.cfg //페이지 단위로 끊어읽기$ less anaconda-ks.cfg //페이지 단위로 끊어읽기 less가 more보다 몇가지 명령어가 더 존재함$ file file1 //디렉터리인지, 링크인지, 비었는지 등을 알려준다.# userdel -r user1 //보통 현업에선 -r옵션을 넣어 디렉토리까진 지우지 않는다. //하지만 실습이므로 과감하게 지운다.# groupadd centosGroup //그룹생성# useradd user1 //user1생성# useradd -g centosGroup user1 //centosGroup에 소속된 user1생성# useradd -g centosGroup user2 //centosGroup에 소속된 user2생성# passwd shkim //사용자의 비밀번호를 지정하거나 변경# usermod -g root shkim //사용자의 속성을 변경# userdel shkim //사용자는 지우나 디렉토리를 제거하지 않음. //-r 옵션이 존재. 이는 사용자가 사용하던 디렉토리까지 제거# change -m 2 shkim //사용자의 암호를 주기적으로 변경하도록 설정 //-m 2는 최소 이틀이상 써야한다.(189p 참고)# groups // 사용자가 속한 그룹을 보여줌# groupadd newgroup //새로운 그룹을 새성 # groupmod -n newgroup mygroup//그룹의 속성을 변경 newgroup을 mygroup로 변경# groupdel newgroup //그룹을 삭제# gpasswd newgroup //그룹의 암호설정$ chmod o-x test //일반사용자(o : ordinary)는 -x (x:execute) 실행 못하도록$ ls -l test-rwxrwxrw- 1 centos centos 52 7월 3 13:52 test //마지막 x가 빠짐$ chmod ug-w test //소유주(u: user), 소유그룹(g: group) 쓰기권한 제거$ ls -l test-r-xr-xrw- 1 centos centos 52 7월 3 13:52 test //3번째 6번째 w가 빠짐$ chmod ugo-r test //전부다 읽기권한 제거$ ls -l test ---x--x-w- 1 centos centos 52 7월 3 13:52 test //r이 제거된것 확인$ chmod uo+rw test //소유주, 기타사용자에게 읽기,쓰기 허용$ ls -l test -rwx--xrw- 1 centos centos 52 7월 3 13:52 test//숫자를 넣지 않고 하는것을 심볼릭방법이라 하는데 이것이 더 편할 때가 있다.숫자로 할 경우 기존의 권한도 알아야 하기 때문에..# chown centos sample.txt //centos로 소유권을 넘김# ls -l sample.txt-rw-r-xr-x 1 centos root 0 7월 3 13:35 sample.txt //소유권 변경됨# chgrp centos sample.txt //파일소유그룹 변경# ls -l sample.txt-rw-r-xr-x 1 centos centos 0 7월 3 13:35 sample.txt# chown root.root sample.txt //파일 소유자, 그룹 변경# ls -l sample.txt-rw-r-xr-x 1 root root 0 7월 3 13:35 sample.txt# su - centos //centos계정으로 로그인 //루트계정일 경우 암호를 묻지않는다. //-를 붙이면 디렉토리가 centos디렉토리로 변경되가 //붙이지 않으면 변경되지 않는다.# ps -ef | grep dnsmasq //dnsmasq 프로세스 번호 확인# kill -9 xxxx //xxxx프로세스 kill","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"리눅스 명령어","slug":"리눅스-명령어","permalink":"http://KKimSangHeon.github.io/tags/리눅스-명령어/"}]},{"title":"리눅스 에러","slug":"LinuxError","date":"2017-07-01T04:45:37.000Z","updated":"2018-09-03T05:50:10.132Z","comments":true,"path":"2017/07/01/LinuxError/","link":"","permalink":"http://KKimSangHeon.github.io/2017/07/01/LinuxError/","excerpt":"","text":"증상:Virtualized performance counters are not supported on the host CPU type. Module VPMC power on failed. Failed to start the virtual machine 이라는 에러메세지 출력. 해결법:.vmx 파일을 열고 vpmc.enable 부분을 “FALSE”로 수정. 증상:quotaoff: command not found , 쿼터에 대한 명령어가 실행이 안됨. 해결법:1# yum install quota 증상:ifconfig가 먹히질 않는다. 해결법1# yum install net-tools 방화벽 설정dns 방화벽 설정을 허용한다고 가정. 해결법12# firewall-cmd --permanent --add-service=dns //방화벽 설정 허용# firewall-cmd --reload //설정내용 적용 증상:받고싶은 패키지가 있는데 레드헷전용이다. 해결법1# yum -y install epel-release //레드헷에 접속해서 다운받을수 있도록 설치 증상: vsftpd를 사용하는데 너무 느리다. 해결법123456# vi /etc/vsftpd/vsftpd.conf# local_max_rate=0# systemctl restart vsftpd","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux Error","slug":"Linux-Error","permalink":"http://KKimSangHeon.github.io/tags/Linux-Error/"}]},{"title":"BinarySearch","slug":"BinarySearch","date":"2017-06-30T10:38:20.000Z","updated":"2018-09-03T05:49:11.759Z","comments":true,"path":"2017/06/30/BinarySearch/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/BinarySearch/","excerpt":"","text":"이진탐색데이터의 정렬이 선행되어야 한다. 시간복잡도는 O(log2n) 이다.BinarySearch.c 재귀적인 방법12345678910111213141516int ISearch(int ar[], int first, int last, int target)&#123; int mid; if(first &gt; last) return -1; // -1의 반환은 탐색의 실패를 의미 mid=(first+last) / 2 ; if(ar[mid] == target) return mid; // 탐색된 타겟의 인덱스 값 반환 else if(target &lt; ar[mid]) return ISearch(ar, first, mid-1, target); else return ISearch(ar, mid+1, last, target);&#125; BinarySearch.c 반복문 이용123456789101112131415161718BinarySearch(int DataSet[], int Size, int target)&#123; int Left,Right,Mid; Left=0; Right=Size-1; while(Left&lt;=Right)&#123; Mid=(Left+Rigth) / 2 ; if( Target==DataSet[Mid]) return DataSet[Mid]; else if(Target&gt;DataSet[Mid]) Left=Mid+1; else Right=Mid-1; &#125; return NULL;&#125; 이진탐색의 경우 비교대상이 되는 mid값을 단순히 (first+last)/2로 설정한다.그러나 보간 탐색의 경우 mid 값 설정방식이 다르며 이진탐색보다 우수한 성능을 보인다. 보간탐색탐색대상이 앞쪽에 위치 할 경우 앞쪽에서 탐색을 시작하고 뒤쪽에 위치할 경우 뒤쪽에서 탐색을 시작한다.이진탐색보다 우수하다.ISearch.c12345678910111213141516int ISearch(int ar[], int first, int last, int target)&#123; int mid; if(ar[first]&gt;target || ar[last]&lt;target) return -1; // 이진 탐색과의 차이점을 반영한 문장 mid = ((double)(target-ar[first]) / (ar[last]-ar[first]) *(last-first)) + first; if(ar[mid] == target) return mid; // 탐색된 타겟의 인덱스 값 반환 else if(target &lt; ar[mid]) return ISearch(ar, first, mid-1, target); else return ISearch(ar, mid+1, last, target);&#125; 보간탐색의 mid값 계산 방법 그림[1]에서 arr[s]는 찾는값을 의미함. 참고 : 윤성우의 열혈 자료구조","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://KKimSangHeon.github.io/categories/Algorithm/"},{"name":"Search","slug":"Algorithm/Search","permalink":"http://KKimSangHeon.github.io/categories/Algorithm/Search/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/tags/Data-Structure/"},{"name":"Search","slug":"Search","permalink":"http://KKimSangHeon.github.io/tags/Search/"},{"name":"BinarySearch","slug":"BinarySearch","permalink":"http://KKimSangHeon.github.io/tags/BinarySearch/"}]},{"title":"2장. CentOS 리눅스 소개","slug":"ThisIsLinux1","date":"2017-06-30T09:55:52.000Z","updated":"2018-09-03T05:49:54.370Z","comments":true,"path":"2017/06/30/ThisIsLinux1/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/ThisIsLinux1/","excerpt":"","text":"리눅스 리눅스란?리눅스 = 무료 유닉스 라 생각하면 된다.1991 ‘리누스 토르발스’가 버전 0.01을 최초로 완성. 리누스 토르발스는 커널(kernel)만 개발함(여기서 커널은 자동차 엔진이라고 보면된다.)모든 배포판은 리누스 토르발스가 개발한 커널을 갖고 사람들이 만들어진것이다. CentOS 또한 마찬가지..자동차로 비유하자면 A,B,C 회사가 하나의 엔진을 사용하여 각기 다른 자동차를 만들어내놓음.우리가 공부할 CentOS의 커널버전은 3.17.4인데 변경이 가능하다.!자동차로 비교하면 자동차를 그대로 두고 엔진만 변경하는것.이를 커널 업그레이드 라고 한다. GNU 프로젝트?GNU 프로젝트 - GPL(General Public License[자유 소프트웨어의 수정과 공유의 자유를 보장하는것.]) 에 따라 소스를 배포하여 공개하고 그것을 더 개선하여 배포하고 의 반복.. 리눅스 또한 마찬가지. 그래서 현재는 유닉스 보다 더 좋다고 말하는 사람들이 많다. 여기서 재미있는점 하나. 소스코드를 무료로 얻어서 기능개선 후 판매는 가능하다. 그러나 GPL에 의해 소스코드는 공유해야한다는점. 레드햇 리눅스와 CentOS 리눅스?전 세계적으로 유명하며 기업에서 많이쓴다. 무료버전은 없으며 상용버전만 존재한다. 하지만 GPL에 의해 소스코드는 공개되어 있어 레드햇 엔터프라이즈 리눅스의 소스코드를 그대로 가져와 로고만 바꾼것이 CentOS!!결국 레드햇 리눅스 == CentOS 리눅스","categories":[{"name":"OS","slug":"OS","permalink":"http://KKimSangHeon.github.io/categories/OS/"},{"name":"Linux","slug":"OS/Linux","permalink":"http://KKimSangHeon.github.io/categories/OS/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://KKimSangHeon.github.io/tags/Linux/"},{"name":"This Is Linux","slug":"This-Is-Linux","permalink":"http://KKimSangHeon.github.io/tags/This-Is-Linux/"}]},{"title":"기수정렬 (RadixSort)","slug":"RadixSort","date":"2017-06-30T05:36:34.000Z","updated":"2018-09-03T05:49:36.715Z","comments":true,"path":"2017/06/30/RadixSort/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/RadixSort/","excerpt":"","text":"기수정렬버켓에 데이터를 작은 수 부터 넣고 빼내어 정렬하는 방식이다.기수정렬의 시간복잡도는 O(ln)이며 l은 버켓의 크기를 의미한다. red, why, few 정렬가능 - 버킷 3개 필요10,161,18,1 가능 - 버킷 3개 필요proffesor , red , why 불가능125 , -101, 167, -505 불가능 ##참고사항 1의자리 수 구하기-num/1%1010의자리 수 구하기 -num/10%10100의 자리 수 구하기 -num/100%10 InsertionSort.c123456789101112131415161718192021222324252627282930313233343536373839void RadixSort(int arr[], int num, int maxLen) // maxLen은 가장 긴 데이터의 길이&#123; Queue buckets[BUCKET_NUM]; int bi; int pos; int di; int divfac = 1; int radix; // 총 10개의 버킷 초기화 for(bi=0; bi&lt;BUCKET_NUM; bi++) QueueInit(&amp;buckets[bi]); // 가장 긴 데이터의 길이만큼 반복 for(pos=0; pos&lt;maxLen; pos++) &#123; // 정렬 대상의 수만큼 반복 for(di=0; di&lt;num; di++) &#123; // N번째 자리의 숫자 추출 radix = (arr[di] / divfac) % 10; // 추출한 숫자를 근거로 데이터 버킷에 저장 Enqueue(&amp;buckets[radix], arr[di]); &#125; // 버킷 수만큼 반복 for(bi=0, di=0; bi&lt;BUCKET_NUM; bi++) &#123; // 버킷에 저장된 것 순서대로 다 꺼내서 다시 arr에 저장 while(!QIsEmpty(&amp;buckets[bi])) arr[di++] = Dequeue(&amp;buckets[bi]); &#125; // N번째 자리의 숫자 추출을 위한 피제수의 증가 divfac *= 10; &#125;&#125; 참고 : 윤성우의 열혈 자료구조","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://KKimSangHeon.github.io/categories/Algorithm/"},{"name":"Sort","slug":"Algorithm/Sort","permalink":"http://KKimSangHeon.github.io/categories/Algorithm/Sort/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/tags/Data-Structure/"},{"name":"Sort","slug":"Sort","permalink":"http://KKimSangHeon.github.io/tags/Sort/"},{"name":"Radix Sort","slug":"Radix-Sort","permalink":"http://KKimSangHeon.github.io/tags/Radix-Sort/"}]},{"title":"퀵정렬 (QuickSort)","slug":"QuickSort","date":"2017-06-30T05:36:18.000Z","updated":"2018-09-03T05:49:32.953Z","comments":true,"path":"2017/06/30/QuickSort/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/QuickSort/","excerpt":"","text":"퀵정렬퀵 정렬 O(nlog2n)- 피벗을 정하여 분할하여 정복.. 피벗을 선택 할때 3개를 선택하여 평균치를 구하여 구하면 더 효율적으로 피벗을 정할 수 있다.피벗이 잘 선택될 경우 시간복잡도가 줄어든다. 최악의 경우 O(n^2)이 될 수 있다 (피벗값이 많이 안좋을 경우) O(nlog2n)의 시간복잡도를 갖는 다른 정렬 알고리즘 보다 평균적으로 빠르다.why ? 데이터 이동이 상대적으로 작고 병합정렬과 같이 별도의 메모리 공간을 요구하지 않기 때문에.. 나만의 요약! : 피벗값을 기준으로 처음지점부터 시작한 반복문은 피벗보다 작은값을 찾고 뒤에서 시작한 반복문은 피벗보다 큰값을 찾아 서로 바꾼다. ( 단 피벗을 지나치치 않음) QuickSort.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void Swap(int arr[], int idx1, int idx2)&#123; int temp = arr[idx1]; arr[idx1] = arr[idx2]; arr[idx2] = temp;&#125;int Partition(int arr[], int left, int right)&#123; int pivot = arr[left]; // 피벗의 위치는 가장 왼쪽! int low = left+1; int high = right; while(low &lt;= high) // 교차되지 않을 때까지 반복 &#123; while(pivot &gt; arr[low]) low++; while(pivot &lt; arr[high]) high--; /* while(pivot &gt;= arr[low] &amp;&amp; low &lt;= right) low++; while(pivot &lt;= arr[high] &amp;&amp; high &gt;= (left+1)) high--; */ if(low &lt;= high) // 교차되지 않은 상태라면 Swap 실행 Swap(arr, low, high); // low와 high가 가리키는 대상 교환 &#125; Swap(arr, left, high); // 피벗과 high가 가리키는 대상 교환 return high; // 옮겨진 피벗의 위치 정보 반환&#125;void QuickSort(int arr[], int left, int right)&#123; if(left &lt;= right) &#123; int pivot = Partition(arr, left, right); // 둘로 나눠서 QuickSort(arr, left, pivot-1); // 왼쪽 영역을 정렬 QuickSort(arr, pivot+1, right); // 오른쪽 영역을 정렬 &#125;&#125; 참고 : 윤성우의 열혈 자료구조","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://KKimSangHeon.github.io/categories/Algorithm/"},{"name":"Sort","slug":"Algorithm/Sort","permalink":"http://KKimSangHeon.github.io/categories/Algorithm/Sort/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/tags/Data-Structure/"},{"name":"Sort","slug":"Sort","permalink":"http://KKimSangHeon.github.io/tags/Sort/"},{"name":"Quick Sort","slug":"Quick-Sort","permalink":"http://KKimSangHeon.github.io/tags/Quick-Sort/"}]},{"title":"병합정렬 (MergeSort)","slug":"MergeSort","date":"2017-06-30T05:36:10.000Z","updated":"2018-09-03T05:49:26.329Z","comments":true,"path":"2017/06/30/MergeSort/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/MergeSort/","excerpt":"","text":"병합정렬재귀적으로 분할하여 병합하는 방식으로 재귀적으로 모든 요소들을 쪼갠 후 합쳐나간다. 시간복잡도는 O(nlog2n))이다. MergeSort.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void MergeTwoArea(int arr[], int left, int mid, int right)&#123; int fIdx = left; int rIdx = mid+1; int i; int * sortArr = (int*)malloc(sizeof(int)*(right+1)); int sIdx = left; while(fIdx&lt;=mid &amp;&amp; rIdx&lt;=right) &#123; if(arr[fIdx] &lt;= arr[rIdx]) sortArr[sIdx] = arr[fIdx++]; else sortArr[sIdx] = arr[rIdx++]; sIdx++; &#125; if(fIdx &gt; mid) &#123; for(i=rIdx; i&lt;=right; i++, sIdx++) sortArr[sIdx] = arr[i]; &#125; else &#123; for(i=fIdx; i&lt;=mid; i++, sIdx++) sortArr[sIdx] = arr[i]; &#125; for(i=left; i&lt;=right; i++) arr[i] = sortArr[i]; free(sortArr);&#125;void MergeSort(int arr[], int left, int right)&#123; int mid; if(left &lt; right) &#123; // 중간 지점을 계산한다. mid = (left+right) / 2; // 둘로 나눠서 각각을 정렬한다. MergeSort(arr, left, mid); MergeSort(arr, mid+1, right); // 정렬된 두 배열을 병합한다. MergeTwoArea(arr, left, mid, right); &#125;&#125; 참고 : 윤성우의 열혈 자료구조","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://KKimSangHeon.github.io/categories/Algorithm/"},{"name":"Sort","slug":"Algorithm/Sort","permalink":"http://KKimSangHeon.github.io/categories/Algorithm/Sort/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/tags/Data-Structure/"},{"name":"Sort","slug":"Sort","permalink":"http://KKimSangHeon.github.io/tags/Sort/"},{"name":"Merge Sort","slug":"Merge-Sort","permalink":"http://KKimSangHeon.github.io/tags/Merge-Sort/"}]},{"title":"힙정렬 (HeapSort)","slug":"HeapSort","date":"2017-06-30T05:35:38.000Z","updated":"2018-09-03T05:49:20.343Z","comments":true,"path":"2017/06/30/HeapSort/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/HeapSort/","excerpt":"","text":"힙 정렬힙을 만들어서 힙에 넣고 빼는것으로서 시간복잡도는 O(nlog2n) 이다. BubbleSort.c12345for(i=0;i&lt;n;i++) HInsert(&amp;heap,arr[i]);for(i=0;i&lt;n;i++) arr[i]=HDelete(&amp;heap); 참고 : 윤성우의 열혈 자료구조","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://KKimSangHeon.github.io/categories/Algorithm/"},{"name":"Sort","slug":"Algorithm/Sort","permalink":"http://KKimSangHeon.github.io/categories/Algorithm/Sort/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/tags/Data-Structure/"},{"name":"Sort","slug":"Sort","permalink":"http://KKimSangHeon.github.io/tags/Sort/"},{"name":"Heap Sort","slug":"Heap-Sort","permalink":"http://KKimSangHeon.github.io/tags/Heap-Sort/"}]},{"title":"삽입정렬 (InsertionSort)","slug":"InsertionSort","date":"2017-06-30T05:35:28.000Z","updated":"2018-09-03T05:49:23.449Z","comments":true,"path":"2017/06/30/InsertionSort/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/InsertionSort/","excerpt":"","text":"삽입정렬1~n까지 정렬해 나감 1~2 정렬 12묶음 3정렬 13묶음 4정렬첫 번째 데이터는 정렬이 되어있다고 봄. 그래서 i=0이아닌 1부터 시작.시간복잡도는 O(n^2) 이다. InsertionSort.c123456789101112for(i=1;i&lt;n;i++)&#123; insData=arr[i]; //정렬대상을 insData에 저장 for(j=i-1;i&gt;=0;j--) &#123; if(arr[j]&gt;insData) arr[j+1]=arr[j]; else break; &#125; arr[j+1]=insData;&#125; 참고 : 윤성우의 열혈 자료구조","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://KKimSangHeon.github.io/categories/Algorithm/"},{"name":"Sort","slug":"Algorithm/Sort","permalink":"http://KKimSangHeon.github.io/categories/Algorithm/Sort/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/tags/Data-Structure/"},{"name":"Sort","slug":"Sort","permalink":"http://KKimSangHeon.github.io/tags/Sort/"},{"name":"Insertion Sort","slug":"Insertion-Sort","permalink":"http://KKimSangHeon.github.io/tags/Insertion-Sort/"}]},{"title":"선택정렬 (SelectionSort)","slug":"SelectionSort","date":"2017-06-30T04:59:38.000Z","updated":"2018-09-03T05:49:40.089Z","comments":true,"path":"2017/06/30/SelectionSort/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/SelectionSort/","excerpt":"","text":"선택정렬오름차순일 경우 작은걸 맨앞에 넣고 그 다음 작은걸 두 번째 넣고 ..이 과정을 계속 반복한다. 시간복잡도는 O(n^2) 이다. SelectionSort.c12345678910for(i=0;i&lt;n-1;i++)&#123; maxIdx=i; for(j=i+1;j&lt;n;j++) //최소값 탐색 &#123; if(arr[i]&lt;arr[maxIdx]) maxIdx=j; &#125; swap;&#125; 참고 : 윤성우의 열혈 자료구조","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://KKimSangHeon.github.io/categories/Algorithm/"},{"name":"Sort","slug":"Algorithm/Sort","permalink":"http://KKimSangHeon.github.io/categories/Algorithm/Sort/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/tags/Data-Structure/"},{"name":"Sort","slug":"Sort","permalink":"http://KKimSangHeon.github.io/tags/Sort/"},{"name":"Selection Sort","slug":"Selection-Sort","permalink":"http://KKimSangHeon.github.io/tags/Selection-Sort/"}]},{"title":"작성논문","slug":"paper","date":"2017-06-30T04:40:14.000Z","updated":"2017-07-07T00:51:51.519Z","comments":true,"path":"2017/06/30/paper/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/paper/","excerpt":"","text":"A Survey of Fingerprint Indoor Positioning TechniquesintroductionThe location based service (LBS) industry is so flourishing that enumerating all LBSs available now is almost impossible. In the marketing field, LBSs may recognize the current location of tenta-tive customers and push advertisement messages and coupons to them when they enter a predefined area. When a person makes a call to 911, the location of the person is identified by the emergency response agency so that help can be provided quickly. The location-based information service deliv-ers information of points of interests located near to the user. The navigation service is another well-known type of location-based services.Location-based service cannot be realized unless the positioning problem is solved. The Global Positioning System (GPS) can be used as a general solution for outdoor positioning. However, posi-tioning for indoor area is still under development. We are especially interested in wireless local area network (WLAN)-based indoor positioning techniques because it is available in almost all huge man made constructions. Most of WLAN-based indoor positioning techniques use either the signal propa-gation model or fingerprints.Implementation of the signal propagation model based indoor positioning method can be done quickly whereas implementation of the fingerprint method takes a long time. However, the finger-print method is more accurate than the signal propagation model based method. This paper surveys recently published fingerprint indoor positioning techniques. 자세히 보기 Review of the Techniques for Smart Learning SystemsintroductionFlipped learning is said to be one of the most efficient teaching and learning methods. In flipped learning, students watch lecture videos at home. In the class, they solve interesting problems under the teacher’s guide. Nowadays, students watch videos through smart devices while they are on the way home. Therefore, schools should provide a smart learning system.A database of lecture videos, smart applications, content management systems, and streaming servers are essential parts of smart learning systems. There are many database management system (DBMS) with which we can develop database of lecture videos. Among them, this paper reviews techniques to use MySQL DBMS. 자세히 보기 Techniques for Group Management Application DevelopmentintroductionA group management system provides many types of valuable services. For example, a teacher can be aware of current locations of all the students in real time during a field trip using a group management mobile application. In the early stage of location based service, fleet management was one of the hottest research topics. This paper reviews group management related research results.Positioning, handling maps, handling a database and mobile programming are indispensable technologies for the development of fleet management systems. Usages of these technologies in fleet management system development are discussed.자세히 보기 Survey of Techniques for Location-Based Mobile Campus Guide SystemsintroductionLocation-based service provides useful information based on the place where the user is located. Smart phones are ideal devices that provide location-based services because they are equipped with various sensors with which we can determine the location of smart phones.As an example of location-based service, the authors of [1] introduced a campus guide mobile app. This paper surveys techniques needed in development of location-based mobile campus guide systems. Campus guide systems prints out texts and images. It also plays audios and videos. Therefore, video on demand (VOD) techniques will be discussed. Techniques to identify the context of user will also be discussed. Finally, this paper will propose a design of a campus guide 자세히 보기","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"작성 논문","slug":"작성-논문","permalink":"http://KKimSangHeon.github.io/tags/작성-논문/"}]},{"title":"시각장애인을 위한 길안내 app","slug":"For-blind","date":"2017-06-30T03:42:08.000Z","updated":"2017-06-30T04:32:05.752Z","comments":true,"path":"2017/06/30/For-blind/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/For-blind/","excerpt":"","text":"참가배경-교내 창업경진대회가 진행 중이라는 소식을 듣고 참가하게 되었습니다. 비콘과 관련된 프로젝트를 진행중이던 상황이라 비콘을 이용해서 창업아이템을 고안하게 되었습니다. Idea를 떠올린 계기 -지하철을 이용하던 어느 날 시각장애인이 길을 찾는데 어려움을 겪는 것을 보았습니다. 시각장애인이 길을 찾는데 어려움을 겪은 이유는 점형블록에 대한 인식이 부족한 상인이 올려둔 짐 때문이었고 결국 시각 장애인은 주변 사람들의 도움을 통해 올바른 길을 찾아 갈 수 있었습니다. 저는 그 이후 지하철 내 점형블록을 눈여겨보게 되었습니다. [그림1]의 좌측 사진과 같이 깨진 점형블록이 보수되지 않은 채 존재하며, 우측 사진과 같이 매트가 깔려있기도 했습니다. -또한 그들을 위한 시설인 음성유도기 또한 고장나있는경우가 많으며 가격이 비싸다는 단점이 존재하였습니다.(개당 약 270만원) Idea 소개역사에 10m^2당 비콘을 하나씩 설치하여 핑거프린팅 알고리즘을 적용한 후 현재위치를 파악합니다. (FingerPrinting Algorithm(참고)) 그 후 [그림3]과 같이 이동방향을 파악 후 이동방향에 따른 음성안내를 실시합니다.음성안내를 실시하기 위해서는 다음의 Newtone API 혹은 Naver의 음성합성 기능을 사용하면 가능합니다. 결과 운이 좋게도 장려상과 30만원의 장학금을 지급받았습니다 !","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://KKimSangHeon.github.io/tags/Android/"},{"name":"Beacon","slug":"Beacon","permalink":"http://KKimSangHeon.github.io/tags/Beacon/"},{"name":"창업경진대회","slug":"창업경진대회","permalink":"http://KKimSangHeon.github.io/tags/창업경진대회/"}]},{"title":"기숙사 외박계","slug":"Dormitory-Sleep-Out","date":"2017-06-30T01:22:14.000Z","updated":"2017-06-30T03:37:41.143Z","comments":true,"path":"2017/06/30/Dormitory-Sleep-Out/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/Dormitory-Sleep-Out/","excerpt":"","text":"프로그램 개발배경-교내 기숙사의 외박계 프로그램이 존재하지 않으며, 업체에 의뢰하여 제작하려했으나 비용상의 문제로 거절된것을 알게되었습니다. 그래서 직접 만들어서 제출하면 어떨까 라는 생각을 하게되어 개발하게 되었습니다. 프로그램 소개CentOS상에 서버를 실행시켰으며, 카카오톡 옐로아이디 페이지에서 세팅을 진행하였습니다. 각 과정을 거친 후 자신의 외박계를 하나 작성할 수 있는 프로그램입니다. 프로그램 동작화면 초기 채팅방에 진입하였을 경우 외박계를 작성할 것인지, 작성한 외박계를 확인할 것인지 선택합니다.외박계 작성을 선택하였을 경우 이름, 거주하는 동, 호수, 귀관일, 행선지를 입력하고전화번호 또한 입력 후 아무키나 입력하면 등록이 완료됩니다.[그림1]에서 확인버튼을 선택하였을 경우 [그림4]와 같이 입력한 내용을 확인할 수 있습니다. 작성된 외박계를 관리자가 확인하기 위해서는 채팅방에서 supervisorgj@를 입력합니다. 그 후 [그림5]와 같이 외박계를 조회할 수 있습니다. 소스코드 (Github Repository)-카카오톡 자동응답 서버 소스코드","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://KKimSangHeon.github.io/tags/Node-js/"},{"name":"Kakao talk open API","slug":"Kakao-talk-open-API","permalink":"http://KKimSangHeon.github.io/tags/Kakao-talk-open-API/"},{"name":"챗봇","slug":"챗봇","permalink":"http://KKimSangHeon.github.io/tags/챗봇/"},{"name":"MySQL","slug":"MySQL","permalink":"http://KKimSangHeon.github.io/tags/MySQL/"},{"name":"CentOS","slug":"CentOS","permalink":"http://KKimSangHeon.github.io/tags/CentOS/"}]},{"title":"Music Share","slug":"music-share","date":"2017-06-30T00:31:38.000Z","updated":"2017-08-11T06:17:27.853Z","comments":true,"path":"2017/06/30/music-share/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/30/music-share/","excerpt":"","text":"프로그램 개발배경-C 소켓프로그래밍에 대한 이해를 높이고자 진행한 프로젝트입니다. 프로그램 소개-본 프로그램은 회원가입기능, 로그인기능, 서버에 mp3파일을 올리는기능 등이 구현되어 있습니다. 회원가입을 하고 로그인 후 서버에 mp3파일을 올리거나 다운로드 받을 수 있습니다. 프로그램 개발환경은 우분투 14.04 LTS 입니다. 프로그램 기능 초기 서버에 접속하였을 경우 화면입니다. 서버에서는 클라이언트의 접속현황 및 상태를 확인할 수 있으며 클라이언트에서는 다음에 할 수 있는 일을 확인할 수 있습니다. 두 클라이언트가 회원가입을 진행하고 있고 이에 대한 내용이 서버측 화면에 출력됩니다. 클라이언트가 가입한 ID를 이용하여 로그인을 하였습니다. 로그인 후 에는 서버에 존재하는 mp3파일리스트를 조회하거나 mp3파일을 업로드, 다운로드 할 수있습니다. 클라이언트가 로그인을 한 후 mp3파일을 업로드하는 화면입니다. 클라이언트가 로그인을 한 후 서버에 존재하는 mp3파일을 조회하는 화면입니다. [그림4]에서 KSH클라이언트가 업로드한 hello.mp3 파일을 HRA클라이언트가 접속하여 다운로드 하는 화면입니다. 비밀번호를 찾기위해 ID, Email을 입력하였고 이 후 비밀번호가 화면에 출력되는 모습입니다. github Repository","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"C","slug":"C","permalink":"http://KKimSangHeon.github.io/tags/C/"},{"name":"Socket","slug":"Socket","permalink":"http://KKimSangHeon.github.io/tags/Socket/"},{"name":"Music Share","slug":"Music-Share","permalink":"http://KKimSangHeon.github.io/tags/Music-Share/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://KKimSangHeon.github.io/tags/Ubuntu/"}]},{"title":"다수 사용자의 실시간 위치추적 어플리케이션 구현","slug":"where-are-you","date":"2017-06-29T14:53:44.000Z","updated":"2017-10-03T18:02:21.818Z","comments":true,"path":"2017/06/29/where-are-you/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/29/where-are-you/","excerpt":"","text":"App 개발배경-한 인원이 다수의 인원을 통제해야 하는 상황은 다양한 상황에서 발생할 수 있습니다. 가령 한 초등학교에서 현장체험학습의 일환으로 박물관을 방문하였을 경우, 교사 한명이 통제해야할 학생수는 약 30명에 이릅니다. 이는 교사에게 부담스러운 수가 될 수 있을것이라 판단하여 어플리케이션을 통해 극복하고자 하였습니다. App 소개-본 어플리케이션은 BLE기반의 비콘을 이용하여 실내에서 다수 사용자의 위치를 파악하는 어플리케이션입니다. App을 사용하기 위해서는 User는 자신의 정보를 등록해야 하며 이때 입력하는 데이터는 이름, ClassID 입니다. Supervisor는 이름 혹은 (이름,ClassID)를 이용하여 User의 최근 위치를 파악할 수 있는데 ClassID로는 해당 ClassID를 갖는 모든 User가 조회되며, (이름,ClassID)으로는 해당 User의 이동경로를 파악할 수 있습니다. System Architecture -본 어플리케이션의 이용자는 크게 User, Supervisor로 나뉘는데 User의 경우 FingerPrintingServer로 자신이 인식한 비콘들의 값을 전송합니다. 이를 수신한 FingerPrintingServer 서버는 User의 위치를 FingerPrinting 알고리즘을 적용하여 계산한 후 DB에 업데이트합니다. 이용자가 Supervisor 일 경우에는 StudentLocationPage에 접근하여 User들의 위치를 읽어옵니다. FingerPrinting Algorithm-본 어플리케이션의 핵심 알고리즘은 FingerPrinting Algorithm 입니다. 이 알고리즘을 구현하기 위해 72개 지점에서 비콘인식 실험을 100번 간 진행하였습니다. 결과물을 토대로 평균, 분산, 표준편차 등을 곱하고 나누어서 가장 실제 위치와 근접한 값을 구할 수 있었으며 최종적으로 오차를 약 1.65m 까지 줄일 수 있었습니다. -다음은 간단한 FingerPrinting Algorithm 적용 방식입니다. (서버에서 사용하는 알고리즘과는 다릅니다.)핑거프린팅 기법은 사전에 측정된 각 좌표 별 비콘의 신호값을 토대로 현재 위치를 추측하는 기술입니다. 예를 들어 그림1과 같이 각 좌표 별 사전에 측정된 비콘의 신호값(RSSI)이 존재한다고 가정 해 보겠습니다.현재 위치에서 측정된 각 비콘의 RSSI 값이 B1: -86 B2: -91 B3: -100 일 때 Coordinate1에 대한 각 비콘 신호의 차이의 합을 구하면 (-86, -87과의 차이) + (-91, -90과의 차이) + (-100, -101과의 차이) 3입니다. 이 과정을 Coordinate2 또한 반복하면 결과값은 14이며 , Coordinate3 은 26입니다.이 중 오차가 가장 작은 즉 최소값을 갖는 좌표가 현재 위치라 판단할 수 있을 것 이므로 현재 위치는 Coordinate1이라 추측할 수 있겠습니다. Result ClassID로 조회하였을 경우 [그림1]과 같이 해당 User들이 최근에 위치한 좌표값을 확인할 수 있습니다. (이름,ClassID)로 조회하였을 경우 해당 User의 이동경로가 [그림2]와 같이 출력됩니다. User의 위치는 카카오톡 yelloID (ID:WhereAreYou)로도 확인이 가능한데 [그림3]과 같이 카카오톡을 이용하여 위치 조회가 가능합니다. 소스코드 (Github Repository)-안드로이드 어플리케이션 소스코드-카카오톡 자동응답 서버 소스코드-웹페이지 서버 소스코드-소켓 서버 소스코드","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://KKimSangHeon.github.io/tags/Android/"},{"name":"Reco Beacon","slug":"Reco-Beacon","permalink":"http://KKimSangHeon.github.io/tags/Reco-Beacon/"},{"name":"Beacon","slug":"Beacon","permalink":"http://KKimSangHeon.github.io/tags/Beacon/"}]},{"title":"안녕하세요!","slug":"about-me","date":"2017-06-29T09:58:22.000Z","updated":"2019-01-21T15:15:16.932Z","comments":true,"path":"2017/06/29/about-me/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/29/about-me/","excerpt":"","text":"Introduction안녕하세요. 이 블로그는 제가 개인적으로 공부한 내용, 진행했던 프로젝트를 업로드하고, 공유하고자 만들었습니다. 부족한 부분에 대한 태클은 언제든지 환영하며 빠르게 반영하도록 하겠습니다. 부족하지만 방문해주셔서 감사드리며 앞으로 더욱 완벽한 블로그를 만들기 위해 노력하겠습니다! Profile 부명고등학교 졸업 (2008.03~2011.02) 동국대학교 경주캠퍼스 컴퓨터공학과 졸업 (2011.03~2017.02) [4.07/4.5] 아이티센 인턴수료 [공공2사업부문 개발2팀] (2016.12~2017.03) 비트교육센터 빅데이터 전문가양성과정 수강 (2017.07.31~2017.11.10) 마인즈랩 인턴수료 [Machine Learning Tutor 팀] (2017.11~2018.03) 웍스모바일 인턴수료 [Media Cloud Platform 팀] (2018.03 ~ 2018.05) KT [IT기획실 / 소프트웨어개발단] (2018.10 ~ 현재) Awards General Co-chairs of 2016 9th International Workshop Series / Best Paper Award (2016.04) 동국창업아이템 경진대회 / 장려상 (2016.05) ABLETHON / 우수상 (2017.10) Certificate 워드프로세서 (2012.06) 컴퓨터활용능력 1급 (2013.08) 정보처리기사 (2016.11) SQLD (2017.10) 리눅스마스터 2급 (2018.03) Activity 대한민국청소년의회 / 청소년 모의국회 스태프 (2011.07) 버담소리 / 보육원 봉사활동 (2014.12 ~ 2015.05) 코딩클럽 / 아동 코딩교육 (2015.08 ~ 2015.12) 동국대학교 컴퓨터공학과 / C, Java 멘토링 멘토 (2015.09 ~ 2016.12) 정보통신산업진흥원 / 한이음 ICT 멘토링 멘티 (2016.04 ~ 2016.12) Project- 다수 사용자의 실시간 위치추적 어플리케이션(Android, Beacon, Socket) - 부모님을 부탁해(Android) - Music Share(C, Socket) - 기숙사 외박계(Node.js, Kakao API) - 시각장애인을 위한 길안내 app제안(android) - 작성 논문 - 엄마가 보고있다(android) - 데이터 프리 기프티콘(android) - 동국대 경주캠퍼스 채팅봇(Node.js, Kakao API, AWS) - Wholin 밴드(android) - 그룹웨어(Web, Spring) - 쓱쓱끝(Android, Web, Spring)","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"Introduction","slug":"About-Me/Introduction","permalink":"http://KKimSangHeon.github.io/categories/About-Me/Introduction/"}],"tags":[{"name":"Sang Heon Kim","slug":"Sang-Heon-Kim","permalink":"http://KKimSangHeon.github.io/tags/Sang-Heon-Kim/"}]},{"title":"부모님을 부탁해","slug":"request-parent","date":"2017-06-29T09:52:18.000Z","updated":"2017-08-11T06:19:57.080Z","comments":true,"path":"2017/06/29/request-parent/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/29/request-parent/","excerpt":"","text":"App 소개 및 개발배경-본 어플리케이션은 증가하는 고독사를 줄여보자는 취지에서 개발하게 된 어플리케이션입니다. 부재중 통화수가 사전에 등록해 놓은 n 개가 되었을 경우 사전에 등록해 놓은 지인에게 위치정보가 포함된 문자메세지가 송신되는 앱 입니다. 초기화면에서 문자메세지를 수신할 번호, 부재중통화의 개수n을 입력하고 동작하기 버튼을 누릅니다. 어플리케이션을 설치한 스마트폰 주인이 부재중통화를 n번 받지 않을 경우 스마트폰의 현재 위치가 등록한 번호로 전송됩니다. -시연영상github Repositorygoogle play 방문","categories":[{"name":"About Me","slug":"About-Me","permalink":"http://KKimSangHeon.github.io/categories/About-Me/"},{"name":"My Projects","slug":"About-Me/My-Projects","permalink":"http://KKimSangHeon.github.io/categories/About-Me/My-Projects/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://KKimSangHeon.github.io/tags/Android/"},{"name":"고독사 감소","slug":"고독사-감소","permalink":"http://KKimSangHeon.github.io/tags/고독사-감소/"}]},{"title":"거품정렬 (BubbleSort)","slug":"BubbleSort","date":"2017-06-29T05:36:52.000Z","updated":"2018-09-03T06:03:44.702Z","comments":true,"path":"2017/06/29/BubbleSort/","link":"","permalink":"http://KKimSangHeon.github.io/2017/06/29/BubbleSort/","excerpt":"","text":"거품정렬거품정렬의 코드는 다음과 같다.시간복잡도는 O(n^2) 이다. BubbleSort.c12345678910for(i=0;i&lt;n-1;i++)&#123; for(j=0;j&lt;(n-i)-1;j++) &#123; if(arr[j]&gt;arr[j+1]) &#123; swap; &#125; &#125;&#125; 참고 : 윤성우의 열혈 자료구조","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://KKimSangHeon.github.io/categories/Algorithm/"},{"name":"Sort","slug":"Algorithm/Sort","permalink":"http://KKimSangHeon.github.io/categories/Algorithm/Sort/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://KKimSangHeon.github.io/tags/Data-Structure/"},{"name":"Sort","slug":"Sort","permalink":"http://KKimSangHeon.github.io/tags/Sort/"},{"name":"Bubble Sort","slug":"Bubble-Sort","permalink":"http://KKimSangHeon.github.io/tags/Bubble-Sort/"}]}]}